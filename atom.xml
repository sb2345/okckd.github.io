<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Octopress Blog]]></title>
  <link href="http://okckd.github.io/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-26T01:35:35+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Design] OOD Design of Elevator]]></title>
    <link href="http://okckd.github.io/blog/2014/08/26/Design-OOD-elevator/"/>
    <updated>2014-08-26T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/26/Design-OOD-elevator</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://thought-works.blogspot.sg/2012/11/object-oriented-design-for-elevator-in.html">link</a></p>

<blockquote><p>Object Oriented design for Elevator in a multi-storied apartment</p></blockquote>

<h3>A Single Elevator</h3>

<p>Use Case:</p>

<ol>
<li>User

<ol>
<li>press a button to summon the lift</li>
<li>press a button to get to a specific floor</li>
</ol>
</li>
<li>Button

<ol>
<li>floor button and level button</li>
<li>illuminates when pressed</li>
<li>place an &lsquo;elevator request&rsquo; when pressed</li>
</ol>
</li>
<li>Elevator

<ol>
<li>moves up/down</li>
<li>open/close the door</li>
</ol>
</li>
</ol>


<p><img class="middle" src="http://okckd.github.io/assets/images/elevator-class-diagram.png"></p>

<p><strong>ElevatorRequests Class</strong></p>

<p>Each button press results in an elevator request which has to be served. Each of these requests is tracked at a global place. ElevatorRequests, the class which stores elevator requests can use different strategies to schedule the elevator requests.</p>

<p><strong>ElevatorController</strong></p>

<p>The elevator is controlled by a controller class which we call ElevatorController. The elevator controller instructs the elevator what to do and also can shutdown/start up the elevator of the building. The elevator controller reads the next elevator request to be processed and serves it.</p>

<p><strong>Button (Abstract) Class</strong></p>

<p>Button is abstract class defining common behavior like illuminate, doNotIlluminate. FloorButton, ElevatorButton extend Button type and define placeRequest() which is invoked when the button is pressed.</p>

<p>In conclusion, <strong>ElevatorController</strong> runs the show by reading the <strong>ElevatorRequests</strong> to process and instructing the <strong>Elevator</strong> what to do. User send request by pressing <strong>Buttons</strong>.</p>

<h3>Extend the answer to multiple elevators</h3>

<ol>
<li><p>Each elevator have 1 controller.</p></li>
<li><p>Floor based requests can be served by any elevator, thus these requests are added to a common area accessible by all controllers.</p></li>
<li><p>Each elevator controller runs as a separate thread and checks if it can process a floor request. Mind synchronization issues.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 8.4 Design a Parking Lot]]></title>
    <link href="http://okckd.github.io/blog/2014/08/25/design-parking-lot/"/>
    <updated>2014-08-25T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/25/design-parking-lot</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Design a Parking Lot.</p></blockquote>

<h3>Solution</h3>

<p>Class hierarchy:</p>

<ol>
<li>A parking lot has multiple Levels.</li>
<li>A Level has multiple Parking Spot.</li>
<li>A Spot can park motorcycle, car or bus, which all belongs to Vehicle.</li>
</ol>


<p>Implement methods:</p>

<ol>
<li>Vehicle.parkInSpot(Spot s)</li>
<li>Vehicle.leaveSpot(Spot s)</li>
<li>Vehicle.canFitIn(Spot s)</li>
<li>ParkingLot.parkVehicle(Vehicle v)</li>
<li>Level.parkVehicle(Vehicle v)</li>
<li>Level.parkVehicleAtSpot(Vehicle v, Spot s)</li>
<li>Level.findAvailableSpot(VehicleType vt)</li>
</ol>


<p><strong>ParkingLot Class is just a wrapper class of Levels</strong>. By doing this, we seperated out parking logic from other broader actions (like Spot management).</p>

<p>The code below is from CC150v5. <strong>Its design is a bit strange</strong> (a car can occupy multiple spots), so just use this code as a guide but not a reference.</p>

<h3>Code</h3>

<p>ParkingLot.java</p>

<pre><code>public class ParkingLot {
    private Level[] levels;
    private final int NUM_LEVELS = 5;

    public ParkingLot() {
        levels = new Level[NUM_LEVELS];
        for (int i = 0; i &lt; NUM_LEVELS; i++) {
            levels[i] = new Level(i, 30);
        }
    }

    /* Park the vehicle in a spot (or multiple spots). Return false if failed. */
    public boolean parkVehicle(Vehicle vehicle) {
        for (int i = 0; i &lt; levels.length; i++) {
            if (levels[i].parkVehicle(vehicle)) {
                return true;
            }
        }
        return false;
    }

    public void print() {
        for (int i = 0; i &lt; levels.length; i++) {
            System.out.print("Level" + i + ": ");
            levels[i].print();
            System.out.println("");
        }
        System.out.println("");
    }
}
</code></pre>

<p>Level.java</p>

<pre><code>/* Represents a level in a parking garage */
public class Level {
    private int floor;
    private ParkingSpot[] spots;
    private int availableSpots = 0; // number of free spots
    private static final int SPOTS_PER_ROW = 10;

    public Level(int flr, int numberSpots) {
        floor = flr;
        spots = new ParkingSpot[numberSpots];
        int largeSpots = numberSpots / 4;
        int bikeSpots = numberSpots / 4;
        int compactSpots = numberSpots - largeSpots - bikeSpots;
        for (int i = 0; i &lt; numberSpots; i++) {
            VehicleSize sz = VehicleSize.Motorcycle;
            if (i &lt; largeSpots) {
                sz = VehicleSize.Large;
            } else if (i &lt; largeSpots + compactSpots) {
                sz = VehicleSize.Compact;
            }
            int row = i / SPOTS_PER_ROW;
            spots[i] = new ParkingSpot(this, row, i, sz);
        }
        availableSpots = numberSpots;
    }

    public int availableSpots() {
        return availableSpots;
    }

    /* Try to find a place to park this vehicle. Return false if failed. */
    public boolean parkVehicle(Vehicle vehicle) {
        if (availableSpots() &lt; vehicle.getSpotsNeeded()) {
            return false;
        }
        int spotNumber = findAvailableSpots(vehicle);
        if (spotNumber &lt; 0) {
            return false;
        }
        return parkStartingAtSpot(spotNumber, vehicle);
    }

    /* Park a vehicle starting at the spot spotNumber, and continuing until vehicle.spotsNeeded. */
    private boolean parkStartingAtSpot(int spotNumber, Vehicle vehicle) {
        vehicle.clearSpots();
        boolean success = true;
        for (int i = spotNumber; i &lt; spotNumber + vehicle.spotsNeeded; i++) {
             success &amp;= spots[i].park(vehicle);
        }
        availableSpots -= vehicle.spotsNeeded;
        return success;
    }

    /* find a spot to park this vehicle. Return index of spot, or -1 on failure. */
    private int findAvailableSpots(Vehicle vehicle) {
        int spotsNeeded = vehicle.getSpotsNeeded();
        int lastRow = -1;
        int spotsFound = 0;
        for (int i = 0; i &lt; spots.length; i++) {
            ParkingSpot spot = spots[i];
            if (lastRow != spot.getRow()) {
                spotsFound = 0;
                lastRow = spot.getRow();
            }
            if (spot.canFitVehicle(vehicle)) {
                spotsFound++;
            } else {
                spotsFound = 0;
            }
            if (spotsFound == spotsNeeded) {
                return i - (spotsNeeded - 1);
            }
        }
        return -1;
    }

    public void print() {
        int lastRow = -1;
        for (int i = 0; i &lt; spots.length; i++) {
            ParkingSpot spot = spots[i];
            if (spot.getRow() != lastRow) {
                System.out.print("  ");
                lastRow = spot.getRow();
            }
            spot.print();
        }
    }

    /* When a car was removed from the spot, increment availableSpots */
    public void spotFreed() {
        availableSpots++;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 8.9 Design a In-memory File System]]></title>
    <link href="http://okckd.github.io/blog/2014/08/25/design-in-memory-file-system/"/>
    <updated>2014-08-25T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/25/design-in-memory-file-system</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Explain the data structures and algorithms that you would use to design an in-memory file system. Illustrate with an example in code where possible.</p></blockquote>

<h3>Solution</h3>

<p><strong>A file system consists of Files and Directories</strong>. Each Directory contains a set of Files and Directories.</p>

<p>Since Files and Directories share so many characteristics, we&rsquo;ve implemented them such that they <strong>inherit from the same class</strong> &mdash; Entry.</p>

<h3>Code</h3>

<p>Entry.java</p>

<pre><code>public abstract class Entry {
    protected Directory parent;
    protected long created;
    protected long lastUpdated;
    protected long lastAccessed;
    protected String name;

    public Entry(String n, Directory p) {
        name = n;
        parent = p;
        created = System.currentTimeMillis();
    }

    public boolean delete() {
        if (parent == null) {
            return false;
        }
        return parent.deleteEntry(this);
    }

    public abstract int size();

    public String getFullPath() {
        if (parent == null) {
            return name;
        } else {
            return parent.getFullPath() + "/" + name;
        }
    }

    public long getCreationTime() {
        return created;
    }

    public long getLastUpdatedTime() {
        return lastUpdated;
    }

    public long getLastAccessedTime() {
        return lastAccessed;
    }

    public void changeName(String n) {
        name = n;
    }

    public String getName() {
        return name;
    }
}
</code></pre>

<p>Directory.java</p>

<pre><code>public class Directory extends Entry {
    protected ArrayList&lt;Entry&gt; contents;

    public Directory(String n, Directory p) {
        super(n, p);
        contents = new ArrayList&lt;Entry&gt;();
    }

    protected ArrayList&lt;Entry&gt; getContents() {
        return contents;
    }

    public int size() {
        int size = 0;
        for (Entry e : contents) {
            size += e.size();
        }
        return size;
    }

    public int numberOfFiles() {
        int count = 0;
        for (Entry e : contents) {
            if (e instanceof Directory) {
                count++; // Directory counts as a file
                Directory d = (Directory) e;
                count += d.numberOfFiles();
            } else if (e instanceof File) {
                count++;
            }
        }
        return count;
    }

    public boolean deleteEntry(Entry entry) {
        return contents.remove(entry);
    }

    public void addEntry(Entry entry) {
        contents.add(entry);
    }
}
</code></pre>

<p>File.java</p>

<pre><code>public class File extends Entry {
    private String content;
    private int size;

    public File(String n, Directory p, int sz) {
        super(n, p);
        size = sz;
    }

    public int size() {
        return size;
    }

    public String getContents() {
        return content;
    }

    public void setContents(String c) {
        content = c;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 8.10 Implement a Hashmap]]></title>
    <link href="http://okckd.github.io/blog/2014/08/25/Implement-HashMap/"/>
    <updated>2014-08-25T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/25/Implement-HashMap</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Design and implement a hash table which uses chaining (linked lists) to handle collisions.</p></blockquote>

<h3>Solution</h3>

<p>I wrote this topic before (using Java source code as a reference). This time, I would like to take another (easier) approach.</p>

<p>The main part of this is to use an array of list structure like this:</p>

<pre><code>LinkedList&lt;Cell&lt;K, V&gt;&gt;[] items;
</code></pre>

<p>And the Cell Class looks like this:</p>

<pre><code>public class Cell&lt;K, V&gt; {
    private K key;
    private V value;

    public Cell(K k, V v) {
        key = k;
        value = v;
    }

    public boolean equivalent(Cell&lt;K, V&gt; c) {
        return equivalent(c.getKey());
    }

    public boolean equivalent(K k) {
        return key.equals(k);
    }

    public K getKey() {
        return key;
    }

    public V getValue() {
        return value;
    }
}
</code></pre>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public class HashMapCC150&lt;K, V&gt; {

    int size;
    LinkedList&lt;Cell&lt;K, V&gt;&gt;[] items;

    public HashMapCC150(int num) {
        this.size = num;
        items = (LinkedList&lt;Cell&lt;K, V&gt;&gt;[]) new LinkedList[10];
    }

    public V get(K k) {
        int hashValue = this.calculateHashCode(k);
        if (items[hashValue] == null) {
            items[hashValue] = new LinkedList&lt;Cell&lt;K, V&gt;&gt;();
            return null;
        }
        for (Cell&lt;K, V&gt; cell : items[hashValue]) {
            if (k.equals(cell.getKey())) {
                return cell.getValue();
            }
        }
        return null;
    }

    public V put(K k, V v) {
        int hashValue = this.calculateHashCode(k);
        if (items[hashValue] == null) {
            items[hashValue] = new LinkedList&lt;Cell&lt;K, V&gt;&gt;();
        }
        for (Cell&lt;K, V&gt; cell : items[hashValue]) {
            if (k.equals(cell.getKey())) {
                items[hashValue].remove(cell);
                break;
            }
        }
        Cell&lt;K, V&gt; newItem = new Cell&lt;K, V&gt;(k, v);
        items[hashValue].add(newItem);
        return null;
    }

    public V remove(K k) {
        // not written
        return null;
    }

    private int calculateHashCode(K k) {
        return k.toString().length() % size;
    }

    public static void main(String[] args) {
        HashMapCC150&lt;String, String&gt; map = new HashMapCC150&lt;String, String&gt;(10);
        map.put("kevin", "durant");
        map.put("steven", "curry");
        map.put("al", "jefferson");
        System.out.println(map.get("kevin"));
        System.out.println(map.get("steven"));
        System.out.println(map.get("al"));
        map.put("kevin", "martin");
        map.put("steven", "nash");
        map.put("kevin", "braynt");
        System.out.println(map.get("kevin"));
        System.out.println(map.get("steven"));
        System.out.println(map.get("al"));
    }
}

class Cell&lt;K, V&gt; {
    private K key;
    private V value;

    public Cell(K k, V v) {
        key = k;
        value = v;
    }

    public boolean equivalent(Cell&lt;K, V&gt; c) {
        return equivalent(c.getKey());
    }

    public boolean equivalent(K k) {
        return key.equals(k);
    }

    public K getKey() {
        return key;
    }

    public V getValue() {
        return value;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 8.8 Design Othello Game]]></title>
    <link href="http://okckd.github.io/blog/2014/08/24/design-othello-game/"/>
    <updated>2014-08-24T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/24/design-othello-game</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Othello is played as follows: Each Othello piece is white on one side and black on the other. When a piece is surrounded by its opponents on both the left and right sides, or both the top and bottom, it is said to be captured and its color is flipped.</p>

<p>The win is assigned to the person with the most pieces. Implement the object-oriented design for Othello.</p></blockquote>

<h3>Class</h3>

<ol>
<li>Game

<ol>
<li>Two Player objects</li>
<li>a board object</li>
<li>singleton class (unless otherwise specified, this needs to be discussed)</li>
</ol>
</li>
<li>Board

<ol>
<li>Keep the score (black/white count). Of course we can put score in Game Class as well, it seems logically related to the board a bit more.</li>
<li>Array of Piece objects</li>
<li>getScore() method</li>
</ol>
</li>
<li>Piece

<ol>
<li>stores color info</li>
<li>flip() function</li>
</ol>
</li>
<li>Player

<ol>
<li>stores color info</li>
<li>playPiece() method</li>
</ol>
</li>
<li>Color Enum</li>
<li>Direction Enum</li>
</ol>


<h3>Functions</h3>

<ol>
<li>placePiece() by the Player (which triggers the following 2 methods)</li>
<li>private flipSection(Position fromWhere, Color c, Direction up/down/left/right) by the board</li>
<li>private updateScore() by the board</li>
<li>getScore() by the board</li>
</ol>


<h4>Follow up: Do we need separate Board and Game classes?</h4>

<p>Strictly speaking, no. The drawback is adding an extra layers. A function that calls Game class is immediately calling Board class.</p>

<p>But keeping the objects separate allows us to have a logical separation between the board (which contains just logic involving placing pieces) and the game (which involves times, game flow, etc.).</p>

<h3>Conclusion</h3>

<p>This is an easy, and very standard OOD question. Keep the logic clear, design the layers and object hierarchy, and the rest of things will come naturally.</p>

<h3>Code</h3>

<p>Game.java</p>

<pre><code>public class Game {
    private Player[] players;
    private static Game instance;
    private Board board;
    private final int ROWS = 10;
    private final int COLUMNS = 10;

    private Game() {
        board = new Board(ROWS, COLUMNS);
        players = new Player[2];
        players[0] = new Player(Color.Black);
        players[1] = new Player(Color.White);
        Automator.getInstance().initialize(players); // used for testing
    }

    public static Game getInstance() {
        if (instance == null) {
            instance = new Game();
        }
        return instance;
    }

    public Board getBoard() {
        return board;
    }
}
</code></pre>

<p>Board.java</p>

<pre><code>public class Board {
    private int blackCount = 0;
    private int whiteCount = 0;
    private Piece[][] board;

    public Board(int rows, int columns) {
        board = new Piece[rows][columns];
    }

    public void initialize() {
        /* initial board has a grid like the following in the center:
         *     WB
         *     BW
         */
        int middleRow = board.length / 2;
        int middleColumn = board[middleRow].length / 2;
        board[middleRow][middleColumn] = new Piece(Color.White);
        board[middleRow + 1][middleColumn] = new Piece(Color.Black);
        board[middleRow + 1][middleColumn + 1] = new Piece(Color.White);
        board[middleRow][middleColumn + 1] = new Piece(Color.Black);
        blackCount = 2;
        whiteCount = 2;
    }

    public boolean placeColor(int row, int column, Color color) {
        if (board[row][column] != null) {
            return false;
        }

        /* attempt to flip each of the four directions */
        int[] results = new int[4];
        results[0] = flipSection(row - 1, column, color, Direction.up);
        results[1] = flipSection(row + 1, column, color, Direction.down);
        results[2] = flipSection(row, column + 1, color, Direction.right);
        results[3] = flipSection(row, column - 1, color, Direction.left);

        /* compute how many pieces were flipped */
        int flipped = 0;
        for (int result : results) {
            if (result &gt; 0) {
                flipped += result;
            }
        }

        /* if nothing was flipped, then it's an invalid move */
        if (flipped &lt; 0) {
            return false;
        }

        /* flip the piece, and update the score */
        board[row][column] = new Piece(color);
        updateScore(color, flipped + 1);
        return true;
    }

    private int flipSection(int row, int column, Color color, Direction d) {
        /* Compute the delta for the row and the column. At all times, only the row or the column
         * will have a delta, since we're only moving in one direction at a time.
         */
        int r = 0;
        int c = 0;
        switch (d) {
        case up:
            r = -1;
            break;
        case down:
            r = 1;
            break;
        case left:
            c = -1;
            break;
        case right:
            c = 1;
            break;
        }

        /* If out of bounds, or nothing to flip, return an error (-1) */
        if (row &lt; 0 || row &gt;= board.length || column &lt; 0 || column &gt;= board[row].length || board[row][column] == null) {
            return -1;
        }

        /* Found same color - return nothing flipped */
        if (board[row][column].getColor() == color) {
            return 0;
        }

        /* Recursively flip the remainder of the row. If -1 is returned, then we know we hit the boundary
         * of the row (or a null piece) before we found our own color, so there's nothing to flip. Return
         * the error code.
         */
        int flipped = flipSection(row + r, column + c, color, d);
        if (flipped &lt; 0) {
            return -1;
        }

        /* flip our own color */
        board[row][column].flip();
        return flipped + 1;
    }

    public int getScoreForColor(Color c) {
        if (c == Color.Black) {
            return blackCount;
        } else {
            return whiteCount;
        }
    }

    private void updateScore(Color newColor, int newPieces) {
        /* If we added x pieces of a color, then we actually removed x - 1 pieces of the other
         * color. The -1 is because one of the new pieces was the just-placed one.
         */
        if (newColor == Color.Black) {
            whiteCount -= newPieces - 1;
            blackCount += newPieces;
        } else {
            blackCount -= newPieces - 1;            
            whiteCount += newPieces;
        }
    }

    public void printBoard() {
        for (int r = 0; r &lt; board.length; r++) {
            for (int c = 0; c &lt; board[r].length; c++) {
                if (board[r][c] == null) {
                    System.out.print("_");
                } else if (board[r][c].getColor() == Color.White) {
                    System.out.print("W");
                } else {
                    System.out.print("B");
                }
            }
            System.out.println();
        }
    }
}
</code></pre>

<p>Player.java</p>

<pre><code>public class Player {
    private Color color;
    public Player(Color c) {
        color = c;
    }

    public int getScore() {
        return Game.getInstance().getBoard().getScoreForColor(color);
    }

    public boolean playPiece(int row, int column) {
        return Game.getInstance().getBoard().placeColor(row, column, color);
    }

    public Color getColor() {
        return color;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 8.7 Design Online Chat Server (2)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/24/design-online-chat-server-2/"/>
    <updated>2014-08-24T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/24/design-online-chat-server-2</id>
    <content type="html"><![CDATA[<p>&hellip; Continued from previous post.</p>

<h3>Overall view</h3>

<p>The system consists of a database, a set of clients, and a set of servers. This is not about OOD, but we need to know.</p>

<ol>
<li><p>DB stores user list, chat archive. An SQL DB would be good, <strong>unless we want BigTable for scalability purpose</strong>.</p></li>
<li><p><strong>We use XML for server-client communication</strong>. Because it&rsquo;s debugging friendly.</p></li>
<li><p><strong>A set of servers</strong>.</p>

<ol>
<li>Data will be <strong>divided up across machines</strong>, requiring us to potentially hop from machine to machine.</li>
<li>When possible, we will try to <strong>replicate some data</strong> across machines to minimize the lookups.</li>
<li>One major design constraint here is to <strong>prevent having a single point of failure</strong>. For instance, if one machine controlled all the user sign-ins, then we&rsquo;d cut off millions of users potentially if a single machine lost network connectivity.</li>
</ol>
</li>
</ol>


<h3>Hardest problems</h3>

<p>Or the most interesting questions.</p>

<h4>Q1: How do we know if someone is online?</h4>

<p>While we would like users to tell us when they sign off, we can&rsquo;t know for sure. A user&rsquo;s connection might have died, for example. To make sure that we know when a user has signed off, we might try regularly pinging the client to make sure it&rsquo;s still there.</p>

<h4>Q2: How do we deal with conflicting information?</h4>

<p>We have some information stored in the computer&rsquo;s memory and some in the database. What happens if they get out of sync? Which one is &ldquo;right&rdquo;?</p>

<h4>Q3: How do we make our server scale?</h4>

<p>While we designed out chat server without worrying—too much- about scalability, in real life this would be a concern. We&rsquo;d need to split our data across many servers, which would increase our concern about out-of-sync data.</p>

<h4>Q4: How we do prevent denial of service attacks?</h4>

<p>Clients can push data to us —- what if they try to DOS (denial of service) us? How do we prevent that?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 8.7 Design Online Chat Server (1)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/24/design-online-chat-server-1/"/>
    <updated>2014-08-24T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/24/design-online-chat-server-1</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Explain how you would design a chat server. In particular, provide details about the various back end components, classes, and methods.</p>

<p>What would be the hardest problems to solve?</p></blockquote>

<h3>Solution</h3>

<p>First, decide the objects and methods. Here we&rsquo;ll focus on the core user management and conversation aspects.</p>

<h4>Class</h4>

<ol>
<li>UserMgmt (business logic)</li>
<li>User (includes basic info, UserStatus, a map of conversation, a map of requests)</li>
<li>UserStatus (on/offline, status message)</li>
<li>Conversation Abstract Class (a list of user and a list of messages)

<ol>
<li>PrivateChat (private conversation)</li>
<li>GroupChat</li>
</ol>
</li>
<li>Message (a string and a date/time)</li>
<li>Request (add request and delete request, involves 2 Users)</li>
</ol>


<h4>Functions</h4>

<ol>
<li>Sign in and log off (update availability)</li>
<li>update status message</li>
<li>add/delete request</li>
<li>send/accept/reject a request</li>
<li>create a conversation (group or private)</li>
<li>add a new message (group or private)</li>
</ol>


<h3>Code</h3>

<p>The most important classes is User and UserMgmt. The others are simply data containers.</p>

<p>UserManager.java</p>

<pre><code>public class UserManager {
    private static UserManager instance;
    private HashMap&lt;Integer, User&gt; usersById = new HashMap&lt;Integer, User&gt;();
    private HashMap&lt;String, User&gt; usersByAccountName = new HashMap&lt;String, User&gt;();
    private HashMap&lt;Integer, User&gt; onlineUsers = new HashMap&lt;Integer, User&gt;();

    public static UserManager getInstance() {
        if (instance == null) {
            instance = new UserManager();
        }
        return instance;
    }

    public void addUser(User fromUser, String toAccountName) {
        User toUser = usersByAccountName.get(toAccountName);
        AddRequest req = new AddRequest(fromUser, toUser, new Date());
        toUser.receivedAddRequest(req);
        fromUser.sentAddRequest(req);
    }

    public void approveAddRequest(AddRequest req) {
        req.status = RequestStatus.Accepted;
        User from = req.getFromUser();
        User to = req.getToUser();
        from.addContact(to);
        to.addContact(from);
    }

    public void rejectAddRequest(AddRequest req) {
        req.status = RequestStatus.Rejected;
        User from = req.getFromUser();
        User to = req.getToUser();
        from.removeAddRequest(req);
        to.removeAddRequest(req);       
    }

    public void userSignedOn(String accountName) {
        User user = usersByAccountName.get(accountName);
        if (user != null) {
            user.setStatus(new UserStatus(UserStatusType.Available, ""));           
            onlineUsers.put(user.getId(), user);
        }
    }

    public void userSignedOff(String accountName) {
        User user = usersByAccountName.get(accountName);
        if (user != null) {
            user.setStatus(new UserStatus(UserStatusType.Offline, ""));
            onlineUsers.remove(user.getId());
        }
    }   
}
</code></pre>

<p>User.java</p>

<p>Property:</p>

<ol>
<li>id and name</li>
<li>a map of conversations</li>
<li>a map of sent request</li>
<li>a map of received request</li>
<li>a map of friends list</li>
</ol>


<p>Methods:</p>

<ol>
<li>sendMessageToUser(User)</li>
<li>addContact(User)</li>
<li>receivedAddRequest(Request)</li>
<li>sentAddRequest(Request)</li>
<li>removeAddRequest(Request)</li>
<li>addConversation(Conversation)</li>
</ol>


<p>Note that all user actions are controlled by the UserManager Class. For example, when adding a friend:</p>

<ol>
<li>User A clicks &ldquo;add user&rdquo; on the client.</li>
<li>User A calls requestAddUser (User B).</li>
<li>This method calls UserManager.addUser(User a, userBid).</li>
<li>UserManager calls both User A.sentAddRequest() and User B.receivedAddRequest().</li>
</ol>


<p>Code:</p>

<pre><code>public class User {
    private int id;
    private UserStatus status = null;
    private HashMap&lt;Integer, PrivateChat&gt; privateChats = new HashMap&lt;Integer, PrivateChat&gt;();
    private ArrayList&lt;GroupChat&gt; groupChats = new ArrayList&lt;GroupChat&gt;();
    private HashMap&lt;Integer, AddRequest&gt; receivedAddRequests = new HashMap&lt;Integer, AddRequest&gt;();
    private HashMap&lt;Integer, AddRequest&gt; sentAddRequests = new HashMap&lt;Integer, AddRequest&gt;();

    private HashMap&lt;Integer, User&gt; contacts = new HashMap&lt;Integer, User&gt;();
    private String accountName;
    private String fullName;

    public User(int id, String accountName, String fullName) {
        this.accountName = accountName;
        this.fullName = fullName;
        this.id = id;
    }

    public boolean sendMessageToUser(User toUser, String content) {
        PrivateChat chat = privateChats.get(toUser.getId());
        if (chat == null) {
            chat = new PrivateChat(this, toUser);
            privateChats.put(toUser.getId(), chat);
        }
        Message message = new Message(content, new Date());
        return chat.addMessage(message);
    }

    public boolean sendMessageToGroupChat(int groupId, String content) {
        GroupChat chat = groupChats.get(groupId);
        if (chat != null) {
            Message message = new Message(content, new Date());
            return chat.addMessage(message);
        }
        return false;
    }

    public void setStatus(UserStatus status) {
        this.status = status;
    }

    public UserStatus getStatus() {
        return status;
    }

    public boolean addContact(User user) {
        if (contacts.containsKey(user.getId())) {
            return false;
        } else {
            contacts.put(user.getId(), user);
            return true;
        }
    }

    public void receivedAddRequest(AddRequest req) {
        int senderId = req.getFromUser().getId();
        if (!receivedAddRequests.containsKey(senderId)) {
            receivedAddRequests.put(senderId, req);
        }       
    }

    public void sentAddRequest(AddRequest req) {
        int receiverId = req.getFromUser().getId();
        if (!sentAddRequests.containsKey(receiverId)) {
            sentAddRequests.put(receiverId, req);
        }       
    }

    public void removeAddRequest(AddRequest req) {
        if (req.getToUser() == this) {
            receivedAddRequests.remove(req);
        } else if (req.getFromUser() == this) {
            sentAddRequests.remove(req);
        }
    }

    public void requestAddUser(String accountName) {
        UserManager.getInstance().addUser(this, accountName);
    }

    public void addConversation(PrivateChat conversation) {
        User otherUser = conversation.getOtherParticipant(this);
        privateChats.put(otherUser.getId(), conversation);
    }

    public void addConversation(GroupChat conversation) {
        groupChats.add(conversation);
    }   

    public int getId() {
        return id;
    }

    public String getAccountName() {
        return accountName;
    }

    public String getFullName() {
        return fullName;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Stack and Heap]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/stack-and-heap/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/stack-and-heap</id>
    <content type="html"><![CDATA[<h3>Overview</h3>

<p>Value types are created on the stack, and reference types are created on the heap.</p>

<p><strong>Both are stored in computer RAM</strong>.</p>

<p><strong>Each thread gets a stack</strong>, while there&rsquo;s typically only one heap for the application.</p>

<h4>Stack</h4>

<p><a href="http://stackoverflow.com/a/80113">When a function</a> is called, a block is reserved <strong>on the top of the stack</strong> for local variables and some bookkeeping data in a LIFO order. Freeing a block from the stack is nothing more than adjusting one pointer.</p>

<h4>Heap</h4>

<p>Unlike the stack, there&rsquo;s no enforced pattern to the allocation and deallocation of blocks from the heap; you can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time; there are many custom heap allocators available to tune heap performance for different usage patterns.</p>

<h3>Q &amp; A</h3>

<h4>What is their scope?</h4>

<p>The stack is attached to a thread, so <strong>when the thread exits</strong> the stack is reclaimed.</p>

<p>The heap is typically allocated at application startup by the runtime, and is reclaimed <strong>when the application (technically process) exits</strong>.</p>

<h4>What determines the size of each of them?</h4>

<p>The size of the stack is set when a thread is created.</p>

<p>The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system).</p>

<h4>What makes one faster?</h4>

<p><strong>The stack is faster</strong> because the access pattern makes it trivial to allocate and deallocate memory from it, while the heap has much more complex bookkeeping involved in an allocation or free.</p>

<p>Each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor&rsquo;s cache, making it very fast.</p>

<p>Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe, i.e. each allocation and deallocation needs to be (typically) synchronized.</p>

<p><img class="middle" src="http://okckd.github.io/assets/images/stack-and-heap.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Shared Hosting vs. VPS Hosting]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/Web-hosting-shared-and-vps/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/Web-hosting-shared-and-vps</id>
    <content type="html"><![CDATA[<h3>Shared hosting</h3>

<p><a href="https://kb.greengeeks.com/3072/shared-hosting-vs-vps-hosting/">Shared hosting</a> is like living in an apartment where you share a common space with your neighbors. You cannot customize anything but you share maintenance cost and responsibility with your neighbors.</p>

<ol>
<li>Economical</li>
<li>Technical maintenance of the server is not required</li>
<li>Limited number of resources</li>
<li>Your website performance may be affected by other websites hosted on the shared server</li>
<li>Possible long term problems with scalability and backup</li>
<li>Possible security issues for sharing a common server</li>
</ol>


<h3>Virtual Private Server</h3>

<p>Virtual Private Server (VPS) Hosting is like living in a simplex or half-plex where you can customize everything to your own tastes. However, you still need to maintain your own area. Companies that deal with resource-heavy applications and secured data most often use VPS.</p>

<ol>
<li>Larger space and bandwidth</li>
<li>Can configure anything</li>
<li>Run your own batch files to create multiple services inside the server using shell access</li>
<li>Easy scalability and backup</li>
<li>You need a dedicated system administrator</li>
<li>Costly</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Designing Scalable Systems (`)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/Design-scalable-system/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/Design-scalable-system</id>
    <content type="html"><![CDATA[<ol>
<li>horizontal scaling</li>
</ol>


<p>load balancer get all requests, and distribute to one of the back-end servers</p>

<p>user sees not DNS, but address of load balancer</p>

<p>all backend server must have identical information (the price you pay for scalability)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Binary Search Trees Over Hash Tables]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/BST-over-hashmap/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/BST-over-hashmap</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://stackoverflow.com/questions/4128546/advantages-of-binary-search-trees-over-hash-tables">What are the advantages</a> of binary search trees over hash tables?</p>

<h3>Answer</h3>

<ol>
<li><p><strong>More memory-efficient</strong>. (They do not reserve more memory than they need to)</p>

<p> For instance, if a hash function has a range R(h) = 0&hellip;100, then you need to allocate an array of 100 (pointers-to) elements, even if you are just hashing 20 elements.</p></li>
<li><p><a href="http://stackoverflow.com/a/4128585">Inorder traverse</a>.</p></li>
<li><p>Collision might hamper HashMap&rsquo;s performance.</p></li>
<li><p><a href="http://stackoverflow.com/a/4129272">Resizing issue</a></p>

<p> When the hash table pressure grows too much, you often tend to enlargen and reallocate the hash table. The BST has simpler behavior here and does not tend to suddenly allocate a lot of data and do a rehashing operation.</p></li>
<li><p>Binary search tree do range searches efficiently.</p></li>
</ol>


<h3>One more thing</h3>

<p><strong>Trees tend to be the <a href="http://stackoverflow.com/a/19896875">ultimate average data structure</a></strong>. They can act as lists, can easily be split for parallel operation, have fast removal, insertion and lookup on the order of O(lgn). They do nothing particularly well, but they don&rsquo;t have any excessively bad behavior either.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 8.1 Design a Generic Deck of Cards]]></title>
    <link href="http://okckd.github.io/blog/2014/08/22/design-deck-card/"/>
    <updated>2014-08-22T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/22/design-deck-card</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Design a Generic Deck of Cards</p></blockquote>

<h3>Solution</h3>

<p>A simple design:</p>

<pre><code>enum Suit {
    HEART, DIAMOND, SPADES, CLUBS;
}

class Deck {
    List&lt;Card&gt; deck;
}

class Card {
    Suit suit;
    int num;
}
</code></pre>

<p>A more complex design:</p>

<pre><code>enum Suit {
    HEART, DIAMOND, SPADES, CLUBS;
}

class Deck&lt;T extends Card&gt; {
    List&lt;Card&gt; deck;

    public void shuffle() {
    };
}

abstract class Card {
    boolean available;
    Suit suit;
    int num;

    public boolean isAvailable() {
        return available;
    };
}

class Hand&lt;T extends Card&gt; {
    List&lt;Card&gt; cards;

    public int score() {
        int score = 0;
        for (Card c : cards) {
            score += c.num;
        }
        return score;
    }

    public void addCard(T card) {
        cards.add(card);
    }
}

// Now use the above generic Data Structure to make a
// Blackjack Game
class Blackjack extends Hand&lt;BlackJackCard&gt; {
}

class BlackJackCard extends Card {
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] About Singleton]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Talk-about-singleton/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Talk-about-singleton</id>
    <content type="html"><![CDATA[<h3>Implement Singlton</h3>

<p><a href="http://javarevisited.blogspot.sg/2012/07/why-enum-singleton-are-better-in-java.html">3 ways</a> of writing Singleton.</p>

<h4>using Enum</h4>

<p>This is only available since Java 6.</p>

<pre><code>public enum Singleton_Enum {
    INSTANCE;
}
</code></pre>

<h4>using double checked locking</h4>

<p>This is <strong>lazy loaded thread-safe</strong> Singleton, which is popular during Java 5 (with the use of Volatile variable).</p>

<pre><code>public class Singleton_DoubleCheckedLocking implements Cloneable {
    private static volatile Singleton_DoubleCheckedLocking INSTANCE;

    private Singleton_DoubleCheckedLocking() {
    }

    public static Singleton_DoubleCheckedLocking getInstance() {
        if (INSTANCE == null) {
            synchronized (Singleton_DoubleCheckedLocking.class) {
                // double checking Singleton instance
                if (INSTANCE == null) {
                    INSTANCE = new Singleton_DoubleCheckedLocking();
                }
            }
        }
        return INSTANCE;
    }
}
</code></pre>

<h4>using static factory method</h4>

<p>Singleton instance is <a href="http://javarevisited.blogspot.sg/2012/07/why-enum-singleton-are-better-in-java.html">static and final variable</a> it initialized when class is first loaded into memeory so creation of instance is inherently <strong>thread-safe</strong>.</p>

<pre><code>public class Singleton_StaticFactory {
    // initailzed during class loading
    private static final Singleton_StaticFactory INSTANCE = new Singleton_StaticFactory();

    // to prevent creating another instance of Singleton
    private Singleton_StaticFactory() {
    }

    public static Singleton_StaticFactory getSingleton() {
        return INSTANCE;
    }
}
</code></pre>

<h3>About thread-saft</h3>

<p><a href="http://javarevisited.blogspot.sg/2012/12/how-to-create-thread-safe-singleton-in-java-example.html">Prior to Java 5</a> <strong>double checked locking</strong> mechanism is used to create thread-safe singleton in Java, which breaks if one Thread doesn&rsquo;t see instance created by other thread at same time and eventually you will end up with more than one instance of Singleton class.</p>

<p>From Java 5 onwards <strong>volatile variable</strong> guarantee can be used to write thread safe singleton by using double checked locking pattern.</p>

<p>I personally don&rsquo;t prefer that way as there are many other simpler alternatives like:</p>

<ol>
<li>using static field</li>
<li>using Enum</li>
</ol>


<h3>Q &amp; A</h3>

<p>Question: How do you prevent for creating another instance of Singleton using clone() method?</p>

<p>Answer: Preferred way is not to implement Clonnable interface. And if you do, just throw Exception from clone() method as &ldquo;Can not create clone of Singleton class&rdquo;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Square Count of Matchstick Graph]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Square-count-in-matchstick-graph/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Square-count-in-matchstick-graph</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>给出下面这个图 设计数据结构和算法求出图中<strong>所有的正方形数量</strong> (count the number of squares).</p></blockquote>

<p><img class="middle" src="http://okckd.github.io/assets/images/matchstick-square-count.jpg"></p>

<h3>Solution</h3>

<ol>
<li><p><strong>Pre-processing</strong>: 从每一个点开始存储上下左右四个方向最多延伸到的位置</p></li>
<li><p><strong>Main algorithm</strong>: 枚举右下角位置 然后枚举正方形边长</p></li>
<li><p>根据预处理的延伸情况判断是否能够有一个正方形被构造出来</p></li>
</ol>


<p>Total time complexity is O(n<sup>3</sup>).</p>

<blockquote><p>预处理可以O(n<sup>2</sup>) 预处理是有递推关系的</p>

<p>但是后面枚举的部分，只能O(n<sup>3</sup>)</p>

<p><strong>不能动态规划的原因是</strong>：他给定了一个可以变化的图，这个图上规模为n的图和规模为n-1的图中正方形个数之间不存在递推关系。</p></blockquote>

<p>And 一般来说处理矩阵的问题，大部分都是O(n<sup>3</sup>)</p>

<h3>Code</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Ways of Dice Throw]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Dice-roll-DP-question/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Dice-roll-DP-question</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/dice-throw-problem/">link</a></p>

<blockquote><p>Given n dice each with m faces, numbered from 1 to m, find the number of ways to get sum X. X is the summation of values on each face when all the dice are thrown.</p></blockquote>

<h3>Solution</h3>

<p><strong>DP</strong></p>

<blockquote><p>Sum(m, n, X) = Sum(m, n &ndash; 1, X &ndash; 1) +</p>

<pre><code>           Sum(m, n - 1, X - 2) +

           .................... + 

           Sum(m, n - 1, X - m)
</code></pre></blockquote>

<p>So we can have dp(n)(X) and for each, iterate m time. Total time is O(m * n * X).</p>

<h3>Code</h3>

<p><strong>not written by me</strong>.</p>

<pre><code>int findWays(int m, int n, int x)
{
    // Create a table to store results of subproblems.  One extra 
    // row and column are used for simpilicity (Number of dice
    // is directly used as row index and sum is directly used
    // as column index).  The entries in 0th row and 0th column
    // are never used.
    int table[n + 1][x + 1];
    memset(table, 0, sizeof(table)); // Initialize all entries as 0

    // Table entries for only one dice
    for (int j = 1; j &lt;= m &amp;&amp; j &lt;= x; j++)
        table[1][j] = 1;

    // Fill rest of the entries in table using recursive relation
    // i: number of dice, j: sum
    for (int i = 2; i &lt;= n; i++)
        for (int j = 1; j &lt;= x; j++)
            for (int k = 1; k &lt;= m &amp;&amp; k &lt; j; k++)
                table[i][j] += table[i-1][j-k];

    /* Uncomment these lines to see content of table
    for (int i = 0; i &lt;= n; i++)
    {
      for (int j = 0; j &lt;= x; j++)
        cout &lt;&lt; table[i][j] &lt;&lt; " ";
      cout &lt;&lt; endl;
    } */
    return table[n][x];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Count Set Bit in Binary Number]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Count-set-bit-in-binary-number/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Count-set-bit-in-binary-number</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Count Set Bit in Binary Number.</p>

<p>3 = 00000011 => 2</p>

<p>128 = 10000000 => 1</p></blockquote>

<h3>Solution</h3>

<p><strong>Bits counting algorithm</strong> (Brian Kernighan). Basic idea is <strong>clear 1 bit at a time</strong>.</p>

<p>This algorithm goes through as many iterations as there are set bits. In the worst case, it will pass once per bit. An integer n has log(n) bits, hence <a href="http://stackoverflow.com/a/12381102">the worst case</a> is O(log(n)).</p>

<h3>Code</h3>

<pre><code>public int countSetBit(String binary) {
    int num = Integer.parseInt(binary, 2);
    int count = 0;
    while (num != 0) {
        num &amp;= num - 1;
        count++;
    }
    return count;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Design Pattern - Singleton & Factory]]></title>
    <link href="http://okckd.github.io/blog/2014/08/19/design-pattern-basic-singleton-factory/"/>
    <updated>2014-08-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/19/design-pattern-basic-singleton-factory</id>
    <content type="html"><![CDATA[<h3>First Word</h3>

<p><strong>Singleton</strong> and <strong>Factory Method</strong> design pattern are the <strong>2 most frequent topics</strong> for OOD.</p>

<h3>Singleton Pattern</h3>

<p><strong><a href="http://en.wikipedia.org/wiki/Singleton_pattern">Singleton pattern</a></strong> is a design pattern that restricts the instantiation of a class to one object.</p>

<h4>in Java</h4>

<p>Since Java 5.0, the easiest way to create a Singleton is the <strong><a href="http://en.wikipedia.org/wiki/Singleton_pattern#The_Enum_way">enum type approach</a></strong>. Here the code is not given.</p>

<p>We will instead cover a very popular implementation: <strong><a href="http://en.wikipedia.org/wiki/Singleton_pattern#Lazy_initialization">Lazy initialization</a></strong>.</p>

<pre><code>public class SingletonDemo {
    private static volatile SingletonDemo instance = null;
    private SingletonDemo() { }
    public static SingletonDemo getInstance() {
        if (instance == null) {
            synchronized (SingletonDemo.class) {
                if (instance == null) {
                    instance = new SingletonDemo();
                }
            }
        }
        return instance;
    }
}
</code></pre>

<p>An alternate simpler version (non-sync):</p>

<pre><code>public class SingletonDemo {
    private static SingletonDemo instance = null;
    private SingletonDemo() { }
    public static synchronized SingletonDemo getInstance() {
        if (instance == null) {
            instance = new SingletonDemo();
        }
        return instance;
    }
}
</code></pre>

<h3>Factory Method Pattern</h3>

<p><strong><a href="http://en.wikipedia.org/wiki/Factory_method_pattern">Factory method pattern</a></strong> is a creational pattern which uses <strong>factory methods</strong> to deal with the problem of creating objects without specifying the exact class of object that will be created.</p>

<p>This is done by creating objects via factory method, either:</p>

<ol>
<li>specified in an interface/abstract class and implemente (differently)</li>
<li>implemented in a base class, and be overridden in derived classes</li>
</ol>


<h4>in Java</h4>

<p>A normal <a href="http://en.wikipedia.org/wiki/Factory_method_pattern#Java">Maze Game</a>:</p>

<pre><code>public class MazeGame {
    public MazeGame() {
        Room room1 = makeRoom();
        Room room2 = makeRoom();
        room1.connect(room2);
        this.addRoom(room1);
        this.addRoom(room2);
    }

    protected Room makeRoom() {
        return new OrdinaryRoom();
    }
}
</code></pre>

<p>A magic game:</p>

<pre><code>public class MagicMazeGame extends MazeGame {
    @Override
    protected Room makeRoom() {
        return new MagicRoom();
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Count Level in Perfect Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/08/19/Count-level-in-perfect-BT/"/>
    <updated>2014-08-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/19/Count-level-in-perfect-BT</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://stackoverflow.com/questions/10721583/how-can-i-calculate-the-level-of-a-node-in-a-perfect-binary-tree-from-its-depth">link</a></p>

<blockquote><p>A perfect binary tree, i.e. each node in the tree is either a leaf node, or has two children, and all leaf nodes are on the same level. Each node has an index in depth-first order.</p></blockquote>

<pre><code>      0
    /   \
  1      4
 / \    / \
2   3  5   6
</code></pre>

<blockquote><p>Given the index (k) of a particular node, calculate its level.</p></blockquote>

<h3>Solution</h3>

<p><strong>This is a <a href="http://stackoverflow.com/a/10721897">magical solution</a></strong>.  It divides the tree in the middle with number k decrease by 1 each time.</p>

<p>Beautiful, and hard to understand.</p>

<h3>Code</h3>

<p><strong>not written by me</strong>.</p>

<pre><code>public int countLevel(TreeNode root, int k, int n) {
    int level = 0;
    while (k != 0) {
        k--;
        n = (n - 1) / 2;
        k = k % n;
        level++;
    }
    return level + 1;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Random Thought]]></title>
    <link href="http://okckd.github.io/blog/2014/08/19/A-random-thought/"/>
    <updated>2014-08-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/19/A-random-thought</id>
    <content type="html"><![CDATA[<p>自从7月16号投了Fb，到今天一共33天。</p>

<p>我大概交了五六次简历。</p>

<p>一个面试都没有，妈的！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Leetcode] Leetcode Second Round (3)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/18/Leetcode-second-third/"/>
    <updated>2014-08-18T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/18/Leetcode-second-third</id>
    <content type="html"><![CDATA[<ol>
<li>Gas Station</li>
<li>Remove Duplicates from Sorted Array II</li>
<li>Word Search</li>
<li>First Missing Positive</li>
<li>Permutations II</li>
<li>Palindrome Partitioning II</li>
<li>Word Ladder</li>
<li>Minimum Window Substring</li>
<li>Largest Rectangle in Histogram</li>
<li>LRU Cache</li>
<li>Regular Expression Matching &ndash; difficult</li>
<li>Wildcard Matching &ndash; very difficult, still</li>
</ol>

]]></content>
  </entry>
  
</feed>
