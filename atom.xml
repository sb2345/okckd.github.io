<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Octopress Blog]]></title>
  <link href="http://okckd.github.io/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-07-31T22:50:32+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Run-Length Encoding]]></title>
    <link href="http://okckd.github.io/blog/2014/07/31/Run-Length-Encoding/"/>
    <updated>2014-07-31T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/31/Run-Length-Encoding</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://tech-queries.blogspot.sg/2008/11/run-length-encoding.html">link</a></p>

<blockquote><p>You are given a string like &ldquo;aaaabbbcc&rdquo;, do an in place conversion which write frequency of each charater(which come continuosly) with that character.</p>

<p>Example:</p>

<p>input: aaabbbcc</p>

<p>output: a3b2c2</p></blockquote>

<h3>Solution</h3>

<p>The most important point is <strong>whether or not you find the special cases</strong>, and did you clarify how to handle them.</p>

<p><strong>First special case is only 1 character</strong>, should you append a &lsquo;1&rsquo; or not. Note that this question requires &lsquo;in place&rsquo; conversion. So &lsquo;1&rsquo; is not supposed to be appended after single-occurance character. This is really important to know, if the question does not specify. (though sometimes, the question asks you to apppend a &lsquo;1&rsquo;, eg. <a href="http://www.geeksforgeeks.org/run-length-encoding/">here</a>).</p>

<p><strong>Second case is when occurance >= 10</strong>. We could not simply append (&lsquo;0&rsquo; + numberOfOccurance), because the number could be 12. This is another very important case to take note.</p>

<p>The code can be seen anywhere.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Points on Globe Puzzle]]></title>
    <link href="http://okckd.github.io/blog/2014/07/31/Points-On-Globe/"/>
    <updated>2014-07-31T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/31/Points-On-Globe</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://tech-queries.blogspot.sg/2009/08/points-on-globe.html">link</a></p>

<blockquote><p>How many points are there on the globe where, by walking one mile south, one mile east, and one mile north, you reach the place where you started?</p></blockquote>

<h3>Solution</h3>

<p>One point in the <strong>North Pole</strong>, and many circles in the <strong>South Pole</strong>.</p>

<p>Read more at question post.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Number of Bus-Stations]]></title>
    <link href="http://okckd.github.io/blog/2014/07/31/Number-Of-Bus-Stations/"/>
    <updated>2014-07-31T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/31/Number-Of-Bus-Stations</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://tech-queries.blogspot.sg/2009/05/number-of-bus-stations.html">link</a></p>

<blockquote><p>At a bus-station, you have time-table for buses arrival and departure. You need to find the minimum number of platforms so that all the buses can be accommodated as per their schedule.</p>

<p>Example: Time table is like below:</p></blockquote>

<pre><code>Bus         Arrival         Departure 
BusA        0900 hrs        0930 hrs
BusB        0915 hrs        1300 hrs
BusC        1030 hrs        1100 hrs
BusD        1045 hrs        1145 hrs
</code></pre>

<blockquote><p>The answer must be 3.</p></blockquote>

<h3>Solution</h3>

<p>The answer is same as finding the maximum number of bus at the bus-station at the same time.</p>

<p><strong>The suggestted solution</strong> from <a href="http://tech-queries.blogspot.sg/2009/05/number-of-bus-stations.html">here</a>:</p>

<blockquote><p>So first sort all the arrival(A) and departure(D) time in an int array. Please save the corresponding arrival or departure in the array also.</p>

<p>After sorting our array will look like this:</p></blockquote>

<pre><code>0900    0915    1930    1030    1045    1100    1145    1300
A       A       D       A       A       D       D       D
</code></pre>

<p>Now use a counter. When sees an A, increment. When sees an D, decreament. In the end, return the largest counter value.</p>

<p>Note: If you have a arriving and a departing at same time, put departure time first.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Inorder Successor in Binary Search Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/07/31/Inorder-Successor-BST/"/>
    <updated>2014-07-31T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/31/Inorder-Successor-BST</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/inorder-successor-in-binary-search-tree/">link</a></p>

<blockquote><p>In Binary Tree, Inorder successor of a node is the next node in Inorder traversal of the Binary Tree. Inorder Successor is NULL for the last node in Inoorder traversal.</p>

<p>Write a program with:</p>

<ol>
<li>parent pointer provided</li>
<li>parent pointer not provided</li>
</ol>
</blockquote>

<h3>Solution</h3>

<p><strong>If have parent pointer, it&rsquo;s easy</strong>. Read solution <a href="http://tech-queries.blogspot.sg/2010/04/inorder-succesor-in-binary-tree.html">here</a>.</p>

<p><strong>If no parent pointer, then we make use of the property of BST, can get an O(h) solution</strong>. h is the height.</p>

<p>A very good solution from <a href="http://algorithmsandme.blogspot.sg/2013/08/binary-search-tree-inorder-successor.html">this blog</a>.</p>

<ol>
<li>Start with root.</li>
<li>If the node is given has less than root, then search on left side <strong>and update successor</strong>.</li>
<li>If the node is greater than root, then search in right part, <strong>don&rsquo;t update successor</strong>.</li>
<li>If we find the node

<ol>
<li>if the node has right sub tree, then the minimum node on the right sub tree of node is the in-order successor.</li>
<li>otherwise, just return successor</li>
</ol>
</li>
</ol>


<p>The most important point is: we only update <strong>successor</strong> during left turn, and don&rsquo;t update during right turn.</p>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public TreeNode inorderSuccessor(TreeNode root, TreeNode target) {
    if (target.right != null) {
        return this.findLeftMost(target.right);
    } else {
        return this.traverse(root, new TreeNode(-1), target);
    }
}

private TreeNode traverse(TreeNode cur, TreeNode pre, TreeNode target) {
    if (cur.val == target.val) {
        return pre;
    } else if (cur.val &lt; target.val) {
        cur = cur.right;
        return traverse(cur, pre, target);
    } else {
        pre = cur;
        cur = cur.left;
        return traverse(cur, pre, target);
    }
}

private TreeNode findLeftMost(TreeNode node) {
    while (node.left != null) {
        node = node.left;
    }
    return node;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Peripheral of a Complete Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/07/30/Peripheral-Of-Complete-Tree/"/>
    <updated>2014-07-30T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/30/Peripheral-Of-Complete-Tree</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://tech-queries.blogspot.sg/2010/09/peripheral-boundary-of-complete-tree.html">link</a></p>

<blockquote><p>Write a program to find the anti-clock-wise peripheral (boundary) of a complete tree.</p>

<p>For a complete tree peripheral (boundary) is defined as</p></blockquote>

<pre><code>1. First the root
1. Then nodes on left edge
1. Then leaf nodes
1. Then nodes on right edge
</code></pre>

<p><img class="left" src="http://okckd.github.io/assets/images/peripheral-of-tree.png"></p>

<blockquote><p>For the above tree, peripheral will be: 0 1 3 7 8 9 10 11 12 13 14 6 2</p></blockquote>

<h3>Solution</h3>

<p><strong>It&rsquo;s a very tricky solution</strong>. Very clever I would say.</p>

<ol>
<li>print root node</li>
<li>print left nodes and leafs of left subtree in same order</li>
<li>print leafs and right nodes of right subtree in same order</li>
</ol>


<p>Do practise this question again in the future!</p>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<p>I used an Enum in the code.</p>

<pre><code>public enum PeriType {
    LEFT, RIGHT, LEAF
}

private void peripheral(TreeNode root) {
    printNode(root);
    helper(root.left, PeriType.LEFT);
    helper(root.right, PeriType.RIGHT);
    System.out.println();
}

private void helper(TreeNode node, PeriType type) {
    if (node == null) {
        return;
    }
    switch (type) {
    case LEFT:
        printNode(node);
        helper(node.left, PeriType.LEFT);
        helper(node.right, PeriType.LEAF);
        break;
    case RIGHT:
        helper(node.left, PeriType.LEAF);
        helper(node.right, PeriType.RIGHT);
        printNode(node);
        break;
    case LEAF:
        if (node.left == null &amp;&amp; node.right == null) {
            printNode(node);
        } else {
            helper(node.left, PeriType.LEAF);
            helper(node.right, PeriType.LEAF);
        }
        break;
    }
}

private void printNode(TreeNode root) {
    System.out.print(root.val + " ");
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Nth Fibonacci Number in O(LogN)]]></title>
    <link href="http://okckd.github.io/blog/2014/07/30/Nth-Fibonacci-Number-In-LogN/"/>
    <updated>2014-07-30T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/30/Nth-Fibonacci-Number-In-LogN</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://tech-queries.blogspot.sg/2010/09/nth-fibbonacci-number-in-ologn.html">link</a></p>

<blockquote><p>Find Nth fibonacci number in O(logN) time complexity.</p></blockquote>

<h3>Solution</h3>

<p><img class="middle" src="http://okckd.github.io/assets/images/fibonacci_matrix.png"></p>

<p>It&rsquo;s a recursive sequence, where we can get the following equation:</p>

<pre><code>A* [ F(1) F(0) ] = [ F(2) F(1) ]
A* [ F(2) F(1) ] = [ F(3) F(2) ] = A^2 * [ F(1) F(0) ]
A* [ F(3) F(2) ] = [ F(4) F(3) ] = A^3 * [ F(1) F(0) ]
..
..
..
..
A* [ F(n) F(n-1) ] = [ F(n+1) F(n) ] = A^n * [ F(1) F(0) ]
</code></pre>

<p>Which means:</p>

<p><img class="middle" src="http://okckd.github.io/assets/images/fibonacci_equation.png"></p>

<p>So all that is left is finding the nth power of the matrix A. Well, this can be computed in O(log n) time, by recursive doubling. For more, see question post or <a href="http://www.codechef.com/wiki/tutorial-dynamic-programming#Finding_nth_Finobacci_number_in_Olog_n">here</a>.</p>

<h3>Code</h3>

<p><strong>not written</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Which Loop Is Faster]]></title>
    <link href="http://okckd.github.io/blog/2014/07/29/Which-is-faster/"/>
    <updated>2014-07-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/29/Which-is-faster</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://tech-queries.blogspot.sg/2010/09/which-loop-is-faster.html">link</a></p>

<blockquote><p>A very basic programming puzzle is being asked in programming interviews since last few years. Which of the below two loops will run faster?</p></blockquote>

<pre><code>/* First */  
for(i=0;i&lt;100;i++)  
 for(j=0;j&lt;10;j++)  
     //do somthing

/* Second */  
for(i=0;i&lt;10;i++)  
 for(j=0;j&lt;100;j++)  
     //do somthing  
</code></pre>

<h3>Solution</h3>

<ol>
<li>The First executes assignment operations 101 times, while Second executes only 11 times.</li>
<li>The First does 101 + 1100 = 1201 comparisons, while the Second does 11 + 1010 = 1021 comparisons.</li>
<li>The First executes 1100 increments, while the Second executes 1010 increments.</li>
</ol>


<h3>Code</h3>

<p>The following code proves why First is faster.</p>

<pre><code>public static void solution() {
    int i, j, k, l;
    k = 0;
    l = 0;
    /* FIRST */
    for (i = 0, l++; i &lt; 10; i++, k++)
        for (j = 0, l++; j &lt; 100; j++, k++)
            ;
    // printf("First Loop: %d\t%d\n", k, l);
    System.out.println(k);
    System.out.println(l);

    k = 0;
    l = 0;
    /* SECOND */
    for (i = 0, l++; i &lt; 100; i++, k++)
        for (j = 0, l++; j &lt; 10; j++, k++)
            ;
    // printf("Second Loop: %d\t%d\n", k, l);
    System.out.println(k);
    System.out.println(l);
}
</code></pre>

<p>output is : 1010, 11, 1100, 101</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Remove Chars in Pairs]]></title>
    <link href="http://okckd.github.io/blog/2014/07/29/Remove-char-in-Pairs/"/>
    <updated>2014-07-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/29/Remove-char-in-Pairs</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/recursively-remove-adjacent-duplicates-given-string/">link</a></p>

<blockquote><p>Given a string, recursively remove adjacent duplicate characters from string. The output string should not have any adjacent duplicates.</p>

<p>Input:  azxxzy</p>

<p>Output: ay</p>

<p>First &ldquo;azxxzy&rdquo; is reduced to &ldquo;azzy&rdquo;. The string &ldquo;azzy&rdquo; contains duplicates, so it is further reduced to &ldquo;ay&rdquo;.</p></blockquote>

<h3>Analysis</h3>

<p>We could do it recursively until all pairs are removed, but it&rsquo;s not good.</p>

<p>There&rsquo;s an O(n) solution.</p>

<h3>Solution</h3>

<p><strong>Most obvious solution is to use a stack</strong>. In the end, the stack stores all unmatched chars.</p>

<p>But we can also <strong>do it without using space</strong> (assuming the input is char array). Just use the original char array to store result, with the helper of 2 pointers. <a href="http://tech-queries.blogspot.sg/2011/02/remove-pairs.html">The code</a> is very much concise.</p>

<h3>Code</h3>

<p><strong>Refactored code by me</strong></p>

<pre><code>public static String remove_pair(char[] input) {
    int len = input.length;
    int right = 1, left = 0;

    while (right &lt; len) {
        // Cancel pairs
        while (right &lt; len &amp;&amp; left &gt;= 0 &amp;&amp; input[right] == input[left]) {
            right++;
            left--;
        }
        if (right == len) {
            break;
        }
        input[++left] = input[right++];
    }
    return String.valueOf(input).substring(0, left + 1);
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Find Min & Max in an Array Using Minimum Comparisons]]></title>
    <link href="http://okckd.github.io/blog/2014/07/29/Find-Min-Max-in-Array/"/>
    <updated>2014-07-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/29/Find-Min-Max-in-Array</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.programcreek.com/2014/02/find-min-max-in-an-array-using-minimum-comparisons/">link</a></p>

<blockquote><p>Given an array of integers find the maximum and minimum elements by using minimum comparisons.</p></blockquote>

<h3>Solution</h3>

<p><strong><a href="http://www.geeksforgeeks.org/maximum-and-minimum-in-an-array/">Compare in Pairs</a></strong>.</p>

<ol>
<li>If n is odd then initialize min and max as first element.</li>
<li>If n is even then initialize min and max as minimum and maximum of the first two elements respectively.</li>
<li>For rest of the elements, pick them in pairs and compare their maximum and minimum with max and min respectively.</li>
</ol>


<p>Number of comparison is 1.5*n.</p>

<p>There&rsquo;s also a <strong>Tournament Method</strong> from G4G, but the implementation is a bit difficult.</p>

<h3>Code</h3>

<p><strong>not written by me</strong></p>

<pre><code>public static void minmax2(int[] a) {
    if (a == null || a.length &lt; 1)
        return;

    int min, max;

    // if only one element
    if (a.length == 1) {
        max = a[0];
        min = a[0];
        System.out.println("min: " + min + "\nmax: " + max);
        return;
    }

    if (a[0] &gt; a[1]) {
        max = a[0];
        min = a[1];
    } else {
        max = a[1];
        min = a[0];
    }

    for (int i = 2; i &lt;= a.length - 2;) {
        if (a[i] &gt; a[i + 1]) {
            min = Math.min(min, a[i + 1]);
            max = Math.max(max, a[i]);
        } else {
            min = Math.min(min, a[i]);
            max = Math.max(max, a[i + 1]);
        }

        i = i + 2;
    }

    if (a.length % 2 == 1) {
        min = Math.min(min, a[a.length - 1]);
        max = Math.max(max, a[a.length - 1]);
    }

    System.out.println("min: " + min + "\nmax: " + max);
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Construct a BST From Preorder Traversal]]></title>
    <link href="http://okckd.github.io/blog/2014/07/29/Construct-BST-from-preorder/"/>
    <updated>2014-07-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/29/Construct-BST-from-preorder</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/g-fact-17/">link</a></p>

<blockquote><p>Given preorder, construct the BST.</p></blockquote>

<h3>Solution</h3>

<p>We can get <strong>Inorder traversal</strong> by sorting the given Preorder traversal. So we have the required two traversals to construct the Binary Search Tree.</p>

<p>A very similar approach would be <strong>always spliting the array</strong> by the head value. Time complexity is O(nlgn) for a balanced BST, or O(n<sup>2</sup>) for a screwed tree.</p>

<p><strong>Howver, there&rsquo;s <a href="http://www.geeksforgeeks.org/construct-bst-from-given-preorder-traversa/">O(n) solutions</a></strong>.</p>

<blockquote><p>The trick is to set a range {min .. max} for every node. Initialize the range as {INT_MIN .. INT_MAX}. The first node will definitely be in range, so create root node. To construct the left subtree, set the range as {INT_MIN …root->data}. If a values is in the range {INT_MIN .. root->data}, the values is part part of left subtree. To construct the right subtree, set the range as {root->data..max .. INT_MAX}.</p></blockquote>

<p><strong>The key</strong> is the we need <strong>a public variable</strong> as a pointer (to traverse thru the array).</p>

<p>There&rsquo;s another <a href="http://www.geeksforgeeks.org/construct-bst-from-given-preorder-traversal-set-2/">O(n) solution</a> using stack. I wont&#8217; cover for now.</p>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<p>It&rsquo;s not an easy question, to be frank.</p>

<pre><code>int p;

public TreeNode solution(int[] preorder) {
    p = 0;
    return helper(preorder, Integer.MIN_VALUE, Integer.MAX_VALUE);
}

private TreeNode helper(int[] A, int min, int max) {
    int len = A.length;
    if (p &gt;= len) {
        return null;
    } else if (A[p] &lt; min || A[p] &gt; max) {
        return null;
    }
    TreeNode root = new TreeNode(A[p]);
    p++;
    root.left = helper(A, min, root.val);
    root.right = helper(A, root.val, max);
    return root;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Matching Nuts and Bolts]]></title>
    <link href="http://okckd.github.io/blog/2014/07/28/Matching-Nuts-And-Bolts/"/>
    <updated>2014-07-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/28/Matching-Nuts-And-Bolts</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://tech-queries.blogspot.sg/2011/01/nuts-and-bolts-algorithm.html">link</a></p>

<blockquote><p>You are given a collection of nuts of different size and corresponding bolts. You can choose any nut &amp; any bolt together, from which you can determine whether the nut is larger than bolt, smaller than bolt or matches the bolt exactly. However there is no way to compare two nuts together or two bolts together. Suggest an algorithm to match each bolt to its matching nut.</p></blockquote>

<h3>Analysis</h3>

<p>Use the idea of quicksort. Find pivot and divide.</p>

<h3>Solution</h3>

<ol>
<li>Take a nut from the nuts pile</li>
<li>Divide bolts around it in 2 parts, which are smaller and larger than this.</li>
<li>Find a matching bolt to this nut.</li>
<li>Divide nuts in 2 parts, which are smaller and larger than matching bolt.</li>
</ol>


<p>Now we have 2 subsets of Nuts and Bolts.</p>

<p>At every step, we will be able to divide these piles in 2 halves and reduce complexity by a factor of 2.</p>

<p><strong>Average case time complexity will be O(nlogn)</strong>, but O(n<sup>2</sup>) when pivot is selection poor.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Check if Number Exists]]></title>
    <link href="http://okckd.github.io/blog/2014/07/28/Check-Number-Exists/"/>
    <updated>2014-07-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/28/Check-Number-Exists</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://tech-queries.blogspot.sg/2011/02/check-if-number-exist.html">link</a></p>

<blockquote><p>There is long list of natural numbers. Remove every 2nd no from list in 1st pass. Remove every 3rd no from list in 2nd pass. Find whether Nth natural no will exist after P passes. N and P are inputs.</p></blockquote>

<pre><code>Example: N is 15 and p is 3.
Initial: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
After 1st pass: 1 3 5 7 9 11 13 15 17 19
After 2nd pass: 1 3 7 9 13 15 19
After 3rd pass: 1 3 7 13 15 19
After 4th pass: 1 3 7 13 19
</code></pre>

<blockquote><p>So we see that 15 exists after 3 passes but vanishes after 4th pass.</p></blockquote>

<h3>Analysis</h3>

<p>We see that in any of the pass <strong>new position will be decreased by no of elements deleted</strong> between 1 and current position.</p>

<p>Example: originally number is 15. After 1st pass, it becomes 8th element. After 2nd pass, it becomes 8 &ndash; (8 / 3) = 6th element.</p>

<p>We stop when either P(i-1)/(i+1) is an integer, or when number is smaller than pass.</p>

<h3>Code</h3>

<p><strong>not written by me</strong></p>

<pre><code>bool check_posiiton(int n, int p)  
{  
 int cur = n;  
 int i = 0;  
 while (i &lt;= p)  
 {  
     i++;  
     if (cur%(i+1) == 0)  
     {  
         //Vanishes in this pass  
         return false;  
     }  
     else if (cur &lt; (i+1))  
     {  
         //Number exist denominator is greater than numerator  
         return true;  
     }  
     cur = cur - cur/(i+1);  
 }  
 return true;  
}  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Breaking Chocolate Bars]]></title>
    <link href="http://okckd.github.io/blog/2014/07/28/Breaking-Chocolate-Bars/"/>
    <updated>2014-07-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/28/Breaking-Chocolate-Bars</id>
    <content type="html"><![CDATA[<h3>Game #1</h3>

<p><a href="http://www.cut-the-knot.org/proofs/chocolad.shtml">link</a></p>

<blockquote><p>Two players take turns breaking a chacolate bar (rectangle-shaped consist of squares). The last to break a piece wins the game.</p>

<p>Design the strategy.</p></blockquote>

<h4>Solution</h4>

<p>Each time the bar is broken, <strong>total number of pieces increase by 1</strong>. Suppose there&rsquo;re even number of squares, 1st player wins regardless of breaking strategy. And vice versa.</p>

<h3>Problem #2</h3>

<p><a href="http://www.cut-the-knot.org/proofs/chocolad.shtml">link</a></p>

<blockquote><p>75 teams took part in a competition where teams met 1-on-1. Each time the defeated team drops out.</p>

<p>How many meets are needed to before one team is declared a winner?</p></blockquote>

<h4>Solution</h4>

<p>Each game will eliminate 1 game, so it needs 74 games.</p>

<h3>Splitting Piles</h3>

<p><a href="http://www.cut-the-knot.org/arithmetic/rapid/piles.shtml">link</a></p>

<blockquote><p>Given a random number of items in a pile. Ask an audience to split a pile into two piles, multiply the numbers of items in the two new piles and keep adding the results. The process stops when there is no pile with more than 1 chip.</p>

<p>For example, let start with 9 chips:</p></blockquote>

<table cellpadding="10">
<tbody><tr><td align="center">Piles</td><td align="center">Which is broken</td><td align="center">What&#8217;s added</td><td align="center">Total</td></tr>
<tr><td colspan="4"><hr></td></tr>
<tr><td align="center">9</td><td align="center">9</td><td align="center">3*6</td><td align="center">18</td></tr>
<tr><td align="center">3,6</td><td align="center">3</td><td align="center">1*2</td><td align="center">20</td></tr>
<tr><td align="center">1,2,6</td><td align="center">6</td><td align="center">3*3</td><td align="center">29</td></tr>
<tr><td align="center">1,2,3,3</td><td align="center">3</td><td align="center">1*2</td><td align="center">31</td></tr>
<tr><td align="center">1,2,1,2,3</td><td align="center">2</td><td align="center">1*1</td><td align="center">32</td></tr>
<tr><td align="center">1,1,1,1,2,3</td><td align="center">2</td><td align="center">1*1</td><td align="center">33</td></tr>
<tr><td align="center">1,1,1,1,1,1,3</td><td align="center">3</td><td align="center">1*2</td><td align="center">35</td></tr>
<tr><td align="center">1,1,1,1,1,1,1,2</td><td align="center">2</td><td align="center">1*1</td><td align="center"><b>36</b></td></tr>
<tr><td align="center">1,1,1,1,1,1,1,1,1</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr>
</tbody></table>


<blockquote><p>Before the audience told the final number, you immediately guess it&rsquo;s 36. How did you do it?</p></blockquote>

<h4>Solution</h4>

<p>The result does not depend on how the piles are split; but only on the initial size of the very first pile. <strong>Answer is always N(N &ndash; 1)/2</strong>.</p>

<p>This can be proved by <a href="http://www.cut-the-knot.org/arithmetic/rapid/piles.shtml">mathematical induction</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode Plus] Sliding Window Maximum]]></title>
    <link href="http://okckd.github.io/blog/2014/07/27/Sliding-Window-Maximum/"/>
    <updated>2014-07-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/27/Sliding-Window-Maximum</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://leetcode.com/2011/01/sliding-window-maximum.html">link</a></p>

<blockquote><p>A long array A[] is given to you. There is a sliding window of size w which is moving from the very left of the array to the very right. You can only see the w numbers in the window. Each time the sliding window moves rightwards by one position. Following is an example:
The array is [1 3 -1 -3 5 3 6 7], and w is 3.</p></blockquote>

<pre><code>Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre>

<blockquote><p>Input: A long array A[], and a window width w</p>

<p>Output: An array B[], B[i] is the maximum value of from A[i] to A[i+w-1]</p></blockquote>

<h3>Analysis</h3>

<p><strong>The  naive approach is using a Heap</strong>. This time complexity is O(n*logn). However, there is a better way using a (double-ended) queue.</p>

<p><strong>We do not need to <a href="http://n00tc0d3r.blogspot.sg/2013/04/sliding-window-maximum.html">keep all numbers</a></strong>. For example, suppose numbers in a window of size 4 are (1, 3, -1, 2). Obviously, no matter what next numbers are, 1 and -1 are never going to be a maximal as the window moving. The queue should look like (3, 2) in this case.</p>

<h3>Solution</h3>

<ol>
<li>When moves to a new number, iterate through back of the queue, removes all numbers that are not greater than the new one, and then insert the new one to the back.</li>
<li>FindMax only need to take the first one of the queue.</li>
<li>To remove a number outside the window, only compare whether the current index is greater than the front of queue. If so, remove it.</li>
</ol>


<p><a href="http://leetcode.com/2011/01/sliding-window-maximum.html">A natural way</a> most people would think is to try to maintain the queue size the same as the window’s size. Try to break away from this thought and think out of the box.</p>

<h3>Code</h3>

<p>Code by N00tc0d3r.</p>

<pre><code>public int[] windowMax(int[] nums, int window) {
    int w = (nums.length &lt; window) ? nums.length : window;
    // A deque allows insertion/deletion on both ends.
    // Maintain the first as the index of maximal of the window
    // and elements after it are all smaller and came later than the first.
    Deque&lt;Integer&gt; que = new ArrayDeque&lt;Integer&gt;();

    // initialize window
    int i = 0;
    while (i &lt; w) {
        while (!que.isEmpty() &amp;&amp; nums[que.getLast()] &lt;= nums[i]) {
            que.removeLast();
        }
        que.addLast(i++);
    }

    // sliding window
    int[] max = new int[nums.length - w + 1];
    max[i - w] = que.getFirst();
    while (i &lt; nums.length) {
        // add new element
        while (!que.isEmpty() &amp;&amp; nums[que.getLast()] &lt;= nums[i]) {
            que.removeLast();
        }
        que.addLast(i);
        // remove old element if still in que
        if (!que.isEmpty() &amp;&amp; i - w &gt;= que.getFirst()) {
            que.removeFirst();
        }
        // get maximal
        ++i;
        max[i - w] = que.getFirst();
    }

    return max;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Reconstruct Tree From Pre-Order Traversal]]></title>
    <link href="http://okckd.github.io/blog/2014/07/27/Reconstruct-Tree-From-PreOrder-Traversal/"/>
    <updated>2014-07-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/27/Reconstruct-Tree-From-PreOrder-Traversal</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://tech-queries.blogspot.sg/2011/06/reconstruct-tree-from-pre-order.html">link</a></p>

<blockquote><p>A tree has a special property where leaves are represented with ‘2’ and non-leaf with ‘1’. Each node has either 0 or 2 children. If given preorder traversal of this tree, construct the tree.</p>

<p>Example: Given Pre Order string => 12122, output:</p></blockquote>

<pre><code>       1
      / \
     2   1
        / \
       2   2
</code></pre>

<h3>Analysis</h3>

<blockquote><p><a href="http://tech-queries.blogspot.sg/2011/06/reconstruct-tree-from-pre-order.html">In normal scenario</a>, it’s not possible to detect where left subtree ends and right subtree starts using only pre-order traversal. But here, we are given a special property. Since every node has either 2 children or no child, we can surely say that if a node exists then its sibling also exists.</p></blockquote>

<p>Keep a public variable and build the tree recursively until the list finishes.</p>

<h3>Code</h3>

<pre><code>ListNode list = null; // this is the input list public variable

public TreeNode main(ListNode input) {
    list = input;
    return constructTree();
}

private TreeNode constructTree() {
    if (list == null) {
        return null;
    }
    TreeNode root = new TreeNode(list.val);
    list = list.next;

    if (root.val == 1) {
        root.left = constructTree();
        root.right = constructTree();
    }
    return root;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Knapsack Problem With Duplications]]></title>
    <link href="http://okckd.github.io/blog/2014/07/27/Knapsack-problem-with-duplication/"/>
    <updated>2014-07-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/27/Knapsack-problem-with-duplication</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://tech-queries.blogspot.sg/2011/04/integer-knapsack-problem-duplicate.html">link</a></p>

<blockquote><p>You have n types of items, where the ith item type has an integer size si and a real value vi. You need to ﬁll a knapsack of total capacity C with a selection of items of maximum value. You can add multiple items of the same type to the knapsack.</p>

<p>This is similar to &ldquo;0-1 Knapsack Problem&rdquo;, but duplication is allowed for this question.</p></blockquote>

<h3>Analysis</h3>

<p>Of course this is DP, and it&rsquo;s 1-D DP. However, <strong>there is one very tricky special case</strong>.</p>

<h3>Solution</h3>

<p>Using &rsquo;M(j)&lsquo; to denote the max value for total weight j, &#8216;w&rsquo; to denote weight, and &lsquo;v&rsquo; to denote value, the equation is:</p>

<blockquote><p>M(j) = max{M(j − 1), max(i=1&hellip;n) M(j − wi) + vi}</p></blockquote>

<p><strong>Note the 2 cases are</strong>:</p>

<ol>
<li>when (j)th spot is not filled, the max value is <strong>M(j-1)</strong></li>
<li>when (j)th spot is filled, the max value is <strong>max(i=1&hellip;n) M(j − wi) + vi</strong></li>
</ol>


<p>This question is trickier than &ldquo;0-1 Knapsack Problem&rdquo;, if not more difficult. <strong>Study the 2 question together</strong>.</p>

<h3>Code</h3>

<p><strong>not written by me</strong></p>

<pre><code>int knapsack(int value[], int weight[], int n, int C, vector&lt;int&gt; backtrack) {
 int *M = new int[C+1];  
 int i, j, tmp, pos;  
 for(i=1; i&lt;= C; i++) {  
     M[i] = M[i-1];  
     pos = i-1;               
     for(j=0; j&lt; n; j++)  
     {  
         if (i &gt;= weight[j])  
             tmp = M[i-weight[j]] + value[j];  
         if (tmp &gt; M[i]){  
             M[i] = tmp;  
             pos = i - weight[j];  
         }  
     }  
     backtrack.push_back(pos);  
 }   
 int ans = M[C];  
 delete[] M;        
 return ans;  
}  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Fit 1*2 Dominos in 2*N Strip]]></title>
    <link href="http://okckd.github.io/blog/2014/07/27/Fit-dominos-in-strip/"/>
    <updated>2014-07-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/27/Fit-dominos-in-strip</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://tech-queries.blogspot.sg/2011/07/fit-12-dominos-in-2n-strip.html">link</a></p>

<blockquote><p>In how many ways can one tile a 2 X N strip of square cells with 1 X 2 dominos?</p></blockquote>

<p><img class="left" src="http://okckd.github.io/assets/images/Dominos.png"></p>

<h3>Solution</h3>

<p><strong>X(n+1) = X(n) + X(n-1)</strong></p>

<p>It&rsquo;s a Fibonacci Series with X(1) = 1 and X(2) = 2.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Elephant and Bananas]]></title>
    <link href="http://okckd.github.io/blog/2014/07/27/Elephant-And-Bananas/"/>
    <updated>2014-07-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/27/Elephant-And-Bananas</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://tech-queries.blogspot.sg/2011/04/elephant-and-banana.html">link</a></p>

<blockquote><p>There&rsquo;s a elephant, which can carry max 1000 bananas. The elephant eats a banana every 1 Km (both forward and back).</p>

<p>Now we want to transfer 3000 bananas to a place 1000 Km away. How many bananas can be left?</p>

<p>Also solved to generalized problem (write code for solution).</p></blockquote>

<h3>Analysis</h3>

<p><strong>If we subdivide distances for each kilometer</strong>. Notice if elephant wants to shift all the bananas 1 km, <strong>you will loose 5 bananas every km</strong>.</p>

<p>So we transferred 2995 (998+998+999) to one km distance. This process continues until after 200 km, we have only 2000 bananas left with remaining distance of 800 km.</p>

<p><strong>Start from here, we only loose 3 bananas every km</strong>. This goes on for another 334 km, we will have 998 bananas left, and the rest of the bananas can be transfered in a single journey.</p>

<h3>Solution</h3>

<p><strong>532 bananas</strong>.</p>

<h3>Code</h3>

<p><strong>not written by me</strong></p>

<pre><code>double transferBananas(double N, double D, double C, double F) {  
    // base case: remaining bananas &lt;= C,  
    // so carry all the bananas in one trip  
    // at this point if distance is more than N/F,  
    // elephant can never reach destination, return 0  
    if (N &lt;= C) {
        double bananasAtDestination = N - D*F;  
        return (bananasAtDestination &gt;= 0.0) ?  
            bananasAtDestination :  0.0;    // out of bananas!  
    }  

    // # trips you would travel back and forth  
    int numTrips = 2*(ceil(N/C) - 1) + 1;  

    // how many bananas you consume per km  
    double costPerKm = numTrips * F;  

    // remaining number of bananas after consumption, we want it  
    // as an integer multiple of C.  
    double remainingBananas = C*(ceil(N/C) - 1.0);  

    // this is the distance you are able to travel before you  
    // reach ONE LESS round trip fetching bananas  
    // derived from eq: N - costPerKm * traveled = remaining bananas  

    double traveled = (N - remainingBananas) / costPerKm;  

    // we are able to travel greater (or equal) than the remaining  
    // distance, so fetch the bananas right to the destination  
    if (traveled &gt;= D)
        return N - D*costPerKm;  

    // calculate recursively as we travel ONE less round trip now.  
    return transferBananas(remainingBananas, D-traveled, C, F);  
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode Plus] Coins in a Line]]></title>
    <link href="http://okckd.github.io/blog/2014/07/27/Coins-in-Line/"/>
    <updated>2014-07-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/27/Coins-in-Line</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://leetcode.com/2011/02/coins-in-line.html">link</a></p>

<blockquote><p>There are n coins in a line. Two players take turns to take a coin from one of the ends of the line until there are no more coins left. The player with the larger amount of money wins. Assume that you go first, describe an algorithm to compute the maximum amount of money you can win.</p></blockquote>

<h3>Analysis</h3>

<p><strong>There&rsquo;s a guaranteed &lsquo;win strategy&rsquo;</strong>, if the input array is even size. Find the sum of coins at even and odd positions respectively. Then, make sure you always take coin from even (or odd, whichever sum is bigger) position.</p>

<p>This strategy is clever and simple, but <strong>DOES NOT maximize your total sum</strong>.</p>

<h3>Solution</h3>

<p><strong>The optimized solution is to use <a href="http://tech-queries.blogspot.sg/2011/06/get-maximum-sum-from-coins-in-line.html">2-D DP</a></strong>. Now we have array A and C(i, j) which is the maximum sum possible when remaining coins are from i to j.</p>

<p>You can take either i or j. Since the opponent is as smart as you, he would have chosen the choice that yields the minimum amount to you.</p>

<p>So, the final equation is:</p>

<blockquote><p>C(i, j) = max { Ai + min{C(i+2, j), C(i+1, j-1)}, Aj + min{C(i+1, j-1), C(i, j-2)} }</p></blockquote>

<h3>Code</h3>

<p>C++ code</p>

<pre><code>#define MAX 100  
int maxMoney(int A[], int N) {
    int C[MAX][MAX] = {0};  
    int x, y, z; //x = C[m+2][n], y = C[m+1][n-1], z = C[m][n-2]  
    for (int i = 0; i &lt; N; i++) {
        for (int m = 0, n = i; n &lt; N; m++, n++) {
          //calculate x, y, z  
          x = (m+2 &lt; N)                         ? C[m+2][n] : 0;  
          y = (m+1 &lt; N &amp;&amp; n-1 &gt;= 0)    ? C[m+1][n-1] : 0;  
          z = (n-1 &gt; 0)                            ? C[m][n-2] : 0;  
          C[m][n] = max(A[m] + min(x,y),  
                                 A[n] + min(y,z));  
          //For Debugging        
          cout &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ", " &lt;&lt; z &lt;&lt; endl;  
          cout &lt;&lt; m &lt;&lt; ", " &lt;&lt; n &lt;&lt; ", " &lt;&lt; C[m][n] &lt;&lt; endl;  
        }
    }
    return C[0][N-1];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Truth Tell Brain Teaser]]></title>
    <link href="http://okckd.github.io/blog/2014/07/26/True-tell-brain-teaser/"/>
    <updated>2014-07-26T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/26/True-tell-brain-teaser</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://tech-queries.blogspot.sg/2011/07/truth-or-lie.html">link</a></p>

<blockquote><p>There are 100 people in a room. A person always speaks either lie or truth.</p>

<p>When asked:</p></blockquote>

<pre><code>1st person says =&gt; all are liars
2nd person says =&gt; at most 1 speaks truth
3rd person says =&gt; at most 2 speak truth
4th person says =&gt; at most 3 speak truth
.
.
.
100th person says =&gt; at most 99 speak truth
</code></pre>

<blockquote><p>&ldquo;At most N&rdquo; means &ldquo;there&rsquo;re N or less than N&rdquo;.</p>

<p>How many people speak only truth?</p></blockquote>

<h3>Solution</h3>

<ol>
<li></li>
<li><p>Assume 1st person speaks truth, then all including him should be liar. It means he doesn’t speak truth.</p></li>
<li><p>Assume 2nd person speaks truth, then he is the only person who speaks truth. But if this statement is true then statements by all others are also true. I.e. if “at most 1 person speaks truth” is true then “at most N speak truth” is also true. So person 2 is also a liar.</p></li>
<li><p>Assume 3rd person is speaking truth. But then the statements of person 4-100 are also true, which contradicts his own statement. It means that person 3 is also a liar.</p></li>
<li><p>This process will continue since 50th person. So 1-50 people are liars.</p></li>
<li><p>51st person says “at most 50 speak truth”. Lets say he is speaking truth. “at most 50” means any number from 0-50. It means that statements like “at most 51 speak truth” and “at most 70 speak truth” are also true. It means that people from 51 to 100 are speaking truth.</p></li>
</ol>


<p><strong>Hence, 50 people speak truth</strong>.</p>
]]></content>
  </entry>
  
</feed>
