<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Octopress Blog]]></title>
  <link href="http://okckd.github.io/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-19T01:25:51+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Random Thought]]></title>
    <link href="http://okckd.github.io/blog/2014/08/19/A-random-thought/"/>
    <updated>2014-08-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/19/A-random-thought</id>
    <content type="html"><![CDATA[<p>自从7月16号投了Fb，到今天为止一共33天，我已经交了五六次简历了。</p>

<p>一个面试都没有，他奶奶的！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Leetcode] Leetcode Second Round (3)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/18/Leetcode-second-third/"/>
    <updated>2014-08-18T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/18/Leetcode-second-third</id>
    <content type="html"><![CDATA[<ol>
<li>Gas Station</li>
<li>Remove Duplicates from Sorted Array II</li>
<li>Word Search</li>
<li>First Missing Positive</li>
</ol>


<h3>2.2</h3>

<ol>
<li>Distinct Subsequences</li>
<li>Merge k Sorted Lists</li>
<li>Permutations II &ndash; duplication removal</li>
<li>Palindrome Partitioning II</li>
<li>Longest Valid Parentheses</li>
<li>Word Ladder</li>
<li>Minimum Window Substring &ndash; only check left bound when count = length</li>
<li>Median of Two Sorted Arrays &ndash; note the main logic conditions</li>
<li>Largest Rectangle in Histogram &ndash; be careful when coding</li>
</ol>


<h3>Difficult</h3>

<ol>
<li>Regular Expression Matching</li>
<li>Wildcard Matching</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Numbers Concatenation to Get Max Value]]></title>
    <link href="http://okckd.github.io/blog/2014/08/17/Numbers-Concatenation-Max/"/>
    <updated>2014-08-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/17/Numbers-Concatenation-Max</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.itint5.com/oj/#45">link</a></p>

<blockquote><p>数组nums中有n个非负整数（整数用字符串表示），将它们以一定的顺序拼接，得到最大的整数。</p>

<p>样例：</p>

<p>nums: [&ldquo;54&rdquo;, &ldquo;546&rdquo;, &ldquo;548&rdquo;, &ldquo;60&rdquo;]</p>

<p>可以拼接得到的最大整数为&#8221;6054854654&#8221;，因此函数应该返回&#8221;6054854654&#8221;。</p></blockquote>

<h3>Solution</h3>

<p><strong>I will first list out 2 special cases</strong>:</p>

<blockquote><p>{40, 20, 201} => 4020201</p>

<p>{40, 20, 203} => 4020320</p></blockquote>

<p>Knowing about this 2 cases helps us to come up with a sorting-based algorithm. We only need to achieve this:</p>

<blockquote><p>201 &lt; 20</p>

<p>20 &lt; 203</p></blockquote>

<p>By reading <a href="http://www.itint5.com/discuss/183/%E8%B0%81%E8%83%BD%E5%B8%AE%E6%88%91%E7%9C%8B%E4%B8%80%E4%B8%8B%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8Cn-200%E6%97%B6%E6%8F%90%E7%A4%BAsegmentation">this post</a>, I found the best comparator solution, defined as below:</p>

<pre><code>String firstNum = s1 + s2;
String secondNum = s2 + s1;
return firstNum.compareTo(secondNum);
</code></pre>

<h3>Code</h3>

<p><strong>written by me</strong>.</p>

<pre><code>public String biggestNum(String[] nums) {
    Arrays.sort(nums, new SpecialComparator());
    StringBuilder sb = new StringBuilder();
    for (int i = nums.length - 1; i &gt;= 0; i--) {
        sb.append(nums[i]);
    }
    return sb.toString();
}

class SpecialComparator implements Comparator&lt;String&gt; {
    public int compare(String s1, String s2) {
        // eg.
        // 40 &gt; 20
        // 20 &gt; 201
        // 203 &gt; 20
        String firstNum = s1 + s2;
        String secondNum = s2 + s1;
        return firstNum.compareTo(secondNum);
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Number of Valid Trees Given Preorder and Postorder]]></title>
    <link href="http://okckd.github.io/blog/2014/08/17/Number-of-tree-given-preorder-postorder/"/>
    <updated>2014-08-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/17/Number-of-tree-given-preorder-postorder</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.itint5.com/oj/#28">link</a></p>

<blockquote><p>对于包含n个结点的二叉树（树中结点编号从1到n），已知前序和后序遍历序列，我们知道不一定能唯一的恢复这棵树。请计算出满足条件的二叉树的总数。</p>

<p>Example</p></blockquote>

<pre><code>前序遍历序列preorder：1 2
后序遍历序列postorder：2 1

一共有2棵满足条件的二叉树：
    1       1
   /         \
  2           2
</code></pre>

<h3>Solution</h3>

<blockquote><p>先看两种遍历的性质:</p>

<p>pre-order: root, left *************, right #########</p>

<p>post-order: **************left, ########right, root</p>

<p>所以 pre-order 的第一个元素一定等于 post-order 的最后一个元素. 然后在post-order中由前往后找, 找出等于pre-oder中第二个元素的位置, 也就是 left 的位置.</p>

<ol>
<li>如果post-order中的这个位置不是倒数第二个, 说明左右子树都非空, 那么对左右子树递归<strong>调用后用乘法原理</strong>.</li>
<li>如果是倒数第二个, 说明有一个子树为空, return的值就是 <strong>2*递归调用非空子树</strong>.</li>
</ol>
</blockquote>

<p><a href="http://www.itint5.com/discuss/94/%E8%AF%B7%E5%A4%A7%E5%AE%B6%E6%8F%90%E4%B8%80%E4%BA%9B%E6%94%B9%E8%BF%9B%E6%84%8F%E8%A7%81">ref</a></p>

<h3>Code</h3>

<p><strong>not written by me</strong>. This code is REALLY 叼炸天。</p>

<pre><code>int helper(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; posorder, 
         int i1, int j1, int i2, int j2){
    if(i1 == j1) return 1;
    if(preorder[i1+1] == posorder[j2-1]){
        return 2*helper(preorder, posorder, i1+1, j1, i2, j2-1);
    }
    int k = i2;
    while(posorder[k] != preorder[i1+1]){ k++; }
    return helper(preorder, posorder, i1+1,i1+1+k-i2 ,i2 , k)
         * helper(preorder, posorder, i1+2+k-i2, j1, k+1, j2-1);
}

int countValidTrees(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; posorder) {
    int n = preorder.size();
    return helper(preorder, posorder, 0, n-1, 0, n-1);
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Twitter] Arithmetic Expression Evaluation]]></title>
    <link href="http://okckd.github.io/blog/2014/08/17/Expression-evaluation/"/>
    <updated>2014-08-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/17/Expression-evaluation</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.itint5.com/oj/#26">link</a></p>

<blockquote><p>给定一个表达式字符串，其中只包含非负整数，加法，减法以及乘法符号，例如7+3<em>4</em>5+2+4-3-1。请写程序计算该表达式的值。</p>

<p>提示：可以尝试使用递归算法，程序将非常简洁易写，很适用于面试场合。</p></blockquote>

<h3>Solution</h3>

<p><strong>Trying to solve this problem iteratively is like suicide</strong>. The code would be lengthy and buggy, and very hard to make it right.</p>

<p><strong>The most important point about this question, is how to handle minus(&ndash;) sign</strong>. We know that when we see * and /, we evaluate immediately, and when sees + and &ndash;, we postpone it. However this case:</p>

<blockquote><p>1 &ndash; 2 &ndash; 3</p></blockquote>

<p>If we postpone the first minus sign, we would end up getting:</p>

<blockquote><p>1 &ndash; (-1)</p></blockquote>

<p>So it&rsquo;s wrong (outputing 2 in this case).</p>

<p><strong>The solution to this issue is, consider (a &ndash; b) as (a + (-b))</strong>. That&rsquo;s why later in the code, you&rsquo;ll see a variable <strong>preNum</strong> being modified.</p>

<p><a href="http://www.itint5.com/discuss/50/case%E9%87%8C%E9%9D%A2%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B8%A6%E8%B4%9F%E6%95%B4%E6%95%B0%E7%9A%84%EF%BC%8C%E5%B9%B6%E6%B1%82%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0">ref</a></p>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>int p;

public int evaluate(String expr) {
    p = 0;
    int firstNum = getNumber(expr);
    return helper(firstNum, expr);
}

private int helper(int preNum, String expr) {
    // now p points to a operator (or end of string)
    if (p == expr.length()) {
        return preNum;
    }
    char operator = expr.charAt(p);
    p++;
    int nextNum = getNumber(expr);
    switch (operator) {
    case '+':
        return preNum + helper(nextNum, expr);
    case '-':
        return preNum + helper(-1 * nextNum, expr);
    case '*':
        return helper(preNum * nextNum, expr);
    default:
        return helper(preNum / nextNum, expr);
    }
}

private int getNumber(String expr) {
    // now p points to a number
    int num = 0;
    while (p &lt; expr.length() &amp;&amp; expr.charAt(p) &gt;= '0'
            &amp;&amp; expr.charAt(p) &lt;= '9') {
        num = num * 10 + expr.charAt(p) - '0';
        p++;
    }
    return num;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Orthogonal Traverse the Map (`)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/16/orthogonal-traverse-map/"/>
    <updated>2014-08-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/16/orthogonal-traverse-map</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.itint5.com/oj/#22">link</a></p>

<blockquote><p>有一个n*m（n和m都不超过50）的棋盘，有k个目标格子需要访问。需要访问的格子的横纵坐标存放在数组x[]和y[]中(0&lt;=x[i]&lt;n, 0&lt;=y[i]&lt;m)。</p>

<p>遍历的规则为：</p>

<p>每一步只能从一个目标格子水平或者竖直跳跃移动到另一个目标格子。</p>

<p>连续的两步必须形成直角。即如果前一步是水平移动，那么下一步只能竖直移动。</p>

<p>问是否存在一种遍历顺序，使得每个目标格子有且仅被访问一次。</p>

<p>样例：k=8, x=[0, 0, 0, 0, 2, 2, 4, 4], y=[0, 2, 4, 6, 4, 6, 2, 4],对应于下图中A, B, C, D, F, E, G, H 8个目标格子，存在满足条件的遍历A->D->E->F->C->B->G->H。</p></blockquote>

<p><img class="middle" src="http://okckd.github.io/assets/images/orthogonal-map.jpg"></p>

<h3>Solution</h3>

<blockquote><p>n,m的棋盘，<a href="http://www.itint5.com/discuss/22/%E7%9B%B4%E8%A7%92%E8%B7%AF%E7%BA%BF%E9%81%8D%E5%8E%86%E6%A3%8B%E7%9B%98">建一个包含n+m个顶点的图G</a>（为了方便说明，类似二分图将其分为两列，左边n个顶点，右边m个顶点，分别代表n行和n列）。</p>

<p>对于目标格子(i,j)，左边第i个顶点和右边第j个顶点连一条边。最后的问题其实就是问转换之后的图G是否存在欧拉欧拉回路或者欧拉路径。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Excel Decimal Conversion]]></title>
    <link href="http://okckd.github.io/blog/2014/08/16/Excel-decimal-conversion/"/>
    <updated>2014-08-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/16/Excel-decimal-conversion</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.itint5.com/oj/#23">link</a></p>

<blockquote><p>Excel中的行列数用A~Z 26个字母表示，A, B, C, D, …, Z, AA, AB, …, AZ, BA, BB, … 分别表示10进制数1, 2, 3, 4, …, 26, 27, 28, …, 52, 53, 54…。</p>

<p>请实现2个函数decToExcel和excelToDec，将10进制数转换为Excel数，以及将Excel数转换为10进制数。</p></blockquote>

<h3>Solution</h3>

<p>Note the indexing starts from 1, not from 0. This caused some trouble for me.</p>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public String decToExcel(int decNum) {
    decNum--;
    int digits = 1;
    int exponen = 26;
    while (decNum &gt;= exponen) {
        decNum -= exponen;
        exponen *= 26;
        digits++;
    }
    // now we know the total number of digits
    int num = decNum;
    int total = exponen / 26;
    String ans = "";
    for (int i = 0; i &lt; digits; i++) {
        ans += (char) (num / total + 'A');
        num %= total;
        total /= 26;
    }
    return ans;
}

public int excelToDec(String excelNum) {
    int digits = excelNum.length();
    int total = 1;
    int sum = 1;
    for (int i = 1; i &lt; digits; i++) {
        total *= 26;
        sum += total;
    }
    for (int i = 0; i &lt; digits; i++) {
        sum += (excelNum.charAt(i) - 'A') * total;
        total /= 26;
    }
    return sum;
}
</code></pre>

<p><strong>updated code</strong>: we can actually do it recursively. The code is much more concise (the code is found in the eclipse project).</p>

<pre><code>//将十进制数转换为excel数
public String decToExcel(int decNum) {
    if (decNum == 0) {
        return "";
    }
    decNum--;
    char last = (char) ('A' + decNum % 26);
    return decToExcel(decNum / 26) + last;
}

//将excel数转换为十进制数
public int excelToDec(String excelNum) {
    if (excelNum.equals("")) {
        return 0;
    }
    int len = excelNum.length();
    int last = 1 + excelNum.charAt(len - 1) - 'A';
    return excelToDec(excelNum.substring(0, len - 1)) * 26 + last;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Facebook] Task Scheduling Question (`)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/15/Task-scheduling-question/"/>
    <updated>2014-08-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/15/Task-scheduling-question</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.itint5.com/oj/#10">link</a></p>

<blockquote><p>有n个任务需要完成（编号1到n），任务之间有一些依赖关系，如果任务a依赖于任务b和c，那么只有当任务b和任务c完成之后才能完成任务a。给定所有的依赖关系，判断这些任务是否能够完成。如果能够完成，请给出一个合法的任务完成序列。</p>

<p>样例：</p>

<p>n=5</p>

<p>1->2,3</p>

<p>3->4</p>

<p>上述样例中任务1依赖于任务2和任务3，任务3依赖于任务4，那么存在合法的任务完成序列4,3,2,1,5</p></blockquote>

<h3>Solution</h3>

<p><a href="http://www.itint5.com/discuss/8/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6java%E7%A8%8B%E5%BA%8F">http://www.itint5.com/discuss/8/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6java%E7%A8%8B%E5%BA%8F</a></p>

<h3>Code</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Product All 1s]]></title>
    <link href="http://okckd.github.io/blog/2014/08/15/Product-all-ones/"/>
    <updated>2014-08-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/15/Product-all-ones</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.itint5.com/oj/#18">link</a></p>

<blockquote><p>给定一个非负整数a（不超过10<sup>6</sup>），是否存在整数b，使得a和b的乘积全为1。如果存在，返回最小的乘积的位数。如果不存在，返回-1。</p>

<p>样例：a=3，存在b=37，使得3*37=111，则函数应返回3（111的位数）。</p></blockquote>

<h3>Solution</h3>

<p>There&rsquo;s 1 equation of mod operation, which is helpful:</p>

<blockquote><p>(a * b) mod x = ((mx+a&#8217;) * (nx+b&#8217;)) mod x = (a&#8217; mod x) * (b&#8217; mod x) = (a mod x) * (b mod x)</p>

<p>i.e.  (a * b) mod x = (a mod x) * (b mod x)</p></blockquote>

<p>Altough <a href="http://www.itint5.com/discuss/136/%E8%BF%99%E9%A2%98%E6%88%91%E8%B6%85%E6%97%B6%E4%BA%86%EF%BC%8C%E8%AF%B7%E9%97%AE%E5%A6%82%E4%BD%95%E7%BC%A9%E7%9F%AD%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4">I don&rsquo;t understand why</a> does it contribute to the incredibly short solution code posted below. I can&rsquo;t solve this question, freakly speaking.</p>

<h3>Code</h3>

<pre><code>int findMinAllOne(int a) {
    if (a &lt; 0 || (a % 10) % 2 == 0 || a % 10 == 5)
        return -1;

    int ans = 1;
    for (int p = 1; p != 0; p %= a) {
        p = 10 * p + 1;
        ++ans;
    }
    return a == 1 ? ans - 1 : ans;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] 跳马问题加强版]]></title>
    <link href="http://okckd.github.io/blog/2014/08/15/Knight-tour-jumpable-question/"/>
    <updated>2014-08-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/15/Knight-tour-jumpable-question</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.itint5.com/oj/#12">link</a></p>

<blockquote><p>有一个无限大的棋盘，棋盘上有一匹马，马可以从长宽分别为p和q的矩形一个角移动到对角。即假设马当前的位置为(x,y)，那么下一步可以移动到(x+p,y+q)，(x+p,y-q)，(x-p,y+q)，(x-p,y-q)，(x+q,y+p)，(x+q,y-p)，(x-q,y+p)或者(x-q,y-p)这8个位置。</p>

<p>问马是否能从坐标(x,y)按照上述移动规则移动到坐标(x2,y2)。</p></blockquote>

<h3>Solution</h3>

<p><a href="http://www.itint5.com/discuss/16/%E8%B7%B3%E9%A9%AC%E9%97%AE%E9%A2%98%E5%8A%A0%E5%BC%BA%E7%89%88">ref</a></p>

<ol>
<li>计算dx=x-x2,dy=y-y2。</li>
<li>求出p,q的最大公约数g，如果dx或者dy不能被g整除，那么很显然无解。</li>
<li>将p,q,dx,dy都除以g，现在p和q互质了。</li>
<li>注意到马可以跳到点(0,2p)（先(p,q)跳一下，然后(p,-q)跳一下），重复这个过程，马可以跳到任意(0,2kp)的点，由于对称性，也可以跳到任意(2kp,0)的点。
5.下面这一步很关键，由于p,q互质，那么存在x,y满足px+qy=1（扩展欧几里德定理）。这样，马可以跳到(0,2)和和(2,0)，由于对称性，马可以跳到任意坐标都为偶数点。</li>
<li>有了上面的结论，其实只用考虑(0,0),(0,1),(1,0),(1,1)这4个点是否可达。(0,0)是可达的，(0,1)和(1,0)由于对称性只用考虑(0,1)。</li>
<li>对于(1,1)，其实是永远可达的。如果q,p都为奇数，可以先跳到(1+p,1+q)的点（利用5中的结论，可以跳到都是偶数的点），然后(-p,-q)跳到(1,1)。如果p,q一奇一偶，可以先跳到(1+p+q,1+q+p)的点（利用5中的结论），然后(-p,-q),(-q,-p)两步跳到(1,1)。</li>
<li>对于(0,1)，如果p,q一奇一偶，那么也是永远可达的（同7可证）。如果p,q都是奇数，那么是不可能跳到(0,1)的，因为两个奇数不管怎么加减交替运算都不可能变成一奇一偶。</li>
</ol>


<p>所以最后的结论就是：<strong>第3步之后，如果p,q一奇一偶，那么可达。否则dx,dy同奇或同偶才可达</strong>。</p>

<p>gcd的代码 (concise version):</p>

<pre><code>int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
</code></pre>

<h3>Code</h3>

<p><strong>not written by me</strong></p>

<pre><code>int gcd(int a, int b){
    return b? gcd(b, a%b) : a;
}
bool canJump(int p, int q, int x, int y, int x2, int y2) {
    if(p==0 &amp;&amp; q==0) return (x==x2)&amp;&amp;(y==y2);
    int x1 = x2 - x, y1 = y2 - y;
    int g1 = gcd(p, q);
    if( x1 % g1 || y1 % g1) return false;
    p = p/g1;
    q = q/g1;
    x1 = x1/g1;
    y1 = y1/g1;
    if((p-q)%2 ) return true;
    else return (x1-y1)%2 == 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Greatest Common Divisor]]></title>
    <link href="http://okckd.github.io/blog/2014/08/15/Greatest-common-divisor/"/>
    <updated>2014-08-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/15/Greatest-common-divisor</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Get GCD in more efficient code</p></blockquote>

<h3>Code</h3>

<p>this is 掉渣天。</p>

<pre><code>public int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Alphabet Table (`)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/15/Alphabet-table/"/>
    <updated>2014-08-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/15/Alphabet-table</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://blog.sina.com.cn/s/blog_979956cc0101i67x.html">link</a></p>

<blockquote><p>每一种语言，都有自己的字母表，类似英文的a-z，但是顺序不相同。例如，有的语言可能是z是第一个之类的。现在给定这个语言的字典，请分析这个字典，得到这个语言的字母表的顺序。</p>

<p>例如：有如下的字母：C CAC CB BCC BA。 经过分析，得到字母表为C->A->B。</p></blockquote>

<h3>Solution</h3>

<p><a href="http://page.renren.com/601882592/channel-noteshow-927705419">http://page.renren.com/601882592/channel-noteshow-927705419</a></p>

<ol>
<li>C 2. CAC 3. CB 4. BCC 5. BA 经过分析，得到字母表为C->A->B。</li>
</ol>


<p>分析 字典序相邻的位置的字符串，只会有如下两种情况：</p>

<p>（1）排在前面的字符串是下一个串的子串，如C与CAC</p>

<p>（2）两个字符串具有第一对不相同的字符对，如CAC和CBB，第一个不相同的字符对为（A，B），这是就要求A在字母表中的顺序在B前面。对于后面字符并没有要求，如并不要求第二个不相同的字符对（C，B）中的C在字母表中的顺序在B前面。</p>

<p>所以按照第（2）种情况建图，然后对该有向无环图求拓扑排序即可。</p>

<p>So this becomes a Topology Sorting question.</p>

<h3>Code</h3>

<p><strong>not written by me</strong></p>

<pre><code>pair&lt;char,char&gt;  constructEdge(const string &amp; src1, const string &amp; src2)
{
     int min_len = min(src1.length(), src2.length());
     int i = 0;
     while(i &lt; min_len &amp;&amp; src1[i] == src2[i]){
           i++;
     }
     if(i &lt; min_len){
           return  make_pair(src1[i], src2[i]);
     }else{
           return  make_pair('\0','\0');
     }
}
//-1, 0, 1
int  alphaTable(const vector&lt;string&gt; &amp;  dict, vector&lt;char&gt; &amp; alpha_table)
{
     unordered_map&lt;char,set&lt;char&gt; &gt;  edges;
     set&lt;char&gt; nodes;
     for(const string &amp; word : dict){
          for(char c : word){
              nodes.insert(c);
          }
     }
     unordered_map&lt;char,int&gt;  in_degree;
     for(int i = 1; i &lt; dict.length(); i++){
          pair edge = constructEdge(dict[i-1],dict[i]);
          if(edge.first != '\0'){
              edges[edge.first].insert(edge.second);
              in_degree[edge.second]++;
          }
     }
     queue&lt;char&gt;  q;
     for(char node : nodes){
         if(in_degree[node] == 0){
              q.push(node);
         }
     }
     alpha_table.clear();
     int result = 0;
     while(!q.empty()){
        if(q.size() &gt; 1){
            result = 1;
        }
        char  c = q.front();
        q.pop();
        alpha_table.push_back(c);
        for(char node : edges[c]){
             in_degree[node] --;
             if(in_degree[node] == 0){
                  q.push(node);
             }
         }
     }//while
     if(alpha_table.size() &lt; nodes.size()){
         result = -1;
     }
     return result;    
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Facebook] Large String Find Substring]]></title>
    <link href="http://okckd.github.io/blog/2014/08/14/Large-string-find-substring/"/>
    <updated>2014-08-14T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/14/Large-string-find-substring</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.itint5.com/oj/#15">link</a></p>

<blockquote><p>有一个长度为n的字符串str，有非常多的关键字query（长度不超过10），需要判断每个关键字是否是str的子串。</p>

<p>注意：query是动态的输入进行查询的，预先并不知道所有的query。</p></blockquote>

<h3>Solution</h3>

<p><strong>Basic idea of the solution is to use Prefix Tree (Trie)</strong> and similar alternatives.</p>

<p><strong>Solution 1</strong> is <a href="http://www.itint5.com/discuss/27/%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%A2%84%E5%A4%84%E7%90%86">an nice idea using HashMap</a>.</p>

<blockquote><p>我是把所有长度&lt; =10的子串，哈希一下存放到10个哈希表中。</p>

<p>至于哈希函数的选取，随便选一个应该都不会超时。</p></blockquote>

<p><strong>Solution 2</strong> is using so-called &lsquo;<strong>prefix array</strong>&rsquo;. The most important point of this idea is to only make a substring instance <strong>for every 10 characters</strong>.</p>

<blockquote><p>只用=10的子串。然后二分查找</p>

<p>用=10的字串排序即可，如包含更短的串会使得预处理变成O(10nlg(10n))。 查找的复杂度可能没什么变化，使用&lt;=10会是O(lg(10n))，而只使用=10子串初始化的话，因为可能还要进行短query跟长子串间的前缀比较，复杂度会是O(10lgn)，稍微有点提高。</p></blockquote>

<p>Which is to say, using substring length == 10, we comsume <strong>less time for pre-processing</strong>, and a little <strong>more time when querying</strong>.</p>

<h3>Code</h3>

<p><strong>read it from <a href="http://www.itint5.com/discuss/203/%E8%B6%85%E7%AE%80%E5%8D%95%E7%9A%84prefix-array-java-code">here</a></strong>, note written by me</p>

<pre><code>private List&lt;String&gt; prefixList;

// pre-process the large string
public void initWithString(String str) {
    Set&lt;String&gt; strs = new HashSet&lt;String&gt;();

    for(int i = 0; i &lt; str.length(); ++i) {
        strs.add(str.substring(i, Math.min(str.length(), i + 10)));
    }
    prefixList = new ArrayList&lt;String&gt;(strs);
    Collections.sort(prefixList);
}

// find the query substring
public boolean existSubString(String query) {
    int low = 0;
    int high = prefixList.size() - 1;
    while(low &lt;= high) {
        int mid = (low + high) / 2;
        int comp = prefixList.get(mid).compareTo(query);
        if(comp == 0)  {
            return true;
        }
        if(prefixList.get(mid).startsWith(query)) {
            return true;
        }
        if(comp &gt; 0) //mid &gt; query
        {
            high = mid - 1;
        }else{
            low = mid + 1;
        }
    }
    return false;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] From Client/Server to Multi-Tier]]></title>
    <link href="http://okckd.github.io/blog/2014/08/12/From-ClientServer-to-Multi-Tier/"/>
    <updated>2014-08-12T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/12/From-ClientServer-to-Multi-Tier</id>
    <content type="html"><![CDATA[<h3>Client/Server</h3>

<p><a href="http://wiki.remobjects.com/wiki/From_Client/Server_to_Multi-Tier">link</a></p>

<p>Client have <strong>direct and full access to the physical database</strong> based on their login string. This is the major weakness of the Client/Server paradigm. The system is vulnerable to attacks.</p>

<p>Because all business logic was <strong>implemented on the client application</strong>, changes to business logic means redeploying new client software to all users again.</p>

<p>Another drawback is that the network interface provided by most back-end database systems has been designed for access over the local network, using fast connections and no firewalls. Nowadays, many clients’ software needs to run from employee&rsquo;s home offices or from airport lounges. In many cases such connections <strong>will be unreliable or inefficient</strong> to work on.</p>

<h3>Multi-Tier</h3>

<p>The communication between clients and middle-tier server is <strong>no longer tied to a protocol dictated by the database</strong> (no database drivers or connection string on the client). Client applications can authenticate with <strong>a username and password (compare to login string)</strong>.</p>

<p>Communication can be done via HTTP or HTTPS, alternatively or additionally, open standards such as <strong>SOAP, OData and JSON can be used to expose a middle tier</strong> to different clients using protocols that are widely understood.</p>

<p>Biggest advantage is that <strong>all the business logic is transferred from client application into the middle tier</strong>. And the middle tier holds the final control over what data goes in or out.</p>

<p>Still, there&rsquo;re still some business logic on the client tier as well. But it only <strong>complement the rules</strong> that are enforced on the server. Eg. Twitter enforce the 140 character limit locally, and stop you from sending a tweet that is too long (by graying out the Send button).</p>

<p>That means, client side checks are for convenience, and for convenience only; the middle tier server is and must be authoritative for what is allowed and what is not.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150] 9.7 Circus Tower Routine]]></title>
    <link href="http://okckd.github.io/blog/2014/08/12/9-7-circus-man-ordering/"/>
    <updated>2014-08-12T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/12/9-7-circus-man-ordering</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>A circus is designing a tower routine consisting of people standing atop one another’s shoulders. For practical and aesthetic reasons, each person must be both shorter and lighter than the person below him or her. Given the heights and weights of each person in the circus, write a method to compute the largest possible number of people in such a tower.</p>

<p>EXAMPLE:</p>

<p>Input: (ht, wt): (65, 100) (70, 150) (56, 90) (75, 190) (60, 95) (68, 110)</p>

<p>Output: The longest tower is length 6 and includes from top to bottom: (56, 90) (60,95) (65,100) (68,110) (70,150) (75,190)</p></blockquote>

<h3>Solution</h3>

<p>The solution given in the book is unclear, but it&rsquo;s a very simple idea which is pointed out <a href="http://www.careercup.com/question?id=9339758">here</a> and <a href="http://hawstein.com/posts/9.7.html">here</a>.</p>

<ol>
<li>sort the input persons by &lsquo;height&rsquo;. O(nlogn)</li>
<li>find the longest increasing &lsquo;weight&rsquo; sequence in the sorted list. This can be done in O(nlogn) with DP.</li>
</ol>


<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public int longestTower(List&lt;Man&gt; list) {
    Collections.sort(list, new ManComparator());
    // now find the longest increasing sequence of 'weight' property
    int len = list.size();
    int maxLen = 1;
    int[] dp = new int[len];
    for (int i = 1; i &lt; len; i++) {
        dp[i] = 1;
        for (int j = 0; j &lt; i; j++) {
            if (list.get(i).weight &gt; list.get(j).weight) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        maxLen = Math.max(maxLen, dp[i]);
    }
    return maxLen;
}

class ManComparator implements Comparator&lt;Man&gt; {
    @Override
    public int compare(Man o1, Man o2) {
        return o1.height - o2.height;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Maximum Circular Subarray Sum]]></title>
    <link href="http://okckd.github.io/blog/2014/08/11/max-circular-subarray/"/>
    <updated>2014-08-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/11/max-circular-subarray</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.itint5.com/oj/#9">link</a></p>

<blockquote><p>Given n numbers (both +ve and -ve), arranged in a circle, fnd the maximum sum of consecutive number</p></blockquote>

<h3>Solution</h3>

<p>First pass: find max subarray sum.</p>

<p>Second pass: find min subarray sum, and subtract it from total sum.</p>

<p>Suggested on <a href="http://www.geeksforgeeks.org/maximum-contiguous-circular-sum/">G4G</a></p>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public int maxConsSum2(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    int soFar = 0;
    int max = 0;
    int totalSum = 0;
    for (Integer i: arr) {
        totalSum += i;
        // totalSum is used in next step
        soFar += i;
        soFar = Math.max(soFar, 0);
        max = Math.max(max, soFar);
    }
    int min = 0;
    // calculate the min subarray
    for (Integer i: arr) {
        soFar += i;
        soFar = Math.min(soFar, 0);
        min = Math.min(min, soFar);
    }
    return Math.max(max, totalSum - min);
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] TCP 3-Way Handshake]]></title>
    <link href="http://okckd.github.io/blog/2014/08/11/Tcp-3way-handshake/"/>
    <updated>2014-08-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/11/Tcp-3way-handshake</id>
    <content type="html"><![CDATA[<h3>Handshaking</h3>

<p><strong><a href="http://en.wikipedia.org/wiki/Handshaking">Handshaking</a> is an automated process of negotiation</strong> that dynamically sets parameters of a communications channel established between two entities before normal communication over the channel begins.</p>

<p>It is usually a process that takes place when a computer is about to communicate with a foreign device to establish rules for communication.</p>

<h3>TCP three-way handshake</h3>

<p><strong><a href="http://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml">TCP three-way handshake</a></strong> is the method used by TCP set up a TCP/IP connection over an Internet Protocol based network.</p>

<p>It&rsquo;s commonly referred to as &ldquo;<strong>SYN-SYN-ACK</strong>&rdquo;.</p>

<p><img class="middle" src="http://okckd.github.io/assets/images/3way-Tcp-handshake.png"></p>

<h3>Process</h3>

<ol>
<li>Host A sends a TCP <strong>SYN</strong>chronize packet to Host B</li>
<li>Host B receives A&rsquo;s SYN</li>
<li>Host B sends a <strong>SYN</strong>chronize-<strong>ACK</strong>nowledgement</li>
<li>Host A receives B&rsquo;s SYN-ACK</li>
<li>Host A sends <strong>ACK</strong>nowledge</li>
<li>Host B receives ACK.</li>
<li>TCP socket connection is ESTABLISHED.</li>
</ol>


<p>Alternatively, there&rsquo;s a good illustration on <a href="http://en.wikipedia.org/wiki/Handshaking">wiki</a>:</p>

<blockquote><p>Establishing a normal TCP connection requires three separate steps:</p>

<ol>
<li><p>The first host (Alice) sends the second host (Bob) a &ldquo;synchronize&rdquo; (SYN) message with its own sequence number x, which Bob receives.</p></li>
<li><p>Bob replies with a synchronize-acknowledgment (SYN-ACK) message with its own sequence number y and acknowledgement number x + 1, which Alice receives.</p></li>
<li><p>Alice replies with an acknowledgment message with acknowledgement number y + 1, which Bob receives and to which he doesn&rsquo;t need to reply.</p></li>
</ol>
</blockquote>

<h3>Two more thing</h3>

<p>Note that <strong>FTP, Telnet, HTTP, HTTPS, SMTP, POP3, IMAP, SSH</strong> and any other protocol that rides over TCP <strong>also has a three way handshake</strong> performed as connection is opened.</p>

<p>TCP &lsquo;rides&rsquo; on top of Internet Protocol (IP) in the protocol stack. IP handles <strong>IP addressing and routing</strong> and gets the packets from one place to another, but TCP manages the <strong>actual communication sockets</strong> between endpoints.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Count Complete Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/08/11/Count-complete-binary-tree/"/>
    <updated>2014-08-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/11/Count-complete-binary-tree</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.itint5.com/oj/#4">link</a></p>

<blockquote><p>给定一棵<a href="http://baike.baidu.com/view/427107.htm">完全二叉树</a>（complete binary tree）的根结点，统计该树的结点总数。</p>

<p>提示：使用O(n)的递归算法统计二叉树的结点数是一种显而易见的方法，此题中请利用完全二叉树的性质，想出效率更高的算法。</p></blockquote>

<h3>Solution</h3>

<p>Similar to binary search, O(lgn) complexity.</p>

<p>The idea is, sum up 1 branch of nodes at a time. Do it recursively. The following code is refactored and written by me.</p>

<h3>Code</h3>

<p><strong>read it from <a href="http://www.itint5.com/discuss/125/%E5%A4%A7%E7%89%9B%E8%AF%B7%E6%8C%87%E7%82%B9%EF%BC%8C%E6%95%B0%E6%8D%AE37%E8%BF%90%E8%A1%8C%E8%B6%85%E6%97%B6%EF%BC%88%E9%99%84%E4%BB%A3%E7%A0%81%EF%BC%89">here</a></strong></p>

<pre><code>//使用TreeNodeUtil.getLeftChildNode(TreeNode)获得左儿子结点
//使用TreeNodeUtil.getRightChildNode(TreeNode)获得右儿子结点
//使用TreeNodeUtil.isNullNode(TreeNode)判断结点是否为空
public class CountCompleteBinayTreeNodes {
    public int countNodes(TreeNode root) {
        if (TreeNodeUtil.isNullNode(root)) {
            return 0;
        }
        int hl = height(TreeNodeUtil.getLeftChildNode(root));
        int hr = height(TreeNodeUtil.getRightChildNode(root));
        if (hl == hr) {
            return (int) Math.pow(2, hl) + countNodes(TreeNodeUtil.getRightChildNode(root));
        } else {
            return (int) Math.pow(2, hr) + countNodes(TreeNodeUtil.getLeftChildNode(root));
        }
    }

    private int height(TreeNode root) {
        int count = 0;
        while (!TreeNodeUtil.isNullNode(root)) {
            root = TreeNodeUtil.getLeftChildNode(root);
            count++;
        }
        return count;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Big Data - Top K Questions (Summarize)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/10/big-data-top-k-questions-summarize/"/>
    <updated>2014-08-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/10/big-data-top-k-questions-summarize</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://dongxicheng.org/big-data/select-ten-from-billions/">link</a></p>

<blockquote><p>在海量数据中找出出现频率最高的前K个数，或者从海量数据中找出最大的前K个数，这类问题通常称为“top K”问题，</p>

<ol>
<li>top K value</li>
<li>top K frequency</li>
</ol>
</blockquote>

<h3>Analysis</h3>

<p><strong>Standard solution</strong> is 【分治+trie树/hash+小顶堆】, which I covered in another post <a href="http://okckd.github.io/blog/2014/07/25/big-data-Top-k-frequency/">Big Data &ndash; Top k Frequency</a>. Briefly it is 3 steps:</p>

<ol>
<li>先将数据集按照hash方法分解成多个小数据集，</li>
<li>使用trie树或者hash统计每个小数据集中的query词频，</li>
<li>用小顶堆求出每个数据集中出频率最高的前K个数</li>
</ol>


<p>But, there&rsquo;re other senarios where different solutions may apply. Consider:</p>

<ol>
<li><p>Single core vs. multiple core</p></li>
<li><p>Single PC vs. multiple PC</p></li>
<li><p>Large RAM vs. limited RAM</p></li>
<li><p>Distributed system</p></li>
</ol>


<h3>1. 单机+单核+足够大内存</h3>

<p>设每个查询词平均占8Byte，则10亿个查询词所需的内存大约是10<sup>9</sup>*8=8G内存。如果你有这么大的内存，直接在内存中对查询词进行排序，顺序遍历找出10个出现频率最大的10个即可。这种方法简单快速，更加实用。当然，也可以先用HashMap求出每个词出现的频率，然后求出出现频率最大的10个词。</p>

<h3>2. 单机+单核+受限内存</h3>

<p>这种情况下，需要将原数据文件切割成一个一个小文件，如，采用hash(x)%M，将原文件中的数据切割成M小文件，如果小文件仍大于内存大小，继续采用hash的方法对数据文件进行切割，直到每个小文件小于内存大小，这样，每个文件可放到内存中处理。采用3.1节的方法依次处理每个小文件。</p>

<h3>3. 单机+多核+足够大内存</h3>

<p>这时可以直接在内存中实用hash方法将数据划分成n个partition，每个partition交给一个线程处理，线程的处理逻辑是同[1]节类似，最后一个线程将结果归并。</p>

<p>该方法存在一个瓶颈会明显影响效率，即数据倾斜，每个线程的处理速度可能不同，快的线程需要等待慢的线程，最终的处理速度取决于慢的线程。解决方法是，<strong>将数据划分成 (c x n)个partition（c>1），每个线程处理完当前partition后主动取下一个partition继续处理</strong>，直到所有数据处理完毕，最后由一个线程进行归并。</p>

<h3>4. 多机+受限内存</h3>

<p>这种情况下，为了合理利用多台机器的资源，可将数据分发到多台机器上，每台机器采用[3]节中的策略解决本地的数据。可采用<strong>hash + socket</strong>方法进行数据分发。</p>

<h3>5. Distributed</h3>

<p>Top k问题很适合采用<strong>MapReduce框架</strong>解决，用户只需编写一个map函数和两个reduce 函数，然后提交到Hadoop（采用mapchain和reducechain）上即可解决该问题。</p>

<p>A map function. 对于map函数，采用hash算法，将hash值相同的数据交给同一个reduce task.</p>

<p>2 reduce functions. 对于<strong>第一个reduce函数</strong>，采用HashMap统计出每个词出现的频率，对于<strong>第二个reduce函数</strong>，统计所有reduce task输出数据中的top k即可。</p>

<h3>6. Other</h3>

<p>公司一般不会自己写个程序进行计算，而是提交到自己核心的数据处理平台上计算，该平台的计算效率可能不如直接写程序高，但它具有<strong>良好的扩展性和容错性</strong>，而这才是企业最看重的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Big Data - Top K Frequency 2]]></title>
    <link href="http://okckd.github.io/blog/2014/08/10/big-data-top-k-frequency-2/"/>
    <updated>2014-08-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/10/big-data-top-k-frequency-2</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://blog.csdn.net/v_july_v/article/details/7382693">link</a></p>

<blockquote><p>一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</p></blockquote>

<h3>Analysis</h3>

<p><strong>The basic solution for &lsquo;Top K&rsquo; questions</strong> is 【分治+trie树/hash+小顶堆】.</p>

<p>In the previous post <a href="http://okckd.github.io/blog/2014/07/25/big-data-Top-k-frequency/">Big Data &ndash; Top k Frequency</a>, we used HashMap for calculating query frequency. Now we <strong>use Trie to do it</strong>.</p>

<blockquote><p>这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n x le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n x lg10)。所以总的时间复杂度，是O(n x le)与O(n x lg10)中较大的哪一个。</p></blockquote>

<h4>How to use Trie to calculate word frequency?</h4>

<p>在Trie的node节点中<a href="http://blog.csdn.net/ohmygirl/article/details/7953814">添加count域后</a>，可以统计单词出现的次数。统计的方法就是在插入单词的时候，令相应的count域加1（初始化为0）.</p>
]]></content>
  </entry>
  
</feed>
