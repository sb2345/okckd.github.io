<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Woodstock Blog]]></title>
  <link href="http://okckd.github.io/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-16T22:38:56+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 5.6 Swap Odd and Even Bits]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/swap-odd-even-bits/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/swap-odd-even-bits</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Write a program to swap odd and even bits in an integer with as few instructions as possible (e.g., bit 0 and bit 1 are swapped, bit 2 and bit 3 are swapped, and so on).</p></blockquote>

<h3>Solution</h3>

<p>Mask odd and even bits seperately.</p>

<h3>Code</h3>

<pre><code>public static int swapOddEvenBits(int x) {
    return (((x &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((x &amp; 0x55555555) &lt;&lt; 1));
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Guess Password]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/google-guess-password/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/google-guess-password</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.mitbbs.com/article_t/JobHunting/32658281.html">link</a></p>

<blockquote><p>给你一个password 假定6位</p>

<p>有个function, 每call一次就给你一个triplet 是password 里的随即三位(order不变)。比如google, 可能返回: ggl, goe, oog, ool&hellip;</p>

<p>问如何最有效破译这个密码?</p></blockquote>

<h3>Solution</h3>

<p>This is just a rough idea suggested by Level 6 from the post.</p>

<blockquote><p>六位密码随机给三位，应该有C(6, 3) = 20个bucket。</p>

<p>如果密码是abcdef，那么以a开头的bucket应该是10个。以b开头的buckt应该是6个，以c开头的是3个，以d开头的是1个。</p>

<p>如果abcd中间有相同，那么就会出现以a开头的是11个（abca)，13个(abad)，14个(abaa)，16个(aacd)，17个(aaca),19个(aaad)或者20个(aaaa).</p></blockquote>

<p>So we generate many triplets, and calculate based on their frequencies.</p>

<h3>Code</h3>

<p><strong>not written</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 9.3 Find Magic Index (`)]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/find-magic-index/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/find-magic-index</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>A magic index in an array A[l.. .n-l] is defined to be an index such that A[i] = i.</p>

<p>Given a sorted array of distinct integers, write a method to find a magic index, if one exists, in array A.</p>

<p>FOLLOW UP: What if the values are not distinct?</p></blockquote>

<h3>Solution</h3>

<h3>Code</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 5.5 Calculate Bits Conversion Required]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/calculate-bits-convertions/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/calculate-bits-convertions</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Write a function to determine the number of bits (change) required to convert integer A to integer B.</p></blockquote>

<h3>Solution</h3>

<p>The only thing to know is <strong>how to count the number of &lsquo;1&rsquo;s in a integer</strong>. It&rsquo;s like this:</p>

<blockquote><p>c = c &amp; (c &ndash; l) clears the least significant bit of &lsquo;1&rsquo;.</p>

<p>Keep doing this until all &lsquo;1&rsquo;s are cleared.</p></blockquote>

<h3>Code</h3>

<p><strong>code 1</strong></p>

<pre><code>public static int calcBitsSwapMe1(int a, int b) {
    int num = a ^ b;
    int count = 0;
    while (num != 0) {
        count += num &amp; 1;
        num = num &gt;&gt;&gt; 1;
    }
    return count;
}
</code></pre>

<p><strong>code 2</strong></p>

<pre><code>public static int calcBitsSwapMe2(int a, int b) {
    int num = a ^ b;
    int count = 0;
    while (num != 0) {
        num = num &amp; (num - 1);
        count++;
    }
    return count;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Brain Teaser] 6.1 Bottles of Pills]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/bottles-of-spills/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/bottles-of-spills</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>You have 20 bottles of pills. 19 bottles have 1.0 gram pills, but one has pills of weight 1.1 grams.</p>

<p>Given a scale, how to find the heavy bottle <strong>only scaling ONCE</strong>?</p></blockquote>

<h3>Solution</h3>

<p>Take 1 pill from Bottle 1, 2 pills from Bottle 2, and so on. We&rsquo;ll expect (1 + 2 + &hellip; + 20) = 210 gram of pills.</p>

<p>The answer would be {(weight &ndash; 210 grams) / 0.1}.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 5.1 Binary Merge 2 Numbers]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/binary-merge-two-numbers/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/binary-merge-two-numbers</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>You are given two 32-bit numbers, N andM, and two bit positions, i and j. Write a method to insert M into Nsuch that M starts at bit j and ends at bit i. You can assume that the bits j through i have enough space to fit all ofM. That is, ifM= 10011, you can assume that there are at least 5 bits between j and i. You would not, for example, have j-3 and i=2, because M could not fully fit between bit 3 and bit 2.</p>

<p>EXAMPLE:</p>

<p>Input: N = 16000000000, M = 10011, i = 2, j = 6</p>

<p>Output: N = 10001001100</p></blockquote>

<h3>Solution</h3>

<p><strong>This is a basic bit manipulation question</strong>. The key is to use binary maks. Two things to note:</p>

<ol>
<li><p>The &lsquo;~&rsquo; means negate. So (~0) is a sequence of 1 (the value equals to -1).</p></li>
<li><p>When shifting bits, <strong>DO NOT USE &lsquo;>>&rsquo; because it&rsquo;s signed shift</strong>. Instead, <strong>use &lsquo;>>>&rsquo; (unsigned right shift operator)</strong>.</p></li>
</ol>


<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public static int myAnswer(int n, int m, int i, int j) {
    int rr = (~0 &gt;&gt;&gt; (31 - j));
    int ll = (~0 &lt;&lt; i);
    // printBinary(rr);
    // printBinary(ll);

    int middleMask = ll &amp; rr;
    int twoEndMask = ll ^ rr;

    n = n &amp; twoEndMask;
    m = (m &lt;&lt; i) &amp; middleMask;

    return n | m;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 9.]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote></blockquote>

<h3>Solution</h3>

<h3>Code</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 3.7 Stack of Animals]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/stack-of-animals/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/15/stack-of-animals</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>An animal shelter holds only dogs and cats. People must adopt either the &ldquo;oldest&rdquo; animals, or they can select whether they would prefer a dog or a cat (and will receive the oldest animal of that type). They cannot select which specific animal they would like.</p>

<p>Create the data structures to maintain this system and implement operations such as enqueue, dequeueAny, dequeueDog and dequeueCat. You may use the built-in LinkedList data structure.</p></blockquote>

<h3>Solution</h3>

<p>There are 2 solutions.</p>

<p><strong>First one is using a single queue</strong>. This makes &lsquo;dequeueAny&rsquo; easy, but &lsquo;dequeueCat&rsquo; and &lsquo;dequeueDog&rsquo; difficult.</p>

<p><strong>Second approach would be using 2 queues for dogs and cats</strong>. We need something like timestamp to be stored (more space usage).</p>

<p>When we return, we peek both queues are choose the older one. <strong>This is recommended solution in the book</strong>.</p>

<h3>Code</h3>

<p><strong>from the book</strong></p>

<p>Animal.java</p>

<pre><code>public abstract class Animal {
    int order;
    String name;

    public Animal(String n) {
        name = n;
    }

    public abstract String name();

    public boolean isOlderThan(Animal a) {
        return this.order &lt; a.order;
    }
}

class Cat extends Animal {
    public Cat(String n) {
        super(n);
    }

    public String name() {
        return "Cat: " + name;
    }
}

class Dog extends Animal {
    public Dog(String n) {
        super(n);
    }

    public String name() {
        return "Dog: " + name;
    }
}
</code></pre>

<p>AnimalQueue.java</p>

<pre><code>public class AnimalQueue {
    LinkedList&lt;Dog&gt; dogs = new LinkedList&lt;Dog&gt;();
    LinkedList&lt;Cat&gt; cats = new LinkedList&lt;Cat&gt;();
    private int order = 0;

    public void enqueue(Animal a) {
        a.order = order;
        order++;
        if (a instanceof Dog) {
            dogs.addLast((Dog) a);
        } else if (a instanceof Cat) {
            cats.addLast((Cat) a);
        }
    }

    public Animal dequeueAny() {
        if (dogs.size() == 0) {
            return dequeueCats();
        } else if (cats.size() == 0) {
            return dequeueDogs();
        }
        Dog dog = dogs.peek();
        Cat cat = cats.peek();
        if (dog.isOlderThan(cat)) {
            return dogs.poll();
        } else {
            return cats.poll();
        }
    }

    public Animal peek() {
        if (dogs.size() == 0) {
            return cats.peek();
        } else if (cats.size() == 0) {
            return dogs.peek();
        }
        Dog dog = dogs.peek();
        Cat cat = cats.peek();
        if (dog.isOlderThan(cat)) {
            return dog;
        } else {
            return cat;
        }
    }

    public int size() {
        return dogs.size() + cats.size();
    }

    public Dog dequeueDogs() {
        return dogs.poll();
    }

    public Dog peekDogs() {
        return dogs.peek();
    }

    public Cat dequeueCats() {
        return cats.poll();
    }

    public Cat peekCats() {
        return cats.peek();
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 3.2 Stack Min Value]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/stack-get-min-value/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/15/stack-get-min-value</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>How would you design a stack which, in addition to push and pop, also has a function min which returns the minimum element?</p>

<p>Push, pop and min should all operate in 0(1) time.</p></blockquote>

<h3>Solution</h3>

<p>This is <strong>a very tricky question</strong>.</p>

<p>The key is how to use the minimum space to achieve O(1) query min operation. The trick is to count how many times the same min-value occur. Eg.</p>

<blockquote><p>input: 5,3,3,1,1,2,2,2,2,2,2,2.</p>

<p>stack: 5,3,3,1,1.</p></blockquote>

<p>So we can pop &lsquo;1&rsquo; twice, pop &lsquo;3&rsquo; twice, and pop &lsquo;5&rsquo; once. Read the code!</p>

<h3>Code</h3>

<pre><code>public class StackMyAnswer extends Stack&lt;Integer&gt; {

    Stack&lt;Integer&gt; min = new Stack&lt;Integer&gt;();

    public void push(int value) {
        if (min.isEmpty() || value &lt;= min.peek()) {
            min.push(value);
        }
        super.push(value);
    }

    public Integer pop() {
        int val = super.pop();
        if (!min.isEmpty() &amp;&amp; val == min.peek()) {
            min.pop();
        }
        return val;
    }

    public int min() {
        if (min.isEmpty()) {
            return Integer.MAX_VALUE;
        }
        return min.peek();
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 2.7 Linked List Palindrome]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/linked-list-palindrome/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/15/linked-list-palindrome</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Implement a function to check if a linked list is a palindrome.</p></blockquote>

<h3>Solution</h3>

<p>There are multiple solutions for this question.</p>

<p><strong>First, maybe the simplest solution of all</strong>, is to compare the list with the reversed list (compare first half would be enough). This is a very nice idea.</p>

<p><strong>Second solution is iterative approach</strong>. My code below is to first get the total length, then <strong>use a Stack</strong>. Alternatively, we can also use <strong>fast/slow pointer</strong> to find the mid point. This solution is easiest to write.</p>

<p><strong>Third solution is recursive</strong>. We basically uses a public pointer to:</p>

<ol>
<li>get starting value</li>
<li>check middle parts</li>
<li>get ending value</li>
<li>if starting == ending and middle part is valid, then true.</li>
</ol>


<p>This code is not easy to write, and hard to think.</p>

<p>It&rsquo;s best to know both iterative and recursive solution.</p>

<h3>Code</h3>

<p>Iterative</p>

<pre><code>public static boolean isPalindrome1(LinkedListNode head) {
    int len = getListLength(head);
    int half = len / 2;
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    for (int i = 0; i &lt; half; i++) {
        stack.push(head.data);
        head = head.next;
    }
    if (len % 2 == 1) {
        head = head.next;
    }
    for (int i = 0; i &lt; half; i++) {
        if (head.data != stack.pop()) {
            return false;
        }
        head = head.next;
    }
    return true;
}
</code></pre>

<p>Recursive</p>

<pre><code>private static LinkedListNode p;

public static boolean isPalindrome2(LinkedListNode head) {
    p = head;
    int len = getListLength(head);
    return helper2(0, len - 1);
}

public static boolean helper2(int from, int to) {
    if (from &gt; to) {
        return true;
    } else if (from == to) {
        p = p.next;
        return true;
    } else {
        // first get fromVal, then check middlep part, last, get toVal
        int fromVal = p.data;
        p = p.next;
        if (!helper2(from + 1, to - 1)) {
            return false;
        }
        int toVal = p.data;
        p = p.next;
        if (fromVal != toVal) {
            return false;
        }
    }
    return true;
}
</code></pre>

<p>Shared method:</p>

<pre><code>private static int getListLength(LinkedListNode node) {
    int count = 0;
    while (node != null) {
        count++;
        node = node.next;
    }
    return count;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] Chap 3 Example - Implement Stack]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/implement-stack/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/15/implement-stack</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Implement a stack.</p></blockquote>

<h3>Solution</h3>

<p><strong>Stack uses LinkedNode to implement</strong>.</p>

<h3>Code</h3>

<pre><code>public class MyStack {

    Node top;

    public int pop() {
        if (top == null) {
            return -1;
        }
        int returnVal = top.val;
        top = top.next;
        return returnVal;
    }

    public int peek() {
        if (top == null) {
            return -1;
        }
        return top.val;

    }

    public void push(int val) {
        Node newNode = new Node(val);
        newNode.next = top;
        top = newNode;
    }

    class Node {

        int val;
        Node next;

        Node(int value) {
            val = value;
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 2.2 Kth Last Element (Recursive)]]></title>
    <link href="http://okckd.github.io/blog/2014/09/14/kth-last-element-recursive/"/>
    <updated>2014-09-14T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/14/kth-last-element-recursive</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Implement an algorithm to find the kth to last element of a singly linked list.</p>

<p>Do it recursively.</p></blockquote>

<h3>Solution</h3>

<p>Iterative solution is easy, <strong>recursive is not</strong>.</p>

<h3>Code</h3>

<pre><code>private static int myAns = -1;

public static int nthToLastMe(LinkedListNode head, int n) {
    if (head == null) {
        return 0;
    } else if (nthToLastMe(head.next, n) &lt; n - 1) {
        return nthToLastMe(head.next, n) + 1;
    } else if (nthToLastMe(head.next, n) == n - 1) {
        myAns = head.data;
        return Integer.MAX_VALUE;
    }
    return Integer.MAX_VALUE;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] DNS Communication Protocol]]></title>
    <link href="http://okckd.github.io/blog/2014/09/12/DNS-communication-protocol/"/>
    <updated>2014-09-12T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/12/DNS-communication-protocol</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>What protocol is used for communicating with a DNS?</p></blockquote>

<h3>Answer</h3>

<p><a href="http://en.wikipedia.org/wiki/Domain_Name_System">Domain Name System</a> (DNS) is a hierarchical distributed naming system for computers, services, or any resource connected to the Internet or a private network. It associates various information with domain names assigned to each of the participating entities. Most prominently, it translates easily memorized domain names to the numerical IP addresses needed for the purpose of locating computer services and devices worldwide. The Domain Name System is an essential component of the functionality of the Internet.</p>

<p><a href="http://en.wikipedia.org/wiki/Domain_Name_System#Protocol_transport">DNS primarily uses</a> <strong>User Datagram Protocol (UDP)</strong> on port number 53 to serve requests.</p>

<p>DNS queries consist of a single UDP request from the client followed by a single UDP reply from the server.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Celebrity Problem]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/celebrity-problem/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/celebrity-problem</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=13167666">link</a></p>

<blockquote><p>You have a room with n people. A celebrity walks in. Everyone knows the celebrity, the celebrity knows no one.</p>

<p>Non-celebrities may/may not know anyone in the room.</p>

<p>Give an algorithm to find the celebrity. Discuss the complexity.</p></blockquote>

<h3>Solution</h3>

<p><a href="http://www.geeksforgeeks.org/the-celebrity-problem/">Classic brute-force solution</a> would take O(n<sup>2</sup>) time to build a map. That&rsquo;s not good, and we have a very simple solution that works in O(n) time:</p>

<blockquote><p>Make all of them stand in a row. Let&rsquo;s say the people are a,b,c,d,e,f,g,h,i,j,&hellip;&hellip;.n</p>

<p>Compare a and b. <strong>If a knows b</strong>, a is not celebrity. <strong>If a doesn&rsquo;t know b</strong>, b is not celebrity.</p>

<p>At the end, the probable celebrity who survives is the certain celebrity. (better do a check)</p></blockquote>

<p>Total number of comparison is <a href="http://www.geeksforgeeks.org/the-celebrity-problem/">3(N-1) times</a>.</p>

<h3>Code</h3>

<p><strong>not written</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Barrier, Goods Van and Distance]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/barrier-goods-van-and-distance/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/barrier-goods-van-and-distance</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.mitbbs.com/article_t1/JobHunting/32631467_0_1.html">link</a></p>

<blockquote><p>2d array ＊代表障碍物 ＃代表货物 空白就是正常的路</p>

<p>问如何找到一个点为出发点 能实现总共取货路径最短？ 每次只能拿一个货物，遇到障碍需要绕开，拿到以后要放回出发点，然后再取另一个.</p></blockquote>

<pre><code>＊＊＊＊＊＊＊＊＊＊
＊  #           ＊
＊  ＊＊＊  ＊   ＊
＊              ＊
＊     ＊＊   ＊ ＊
＊  #    # # ＊＊＊
＊＊＊＊＊＊＊＊＊＊
</code></pre>

<h3>Solution</h3>

<p>This looks like a very difficult question, especially during a phone interview.</p>

<p><strong>The 10th floor gives the best solution</strong>:</p>

<blockquote><p><strong>BFS from every box</strong>. in each box, a non-blocking cell (include box position, but exclude hazard position) will have a weight value, stand for the distance to the box.</p>

<p>after bfs from all the boxes, each cell will have k weight, k is the number of boxes. sum all the weight in each cell, and find the cell with smallest sum of weight.</p>

<p>One problem of this solution may lead to a cell of a box. We can then sort the cell by sum of weight and find the first position that is not a box.</p>

<p>complexity O(k*n<sup>2</sup>)</p></blockquote>

<h3>Code</h3>

<p><strong>not written</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Arithmetic Progression Triplet]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/arithmetic-progression-triplet/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/arithmetic-progression-triplet</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/">link</a></p>

<blockquote><p>Given a sorted set, find if there exist three elements in Arithmetic Progression or not.</p></blockquote>

<h3>Solution</h3>

<p><strong>This is a rather simple Arithmetic Progression question</strong>.</p>

<blockquote><p><a href="http://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/">To find the three elements</a>, we first fix an element as middle element and search for other two (one smaller and one greater).</p></blockquote>

<p>O(n<sup>2</sup>) time.</p>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public boolean longest(int[] A) {
    int len = A.length;
    for (int i = 1; i &lt; len - 1; i++) {
        int left = i - 1;
        int right = i + 1;
        while (left &gt;= 0 &amp;&amp; right &lt; len) {
            int total = A[left] + A[right];
            if (total &gt; 2 * A[i]) {
                left--;
            } else if (total &lt; 2 * A[i]) {
                right++;
            } else {
                return true;
            }
        }
    }
    return false;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Arithmetic Progression Longest]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/arithmetic-progression-longest/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/arithmetic-progression-longest</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=8211177">link</a></p>

<blockquote><p>Given an array of integers A, give an algorithm to find the longest Arithmetic progression in it, i.e find a sequence i1 &lt; i2 &lt; … &lt; ik, such that</p>

<p>A[i1], A[i2], …, A[ik] forms an arithmetic progression, and k is the largest possible.</p>

<p>The sequence S1, S2, …, Sk is called an arithmetic progression if S(j+1) – S(j) is a constant.</p></blockquote>

<h3>Solution</h3>

<p><strong>This is a rather difficult Arithmetic Progression question</strong>.</p>

<p>The solution is 2-D DP.</p>

<blockquote><p><a href="http://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/">The idea is</a> to create a 2D table dp[n][n]. An entry dp[i][j] in this table stores LLAP with input[i] and input[j] as first two elements of AP(j > i).</p>

<p>The last column of the table is always 2. Rest of the table is filled <strong>from bottom right to top left</strong>.</p>

<p>To fill rest of the table, j (second element in AP) is first fixed. i and k are searched for a fixed j. If i and k are found such that i, j, k form an AP, then <strong>the value of dp[i][j] is set as dp[j][k] + 1</strong>.</p>

<p><strong>Note that the value of dp[j][k] must have been filled</strong> before as the loop traverses from right to left columns.</p></blockquote>

<p>The 2 difficult points of this question:</p>

<ol>
<li>how to come up with the transation formula. (i.e. <strong>dp[i][j] = dp[j][k] + 1</strong>, when (i, j, k) forms a AP).</li>
<li>how to fill up all dp[i][j] in each loop of j. (Once inside the if-else, once outside the main while-loop)</li>
</ol>


<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public int longest(int[] A) {
    int len = A.length;
    int[][] dp = new int[len][len];
    for (int i = 0; i &lt; len; i++) {
        // the pair ending at last position is always a progression
        dp[i][len - 1] = 2;
    }
    int longest = 1;
    for (int j = len - 2; j &gt;= 0; j--) {
        // for each j, find i and k that makes 1 progression
        int i = j - 1;
        int k = j + 1;
        while (i &gt;= 0 &amp;&amp; k &lt; len) {
            int total = A[i] + A[k];
            if (total &gt; 2 * A[j]) {
                // this is important!
                dp[i][j] = 2;
                i--;
            } else if (total &lt; 2 * A[j]) {
                k++;
            } else {
                // found a valid progression triplet A(i, j, k)
                dp[i][j] = dp[j][k] + 1;
                longest = Math.max(longest, dp[i][j]);
                i--;
                k++;
            }
        }
        // this is important!
        while (i &gt;= 0) {
            dp[i][j] = 2;
            i--;
            // If the loop was stopped due to k becoming more than
            // n-1, set the remaining dp[i][j] as 2
        }
    }
    return longest;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 20.6 Top Million From Billion]]></title>
    <link href="http://okckd.github.io/blog/2014/09/10/top-million-from-billion/"/>
    <updated>2014-09-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/10/top-million-from-billion</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Describe an algorithm to find the largest 1 million numbers in 1 billion numbers.</p>

<p>Assume that the computer memory can hold all one billion numbers.</p></blockquote>

<h3>Solution</h3>

<p>There&rsquo;re enough discussion on <strong>Top K problems</strong> so far in this blog. The suggest solutions is:</p>

<ol>
<li><p>Sort</p></li>
<li><p>Min Heap, O(n logm) time.</p></li>
<li><p>Quick select algorithm. O(n) time.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 20.12 Sub-matrix With Largest Sum]]></title>
    <link href="http://okckd.github.io/blog/2014/09/10/submatrix-with-largest-sum/"/>
    <updated>2014-09-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/10/submatrix-with-largest-sum</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Given an NxN matrix of positive and negative integers, write code to find the sub-matrix with the largest possible sum.</p></blockquote>

<h3>Solution</h3>

<p>I wrote about this question before: <strong>[Question] Max Sum In A 2D Array (sub-matrix)</strong>, and the solution gave a better time complexity (O(n<sup>3</sup>)) than in the book (O(n<sup>4</sup>)).</p>

<ol>
<li>locate a row &ndash; O(n)</li>
<li>locate another row &ndash; O(n)</li>
<li>compute sub value of that column &ndash; O(n), and then find largest subarray in array &ndash; also O(n)</li>
<li>The above 3 steps each take O(n) time, total time is O(n<sup>3</sup>).</li>
</ol>


<p>Please refer to the other post for more detail.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 20.3 Generate M Int From Array of Size N]]></title>
    <link href="http://okckd.github.io/blog/2014/09/10/generate-m-from-array-of-n/"/>
    <updated>2014-09-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/10/generate-m-from-array-of-n</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Write a method to randomly generate a set of m integers from an array of size n. Each element must have equal probability of being chosen.</p></blockquote>

<h3>Solution</h3>

<p>This is very similar to another post I wrote: <strong>[Question] Shuffle An Array (Fisher–Yates)</strong>.</p>

<p>The basic idea is to choose element one by one using RNG. After choosing an int, swap it to top and <strong>then mark this element as &lsquo;dead&rsquo;</strong>. Next time, the RNG will not touch on the &lsquo;dead&rsquo; elements.</p>

<p><strong>Very similar to Fisher–Yates Shuffle</strong>, and the code below is written by me.</p>

<h3>Code</h3>

<pre><code>public static int[] pickMRandomly(int[] original, int m) {
    int[] ans = new int[m];
    for (int i = 0; i &lt; m; i++) {
        int rand = Question.listRand.get(i);
        // note: rand is RN in the range [i, max]
        ans[i] = original[rand];
        original[rand] = original[i];
        // now (i)th position in original is dead
        // no one cares what value is at original[i]
    }
    return ans;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
