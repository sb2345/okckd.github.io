<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Woodstock Blog]]></title>
  <link href="http://okckd.github.io/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-13T03:38:29+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Java OOP] Java BlockingQueue (2)]]></title>
    <link href="http://okckd.github.io/blog/2015/01/12/java-blocking-queue-2/"/>
    <updated>2015-01-12T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/12/java-blocking-queue-2</id>
    <content type="html"><![CDATA[<h3>Blocking Queue Implementation</h3>

<p><img class="middle" src="http://okckd.github.io/assets/images/blocking-queue.png"></p>

<p><a href="http://tutorials.jenkov.com/java-concurrency/blocking-queues.html">source</a></p>

<ol>
<li><p>A blocking queue is a queue, so we init a queue with a pre-defined size.</p></li>
<li><p>BlockingQueue Class comes with Java 5, in java.util.concurrent.BlockingQueue. This example is only used to help you understand what&rsquo;s happening behind the scene.</p></li>
<li><p>Both <strong>enqueue(Object o){}</strong> and <strong>dequeue(){}</strong> are <strong>synchronized</strong> method.</p></li>
<li><p>Both methods do <strong>while { wait(); }</strong> and then <strong>notifyAll()</strong>.</p></li>
</ol>


<h3>Code</h3>

<pre><code>public class MyBlockingQueue {

    private List&lt;Object&gt; queue = new LinkedList&lt;Object&gt;();
    private int size = 10;

    public MyBlockingQueue(int size) {
        this.size = size;
    }

    public synchronized void enqueue(Object item) throws InterruptedException {
        while (this.queue.size() == this.size) {
            wait();
        }
        if (this.queue.size() == 0) {
            notifyAll();
        }
        this.queue.add(item);
    }

    public synchronized Object dequeue() throws InterruptedException {
        while (this.queue.size() == 0) {
            wait();
        }
        if (this.queue.size() == this.size) {
            notifyAll();
        }

        return this.queue.remove(0);
    }

    public boolean isEmpty() {
        return this.queue.isEmpty();
    }
}
</code></pre>

<h3>Another example</h3>

<p>This BlockingQueue example makes use MyBlockingQueue that we defined above.</p>

<pre><code>public class Main {

    public static void main(String[] args) throws Exception {

        MyBlockingQueue queue = new MyBlockingQueue(1024);

        Producer producer = new Producer(queue);
        Consumer consumer = new Consumer(queue);

        new Thread(producer).start();
        new Thread(consumer).start();

        Thread.sleep(4000);
    }
}
</code></pre>

<p>Producer</p>

<pre><code>public class Producer implements Runnable {

    protected MyBlockingQueue queue = null;

    public Producer(MyBlockingQueue queue) {
        this.queue = queue;
    }

    public void run() {
        System.out.println("Producer starting... ");
        try {
            for (int i = 1; i &lt;= 5; i++) {
                queue.enqueue("" + i);
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>Consumer</p>

<pre><code>public class Consumer implements Runnable {

    protected MyBlockingQueue queue = null;

    public Consumer(MyBlockingQueue queue) {
        this.queue = queue;
    }

    public void run() {
        try {
            for (int i = 1; i &lt;= 5; i++) {
                System.out.println(queue.dequeue());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Consumer finished. ");
    }
}
</code></pre>

<p>Output:</p>

<pre><code>Producer starting... 
1
2
3
4
5
Consumer finished. 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Java OOP] Java BlockingQueue (1)]]></title>
    <link href="http://okckd.github.io/blog/2015/01/12/java-blocking-queue-1/"/>
    <updated>2015-01-12T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/12/java-blocking-queue-1</id>
    <content type="html"><![CDATA[<h3>Overview</h3>

<p><strong><a href="http://tutorials.jenkov.com/java-concurrency/blocking-queues.html">A blocking queue</a></strong> is a queue that blocks when you try to <strong>dequeue from a empty queue</strong>, or if you try to <strong>enqueue items into a full queue</strong>.</p>

<p><img class="middle" src="http://okckd.github.io/assets/images/blocking-queue.png"></p>

<h4>Details</h4>

<ol>
<li><p>BlockingQueue <strong>doesn’t accept null values</strong>. Otherwise throw NullPointerException.</p></li>
<li><p>BlockingQueue implementations are <strong>thread-safe</strong>. All queuing methods are atomic in nature and use internal locks or other forms of concurrency control.</p></li>
<li><p>BlockingQueue interface is part of java collections framework and it’s primarily used for implementing <strong>producer consumer problem</strong>.</p></li>
</ol>


<p>Two important methods:</p>

<ol>
<li><p>put(E e): This method is used to insert elements to the queue, if the queue is full it waits for the space to be available.</p></li>
<li><p>E take(): This method retrieves and remove the element from the head of the queue, if queue is empty it waits for the element to be available.</p></li>
</ol>


<h4>Usage</h4>

<p><a href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html">BlockingQueue is typically used</a> to have one thread produce objects, with another thread consumes (producer consumer problem). Refer to <strong>[Design] Producer Consumer Problem</strong>.</p>

<h3>Example 1</h3>

<p>This example shows <strong>how changing the speed of consuming and producing</strong> results in different sequence of outputs, using a BlockingQueue. The size of the BlockingQueue is initialized at 5.</p>

<pre><code>public class Main {

    // original post from:
    // http://www.journaldev.com/1034/java-blockingqueue-example-implementing-producer-consumer-problem

    private static final Setting testFullQueue = new Setting(3, 10, 0);
    private static final Setting testEmptyQueue = new Setting(10, 3, 100);

    public static void main(String[] args) {

        // Creating BlockingQueue of size 5
        BlockingQueue&lt;Message&gt; queue = new ArrayBlockingQueue&lt;&gt;(5);

        Setting variableSetting = testFullQueue;
        Producer producer = new Producer(queue, variableSetting.produceSpeed);
        Consumer consumer = new Consumer(queue, variableSetting.consumeSpeed,
                variableSetting.consumerDelay);

        // starting producer to produce messages in queue
        new Thread(producer).start();

        // starting consumer to consume messages from queue
        new Thread(consumer).start();

        System.out.println("Producer and Consumer has been started");
    }

    static class Setting {
        int produceSpeed;
        int consumeSpeed;
        int consumerDelay;

        public Setting(int a, int b, int c) {
            this.produceSpeed = a;
            this.consumeSpeed = b;
            this.consumerDelay = c;
        }
    }
}
</code></pre>

<p>Producer</p>

<pre><code>public class Producer implements Runnable {

    private BlockingQueue&lt;Message&gt; queue;
    int produceSpeed;

    public Producer(BlockingQueue&lt;Message&gt; q, int a) {
        this.queue = q;
        this.produceSpeed = a;
    }

    @Override
    public void run() {
        // produce messages
        for (int i = 0; i &lt; 13; i++) {
            Message msg = new Message("" + i);
            try {
                Thread.sleep(produceSpeed);
                queue.put(msg);
                System.out.println("Produced " + msg.getMsg() + "           ("
                        + queue.size() + " items)");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // adding exit message
        Message msg = new Message("exit");
        try {
            queue.put(msg);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}
</code></pre>

<p>Consumer</p>

<pre><code>public class Consumer implements Runnable {

    private BlockingQueue&lt;Message&gt; queue;
    int consumeSpeed;
    int consumerDelay;

    public Consumer(BlockingQueue&lt;Message&gt; q, int a, int b) {
        this.queue = q;
        this.consumeSpeed = a;
        this.consumerDelay = b;
    }

    @Override
    public void run() {
        try {
            // initial delay: used to wait for producer to
            // fill up the queue
            Thread.sleep(consumerDelay);
            Message msg;
            // consuming messages until exit message is received
            while ((msg = queue.take()).getMsg() != "exit") {
            System.out.println("         " + msg.getMsg() + " Consumed"+ "  ("
                    + queue.size() + " items)");
                Thread.sleep(consumeSpeed);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Consumer finished working. Exit. ");
    }
}
</code></pre>

<p>Message Class</p>

<pre><code>public class Message {
    private String msg;

    public Message(String str){
        this.msg=str;
    }

    public String getMsg() {
        return msg;
    }
}
</code></pre>

<p>Output (testFullQueue):</p>

<pre><code>Producer and Consumer has been started
Produced 0           (0 items)
         0 Consumed  (0 items)
Produced 1           (1 items)
Produced 2           (2 items)
         1 Consumed  (1 items)
Produced 3           (2 items)
Produced 4           (3 items)
Produced 5           (4 items)
         2 Consumed  (3 items)
Produced 6           (4 items)
Produced 7           (5 items)
         3 Consumed  (5 items)
Produced 8           (5 items)
         4 Consumed  (4 items)
Produced 9           (5 items)
         5 Consumed  (4 items)
Produced 10           (5 items)
         6 Consumed  (4 items)
Produced 11           (5 items)
         7 Consumed  (4 items)
Produced 12           (5 items)
         8 Consumed  (4 items)
         9 Consumed  (4 items)
         10 Consumed  (3 items)
         11 Consumed  (2 items)
         12 Consumed  (1 items)
Consumer finished working. Exit. 
</code></pre>

<p>Output (testEmptyQueue):</p>

<pre><code>Producer and Consumer has been started
Produced 0           (1 items)
Produced 1           (2 items)
Produced 2           (3 items)
Produced 3           (4 items)
Produced 4           (5 items)
Produced 5           (5 items)
         0 Consumed  (5 items)
         1 Consumed  (4 items)
         2 Consumed  (3 items)
Produced 6           (4 items)
         3 Consumed  (3 items)
         4 Consumed  (2 items)
Produced 7           (3 items)
         5 Consumed  (2 items)
         6 Consumed  (1 items)
         7 Consumed  (0 items)
Produced 8           (1 items)
         8 Consumed  (0 items)
Produced 9           (1 items)
         9 Consumed  (0 items)
Produced 10           (1 items)
         10 Consumed  (0 items)
Produced 11           (0 items)
         11 Consumed  (0 items)
Produced 12           (1 items)
         12 Consumed  (0 items)
Consumer finished working. Exit. 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Java OOP] BlockingQueue and Thread Pool]]></title>
    <link href="http://okckd.github.io/blog/2015/01/12/blocking-queue-and-thread-pool/"/>
    <updated>2015-01-12T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/12/blocking-queue-and-thread-pool</id>
    <content type="html"><![CDATA[<h3>Blocking Queue VS. Thread Pool</h3>

<p>These are 2 very different things, however it might be a little bit confusing for a layman. I have very little knowledge about Java multi-threading. But after writing some example of thread pool and blockingqueue, I am able to identify some significant differences between the 2 DS:</p>

<ol>
<li><p>Thread pools are often used in multi threaded servers. For example, we create 10 thread only for processing 1,000 tasks. However in BlockingQueue, there&rsquo;re typically only 2 thread: Producer and Consumer. Of course there can be more, but the basic pattern defines only 2 (types of) threads.</p></li>
<li><p>Threads are added into thread pool, while in BlockingQueue, it stores tasks (runnables).</p></li>
</ol>


<p>It&rsquo;s not a common practise to compare the 2 DS. If you read this and have got some interesting thoughts, do not hesitate to let me know by commenting below!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Number of Occurence of Given Sub-sequence]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/numer-of-occurrence-given-subsequence/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/numer-of-occurrence-given-subsequence</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://stackoverflow.com/questions/6877249/find-the-number-of-occurrences-of-a-subsequence-in-a-string">link</a></p>

<blockquote><p>Given a digit &lsquo;3141592653&rsquo;, find number of occurence of subsequence &ldquo;123&rdquo;. Note that the sequence occurs twice:</p></blockquote>

<pre><code>3141592653
 1    2  3
   1  2  3
</code></pre>

<blockquote><p>Output 2.</p></blockquote>

<h3>Solution</h3>

<p>Refer to <strong>[LeetCode 115] Distinct Subsequences</strong>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Number of Distinct Sub-sequence]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/numer-of-distinct-subsequence/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/numer-of-distinct-subsequence</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://stackoverflow.com/questions/5151483/how-to-find-the-number-of-distinct-subsequences-of-a-string">link</a></p>

<blockquote><p>Find the number of distinct subsequences of a string (include &ldquo;&rdquo; as a subsequence).</p>

<p>For example, Input</p></blockquote>

<pre><code>AAA 
ABCDEFG 
CODECRAFT 
</code></pre>

<blockquote><p>Output</p></blockquote>

<pre><code>4 
128 
496 
</code></pre>

<h3>Solution</h3>

<p>In <strong>[LeetCode 115] Distinct Subsequences</strong>, we discuss finding occurence of a given subsequence.</p>

<p>Now if we do not specify a subsequence, <strong>we want the total number of distinct subsequence</strong>.</p>

<p>The solution is DP, with the following equation:</p>

<pre><code>Let, 

dp[i] = number of distinct subsequences ending with a[i]

last[i] = last position of character i in the given string.
</code></pre>

<p><strong>Equation</strong>:</p>

<pre><code>dp[i] = dp[last[i] - 1] + ... + dp[i - 1]
</code></pre>

<p>The final result is:</p>

<pre><code>Distinct Subsequences = dp[1] + ... dp[len - 1]
</code></pre>

<p>Example 1:</p>

<pre><code>Input   : - A B C
dp array: 1 1 2 4
Total = 8
</code></pre>

<p>Example 2:</p>

<pre><code>Input   : - A A C
dp array: 1 1 1 3
Total = 6
</code></pre>

<p>The code is posted below.</p>

<h3>Optimize Solution</h3>

<p>There is a good optimization of this DP solution, which is to <strong>keep another dp array &lsquo;sum&rsquo;</strong>, which sum[i] = dp[1] + dp[2] + &hellip; + dp[i]. The final answer would be sum[len &ndash; 1].</p>

<p>This nice idea is from <a href="http://stackoverflow.com/a/5152203">this post</a>. Credit goes to <strong>IVlad</strong>.</p>

<h3>Code</h3>

<p>un-optimized code. calculate dp[0] &hellip; dp[n], then sum to final result.</p>

<pre><code>public int countDistinctSubseq(String input) {
    int len = input.length();
    int[] dp = new int[len + 1];
    // dp[i] denotes the number of distinct subseq within first 'i' chars
    dp[0] = 1;
    // the first 0 chars is "" - we consider it as 1 subseq

    for (int i = 1; i &lt;= len; i++) {
        // set dp[i]
        // dp[i] = dp[i-1] + ... + dp[k] where input{k} == input{i}
        int p = i - 1;
        while (p &gt;= 0) {
            dp[i] += dp[p];
            if (p &gt; 0 &amp;&amp; input.charAt(p - 1) == input.charAt(i - 1)) {
                // when meeting a same char ahead of position i, stop
                // adding to dp[i]
                break;
            }
            p--;
        }
    }
    int sum = 0;
    for (int i : dp) {
        sum += i;
    }
    return sum;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Amazon] Longest Repeating Substring]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/longest-repeating-substring/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/longest-repeating-substring</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=9182781">link</a></p>

<blockquote><p>Finding the longest repeated substring.</p>

<p>Example: &ldquo;banana&rdquo; ==> &ldquo;ana&rdquo;</p></blockquote>

<h3>Solution</h3>

<p>There are 2 solutions: Suffix array, and Suffix tree.</p>

<p><strong>1. Suffix array</strong>. Simple code, explained <a href="http://www.careercup.com/question?id=9182781">here</a>.</p>

<blockquote><p>Bentley&rsquo;s programming pearl book has the simplest implementation (less than 15 lines code) which sort all suffix, and then check common prefix length among adjacent suffix. The time complexity is O(n<sup>2logn</sup>) for sorting the suffix (which has avg length of O(n)).</p></blockquote>

<p>A detailed step-by-step <a href="http://nriverwang.blogspot.com/2013/04/longest-repeated-substring.html">explanation</a>:</p>

<pre><code>str = banana, its suffixes are:
banana
anana
nana
ana
na
a
</code></pre>

<p>after sort, the suffix array looks like:</p>

<pre><code>a
ana
anana
banana
na
nana
</code></pre>

<p>Then for each two adjacent suffixes, check the length of the common prefix.</p>

<p>The answer is &ldquo;ana&rdquo; (if overlapping is allowed, otherwise, should be &ldquo;an&rdquo;).</p>

<p><strong>2. Suffix tree</strong>. Suggest by <a href="http://qr.ae/6W9yJ">this post</a>, Or <a href="http://www.careercup.com/question?id=9182781">this</a>:</p>

<blockquote><p>a good solution is to create a suffix tree for the given word and then find the deepest internal node in that tree (node with at least 2 descendants under it)&hellip;</p></blockquote>

<p>For a nice PPT presentation about suffix tree, look <a href="https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/suffixtrees.pdf">here</a>.</p>

<h3>Code</h3>

<p>Suffix array approach.</p>

<pre><code>public String longestRepeat(String input) {
    int len = input.length();
    String[] suffixArray = new String[len];
    for (int i = 0; i &lt; len; i++) {
        suffixArray[i] = input.substring(i);
    }
    // now sort the suffix array
    Arrays.sort(suffixArray);
    String longest = "";
    // start to compare neighborhood suffixes, and check LCP
    for (int i = 0; i &lt; suffixArray.length - 1; i++) {
        String lcp = longestCommonPrefix(suffixArray[i], suffixArray[i + 1]);
        if (lcp.length() &gt; longest.length()) {
            longest = lcp;
        }
    }
    return longest;
}

private String longestCommonPrefix(String s1, String s2) {
    int p = 0;
    while (p &lt; s1.length() &amp;&amp; p &lt; s2.length()) {
        if (s1.charAt(p) != s2.charAt(p)) {
            break;
        }
        p++;
    }
    return s1.substring(0, p);
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Crazy Distance Between Strings]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/crazy-distance-string/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/crazy-distance-string</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://stackoverflow.com/questions/15061908/google-interview-find-crazy-distance-between-strings">link</a></p>

<blockquote><p>X and Y are strings formed by 0 or 1. Distance is define as:</p></blockquote>

<pre><code>D(X,Y) = Remove chars common at the start from both X &amp; Y. 
Then add the remaining lengths from both the strings.
</code></pre>

<blockquote><p>For e.g.</p></blockquote>

<pre><code>D(1111, 1000) = Only First alphabet is common. So the remaining string is 111 &amp; 000. Therefore the result length("111") &amp; length("000") = 3 + 3 = 6
</code></pre>

<blockquote><p>For e.g.</p></blockquote>

<pre><code>D(0101, 01100) = Only First two alphabets are common. So the remaining string is 01 &amp; 100. Therefore the result length("01") &amp; length("100") = 2 + 3 = 5
</code></pre>

<blockquote><p>Now given n input, say like</p></blockquote>

<pre><code>1111
1000
101
1100
</code></pre>

<blockquote><p>Find out the maximum crazy distance between 2 strings.</p>

<p><strong>n is</strong> the number of input strings. <strong>m is</strong> the max length of any input string.</p></blockquote>

<h3>Solution</h3>

<p>This is the <a href="http://stackoverflow.com/a/15062640">source</a>.</p>

<blockquote><p>Put the strings into a tree, where 0 means go left and 1 means go right. <strong>O(m*n) time</strong>.</p></blockquote>

<p>Example:</p>

<pre><code>            Root
             1
          0      1
         0 1*   0  1
        0*     0*    1*
</code></pre>

<blockquote><p>where the * means that an element ends there. Constructing this tree clearly takes O(n m).</p>

<p>Now we have to find <strong>the diameter of the tree</strong> (the longest path between two nodes).</p></blockquote>

<p>How to find out longest path between 2 leaf nodes? Please refer to <strong>[Google] Diameter of a Binary Tree</strong> for explanation.</p>

<p>Total time complexity is <strong>O(m*n) time</strong>.</p>

<h3>Code</h3>

<pre><code>public int crazyDist(String[] input) {
    TreeNode root = this.buildTree(input);
    return this.findMaxPath(root).path - 1;
}

private Result findMaxPath(TreeNode node) {
    if (node == null) {
        return new Result(Integer.MIN_VALUE, 0);
    }
    Result lr = this.findMaxPath(node.left);
    Result rr = this.findMaxPath(node.right);
    int path = Math.max(lr.path, rr.path);
    if (lr.depth != 0 &amp;&amp; rr.depth != 0) {
        // this check is important, because if any of the child node is
        // NULL, this root will not be eligible for computing the path
        path = Math.max(path, lr.depth + rr.depth + 1);
        // Why? cuz diameter must go from one leaf, thru root, and reach
        // another leaf. This is different from "Maximum Path Sum" leetcode
    }
    return new Result(path, 1 + Math.max(lr.depth, rr.depth));
}

private TreeNode buildTree(String[] input) {
    TreeNode root = new TreeNode(123);
    // share a common root. this root is deducted from the final calculation
    for (String str : input) {
        // insert str under the root
        TreeNode p = root;
        for (char c : str.toCharArray()) {
            if (c == '0') {
                if (p.left == null) {
                    p.left = new TreeNode(124);
                    // if 0, go to left; otherwise go to right
                    // thus value of TreeNodes does not really matter
                }
                p = p.left;
            } else {
                if (p.right == null) {
                    p.right = new TreeNode(125);
                }
                p = p.right;
            }
        }
    }
    return root;
}

class Result {
    int path;
    int depth;

    public Result(int a, int b) {
        path = a;
        depth = b;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Check if Repeating Subsequence Exists]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/check-if-repeating-subsequence-exist/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/check-if-repeating-subsequence-exist</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=5931067269709824">link</a></p>

<blockquote><p>Given a string, find if there is any sub-sequence that repeats itself. Do not reuse any char.</p>

<p>Eg:</p></blockquote>

<pre><code>1. abab &lt;------yes, ab is repeated
2. abba &lt;---- No, a and b follow different order 
3. acbdaghfb &lt;-------- yes, a followed by b twice 
4. abcdacb &lt;----- yes, a followed by b twice 
</code></pre>

<blockquote><p>Note that no char should be reused. I.e. &ldquo;aab&rdquo; is a false.</p></blockquote>

<h3>Solution</h3>

<p>This looks like a question without any clue. However, this actually is a modified version of <strong>[LintCode] Longest Common Subsequence</strong>.</p>

<p>Look at that question: there&rsquo;s 2 input string, and they match char-by-char. For this question, we are simply <strong>matching input string with input string itself</strong>. And chars should be match <strong>ONLY</strong> at different positions, that&rsquo;s the key. As pointed out by the <a href="http://www.careercup.com/question?id=5931067269709824">top comment</a>:</p>

<blockquote><p>Now we can modify the longest_common_subsequence(a, a) to find the value of the longest repeated subsequence in a by excluding the cases when i == j</p></blockquote>

<h3>Code</h3>

<pre><code>public boolean checkRepeatSubseq(String input) {
    int len = input.length();
    int[][] dp = new int[len + 1][len + 1];
    // dp[i][j] denotes the length of subseq between 2 strings:
    // 1. first i chars of input
    // 2. first j chars of input
    for (int i = 1; i &lt;= len; i++) {
        for (int j = i; j &lt;= len; j++) {
            if (i != j &amp;&amp; input.charAt(i - 1) == input.charAt(j - 1)) {
                int temp = Math.max(dp[i - 1][j], dp[i][j - 1]);
                dp[i][j] = Math.max(temp, dp[i - 1][j - 1] + 1);
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[len][len] &gt;= 2;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LinkedIn] Find All Repeating Substring With Given Length]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/all-repeating-substring-given-length/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/all-repeating-substring-given-length</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=6495932900179968">link</a></p>

<blockquote><p>Find all the repeating substring of specified length in a large string sequence.</p>

<p>For e.g.</p></blockquote>

<pre><code>Input String: "ABCACBABC" 
repeated sub-string length: 3 
Output: ABC 
</code></pre>

<blockquote><p>eg.</p></blockquote>

<pre><code>Input String: "ABCABCA" 
repeated sub-string length: 2 
Output: AB, BC, CA
</code></pre>

<h3>Solution</h3>

<p>Similar to <strong>[Amazon] Longest Repeating Substring</strong>, the best solution is to do <strong>Suffix Tree</strong>, or suffix array. We then need to print nodes on a certain level, who has more than 1 descendant.</p>

<p>However, since the length of substring is given, we can also do simply iteration: insert all substring with given length into a HashSet, and check repetition. <a href="https://github.com/techpanja/interviewproblems/blob/master/src/strings/repeatingstringsofspecifiedlength/RepeatingStringOfSpecificLength.java">ref</a></p>

<h3>Code</h3>

<p>Suffix tree solution: not written.</p>

<p>Hashset code:</p>

<pre><code>public List&lt;String&gt; solve(String input, int k) {
    List&lt;String&gt; ans = new ArrayList&lt;String&gt;();
    HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();
    for (int i = 0; i &lt;= input.length() - k; i++) {
        String sub = input.substring(i, i + k);
        if (set.contains(sub)) {
            ans.add(sub);
        }
        set.add(sub);
    }
    return ans;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] All Distinct Subsequences With Given Length]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/all-distinct-subsequences-given-length%20-%20Copy/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/all-distinct-subsequences-given-length - Copy</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://11011110.livejournal.com/254164.html">link</a></p>

<blockquote><p>Find a polynomial-time algorithm that takes a string of length n, and a number k, output the number of distinct k-character subsequences.</p>

<p>For instance, input &ldquo;food&rdquo; and number k=2, output should be 4. There are four distinct 2-character subsequences of &ldquo;food&rdquo;: &ldquo;fo&rdquo;, &ldquo;fd&rdquo;, &ldquo;oo&rdquo;, and &ldquo;od&rdquo;.</p></blockquote>

<h3>Solution</h3>

<p>Similar to <strong>[Question] Number of distinct sub-sequence</strong>, we solve this problem with DP. The dp equation is a bit difficult to write.</p>

<p>The idea come from comment from <a href="http://11011110.livejournal.com/254164.html">gareth_rees</a>:</p>

<blockquote><p>Let θ(S, k) be the number of distinct k-character subsequences in the string S of length n.</p>

<p>Clearly θ(S, k) = 1 if n = k or k = 0</p>

<p>and θ(S, k) = 0 if n &lt; k.</p>

<p>Otherwise, <strong>choose 1 unique char from S</strong>, and deduct k by 1, then do the DP calculation with the remaining part of S.</p></blockquote>

<p>Look at this example:</p>

<pre><code>θ("food", 2) = θ("ood", 1) + θ("od", 1) + θ("", 1)
= (θ("od", 0) + θ("", 0)) + (θ("d", 0) + θ("", 0)) + 0
= (1 + 1) + (1 + 1)
= 4
</code></pre>

<p><strong>&ldquo;food&rdquo; is divided into 3 parts</strong>. First part we choose &ldquo;f&rdquo; to be the first char, thus the value is θ(&ldquo;ood&rdquo;, 1). Second part we choose &ldquo;o&rdquo;, and final part we choose &ldquo;d&rdquo;.</p>

<p><strong>Note that when we choose a char, it must never have been chosen before</strong>. In case of &ldquo;food&rdquo;, we only choose &lsquo;f&rsquo;, &lsquo;o&rsquo;, &rsquo;d&#8217; once for each.</p>

<p>This is a very difficult DP question, but the explanation really makes the answer easier. Read my implementation below.</p>

<h3>Code</h3>

<pre><code>public int countSubSeq(String input, int k) {
    // assuming all input chars are small letter
    return choose(input, 0, k);
}

private int choose(String input, int start, int numChar) {
    int charLeft = input.length() - start;
    if (charLeft == numChar || numChar == 0) {
        return 1;
    } else if (charLeft &lt; numChar || numChar &lt; 0) {
        return 0;
    }
    // now numChar is smaller than charLeft, and larger than 0
    // start to pick a char (which is at first appearance)
    int total = 0;
    HashSet&lt;Character&gt; chosen = new HashSet&lt;Character&gt;();
    while (start &lt; input.length()) {
        char currentChar = input.charAt(start);
        if (!chosen.contains(currentChar)) {
            // pick the char pointer by 'start'
            total += choose(input, start + 1, numChar - 1);
            chosen.add(currentChar);
        }
        start++;
    }
    return total;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Diameter of a Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/Diameter-of-Binary-Tree/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/Diameter-of-Binary-Tree</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/diameter-of-a-binary-tree/">link</a></p>

<blockquote><p>The diameter of a tree (sometimes called the width) is the number of nodes on the longest path between two leaves in the tree.</p></blockquote>

<p><img class="middle" src="http://okckd.github.io/assets/images/tree-diameter-1.gif"></p>

<h3>Solution</h3>

<p>This is a similar question to <strong>[LeetCode 124] Binary Tree Maximum Path Sum</strong>. <strong>However there&rsquo;s a significant difference</strong> which might be overlooked while coding.</p>

<p>Look at this example:</p>

<pre><code>     0
       1
        1
       0  1
           1
</code></pre>

<p>If we only want to find the max path, that would return result of 5, which is root-to-rightmost-leaf. However, the diameter should be 4, which is the distance between 2 leaf nodes.</p>

<p>A solution is available for reading <a href="http://stackoverflow.com/a/3124575">here</a>.</p>

<p>For <strong>[Google] Crazy Distance Between Strings</strong>, there is another special case: {&ldquo;1&rdquo;, &ldquo;11&rdquo;, &ldquo;10&rdquo;}. The program will not output correct result (1), because this is not really the diameter of a tree, but instead, a max path from a non-leaf to a leaf. I leave this part for you to finish.</p>

<h3>Code</h3>

<p>Refer to <strong>[Google] Crazy Distance Between Strings</strong> for complete code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Reverse a Stack Without DS]]></title>
    <link href="http://okckd.github.io/blog/2015/01/10/reverse-a-stack/"/>
    <updated>2015-01-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/10/reverse-a-stack</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/reverse-a-stack-using-recursion/">link</a></p>

<blockquote><p>Reverse a stack using recursion. You are not allowed to use loops or data structure, and you can only use the following functions:</p></blockquote>

<pre><code>isEmpty(S)
push(S)
pop(S)
</code></pre>

<h3>Solution</h3>

<p>Well since we are not allowed to use additional DS or loop, we have to use system stack to help us!</p>

<p>We add a new method: <strong>insert at stack bottom</strong>. Then we can solve this question recursively. Nice question, and tricky answer!</p>

<h3>Code</h3>

<pre><code>public void reverse(Stack&lt;Integer&gt; stack) {
    if (stack.isEmpty() || stack.size() == 1) {
        return;
    }
    int top = stack.pop();
    this.reverse(stack);
    this.insertAtBottom(stack, top);
}

private void insertAtBottom(Stack&lt;Integer&gt; stack, int val) {
    if (stack.isEmpty()) {
        stack.push(val);
        return;
    }
    int temp = stack.pop();
    this.insertAtBottom(stack, val);
    stack.push(temp);
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Amazon] Mininum Range That Includes at Least One]]></title>
    <link href="http://okckd.github.io/blog/2015/01/10/minimum-range-inclueds-at-least-1/"/>
    <updated>2015-01-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/10/minimum-range-inclueds-at-least-1</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=5103437989543936">link</a></p>

<blockquote><p>There are many sorted arrays. Find a minimum range, so that in each array there&rsquo;s at least one integer within this range.</p></blockquote>

<h3>Solution</h3>

<p><strong>Min-heap</strong>. <a href="http://www.careercup.com/question?id=16759664">source</a></p>

<blockquote><p>There are k lists of sorted integers. Make a min heap of size k containing 1 element from each list. Keep track of min and max element and calculate the range.</p>

<p>In min heap, minimum element is at top. Delete the minimum element and another element instead of that from the same list to which minimum element belong. Repeat the process till any one of the k list gets empty.</p></blockquote>

<h3>Code</h3>

<pre><code>public void printMinRange(int[][] input) {
    Comparator&lt;Pointer&gt; compr = new HeapComparator(input);
    // Note that we pass in 'input' arrays to the comparator
    PriorityQueue&lt;Pointer&gt; heap = new PriorityQueue&lt;Pointer&gt;(SIZE, compr);

    int maxVal = Integer.MIN_VALUE;
    for (int i = 0; i &lt; SIZE; i++) {
        heap.add(new Pointer(i, 0));
        // insert the head of each array into the heap
        maxVal = Math.max(maxVal, input[i][0]);
        // keep additional value to keep track of the max value in heap
    }

    int left = 0;
    int right = Integer.MAX_VALUE;
    while (heap.size() == SIZE) {
        Pointer p = heap.remove();
        // first, update the range
        if (maxVal - input[p.index][p.position] &lt; right - left) {
            right = maxVal;
            left = input[p.index][p.position];
        }
        // then, push the next element after 'p' to the heap
        // meanwhile, update 'maxVal'
        if (p.position + 1 &lt; input[p.index].length) {
            Pointer nextP = new Pointer(p.index, p.position + 1);
            heap.add(nextP);
            maxVal = Math.max(maxVal, input[nextP.index][nextP.position]);
        }
        // when 'p' is the last element in the row, terminate loop
    }
    System.out.println("Left boundary: " + left);
    System.out.println("Right boundary: " + right);
}

class HeapComparator implements Comparator&lt;Pointer&gt; {

    int[][] arrays = null;

    public HeapComparator(int[][] input) {
        arrays = input;
    }

    public int compare(Pointer p1, Pointer p2) {
        return arrays[p1.index][p1.position]
                - arrays[p2.index][p2.position];
    }
}

class Pointer {
    int index, position;

    public Pointer(int x, int y) {
        index = x;
        position = y;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Maximum Count Array in a Queue]]></title>
    <link href="http://okckd.github.io/blog/2015/01/10/max-count-array-in-queue/"/>
    <updated>2015-01-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/10/max-count-array-in-queue</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.mitbbs.com/article_t1/JobHunting/32856675_0_1.html#top">link1</a></p>

<blockquote><p>给一个数组a[n]，令s[i]为a[i+1..n-1]中比a[i]大的数的数量。</p>

<p>求最大的s[i]。要求O(nlogn)</p></blockquote>

<h3>Solution</h3>

<p>This is very similar question to <strong>[Google] Form a Queue Given Heights</strong>. The idea is to insert elements into BST and count number of larger elements.</p>

<p>Naitive solution can be reached with a list.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Form a Queue Given Heights]]></title>
    <link href="http://okckd.github.io/blog/2015/01/10/form-queue-given-heights/"/>
    <updated>2015-01-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/10/form-queue-given-heights</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/reverse-a-stack-using-recursion/">link1</a>, <a href="http://www.weiming.info/zhuti/JobHunting/31903469/">link2</a>, <a href="http://www.mitbbs.com/article_t1/JobHunting/32856675_0_1.html#top">link3</a>.</p>

<blockquote><p>There is an array of integers which represent heights of persons.</p>

<p>Given another array&hellip; Let&rsquo;s call it count-array. It contain how many persons in front of him are greater than him in height.</p>

<p>求原数组。(原数组中元素是从1到n。)</p>

<p>Example:</p></blockquote>

<pre><code>Input(Count array): 0, 0, 2, 0
Output(原数组): 2, 3, 1, 4
</code></pre>

<blockquote><p>求nlogn的算法。</p></blockquote>

<h3>Solution</h3>

<p>This is naive solution from floor 29 of <a href="http://www.weiming.info/zhuti/JobHunting/31903469/">this thread</a>:</p>

<blockquote><p>总结一下，用一个List存放1&hellip;n。</p>

<p>从头到尾扫描给定的数组，每得到一个值，从List里删掉。</p>

<p>因为List里数据是有序的，因此remove操作可以使用二分法，复杂度为O(logn).</p>

<p>这样本算法复杂度为O(nlogn).</p></blockquote>

<p>Example:</p>

<pre><code>count array 
i C[0,0,2,0]   N[4, 3, 2, 1]
3 C[3] = 0     在N里面删除N[0]=4, N=[3, 2, 1],   Ans=[4]
2 C[2] = 2     在N里面删除N[2]=1, N=[3, 2],   Ans=[1, 4]
1 C[1] = 0     在N里面删除N[0]=3, N=[2],   Ans=[3, 1, 4]
0 C[0] = 0     在N里面删除N[0]=2, N=[], Ans=[2, 3, 1, 4]
</code></pre>

<p>But there is a problm here, since removing item from list requires O(n), we will achieve O(n<sup>2</sup>) time. How do we optimize this?</p>

<p><strong>The answer is BST</strong> with each node keeping track of how many nodes is on the left branch, and how many on right branch.</p>

<p>The conclusion:</p>

<blockquote><p>可以化归为这样一道题：</p>

<p>设计一个有序的数据结构，最初里头有自然数1到n这n个元素，</p>

<p>随后这些元素可以被删除，但剩下元素仍然保持有序。</p>

<p>要求实现方法GetKthElement(int k)和RemoveKthElemenet(int k)，</p>

<p>使得它们在任意时刻都不超过O(lgN), N为当前的元素个数</p>

<p>感觉要结合BST之类</p></blockquote>

<h3>Code</h3>

<p>Naive approach, O(n<sup>2</sup>):</p>

<pre><code>public int[] form(int peopleCount, int[] countArray) {
    int len = peopleCount;
    int[] heightQueue = new int[len];
    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
    for (int i = peopleCount; i &gt; 0; i--) {
        list.add(i);
    }
    for (int i = len - 1; i &gt;= 0; i--) {
        heightQueue[i] = list.remove(countArray[i]);
    }
    return heightQueue;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Terminology: N-gram]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/terminology-ngram/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/terminology-ngram</id>
    <content type="html"><![CDATA[<h3>n-gram</h3>

<p>In the fields of computational linguistics and probability, an <strong><a href="http://en.wikipedia.org/wiki/N-gram">n-gram</a></strong> is a contiguous sequence of n items from a given sequence of text or speech.</p>

<p>The items can be phonemes, syllables, letters, words or base pairs according to the application. The n-grams typically are collected from a text or speech corpus.</p>

<h4>Example</h4>

<table border="1" width="100%" id="table5" cellpadding="3" style="border-collapse: collapse" bordercolor="#89B0D8" cellspacing="0">
                <tbody><tr>
                    <td bgcolor="#D9ECFF">
                    <p align="center">frequency</p></td>
                    <td bgcolor="#D9ECFF">
                    <p align="center">word1</p></td>
                    <td bgcolor="#D9ECFF">
                    <p align="center">word2</p></td>
                    <td bgcolor="#D9ECFF">
                    <p align="center">word3</p></td>
                </tr>
                <tr>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">1419</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">much</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">the</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">same</p>
                    </td>
                </tr>
                <tr>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">461</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">much</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">more</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">likely</p>
                    </td>
                </tr>
                <tr>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">432</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">much</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">better</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">than</p>
                    </td>
                </tr>
                <tr>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">266</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">much</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">more</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">difficult</p>
                    </td>
                </tr>
                <tr>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">235</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">much</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">of</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">the</p>
                    </td>
                </tr>
                <tr>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">226</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">much</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">more</p>
                    </td>
                    <td bgcolor="#F5F9FC">
                    <p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">than</p>
                    </td>
                </tr>
</tbody></table>


<h4>Downloadable n-grams sets for English</h4>

<ol>
<li><strong><a href="https://catalog.ldc.upenn.edu/LDC2006T13">Google n-grams</a></strong>, based on the web as of 2006.</li>
<li><strong><a href="http://www.ngrams.info/intro.asp">COCA n-grams</a></strong>, based on Corpus of Contemporary American English [COCA]. 450 million words from 1990 to 2012.</li>
</ol>


<p>With n-grams data (2, 3, 4, 5-word sequences, with their frequency), we can carry out powerful queries offline.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Most Frequent Word From a Book]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/most-frequent-word-from-book/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/most-frequent-word-from-book</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=5715664853532672">link</a></p>

<blockquote><p>Let&rsquo;s say I gave you a long String and I wanted you to tell me the most common word in that String. How would you do that?</p>

<p>Follow-up: how about if I gave you the entire works of Alexandre Dumas, one of the most prolific authors in history. How would your solution work? How could you change it to solve this more specific problem?</p></blockquote>

<h3>Solution</h3>

<p>There are 2 solutions. Either <strong>HashMap</strong> or <strong>Trie</strong>. It&rsquo;s easy to think of first, but remember that Trie is designed to do this kind of job.</p>

<blockquote><p>A trie will be more useful in the second situation where you will have millions of words. You can have a counter at every node to see its frequency</p></blockquote>

<p><strong>Now the follow up</strong>. For big data problems, we can always do <strong>divide and conquer</strong> by hash value.</p>

<p>Alternatively, the comment by <a href="http://www.careercup.com/question?id=5715664853532672">Prince</a> mentioned how to solve with <strong>Map Reduce</strong>:</p>

<blockquote><p>Instead of loading it as a string first I would stream data so that I avoid memory spike. Further our map size might increases as new words are added to it. Also, we can use map reduce type job were we create map&lt;word, frequency> of each play in parallel and later join/collapse them this will reduce the time it will take to get result.</p>

<p>Common phrase should be no different then above algorithm. However we need to rebuild our index with &lt;phase, frequency></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Match Triplet With Reverse Order]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/match-triplet-with-reverse-order/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/match-triplet-with-reverse-order</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=11655778">link</a></p>

<blockquote><p>Find the substring of length 3 which is present in the reverse order from the string.</p>

<p>Ex: if the string is abcdcba (cba is the reverse of abc) so we should return cba.</p></blockquote>

<h3>Solution</h3>

<ol>
<li><p><strong>HashMap (recommended)</strong>. Hash all substrings of length 3. O(n). Look up all reverse substrings of length 3 in this hash set. O(n) time and O(n) space.</p></li>
<li><p><strong>KMP Algo</strong>. Take every substring of length 3. Reverse it and find it in the input using KMP. O(n<sup>2</sup>) time and O(1) space.</p></li>
<li><p><strong>Build suffix tree</strong> of height 3. Then in reverse order, check triplets.</p></li>
</ol>


<p>The 3 solutions above all work well. Pick the one you love.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Big Data - Top K Frequency 3]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/big-data-top-k-frequency-3/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/big-data-top-k-frequency-3</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://stackoverflow.com/a/3262855">link</a></p>

<blockquote><p>The input is an endless stream of English words or phrases (we refer them as tokens).</p>

<p>Output top N tokens we have seen so far (from all the tokens we have seen!)</p></blockquote>

<h3>Analysis</h3>

<p>We will discuss the following details of implementation and optimization.</p>

<ol>
<li>String into Integer</li>
<li>Data Storage</li>
<li>Process Incoming Streams</li>
<li>Save result</li>
</ol>


<h4>1. String into Integer</h4>

<p>This is a nice trick that improves eficiency a lot.</p>

<blockquote><p>Though there is almost infinite possible words on the Internet, but after accumulating a large set of words, the possibility of finding new words becomes lower and lower.</p>

<p>We have already found 4 million different words, and assigned a unique ID for each. This is important, because sorting and comparisons on integers is <strong>much much faster</strong> than on strings.</p></blockquote>

<h4>2. Data Storage</h4>

<blockquote><p>The system keeps archive data for every token. Basically it&rsquo;s pairs of (Token, Frequency).</p>

<p>However, the table that stores the data would be so huge such that we have to partition the table physically. One partition scheme is <strong>based on ngrams</strong> of the token. If the token is a single word, it is 1gram. If the token is two-word phrase, it is 2gram.</p></blockquote>

<p>Of course we can also divide the data by the hash value. For information on <strong>ngrams</strong>, read <strong>[Design] Terminology: n-gram</strong>.</p>

<h4>3. Process Incoming Streams</h4>

<blockquote><p>The system will absorbs incoming sentences until memory becomes fully utilized (Ya, we need a MemoryManager). After taking N sentences and storing in memory, the system pauses, and starts tokenize each sentence into words and phrases. Each token (word or phrase) is counted.</p></blockquote>

<p>This data processing logic runs as a process under Memory-Manager. The next part is another processing running concurrently.</p>

<h4>4. Save result</h4>

<blockquote><p>Meanwhile, there will be another process that is activated once it finds any disk file generated by the system, then start merging it. Since the disk file is sorted, merging would take <strong>a similar process like merge sort</strong>.</p></blockquote>

<p>There is <a href="http://stackoverflow.com/a/3262855">some more steps</a> afterwards, but they&rsquo;re trivial. I have listed out the basic steps for processing large stream of incoming data (as string), and how to find out the Top K keywords.</p>

<p>I suggest you read previous <strong>[Design] Big Data &ndash; Top k Frequency</strong> posts before reading this.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Big Data - Real Time Top K]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/big-data-real-time-top-k/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/big-data-real-time-top-k</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://stackoverflow.com/questions/10189685/realtime-tracking-of-top-100-twitter-words-per-min-hour-day">link</a></p>

<blockquote><p>Given a continuous twitter feed, design an algorithm to return the 100 most
frequent words used at this minute, this hour and this day.</p></blockquote>

<h3>Analysis</h3>

<p>This is a frequent and useful problem for companies like Google and Twitter.</p>

<p>The first solution below is <strong>an approximation method</strong> which select keywords that occur more than a certain threshold.</p>

<p>The second solution is <strong>more accurate</strong> but RAM-intensive.</p>

<h3>Lossy Count</h3>

<p><strong>Solution 1 is a modified version of <a href="http://stackoverflow.com/a/8033083">Lossy Count</a></strong>. The detailed steps are explained <a href="http://stackoverflow.com/a/3260905">here</a>:</p>

<blockquote><p>Start with an empty map (red-black tree). The keys will be search terms, and the values will be a counter for the term.</p>

<ol>
<li><p>Look at each item in the stream.</p></li>
<li><p>If the term exists in the map, increment the associated counter.</p></li>
<li><p>Otherwise, if the map has fewer candidates than you&rsquo;re looking for, add it to the map with a count of one.</p></li>
<li><p>However, if the map is &ldquo;full&rdquo;, decrement the counter in each entry. If any counter reaches zero during this process, remove it from the map.</p></li>
</ol>
</blockquote>

<p><a href="http://www.cse.ust.hk/vldb2002/VLDB2002-proceedings/slides/S10P03slides.pdf">This slide show</a> explains <strong>Lossy Count</strong>, which is to divide input data into chunks. Then count elements and decrease counter by 1 after each chunk.</p>

<p><strong>Note that the result is NOT the top frequency items</strong>. Instead, the final results are <strong>order-dependent</strong>, giving heavier weight to the counts processed last. It maybe helpful in some cases, cuz we want to check the latest trend. However, if we want more accurate top keywords for all data, we will <strong>do a second pass over the log data</strong>.</p>

<p>Now let&rsquo;s discuss the threshold. Use &ldquo;aaabcd&rdquo; and map size = 2 as example. &lsquo;a&rsquo; will be inserted into map with occurance = 3. Then &lsquo;b&rsquo; is inserted, and removed. &lsquo;c&rsquo; is inserted, and removed. &rsquo;d&#8217; is inserted. Since we always decrease 1 at each step, &lsquo;a&rsquo; should only have occurance of 1 at the end. As explained <a href="http://stackoverflow.com/a/3260905">here</a>:</p>

<blockquote><p>If we limit the map to 99 entries, we are guaranteed to find any term that occurs more than 1/(1 + 99) (1%) of the time.</p></blockquote>

<p>We change the size of the map to change the threshold. The occurance of in the final result does not matter.</p>

<h3>Solution 2</h3>

<p>The lossy count does not actually produce the hourly, daily and monthly result accurately. Solution 2 will discuss how we deal with retiring old data in an accurate way.</p>

<p>Suggested by <a href="http://stackoverflow.com/a/3260768">this answer</a>, <strong>we keep a 30-day list for each keyword</strong>, that counts the daily occurance. This list is FIFO. When we remove and insert a new counter value, we update monthly total.</p>

<p>Alaternatively, <a href="http://stackoverflow.com/a/10190836">this answer</a> suggests keeping 1440 (24 * 60) HashMaps, each storing the information for one minute. <strong>And another 2 HashMap for the rolling total for the past hour, and past day</strong>.</p>

<blockquote><p>You need an array of 1440 (24*60) word+count hash maps organized the way that you describe; these are your minute-by-minute counts. You need two additional hash maps &ndash; for the rolling total of the hour and the day.</p>

<p>Define two operations on hash maps &ndash; add and subtract, with the semantic of merging counts of identical words, and removing words when their count drops to zero.</p>

<p>Each minute you start a new hash map, and update counts from the feed. At the end of the minute, you place that hash map into the array for the current minute, add it to the rolling total for the hour and for the day, and then subtract the hash map of an hour ago from the hourly running total, and subtract the hash map of 24 hours ago from the daily running total.</p></blockquote>

<p>This is a very good solution, which I would recommend as the standard solution to this &ldquo;Real Time Top k&rdquo; problem.</p>
]]></content>
  </entry>
  
</feed>
