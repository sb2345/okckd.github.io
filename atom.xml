<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Woodstock Blog]]></title>
  <link href="http://okckd.github.io/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-10-26T16:45:13+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Interleave Positive and Negative Numbers]]></title>
    <link href="http://okckd.github.io/blog/2014/10/08/interleave-positive-negative/"/>
    <updated>2014-10-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/10/08/interleave-positive-negative</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://mp.weixin.qq.com/s?__biz=MzA5MzE4MjgyMw==&amp;mid=200355650&amp;idx=1&amp;sn=f94e87cb391fb12af9531cedb452dba1&amp;key=d232b50733c41de56b96f855d9cdea5824f24c712e158651b45d7fe139a94610a7561da1fab0104e968592b01f2439d4&amp;ascene=7&amp;uin=MzM2NjQyNQ%3D%3D&amp;pass_ticket=i7pJQweQbuRdnUFUt5cdOmapPc%2FDW6Xk40U7%2Bcg%2F0o8%3D">link</a></p>

<blockquote><p>给一个包含正负整数的数组，要求对这个数组中的数进行重新排列，使得其正负交替出现。首先出现负数，然后是正数，然后是负数。有多余的数的一方，就放在末尾。</p>

<p>如 [1, 2, 3, -4]&ndash;>[-4, 1, 2, 3]，[1,-3,2,-4,-5]&ndash;>[-3,1,-4,2,-5]. 要求使用O(1)的额外空间。</p>

<p>如果需要保持正数序列和负数序列各自原来的顺序，如何做？</p>

<p>如果不需要保持正数序列和负数序列各自原来的顺序，如何做？</p></blockquote>

<h3>Solution</h3>

<p>I only solve this question if we <strong>do not have to keep the original ordering</strong>.</p>

<p>Basically, 2 pointers search from beginning to end. If there&rsquo;re more + than &ndash;, move the extra positive values to the back of the array. Vice versa.</p>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public void solve(int[] A) {
    int len = A.length;
    int neg = 0;
    int pos = 1;
    while (neg &lt; len || pos &lt; len) {

        while (neg &lt; len &amp;&amp; A[neg] &lt; 0) {
            neg += 2;
        }
        while (pos &lt; len &amp;&amp; A[pos] &gt; 0) {
            pos += 2;
        }
        // neg points to a positive value
        // pos points to a negative value
        // swap them (if they're valid position)
        if (neg &gt;= len &amp;&amp; pos &gt;= len) {
            return;
        } else if (neg &gt;= len) {
            // neg is done, there's more - then +
            // put all negative values pointed by pos to the back
            int right = len - 1;
            if (right % 2 == 0) {
                right--;
            }
            while (pos &lt; right) {
                while (pos &lt; len &amp;&amp; A[pos] &gt; 0) {
                    pos += 2;
                }
                while (right &gt;= 0 &amp;&amp; A[right] &lt; 0) {
                    right -= 2;
                }
                // pos point to a negative value, right to positive value
                if (pos &gt; right) {
                    break;
                } else {
                    swap(A, pos, right);
                }
            }
            return;
        } else if (pos &gt;= len) {
            // pos is done, there's more + then -
            int right = len - 1;
            if (right % 2 == 1) {
                right--;
            }
            while (neg &lt; right) {
                while (neg &lt; len &amp;&amp; A[neg] &lt; 0) {
                    neg += 2;
                }
                while (right &gt;= 0 &amp;&amp; A[right] &gt; 0) {
                    right -= 2;
                }
                if (neg &gt; right) {
                    break;
                } else {
                    swap(A, neg, right);
                }
            }
            return;
        } else {
            swap(A, neg, pos);
        }
    }
}

private void swap(int[] array, int a, int b) {
    int temp = array[a];
    array[a] = array[b];
    array[b] = temp;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Leetcode] Leetcode Third Round (1)]]></title>
    <link href="http://okckd.github.io/blog/2014/10/03/Leetcode-third-1/"/>
    <updated>2014-10-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/10/03/Leetcode-third-1</id>
    <content type="html"><![CDATA[<pre><code>Days:        02/10/2014 - start
Submission:  
Pass:        

Submit/day:  
Pass/day:    

Pass/submit: 
</code></pre>

<h3>Question List</h3>

<ol>
<li>Substring with Concatenation of All Words</li>
<li>Palindrome Partitioning II</li>
<li>Reverse Words in a String</li>
<li>LRU Cache</li>
<li>Binary Tree Postorder Traversal</li>
<li>Word Ladder</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 18.7 Longest Word Made From Other Words]]></title>
    <link href="http://okckd.github.io/blog/2014/10/02/longest-word-made-from-other/"/>
    <updated>2014-10-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/10/02/longest-word-made-from-other</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Given a list of words, write a program to find the longest word made of other words in the list.</p>

<p>EXAMPLE</p>

<p>Input: cat, banana, dog, nana, walk, walker, dogwalker</p>

<p>Output: dogwalker</p></blockquote>

<h3>Solution</h3>

<p><strong>Search it recursively from longest to shortest</strong>. Use HashSet to help us search for words quickly.</p>

<p>This question might look difficult at first, it&rsquo;s actually a very classical recursive search.</p>

<h3>Code</h3>

<pre><code>public static void printLongestWord(String[] arr) {
    Arrays.sort(arr, new LengthComparator());
    HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();
    for (String str : arr) {
        set.add(str);
    }
    for (String word : arr) {
        if (canDivide(word, 0, set)) {
            System.out.println(word);
            return;
        }
    }
    System.out.println("can not find such word");
}

private static boolean canDivide(String word, int from, HashSet&lt;String&gt; set) {
    if (from == word.length()) {
        return true;
    }
    for (int i = from; i &lt; word.length(); i++) {
        String str = word.substring(from, i + 1);
        if (from == 0 &amp;&amp; i == word.length() - 1) {
            continue;
        } else if (!set.contains(str)) {
            continue;
        }
        if (canDivide(word, i + 1, set)) {
            return true;
        }
    }
    return false;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 17.14 Optimal Way to Unconcatenate Doc]]></title>
    <link href="http://okckd.github.io/blog/2014/10/01/optimal-unconcatenate-doc/"/>
    <updated>2014-10-01T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/10/01/optimal-unconcatenate-doc</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Given a lengthy document without spaces, punctuation, and capitalization:</p>

<p>eg: iresetthecomputeritstilldidntboot</p>

<p>Now add back in the punctation and capitalization.</p>

<p>Most of the words will be in a dictionary, but some strings, like proper names, will not. Given a dictionary (a list of words), design an algorithm to find the optimal way of &ldquo;unconcatenating&rdquo; a sequence of words (by minimizing unrecognized sequences of characters).</p>

<p>For example, the string &ldquo;jesslookedjustliketimherbrother&rdquo; would be optimally parsed as &ldquo;JESS looked just like TIM her brother&rdquo;. This parsing has seven unrecognized characters, which we have capitalized for clarity.</p></blockquote>

<h3>Solution</h3>

<p>The solution given in the book is very hard to understand. It uses HashMap to memorize the previous result.</p>

<p>After long time of struggle, I finally solved it with traditional DP approach. The key idea is to consider: &ldquo;<strong>whether I insert a space after this char, or not</strong>&rdquo;.</p>

<p>The code is concise and easy to read.</p>

<h3>Code</h3>

<pre><code>public static int parse(String doc, Trie dict) {
    int len = doc.length();
    int[] dp = new int[len + 1];
    // dp[i] denotes the number of special chars in first i chars of docs
    for (int i = 1; i &lt;= len; i++) {
        dp[i] =  Integer.MAX_VALUE;
        for (int j = 0; j &lt; i; j++) {
            String str = doc.substring(j, i);
            if (dict.contains(str, true)) {
                // consider (i to j) a valid word
                dp[i] = Math.min(dp[i], dp[j]);
            } else {
                // consider (i to j) special chars
                dp[i] = Math.min(dp[i], dp[j] + i - j);
            }
        }
    }
    return dp[len];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 17.13 Convert BST to Doubly-Linked List]]></title>
    <link href="http://okckd.github.io/blog/2014/09/30/convert-bst-doubly-linked-list/"/>
    <updated>2014-09-30T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/30/convert-bst-doubly-linked-list</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Consider a simple node-like data structure called BiNode, which has pointers to two other nodes.</p></blockquote>

<pre><code>public class BiNode {
    public BiNode node1, node2;
    public int data;
}
</code></pre>

<blockquote><p>The data structure BiNode could be used to represent both a binary tree (where node1 is the left node and node2 is the right node) or a doubly linked list (where node1 is the previous node and node2 is the next node). Implement a method to convert a binary search tree (implemented with BiNode) into a doubly linked list. The values should be kept in order and the operation should be performed in place (that is, on the original data structure).</p></blockquote>

<h3>Solution</h3>

<p>At another post <strong>[LeetCode Plus] Convert BST to Doubly-Linked List</strong>, we already discussed 2 approaches:</p>

<ol>
<li>in-order traversal approach</li>
<li>divide and conquer approach</li>
</ol>


<p>First approach isn&rsquo;t intuitive. We will further discuss D&amp;C approach here.</p>

<p><strong>The key of the solution is how we return both HEAD and TAIL</strong>. The book suggests 3 ways:</p>

<ol>
<li>Build a <strong>data structure</strong> to store both head and tail</li>
<li><strong>Just return head</strong>, and retrieve tail by traversing thru &ndash; bad time complexity O(n<sup>2</sup>)</li>
<li><strong>Use circular linked-list</strong>! Time O(n).</li>
</ol>


<p>I wrote the code for 2nd suggestion.</p>

<p><strong>The circular list is a great idea</strong>. It&rsquo;s already covered in previous post. Do keep in mind <strong>why we need the list to be circular</strong>!</p>

<h3>Code</h3>

<p><strong>Just return head approach</strong></p>

<pre><code>public static BiNode convert(BiNode root) {
    if (root == null) {
        return null;
    }
    return helper(root);
}

private static BiNode helper(BiNode node) {
    // node is not null
    BiNode newHead = node;
    // do left part
    if (node.node1 != null) {
        newHead = helper(node.node1);
        BiNode leftTail = getListTail(newHead);
        leftTail.node2 = node;
        node.node1 = leftTail;
    }
    // do right part
    if (node.node2 != null) {
        BiNode rightHead = helper(node.node2);
        node.node2 = rightHead;
        rightHead.node1 = node;
    }
    return newHead;
}

private static BiNode getListTail(BiNode head) {
    // head is not null
    while (head.node2 != null) {
        head = head.node2;
    }
    return head;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 11.8 Get Rank in Stream of Integers]]></title>
    <link href="http://okckd.github.io/blog/2014/09/28/get-rank-stream-integers/"/>
    <updated>2014-09-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/28/get-rank-stream-integers</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Imagine you are reading in a stream of integers. Periodically, you wish to be able to look up the rank of a number x (the number of values less than or equal to x).</p>

<p>Implement the data structures and algorithms to support these operations. That is,implement the method <strong>track(int x)</strong>, which is called when each number is generated, and the method <strong>getRankOfNumber(int x)</strong>, which returns the number of values less than or equal to x (not including x itself).</p></blockquote>

<h3>Solution</h3>

<p><strong>This question requires a special type of Data Structure</strong>. It basically is a modified BST like this:</p>

<blockquote><p>The tree node stores both number value and the <strong>count of node on left subtree</strong></p></blockquote>

<p><img class="middle" src="http://okckd.github.io/assets/images/get-rank-number-stream.png"></p>

<p>Suppose we want to find the rank of 24 in the tree above. We would compare 24 with the root, 20, and find that 24 must reside on the right. The root has 4 nodes in its left subtree, and when we include the root itself, this gives us five total nodes smaller than 24. We set counter to 5.</p>

<p>Then, we compare 24 with node 25 and find that 24 must be on the left. The value of counter does not update, since we&rsquo;re not &ldquo;passing over&rdquo; any smaller nodes. The value of counter is still 5.</p>

<p>Next, we compare 24 with node 23,and find that 24 must be on the right. Counter gets incremented by just 1 (to 6), since 23 has no left nodes.</p>

<p>Finally, we find 24 and we return counter: 6.</p>

<h3>Code</h3>

<p>I did not write code myself. It&rsquo;s too complex!</p>

<p><strong>RankNode.java</strong></p>

<pre><code>public class RankNode {
    public int left_size = 0;
    public RankNode left;
    public RankNode right;
    public int data = 0;
    public RankNode(int d) {
        data = d;
    }

    public void insert(int d) {
        if (d &lt;= data) {
            if (left != null) {
                left.insert(d);
            } else {
                left = new RankNode(d);
            }
            left_size++;
        } else {
            if (right != null) {
                right.insert(d);
            } else {
                right = new RankNode(d);
            }
        }
    }

    public int getRank(int d) {
        if (d == data) {
            return left_size;
        } else if (d &lt; data) {
            if (left == null) {
                return -1;
            } else {
                return left.getRank(d);
            }
        } else {
            int right_rank = right == null ? -1 : right.getRank(d);
            if (right_rank == -1) {
                return -1;
            } else {
                return left_size + 1 + right_rank;
            }
        }
    }
}
</code></pre>

<p><strong>Main Class</strong>:</p>

<pre><code>public class Question {
    private static RankNode root = null;

    public static void track(int number) {
        if (root == null) {
            root = new RankNode(number);
        } else {
            root.insert(number);
        }
    }

    public static int getRankOfNumber(int number) {
        return root.getRank(number);
    }

    public static void main(String[] args) {
        int size = 100;
        int[] list = AssortedMethods.randomArray(size, -100, 100);
        for (int i = 0; i &lt; list.length; i++) {
            track(list[i]);
        }

        int[] tracker = new int[size];
        for (int i = 0; i &lt; list.length; i++) {
            int v = list[i];
            int rank1 = root.getRank(list[i]);
            tracker[rank1] = v;
        }

        for (int i = 0; i &lt; tracker.length - 1; i++) {
            if (tracker[i] != 0 &amp;&amp; tracker[i + 1] != 0) {
                if (tracker[i] &gt; tracker[i + 1]) {
                    System.out.println("ERROR at " + i);
                }
            }
        }

        System.out.println("Array: " + AssortedMethods.arrayToString(list));
        System.out.println("Ranks: " + AssortedMethods.arrayToString(tracker));
    }

}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 17.6 Order an Array by Sorting Middle]]></title>
    <link href="http://okckd.github.io/blog/2014/09/27/Order-array-by-sorting-middle/"/>
    <updated>2014-09-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/27/Order-array-by-sorting-middle</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Given an array of integers, write a method to find indices m and n such that if you sorted elements m through n, the entire array would be sorted. Minimize n-m (that is, find the smallest such sequence).</p></blockquote>

<h3>Solution</h3>

<p>Referring to <a href="http://www.mitbbs.com/article_t/JobHunting/32772399.html">this guy</a>:</p>

<blockquote><ol>
<li><p>找到heading的最长递增序列.</p></li>
<li><p>找到tailing的最长的递增序列.</p></li>
</ol>
</blockquote>

<p>After that:</p>

<blockquote><ol>
<li><p>用中间部分的min去shrink左边.</p></li>
<li><p>用中间部分的max去shrink右边.</p></li>
</ol>
</blockquote>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public static void findUnsortedSequence(int[] array, int[] ans) {
    int len = array.length;
    ans[0] = 0;
    ans[1] = 0;

    // find increasing sequence on left and on right
    int leftPeak = 0;
    while (leftPeak &lt; len - 1) {
        if (array[leftPeak] &lt; array[leftPeak + 1]) {
            leftPeak++;
        } else {
            break;
        }
    }
    if (leftPeak == len - 1) {
        return;
    }
    int rightBottom = len - 1;
    while (rightBottom &gt; 0) {
        if (array[rightBottom] &gt; array[rightBottom - 1]) {
            rightBottom--;
        } else {
            break;
        }
    }

    // leftPeak and rightBottom are found, now read mid part
    int midMin = Integer.MAX_VALUE;
    int midMax = Integer.MIN_VALUE;
    for (int i = leftPeak; i &lt;= rightBottom; i++) {
        midMin = Math.min(midMin, array[i]);
        midMax = Math.max(midMax, array[i]);
    }

    // find left boudary and right boundary
    int leftBound = leftPeak;
    while (leftBound &gt;= 0) {
        if (array[leftBound] &lt; midMin) {
            break;
        }
        leftBound--;
    }
    int rightBound = rightBottom;
    while (rightBound &lt; len) {
        if (array[rightBound] &gt; midMax) {
            break;
        }
        rightBound++;
    }

    // finish it up
    ans[0] = leftBound + 1;
    ans[1] = rightBound - 1;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 14.6 Implement CircularArray in Java]]></title>
    <link href="http://okckd.github.io/blog/2014/09/26/implement-circular-array-java/"/>
    <updated>2014-09-26T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/26/implement-circular-array-java</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Implement a <strong>CircularArray</strong> class that supports an array-like data structure which can be efficiently rotated.</p>

<p>The class should use a generic type, and should support iteration via the standard for (Object : circuLarArray) notation.</p></blockquote>

<h3>Solution</h3>

<p><strong>First part of the question is solved by using an array and a pointer</strong>. The solution simplifies the question by fixing the array size (not a dynamic-resizing array).</p>

<p><strong>The difficult part is how to write iterator</strong>.</p>

<p>Note that we should support <strong>Java Generics</strong>:</p>

<pre><code>class MyCircularArray&lt;T&gt;
</code></pre>

<p>Implement <strong>Iterable Interface</strong>:</p>

<pre><code>public class MyCircularArray&lt;T&gt; implements Iterable&lt;T&gt; {
}
</code></pre>

<p>Override <strong>iterator() method</strong>:</p>

<pre><code>@Override
public Iterator&lt;T&gt; iterator() {
    return new MyIterator&lt;T&gt;(this);
}
</code></pre>

<p>Write our own <strong>Iterator Class</strong>:</p>

<pre><code>class MyIterator&lt;T&gt; implements Iterator&lt;T&gt; {
}
</code></pre>

<p>Finish it up</p>

<pre><code>public class MyCircularArray&lt;T&gt; implements Iterable&lt;T&gt; {

    @Override
    public Iterator&lt;T&gt; iterator() {
        return new MyIterator&lt;T&gt;(this);
    }

    class MyIterator&lt;T&gt; implements Iterator&lt;T&gt; {
        @Override
        public boolean hasNext() {
        }

        @Override
        public T next() {
        }

        @Override
        public void remove() {
        }
    }
}
</code></pre>

<p>It might be confusing when implementing <strong>Iterable</strong> and <strong>Iterator</strong> Class.</p>

<h3>Code</h3>

<pre><code>public class MyCircularArray&lt;T&gt; implements Iterable&lt;T&gt; {

    T[] items;

    int head;
    int cur;

    public MyCircularArray(int size) {
        // this is really important (casting the type)
        items = (T[]) new Object[size];

        head = 0;
        cur = 0;
    }

    public void put(T item) {
        items[cur++] = item;
        cur = cur % items.length;
    }

    public T get(int i) {
        int newIndex = (i + head) % items.length;
        return items[newIndex];
    }

    public void rotate(int shiftRight) {
        head += shiftRight;
        head = head % items.length;
    }

    @Override
    public Iterator&lt;T&gt; iterator() {
        return new MyIterator&lt;T&gt;(this);
    }

    class MyIterator&lt;T&gt; implements Iterator&lt;T&gt; {

        T[] items;
        int head;
        int count;

        public MyIterator(MyCircularArray&lt;T&gt; array) {
            this.items = array.items;
            this.head = array.head;
            this.count = 0;
        }

        @Override
        public boolean hasNext() {
            return this.count != items.length;
        }

        @Override
        public T next() {
            if (hasNext()) {
                return items[(head + count++) % items.length];
            }
            return null;
        }

        @Override
        public void remove() {
        }
    }

}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 12.0 Example - Troubleshoot Google Chrome]]></title>
    <link href="http://okckd.github.io/blog/2014/09/24/troubleshoot-google-chrome/"/>
    <updated>2014-09-24T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/24/troubleshoot-google-chrome</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>You&#8217;reworking on the Google Chrome team when you receivea bug report: Chrome crashes on launch. What would you do?</p></blockquote>

<h3>Step 1: Understand the Scenario</h3>

<ol>
<li>How long has user seen this issue?</li>
<li>version of browser and OS?</li>
<li>Does this happen consistently? How often, and when?</li>
</ol>


<h3>Step 2: Break Down the Problem</h3>

<p>Flow of situation:</p>

<ol>
<li>start menu</li>
<li>click chrome</li>
<li>browser starts</li>
<li>browser load settings</li>
<li>browser issues HTTP response</li>
<li>browser get HTTP response</li>
<li>browser parses webpage</li>
<li>browser displays content</li>
</ol>


<p><strong>At some points in this process, something fails</strong>. A good tester would iterate thru the elements of this scenario and diagnose the problem.</p>

<h3>Step 3: Create Specific, Manageable Tests</h3>

<p>Come up with realistic instructions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 11.4 Sort 20GB File]]></title>
    <link href="http://okckd.github.io/blog/2014/09/24/sort-20GB-file/"/>
    <updated>2014-09-24T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/24/sort-20GB-file</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Imagine you have a 20 GB file with one string per line.</p>

<p>Explain how you would sort the file.</p></blockquote>

<h3>Solution</h3>

<p>Use <strong>External Sort</strong>.</p>

<ol>
<li><p>First divide the file into chunks which are x megabytes each, where x is the amount of memory we have available.</p></li>
<li><p>Each chunk is sorted separately and then saved back to the file system.</p></li>
<li><p>Once all the chunks are sorted, we then merge the chunks, one by one.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 9.10 Stack Up the Boxes]]></title>
    <link href="http://okckd.github.io/blog/2014/09/17/stack-up-boxes/"/>
    <updated>2014-09-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/17/stack-up-boxes</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>You have a stack of n boxes, with widths w., heights h, and depths d. The boxes can only be stacked on top of one another if each box is strictly larger than the box above it in width, height, and depth.</p>

<p>Implement a method to build the tallest stack possible, where the height of a stack is the sum of the heights of each box.</p></blockquote>

<h3>Solution</h3>

<p>This is appearantly a DP question. I did it in the normal way, and the solution turns out to be very good:</p>

<pre><code>DP solution is        2638ms
Recursive solution is 1322ms
My solution is         370ms
</code></pre>

<p>I could not understand the 2 solutions given in the book. Sorry.</p>

<p>The coding is a bit lengthy, and we keeps 2 DP arrays. <strong>Not an easy question of course</strong>, but the solution is actually standard.</p>

<h3>Code</h3>

<pre><code>public static ArrayList&lt;Box&gt; createStack(Box[] boxes) {
    ArrayList&lt;Box&gt; ans = new ArrayList&lt;Box&gt;();
    int len = boxes.length;
    int[] heights = new int[len];
    int[] preMap = new int[len];
    int maxIndex = 0;

    // start DP
    for (int i = 0; i &lt; len; i++) {
        heights[i] = boxes[i].height;
        preMap[i] = -1;
        for (int j = 0; j &lt; i; j++) {
            if (boxes[j].canBeAbove(boxes[i])) {
                int newHeight = heights[j] + boxes[i].height;
                if (newHeight &gt; heights[i]) {
                    heights[i] = newHeight;
                    preMap[i] = j;
                }
            }
        }
        // now updated maxIndex
        if (heights[i] &gt; heights[maxIndex]) {
            maxIndex = i;
        }
    }

    // print from maxIndex all the way backwards
    while (maxIndex != -1) {
        ans.add(boxes[maxIndex]);
        // the print order is reversed, so...
        maxIndex = preMap[maxIndex];
    }
    return ans;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 9.11 Parenthesize the Expression]]></title>
    <link href="http://okckd.github.io/blog/2014/09/17/parenthesize-expression/"/>
    <updated>2014-09-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/17/parenthesize-expression</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Given a boolean expression consisting of the symbols 0, 1, &lsquo;&amp;&rsquo;, &lsquo;|&rsquo;, and &lsquo;^&rsquo;, and a desired boolean result value &lsquo;result&rsquo;.</p>

<p>Now implement a function to count the number of ways of <strong>parenthesizing the expression</strong> such that it evaluates to &lsquo;result&rsquo;.</p></blockquote>

<h3>Solution</h3>

<p><strong>This is a difficult question</strong>.</p>

<blockquote><p>Each parenthesized expression must have an outermost pair of
parentheses.</p>

<p>That is, we can iterate through the expression, treating each operator as the first operator to be parenthesized.</p></blockquote>

<p>Nice idea suggested in the book! So <strong>for each operator, we consider is as first operator (to evaluate)</strong>, and then we shall if the total possible count.</p>

<p>(Note that while coding, we DO NOT WRITE {if-else if-else&hellip;} but instead use {if&hellip; if&hellip; if&hellip;} in order to get the total count. )</p>

<p>DP is more time-efficient.</p>

<p><strong>Like CC150v5 Q9.10, the code given in the book is very hard to read</strong>. I have my own code posted below.</p>

<h3>Code</h3>

<pre><code>public static int countMyAnswer(String exp, boolean result) {
    if (exp.length() == 1) {
        return convertIntToBool(exp.charAt(0)) == result ? 1 : 0;
    }
    // eg. 1^0|0|1
    // result: true
    int totalCount = 0;
    for (int i = 1; i &lt; exp.length(); i += 2) {

        char op = exp.charAt(i);
        String firstHalf = exp.substring(0, i);
        String secondHalf = exp.substring(i + 1);

        int firstHalfTrue = countMyAnswer(firstHalf, true);
        int firstHalfFalse = countMyAnswer(firstHalf, false);
        int secondHalfTrue = countMyAnswer(secondHalf, true);
        int secondHalfFalse = countMyAnswer(secondHalf, false);

        if (evaluate('0', op, '0') == result) {
            totalCount += firstHalfFalse * secondHalfFalse;
        }
        if (evaluate('0', op, '1') == result) {
            totalCount += firstHalfFalse * secondHalfTrue;
        }
        if (evaluate('1', op, '0') == result) {
            totalCount += firstHalfTrue * secondHalfFalse;
        }
        if (evaluate('1', op, '1') == result) {
            totalCount += firstHalfTrue * secondHalfTrue;
        }
    }
    return totalCount;
}

private static boolean convertIntToBool(char num) {
    if (num == '1') {
        return true;
    } else {
        return false;
    }
}

private static boolean evaluate(char num1, char op, char num2) {
    boolean b1 = convertIntToBool(num1);
    boolean b2 = convertIntToBool(num2);
    if (op == '&amp;') {
        return b1 &amp; b2;
    } else if (op == '|') {
        return b1 | b2;
    } else if (op == '^') {
        return b1 ^ b2;
    }
    System.out.println("Did not found operator " + op);
    return false;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 9.7 Paint Fill in Map]]></title>
    <link href="http://okckd.github.io/blog/2014/09/17/paint-fill-map/"/>
    <updated>2014-09-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/17/paint-fill-map</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Implement the &ldquo;paint fill&rdquo; function that one might see on many image editing programs.</p>

<p>That is, given a screen (represented by a two-dimensional array of colors), a point, and a new color, <strong>fill in the surrounding area</strong> until the color changes from the original color.</p></blockquote>

<h3>Solution</h3>

<p>This is a BFS/DFS question, very similar to <strong>[LeetCode 130] Surrounded Regions</strong>.</p>

<p><strong>However, this question is not same as surrounding region</strong>, because no temporary storage of state is needed, <strong>and we DO NOT NEED TO keep track of the visited positions</strong>!</p>

<p>Why is this?</p>

<ol>
<li>This question, we simple change the color <strong>from A to B</strong>.</li>
<li>Surrounding Region is <strong>change A to B, and B to A</strong>.</li>
</ol>


<p>That&rsquo;s why, the nature of 2 questions are different.</p>

<p>Code 1 is my first solution, and Code 2 is doing a BFS and set color directly to expected value. This type of questions is highly frequent and sometimes may cause confusions.</p>

<h3>Code</h3>

<p><strong>my code 1</strong>, with &lsquo;temp&rsquo; state</p>

<pre><code>public static void PaintFill1(Color[][] screen, int posX, int posY,
        Color ncolor) {
    // the queue keeps the list of positions that I'm going to visit
    Queue&lt;Position&gt; q = new LinkedList&lt;Position&gt;();
    int len = screen.length;
    Color original = screen[posX][posY];
    // visited origin node first
    q.offer(new Position(posX, posY));
    while (!q.isEmpty()) {
        // visit positions in q one by one (mark color as 'Temp')
        Position p = q.poll();
        if (p.x &lt; 0 || p.x &gt;= len || p.y &lt; 0 || p.y &gt;= len) {
            // invalid pos coordinate
            continue;
        } else if (screen[p.x][p.y] == Color.Temp
                || screen[p.x][p.y] != original) {
            continue;
        }
        screen[p.x][p.y] = Color.Temp;
        q.offer(new Position(p.x - 1, p.y));
        q.offer(new Position(p.x + 1, p.y));
        q.offer(new Position(p.x, p.y - 1));
        q.offer(new Position(p.x, p.y + 1));
    }
    // finish visiting all positions that's original color
    for (int i = 0; i &lt; len; i++) {
        for (int j = 0; j &lt; len; j++) {
            if (screen[i][j] == Color.Temp) {
                screen[i][j] = ncolor;
            }
        }
    }
}
</code></pre>

<p><strong>my code 2</strong>, without &lsquo;temp&rsquo; state</p>

<pre><code>public static void PaintFill2(Color[][] screen, int posX, int posY,
        Color ncolor) {
    // the queue keeps the list of positions that I'm going to visit
    Queue&lt;Position&gt; q = new LinkedList&lt;Position&gt;();
    int len = screen.length;
    Color original = screen[posX][posY];
    // visited origin node first
    q.offer(new Position(posX, posY));
    while (!q.isEmpty()) {
        // visit positions in q one by one (mark color as 'Temp')
        Position p = q.poll();
        if (p.x &lt; 0 || p.x &gt;= len || p.y &lt; 0 || p.y &gt;= len) {
            // invalid pos coordinate
            continue;
        } else if (screen[p.x][p.y] != original) {
            continue;
        }
        screen[p.x][p.y] = ncolor;
        q.offer(new Position(p.x - 1, p.y));
        q.offer(new Position(p.x + 1, p.y));
        q.offer(new Position(p.x, p.y - 1));
        q.offer(new Position(p.x, p.y + 1));
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 9.3 Find Magic Index]]></title>
    <link href="http://okckd.github.io/blog/2014/09/17/find-magic-index/"/>
    <updated>2014-09-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/17/find-magic-index</id>
    <content type="html"><![CDATA[<h3>Question 1</h3>

<blockquote><p>A magic index in an array A[l.. .n-l] is defined to be an index such that A[i] = i.</p>

<p>Given a sorted array of distinct integers, write a method to find a magic index, if one exists, in array A.</p></blockquote>

<h3>Question 2</h3>

<blockquote><p>FOLLOW UP: What if the values are not distinct?</p></blockquote>

<h3>Solution</h3>

<p><strong>This is a difficult binary search question</strong>!</p>

<p><strong>Question 1 is slightly easier</strong>: we simplyl use binary search, and we are able to discard half of the array each time.</p>

<ol>
<li>if (array[mid] > mid), then we discard the right half.</li>
<li>if (array[mid] &lt; mid), then we discard the left half.</li>
</ol>


<p><strong>Question 2 is difficult</strong>. We cannot discard half of the input any more. Instead, we discard a range between (mid) and (array[mid]). Then check left and right part seperately.</p>

<p>So, I wrote the following code:</p>

<pre><code>int mid = left + (right - left) / 2;
if (array[mid] == mid) {
    return mid;
} else {
    int smaller = Math.min(array[mid], mid);
    int larger = Math.max(array[mid], mid);
    int leftResult = helper(array, left, smaller);
    if (leftResult != -1) {
        return leftResult;
    } else {
        return helper(array, larger, right);
    }
}
</code></pre>

<p>This becomes an endless loop. We did not discard point &lsquo;mid&rsquo; in the code above. The correct code is posted below.</p>

<h3>Code</h3>

<p><strong>code for non-duplicate input</strong></p>

<pre><code>public static int myAnswerNonDup(int[] array) {
    int len = array.length;
    return helper(array, 0, len - 1);
}

public static int helper(int[] array, int left, int right) {
    if (right &lt; left) {
        return -1;
    }
    int mid = left + (right - left) / 2;
    if (array[mid] == mid) {
        return mid;
    } else if (array[mid] &lt; mid) {
        // discard all element to the left of array[mid]
        return helper(array, mid + 1, right);
    } else {
        return helper(array, left, mid - 1);
    }
}
</code></pre>

<p><strong>code for have-duplicate input</strong></p>

<pre><code>public static int myAnswerWithDup(int[] array) {
    int len = array.length;
    return helper(array, 0, len - 1);
}

public static int helper(int[] array, int left, int right) {
    if (right &lt; left) {
        return -1;
    }
    int mid = left + (right - left) / 2;
    if (array[mid] == mid) {
        return mid;
    } else {
        int smaller = 0;
        int larger = 0;
        if (array[mid] &lt; mid) {
            smaller = array[mid];
            larger = mid + 1;
        } else if (array[mid] &gt; mid) {
            smaller = mid - 1;
            larger = array[mid];
        }
        int leftResult = helper(array, left, smaller);
        if (leftResult != -1) {
            return leftResult;
        } else {
            return helper(array, larger, right);
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 5.6 Swap Odd and Even Bits]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/swap-odd-even-bits/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/swap-odd-even-bits</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Write a program to swap odd and even bits in an integer with as few instructions as possible (e.g., bit 0 and bit 1 are swapped, bit 2 and bit 3 are swapped, and so on).</p></blockquote>

<h3>Solution</h3>

<p>Mask odd and even bits seperately.</p>

<h3>Code</h3>

<pre><code>public static int swapOddEvenBits(int x) {
    return (((x &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((x &amp; 0x55555555) &lt;&lt; 1));
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Guess Password]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/google-guess-password/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/google-guess-password</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.mitbbs.com/article_t/JobHunting/32658281.html">link</a></p>

<blockquote><p>给你一个password 假定6位</p>

<p>有个function, 每call一次就给你一个triplet 是password 里的随即三位(order不变)。比如google, 可能返回: ggl, goe, oog, ool&hellip;</p>

<p>问如何最有效破译这个密码?</p></blockquote>

<h3>Solution</h3>

<p>This is just a rough idea suggested by Level 6 from the post.</p>

<blockquote><p>六位密码随机给三位，应该有C(6, 3) = 20个bucket。</p>

<p>如果密码是abcdef，那么以a开头的bucket应该是10个。以b开头的buckt应该是6个，以c开头的是3个，以d开头的是1个。</p>

<p>如果abcd中间有相同，那么就会出现以a开头的是11个（abca)，13个(abad)，14个(abaa)，16个(aacd)，17个(aaca),19个(aaad)或者20个(aaaa).</p></blockquote>

<p>So we generate many triplets, and calculate based on their frequencies.</p>

<h3>Code</h3>

<p><strong>not written</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 5.5 Calculate Bits Conversion Required]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/calculate-bits-convertions/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/calculate-bits-convertions</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Write a function to determine the number of bits (change) required to convert integer A to integer B.</p></blockquote>

<h3>Solution</h3>

<p>The only thing to know is <strong>how to count the number of &lsquo;1&rsquo;s in a integer</strong>. It&rsquo;s like this:</p>

<blockquote><p>c = c &amp; (c &ndash; l) clears the least significant bit of &lsquo;1&rsquo;.</p>

<p>Keep doing this until all &lsquo;1&rsquo;s are cleared.</p></blockquote>

<h3>Code</h3>

<p><strong>code 1</strong></p>

<pre><code>public static int calcBitsSwapMe1(int a, int b) {
    int num = a ^ b;
    int count = 0;
    while (num != 0) {
        count += num &amp; 1;
        num = num &gt;&gt;&gt; 1;
    }
    return count;
}
</code></pre>

<p><strong>code 2</strong></p>

<pre><code>public static int calcBitsSwapMe2(int a, int b) {
    int num = a ^ b;
    int count = 0;
    while (num != 0) {
        num = num &amp; (num - 1);
        count++;
    }
    return count;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Brain Teaser] 6.1 Bottles of Pills]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/bottles-of-spills/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/bottles-of-spills</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>You have 20 bottles of pills. 19 bottles have 1.0 gram pills, but one has pills of weight 1.1 grams.</p>

<p>Given a scale, how to find the heavy bottle <strong>only scaling ONCE</strong>?</p></blockquote>

<h3>Solution</h3>

<p>Take 1 pill from Bottle 1, 2 pills from Bottle 2, and so on. We&rsquo;ll expect (1 + 2 + &hellip; + 20) = 210 gram of pills.</p>

<p>The answer would be {(weight &ndash; 210 grams) / 0.1}.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 5.1 Binary Merge 2 Numbers]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/binary-merge-two-numbers/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/binary-merge-two-numbers</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>You are given two 32-bit numbers, N andM, and two bit positions, i and j. Write a method to insert M into Nsuch that M starts at bit j and ends at bit i. You can assume that the bits j through i have enough space to fit all ofM. That is, ifM= 10011, you can assume that there are at least 5 bits between j and i. You would not, for example, have j-3 and i=2, because M could not fully fit between bit 3 and bit 2.</p>

<p>EXAMPLE:</p>

<p>Input: N = 16000000000, M = 10011, i = 2, j = 6</p>

<p>Output: N = 10001001100</p></blockquote>

<h3>Solution</h3>

<p><strong>This is a basic bit manipulation question</strong>. The key is to use binary maks. Two things to note:</p>

<ol>
<li><p>The &lsquo;~&rsquo; means negate. So (~0) is a sequence of 1 (the value equals to -1).</p></li>
<li><p>When shifting bits, <strong>DO NOT USE &lsquo;>>&rsquo; because it&rsquo;s signed shift</strong>. Instead, <strong>use &lsquo;>>>&rsquo; (unsigned right shift operator)</strong>.</p></li>
</ol>


<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public static int myAnswer(int n, int m, int i, int j) {
    int rr = (~0 &gt;&gt;&gt; (31 - j));
    int ll = (~0 &lt;&lt; i);
    // printBinary(rr);
    // printBinary(ll);

    int middleMask = ll &amp; rr;
    int twoEndMask = ll ^ rr;

    n = n &amp; twoEndMask;
    m = (m &lt;&lt; i) &amp; middleMask;

    return n | m;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 3.7 Stack of Animals]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/stack-of-animals/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/15/stack-of-animals</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>An animal shelter holds only dogs and cats. People must adopt either the &ldquo;oldest&rdquo; animals, or they can select whether they would prefer a dog or a cat (and will receive the oldest animal of that type). They cannot select which specific animal they would like.</p>

<p>Create the data structures to maintain this system and implement operations such as enqueue, dequeueAny, dequeueDog and dequeueCat. You may use the built-in LinkedList data structure.</p></blockquote>

<h3>Solution</h3>

<p>There are 2 solutions.</p>

<p><strong>First one is using a single queue</strong>. This makes &lsquo;dequeueAny&rsquo; easy, but &lsquo;dequeueCat&rsquo; and &lsquo;dequeueDog&rsquo; difficult.</p>

<p><strong>Second approach would be using 2 queues for dogs and cats</strong>. We need something like timestamp to be stored (more space usage).</p>

<p>When we return, we peek both queues are choose the older one. <strong>This is recommended solution in the book</strong>.</p>

<h3>Code</h3>

<p><strong>from the book</strong></p>

<p>Animal.java</p>

<pre><code>public abstract class Animal {
    int order;
    String name;

    public Animal(String n) {
        name = n;
    }

    public abstract String name();

    public boolean isOlderThan(Animal a) {
        return this.order &lt; a.order;
    }
}

class Cat extends Animal {
    public Cat(String n) {
        super(n);
    }

    public String name() {
        return "Cat: " + name;
    }
}

class Dog extends Animal {
    public Dog(String n) {
        super(n);
    }

    public String name() {
        return "Dog: " + name;
    }
}
</code></pre>

<p>AnimalQueue.java</p>

<pre><code>public class AnimalQueue {
    LinkedList&lt;Dog&gt; dogs = new LinkedList&lt;Dog&gt;();
    LinkedList&lt;Cat&gt; cats = new LinkedList&lt;Cat&gt;();
    private int order = 0;

    public void enqueue(Animal a) {
        a.order = order;
        order++;
        if (a instanceof Dog) {
            dogs.addLast((Dog) a);
        } else if (a instanceof Cat) {
            cats.addLast((Cat) a);
        }
    }

    public Animal dequeueAny() {
        if (dogs.size() == 0) {
            return dequeueCats();
        } else if (cats.size() == 0) {
            return dequeueDogs();
        }
        Dog dog = dogs.peek();
        Cat cat = cats.peek();
        if (dog.isOlderThan(cat)) {
            return dogs.poll();
        } else {
            return cats.poll();
        }
    }

    public Animal peek() {
        if (dogs.size() == 0) {
            return cats.peek();
        } else if (cats.size() == 0) {
            return dogs.peek();
        }
        Dog dog = dogs.peek();
        Cat cat = cats.peek();
        if (dog.isOlderThan(cat)) {
            return dog;
        } else {
            return cat;
        }
    }

    public int size() {
        return dogs.size() + cats.size();
    }

    public Dog dequeueDogs() {
        return dogs.poll();
    }

    public Dog peekDogs() {
        return dogs.peek();
    }

    public Cat dequeueCats() {
        return cats.poll();
    }

    public Cat peekCats() {
        return cats.peek();
    }
}
</code></pre>
]]></content>
  </entry>
  
</feed>
