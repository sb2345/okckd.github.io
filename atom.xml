<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Woodstock Blog]]></title>
  <link href="http://okckd.github.io/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-15T14:26:55+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 3.7 Stack of Animals]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/stack-of-animals/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/15/stack-of-animals</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>An animal shelter holds only dogs and cats. People must adopt either the &ldquo;oldest&rdquo; animals, or they can select whether they would prefer a dog or a cat (and will receive the oldest animal of that type). They cannot select which specific animal they would like.</p>

<p>Create the data structures to maintain this system and implement operations such as enqueue, dequeueAny, dequeueDog and dequeueCat. You may use the built-in LinkedList data structure.</p></blockquote>

<h3>Solution</h3>

<p>There are 2 solutions.</p>

<p><strong>First one is using a single queue</strong>. This makes &lsquo;dequeueAny&rsquo; easy, but &lsquo;dequeueCat&rsquo; and &lsquo;dequeueDog&rsquo; difficult.</p>

<p><strong>Second approach would be using 2 queues for dogs and cats</strong>. We need something like timestamp to be stored (more space usage).</p>

<p>When we return, we peek both queues are choose the older one. <strong>This is recommended solution in the book</strong>.</p>

<h3>Code</h3>

<p><strong>not written</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 3.2 Stack Min Value]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/stack-get-min-value/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/15/stack-get-min-value</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>How would you design a stack which, in addition to push and pop, also has a function min which returns the minimum element?</p>

<p>Push, pop and min should all operate in 0(1) time.</p></blockquote>

<h3>Solution</h3>

<p>This is <strong>a very tricky question</strong>.</p>

<p>The key is how to use the minimum space to achieve O(1) query min operation. The trick is to count how many times the same min-value occur. Eg.</p>

<blockquote><p>input: 5,3,3,1,1,2,2,2,2,2,2,2.</p>

<p>stack: 5,3,3,1,1.</p></blockquote>

<p>So we can pop &lsquo;1&rsquo; twice, pop &lsquo;3&rsquo; twice, and pop &lsquo;5&rsquo; once. Read the code!</p>

<h3>Code</h3>

<pre><code>public class StackMyAnswer extends Stack&lt;Integer&gt; {

    Stack&lt;Integer&gt; min = new Stack&lt;Integer&gt;();

    public void push(int value) {
        if (min.isEmpty() || value &lt;= min.peek()) {
            min.push(value);
        }
        super.push(value);
    }

    public Integer pop() {
        int val = super.pop();
        if (!min.isEmpty() &amp;&amp; val == min.peek()) {
            min.pop();
        }
        return val;
    }

    public int min() {
        if (min.isEmpty()) {
            return Integer.MAX_VALUE;
        }
        return min.peek();
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 2.7 Linked List Palindrome]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/linked-list-palindrome/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/15/linked-list-palindrome</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Implement a function to check if a linked list is a palindrome.</p></blockquote>

<h3>Solution</h3>

<p>There are multiple solutions for this question.</p>

<p><strong>First, maybe the simplest solution of all</strong>, is to compare the list with the reversed list (compare first half would be enough). This is a very nice idea.</p>

<p><strong>Second solution is iterative approach</strong>. My code below is to first get the total length, then <strong>use a Stack</strong>. Alternatively, we can also use <strong>fast/slow pointer</strong> to find the mid point. This solution is easiest to write.</p>

<p><strong>Third solution is recursive</strong>. We basically uses a public pointer to:</p>

<ol>
<li>get starting value</li>
<li>check middle parts</li>
<li>get ending value</li>
<li>if starting == ending and middle part is valid, then true.</li>
</ol>


<p>This code is not easy to write, and hard to think.</p>

<p>It&rsquo;s best to know both iterative and recursive solution.</p>

<h3>Code</h3>

<p>Iterative</p>

<pre><code>public static boolean isPalindrome1(LinkedListNode head) {
    int len = getListLength(head);
    int half = len / 2;
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    for (int i = 0; i &lt; half; i++) {
        stack.push(head.data);
        head = head.next;
    }
    if (len % 2 == 1) {
        head = head.next;
    }
    for (int i = 0; i &lt; half; i++) {
        if (head.data != stack.pop()) {
            return false;
        }
        head = head.next;
    }
    return true;
}
</code></pre>

<p>Recursive</p>

<pre><code>private static LinkedListNode p;

public static boolean isPalindrome2(LinkedListNode head) {
    p = head;
    int len = getListLength(head);
    return helper2(0, len - 1);
}

public static boolean helper2(int from, int to) {
    if (from &gt; to) {
        return true;
    } else if (from == to) {
        p = p.next;
        return true;
    } else {
        // first get fromVal, then check middlep part, last, get toVal
        int fromVal = p.data;
        p = p.next;
        if (!helper2(from + 1, to - 1)) {
            return false;
        }
        int toVal = p.data;
        p = p.next;
        if (fromVal != toVal) {
            return false;
        }
    }
    return true;
}
</code></pre>

<p>Shared method:</p>

<pre><code>private static int getListLength(LinkedListNode node) {
    int count = 0;
    while (node != null) {
        count++;
        node = node.next;
    }
    return count;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] Chap 3 Example - Implement Stack]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/implement-stack/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/15/implement-stack</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Implement a stack.</p></blockquote>

<h3>Solution</h3>

<p><strong>Stack uses LinkedNode to implement</strong>.</p>

<h3>Code</h3>

<pre><code>public class MyStack {

    Node top;

    public int pop() {
        if (top == null) {
            return -1;
        }
        int returnVal = top.val;
        top = top.next;
        return returnVal;
    }

    public int peek() {
        if (top == null) {
            return -1;
        }
        return top.val;

    }

    public void push(int val) {
        Node newNode = new Node(val);
        newNode.next = top;
        top = newNode;
    }

    class Node {

        int val;
        Node next;

        Node(int value) {
            val = value;
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 2.]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote></blockquote>

<h3>Solution</h3>

<h3>Code</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 2.2 Kth Last Element (Recursive)]]></title>
    <link href="http://okckd.github.io/blog/2014/09/14/kth-last-element-recursive/"/>
    <updated>2014-09-14T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/14/kth-last-element-recursive</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Implement an algorithm to find the kth to last element of a singly linked list.</p>

<p>Do it recursively.</p></blockquote>

<h3>Solution</h3>

<p>Iterative solution is easy, <strong>recursive is not</strong>.</p>

<h3>Code</h3>

<pre><code>private static int myAns = -1;

public static int nthToLastMe(LinkedListNode head, int n) {
    if (head == null) {
        return 0;
    } else if (nthToLastMe(head.next, n) &lt; n - 1) {
        return nthToLastMe(head.next, n) + 1;
    } else if (nthToLastMe(head.next, n) == n - 1) {
        myAns = head.data;
        return Integer.MAX_VALUE;
    }
    return Integer.MAX_VALUE;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] DNS Communication Protocol]]></title>
    <link href="http://okckd.github.io/blog/2014/09/12/DNS-communication-protocol/"/>
    <updated>2014-09-12T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/12/DNS-communication-protocol</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>What protocol is used for communicating with a DNS?</p></blockquote>

<h3>Answer</h3>

<p><a href="http://en.wikipedia.org/wiki/Domain_Name_System">Domain Name System</a> (DNS) is a hierarchical distributed naming system for computers, services, or any resource connected to the Internet or a private network. It associates various information with domain names assigned to each of the participating entities. Most prominently, it translates easily memorized domain names to the numerical IP addresses needed for the purpose of locating computer services and devices worldwide. The Domain Name System is an essential component of the functionality of the Internet.</p>

<p><a href="http://en.wikipedia.org/wiki/Domain_Name_System#Protocol_transport">DNS primarily uses</a> <strong>User Datagram Protocol (UDP)</strong> on port number 53 to serve requests.</p>

<p>DNS queries consist of a single UDP request from the client followed by a single UDP reply from the server.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Celebrity Problem]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/celebrity-problem/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/celebrity-problem</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=13167666">link</a></p>

<blockquote><p>You have a room with n people. A celebrity walks in. Everyone knows the celebrity, the celebrity knows no one.</p>

<p>Non-celebrities may/may not know anyone in the room.</p>

<p>Give an algorithm to find the celebrity. Discuss the complexity.</p></blockquote>

<h3>Solution</h3>

<p><a href="http://www.geeksforgeeks.org/the-celebrity-problem/">Classic brute-force solution</a> would take O(n<sup>2</sup>) time to build a map. That&rsquo;s not good, and we have a very simple solution that works in O(n) time:</p>

<blockquote><p>Make all of them stand in a row. Let&rsquo;s say the people are a,b,c,d,e,f,g,h,i,j,&hellip;&hellip;.n</p>

<p>Compare a and b. <strong>If a knows b</strong>, a is not celebrity. <strong>If a doesn&rsquo;t know b</strong>, b is not celebrity.</p>

<p>At the end, the probable celebrity who survives is the certain celebrity. (better do a check)</p></blockquote>

<p>Total number of comparison is <a href="http://www.geeksforgeeks.org/the-celebrity-problem/">3(N-1) times</a>.</p>

<h3>Code</h3>

<p><strong>not written</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Barrier, Goods Van and Distance]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/barrier-goods-van-and-distance/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/barrier-goods-van-and-distance</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.mitbbs.com/article_t1/JobHunting/32631467_0_1.html">link</a></p>

<blockquote><p>2d array ＊代表障碍物 ＃代表货物 空白就是正常的路</p>

<p>问如何找到一个点为出发点 能实现总共取货路径最短？ 每次只能拿一个货物，遇到障碍需要绕开，拿到以后要放回出发点，然后再取另一个.</p></blockquote>

<pre><code>＊＊＊＊＊＊＊＊＊＊
＊  #           ＊
＊  ＊＊＊  ＊   ＊
＊              ＊
＊     ＊＊   ＊ ＊
＊  #    # # ＊＊＊
＊＊＊＊＊＊＊＊＊＊
</code></pre>

<h3>Solution</h3>

<p>This looks like a very difficult question, especially during a phone interview.</p>

<p><strong>The 10th floor gives the best solution</strong>:</p>

<blockquote><p><strong>BFS from every box</strong>. in each box, a non-blocking cell (include box position, but exclude hazard position) will have a weight value, stand for the distance to the box.</p>

<p>after bfs from all the boxes, each cell will have k weight, k is the number of boxes. sum all the weight in each cell, and find the cell with smallest sum of weight.</p>

<p>One problem of this solution may lead to a cell of a box. We can then sort the cell by sum of weight and find the first position that is not a box.</p>

<p>complexity O(k*n<sup>2</sup>)</p></blockquote>

<h3>Code</h3>

<p><strong>not written</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Arithmetic Progression Triplet]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/arithmetic-progression-triplet/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/arithmetic-progression-triplet</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/">link</a></p>

<blockquote><p>Given a sorted set, find if there exist three elements in Arithmetic Progression or not.</p></blockquote>

<h3>Solution</h3>

<p><strong>This is a rather simple Arithmetic Progression question</strong>.</p>

<blockquote><p><a href="http://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/">To find the three elements</a>, we first fix an element as middle element and search for other two (one smaller and one greater).</p></blockquote>

<p>O(n<sup>2</sup>) time.</p>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public boolean longest(int[] A) {
    int len = A.length;
    for (int i = 1; i &lt; len - 1; i++) {
        int left = i - 1;
        int right = i + 1;
        while (left &gt;= 0 &amp;&amp; right &lt; len) {
            int total = A[left] + A[right];
            if (total &gt; 2 * A[i]) {
                left--;
            } else if (total &lt; 2 * A[i]) {
                right++;
            } else {
                return true;
            }
        }
    }
    return false;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Arithmetic Progression Longest]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/arithmetic-progression-longest/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/arithmetic-progression-longest</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=8211177">link</a></p>

<blockquote><p>Given an array of integers A, give an algorithm to find the longest Arithmetic progression in it, i.e find a sequence i1 &lt; i2 &lt; … &lt; ik, such that</p>

<p>A[i1], A[i2], …, A[ik] forms an arithmetic progression, and k is the largest possible.</p>

<p>The sequence S1, S2, …, Sk is called an arithmetic progression if S(j+1) – S(j) is a constant.</p></blockquote>

<h3>Solution</h3>

<p><strong>This is a rather difficult Arithmetic Progression question</strong>.</p>

<p>The solution is 2-D DP.</p>

<blockquote><p><a href="http://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/">The idea is</a> to create a 2D table dp[n][n]. An entry dp[i][j] in this table stores LLAP with input[i] and input[j] as first two elements of AP(j > i).</p>

<p>The last column of the table is always 2. Rest of the table is filled <strong>from bottom right to top left</strong>.</p>

<p>To fill rest of the table, j (second element in AP) is first fixed. i and k are searched for a fixed j. If i and k are found such that i, j, k form an AP, then <strong>the value of dp[i][j] is set as dp[j][k] + 1</strong>.</p>

<p><strong>Note that the value of dp[j][k] must have been filled</strong> before as the loop traverses from right to left columns.</p></blockquote>

<p>The 2 difficult points of this question:</p>

<ol>
<li>how to come up with the transation formula. (i.e. <strong>dp[i][j] = dp[j][k] + 1</strong>, when (i, j, k) forms a AP).</li>
<li>how to fill up all dp[i][j] in each loop of j. (Once inside the if-else, once outside the main while-loop)</li>
</ol>


<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public int longest(int[] A) {
    int len = A.length;
    int[][] dp = new int[len][len];
    for (int i = 0; i &lt; len; i++) {
        // the pair ending at last position is always a progression
        dp[i][len - 1] = 2;
    }
    int longest = 1;
    for (int j = len - 2; j &gt;= 0; j--) {
        // for each j, find i and k that makes 1 progression
        int i = j - 1;
        int k = j + 1;
        while (i &gt;= 0 &amp;&amp; k &lt; len) {
            int total = A[i] + A[k];
            if (total &gt; 2 * A[j]) {
                // this is important!
                dp[i][j] = 2;
                i--;
            } else if (total &lt; 2 * A[j]) {
                k++;
            } else {
                // found a valid progression triplet A(i, j, k)
                dp[i][j] = dp[j][k] + 1;
                longest = Math.max(longest, dp[i][j]);
                i--;
                k++;
            }
        }
        // this is important!
        while (i &gt;= 0) {
            dp[i][j] = 2;
            i--;
            // If the loop was stopped due to k becoming more than
            // n-1, set the remaining dp[i][j] as 2
        }
    }
    return longest;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 20.6 Top Million From Billion]]></title>
    <link href="http://okckd.github.io/blog/2014/09/10/top-million-from-billion/"/>
    <updated>2014-09-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/10/top-million-from-billion</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Describe an algorithm to find the largest 1 million numbers in 1 billion numbers.</p>

<p>Assume that the computer memory can hold all one billion numbers.</p></blockquote>

<h3>Solution</h3>

<p>There&rsquo;re enough discussion on <strong>Top K problems</strong> so far in this blog. The suggest solutions is:</p>

<ol>
<li><p>Sort</p></li>
<li><p>Min Heap, O(n logm) time.</p></li>
<li><p>Quick select algorithm. O(n) time.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 20.12 Sub-matrix With Largest Sum]]></title>
    <link href="http://okckd.github.io/blog/2014/09/10/submatrix-with-largest-sum/"/>
    <updated>2014-09-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/10/submatrix-with-largest-sum</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Given an NxN matrix of positive and negative integers, write code to find the sub-matrix with the largest possible sum.</p></blockquote>

<h3>Solution</h3>

<p>I wrote about this question before: <strong>[Question] Max Sum In A 2D Array (sub-matrix)</strong>, and the solution gave a better time complexity (O(n<sup>3</sup>)) than in the book (O(n<sup>4</sup>)).</p>

<ol>
<li>locate a row &ndash; O(n)</li>
<li>locate another row &ndash; O(n)</li>
<li>compute sub value of that column &ndash; O(n), and then find largest subarray in array &ndash; also O(n)</li>
<li>The above 3 steps each take O(n) time, total time is O(n<sup>3</sup>).</li>
</ol>


<p>Please refer to the other post for more detail.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 20.3 Generate M Int From Array of Size N]]></title>
    <link href="http://okckd.github.io/blog/2014/09/10/generate-m-from-array-of-n/"/>
    <updated>2014-09-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/10/generate-m-from-array-of-n</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Write a method to randomly generate a set of m integers from an array of size n. Each element must have equal probability of being chosen.</p></blockquote>

<h3>Solution</h3>

<p>This is very similar to another post I wrote: <strong>[Question] Shuffle An Array (Fisher–Yates)</strong>.</p>

<p>The basic idea is to choose element one by one using RNG. After choosing an int, swap it to top and <strong>then mark this element as &lsquo;dead&rsquo;</strong>. Next time, the RNG will not touch on the &lsquo;dead&rsquo; elements.</p>

<p><strong>Very similar to Fisher–Yates Shuffle</strong>, and the code below is written by me.</p>

<h3>Code</h3>

<pre><code>public static int[] pickMRandomly(int[] original, int m) {
    int[] ans = new int[m];
    for (int i = 0; i &lt; m; i++) {
        int rand = Question.listRand.get(i);
        // note: rand is RN in the range [i, max]
        ans[i] = original[rand];
        original[rand] = original[i];
        // now (i)th position in original is dead
        // no one cares what value is at original[i]
    }
    return ans;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 20.8 Full Text Search]]></title>
    <link href="http://okckd.github.io/blog/2014/09/10/full-text-search/"/>
    <updated>2014-09-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/10/full-text-search</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Given a string s and an array of smaller strings T, design a method to search s for each small string in T.</p></blockquote>

<h3>Solution</h3>

<p><strong>This is a very classic questio of string</strong>, especially favored by Google.</p>

<p>The solution is <strong>suffix tree</strong>. For example, using &ldquo;bibs&rdquo; to build a suffix tree like this:</p>

<p><img class="middle" src="http://okckd.github.io/assets/images/suffix-tree-example-bibs.png"></p>

<p>The building of suffix tree and searching is not a very lengthy code. It&rsquo;s posted below and it&rsquo;s not written by me.</p>

<h3>Code</h3>

<p>Main method:</p>

<pre><code>public static void main(String[] args) {
    String testString = "mississippi";
    String[] stringList = { "is", "sip", "hi", "sis" };
    SuffixTree tree = new SuffixTree(testString);
    for (String s : stringList) {
        ArrayList&lt;Integer&gt; list = tree.getIndexes(s);
        if (list != null) {
            System.out.println(s + ": " + list.toString());
        } else {
            System.out.println(s + ": does not exist.");
        }
    }
}
</code></pre>

<p>SuffixTree.java</p>

<pre><code>public class SuffixTree {
    SuffixTreeNode root = new SuffixTreeNode();

    public SuffixTree(String s) {
        // create a suffix tree with input string s
        for (int i = 0; i &lt; s.length(); i++) {
            String suffix = s.substring(i);
            root.insertString(suffix, i);
        }
    }

    public ArrayList&lt;Integer&gt; getIndexes(String s) {
        return root.getIndexes(s);
    }
}
</code></pre>

<p>SuffixTreeNode.java</p>

<pre><code>public class SuffixTreeNode {

    char value;
    HashMap&lt;Character, SuffixTreeNode&gt; children;
    ArrayList&lt;Integer&gt; indexes = new ArrayList&lt;Integer&gt;();

    public SuffixTreeNode() {
        children = new HashMap&lt;Character, SuffixTreeNode&gt;();
    }

    public void insertString(String s, int index) {
        indexes.add(index);
        if (s != null &amp;&amp; s.length() &gt; 0) {
            value = s.charAt(0);
            SuffixTreeNode child = null;
            if (children.containsKey(value)) {
                child = children.get(value);
            } else {
                child = new SuffixTreeNode();
                children.put(value, child);
            }
            String remainder = s.substring(1);
            child.insertString(remainder, index);
        }
    }

    public ArrayList&lt;Integer&gt; getIndexes(String s) {
        if (s == null || s.length() == 0) {
            return indexes;
        } else {
            char first = s.charAt(0);
            if (children.containsKey(first)) {
                String remainder = s.substring(1);
                return children.get(first).getIndexes(remainder);
            }
        }
        return null;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 20.11 Find Subsquare With Black Border]]></title>
    <link href="http://okckd.github.io/blog/2014/09/10/find-subsquare-with-black-border/"/>
    <updated>2014-09-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/10/find-subsquare-with-black-border</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Imagine you have a square matrix, where each cell is filled with either black or white.</p>

<p>Design an algorithm to find the maximum subsquare such that all four borders are filled with black pixels.</p></blockquote>

<h3>Solution</h3>

<p>There is no better way to solve this except Brute Force. First find a point (as the top-left corner), and then test square size from large to small.</p>

<p>The code below is from the book.</p>

<h3>Code</h3>

<pre><code>public static Subsquare findMaxSquareInMatrix(int[][] matrix) {
    assert (matrix.length &gt; 0);
    for (int row = 0; row &lt; matrix.length; row++) {
        assert (matrix[row].length == matrix.length);
    }

    int N = matrix.length;
    int currentMaxSize = 0;
    Subsquare sq = null;
    int col = 0;

    // Iterate through each column from left to right
    while (N - col &gt; currentMaxSize) { // See step 4 above
        for (int row = 0; row &lt; matrix.length; row++) {
            // starting from the biggest
            int size = N - Math.max(row, col);
            while (size &gt; currentMaxSize) {
                if (checkSquareBorders(matrix, row, col, size)) {
                    currentMaxSize = size;
                    sq = new Subsquare(row, col, size);
                    break; // go to next (full) column
                }
                size--;
            }
        }
        col++;
    }
    return sq;
}

private static boolean checkSquareBorders(int[][] matrix, int row, int col,
        int size) {
    // Check top and bottom border.
    for (int j = 0; j &lt; size; j++) {
        if (matrix[row][col + j] == 1) {
            return false;
        }
        if (matrix[row + size - 1][col + j] == 1) {
            return false;
        }
    }

    // Check left and right border.
    for (int i = 1; i &lt; size - 1; i++) {
        if (matrix[row + i][col] == 1) {
            return false;
        }
        if (matrix[row + i][col + size - 1] == 1) {
            return false;
        }
    }
    return true;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 20.4 Count 2s in Digits]]></title>
    <link href="http://okckd.github.io/blog/2014/09/10/count-2s-in-digits/"/>
    <updated>2014-09-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/10/count-2s-in-digits</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Write a method to count the number of 2s between 0 and n.</p></blockquote>

<h3>Solution</h3>

<p><strong>This is a difficult question</strong>, especially hard to come up with the correct formula. Eg.</p>

<blockquote><p>f(279) = {(79 + 1) + 2 * f(99)} + f(79)</p>

<p>f(513) = {100 + 5 * f(99)} + f(13)</p></blockquote>

<p>Take 513 as example, the first digit is 5. We know that all the 200+ is within the range, so <strong>there&rsquo;re 100 twos in the first digit</strong>. Then, for the rest of the digits, we get f(99) for number between 0 and 99, and another f(99) for number between 100 and 199&hellip; and <strong>this happens 5 times until 499</strong>. That&rsquo;s why we have 5 multiple by f(99).</p>

<p>In the end, we do the calculation <strong>recursively for reminder number 13</strong>.</p>

<h3>Code</h3>

<pre><code>public static int myAnswer(int n) {
    if (n == 0)
        return 0;
    int power = 1;
    while (power * 10 &lt;= n) {
        power *= 10;
    }

    int first = n / power;
    int reminder = n % power;
    int firstDigit2count = 0;
    if (first &gt; 2) {
        firstDigit2count = power;
    } else if (first == 2) {
        firstDigit2count = reminder + 1;
    }
    int totalCountBeforeReminder = firstDigit2count
            + (first * myAnswer(power - 1));
    return totalCountBeforeReminder + myAnswer(reminder);
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 19.4 Get Max Number Without Comparator]]></title>
    <link href="http://okckd.github.io/blog/2014/09/09/get-max-without-comparator/"/>
    <updated>2014-09-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/09/get-max-without-comparator</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Write a method which finds the maximum of two numbers. You should not use if-else or any other comparison operator.</p>

<p>EXAMPLE</p>

<p>Input: 5, 10</p>

<p>Output: 10</p></blockquote>

<h3>Solution</h3>

<p>We can&rsquo;t use >, &lt; or if-else statement, but we can use mathematical operator like subtract and bit operators.</p>

<p>Calculate (a-b) and do (a + K(a-b)) can help us (where K is either 0 or -1).</p>

<h3>Code</h3>

<pre><code>public static int getMax(int a, int b) {
    int c = a - b;
    int signBit = c &gt;&gt; 31 &amp; 1;
    // if (a-b) is negative, sign = 1
    // otherwise, sign = 0
    return a - signBit * c;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 19.6 Convert Integer to English]]></title>
    <link href="http://okckd.github.io/blog/2014/09/09/convert-int-to-english/"/>
    <updated>2014-09-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/09/convert-int-to-english</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<blockquote><p>Given an integer between 0 and 999,999, print an English phrase that describes the integer (eg, “One Thousand, Two Hundred Thirty Four”).</p></blockquote>

<h3>Solution</h3>

<p>The solution in book isn&rsquo;t good, so I wrote the code myself.</p>

<p>Read it below.</p>

<h3>Code</h3>

<pre><code>private static String[] arr1 = { "Zero ", "One ", "Two ", "Three ",
        "Four ", "Five ", "Six ", "Seven ", "Eight ", "Nine " };

private static String[] arr11 = { "Ten ", "Eleven ", "Twelve ",
        "Thirteen ", "Fourteen ", "Fifteen ", "Sixteen ", "Seventeen ",
        "Eighteen ", "Nineteen " };

private static String[] arr10 = { "", "Ten ", "Twenty ", "Thirty ",
        "Forty ", "Fifty ", "Sixty ", "Seventy ", "Eighty ", "Ninety " };

public static String numtostring(int num) {
    int part1 = num / 1000;
    int part2 = num % 1000;
    if (part1 == 0) {
        return numBelowTrousand(part2);
    } else {
        return numBelowTrousand(part1) + "Thousand, "
                + numBelowTrousand(part2);
    }
}

public static String numBelowTrousand(int num) {
    StringBuilder sb = new StringBuilder();
    // assume num is below 1000

    // first, convert hundred digit
    int hundred = num / 100;
    if (hundred != 0) {
        sb.append(arr1[hundred] + "Hundred ");
    }

    // second, convert the rest of digits
    num %= 100;
    if (num != 0) {
        int ten = num / 10;
        int one = num % 10;
        if (ten == 1) {
            sb.append(arr11[num - 10]);
        } else {
            if (ten != 0) {
                // ten is in the range of [2,9]
                sb.append(arr10[ten]);
            }
            if (one != 0) {
                sb.append(arr1[one]);
            }
        }
    }
    return sb.toString();
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Winner of Tic-tac-toe]]></title>
    <link href="http://okckd.github.io/blog/2014/09/09/Winner-tic-tac-toe/"/>
    <updated>2014-09-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/09/Winner-tic-tac-toe</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.glassdoor.com/Interview/How-would-you-determine-if-someone-has-won-a-game-of-tic-tac-toe-on-a-board-of-any-size-QTN_1104.htm">link</a></p>

<blockquote><p>How would you determine if someone has won a game of tic-tac-toe on a board of any size?</p></blockquote>

<p>(This is also on CC150v4 19.2)</p>

<h3>Solution</h3>

<p>First, confirm that when the number of pieces in a line equals to the dimension of the board, one person wins. Eg. for 10 * 10 board, 10 pieces need to be in 1 line.</p>

<p><strong><a href="http://www.glassdoor.com/Interview/How-would-you-determine-if-someone-has-won-a-game-of-tic-tac-toe-on-a-board-of-any-size-QTN_1104.htm">We can determine</a> if someone has won during a game in real time</strong>, as in checking after every move.</p>

<blockquote><p>Create an array of size 2n+2 at the beginning of the game and fill it with zeros. Each spot in the array will be a sum of X&rsquo;s or O&rsquo;s horizontally (the first n places in the array), vertically (the second n places in the array) and diagonally (the last 2 places). Then with every move, you add 1 to the 2 places (or 3 if on a diagnol) of the array if X, and subtract 1 if its an O. After adding you check and see if the value of the array is equal to n or -n, if it is, n mean X has won and -n means O has won.</p></blockquote>

<p>This is uses O(2n+2) space, but it&rsquo;s the best solution I can find online. I wrote code posted below.</p>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>enum Piece {
    Empty, Red, Blue
};

public static Piece hasWon3(Piece[][] board) {

    int N = board.length;

    // O(2n+2) space to store count info
    int[] rowCnt = new int[N];
    int[] colCnt = new int[N];
    int[] digCnt = new int[2];

    for (int i = 0; i &lt; N; i++) {
        for (int j = 0; j &lt; N; j++) {

            int pieceValue = 0;
            if (board[i][j] == Piece.Blue) {
                pieceValue = 1;
            } else if (board[i][j] == Piece.Red) {
                pieceValue = -1;
            }

            // if empty, pieceValue is 0
            // if blue, add 1 in count
            // if red, subtract 1 in count
            rowCnt[i] += pieceValue;
            if (checkFinish(rowCnt[i], N) != null) {
                return checkFinish(rowCnt[i], N);
            }

            // after adding the count, check if the game finishes
            colCnt[j] += pieceValue;
            if (checkFinish(colCnt[j], N) != null) {
                return checkFinish(colCnt[j], N);
            }

            if (i == j) {
                digCnt[0] += pieceValue;
                if (checkFinish(digCnt[0], N) != null) {
                    return checkFinish(digCnt[0], N);
                }
            } else if (i + j == N) {
                digCnt[1] += pieceValue;
                if (checkFinish(digCnt[1], N) != null) {
                    return checkFinish(digCnt[1], N);
                }
            }
        }
    }
    // game not finished, continue
    return Piece.Empty;
}

private static Piece checkFinish(int count, int N) {
    if (count == N)
        return Piece.Blue;
    else if (count == -1 * N)
        return Piece.Red;
    else
        return null;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
