<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8" />
		<title>[LeetCode 76] Minimum Window Substring - Woodstock Blog</title>
		<meta name="author" content="Charlie Brown">
		
		<meta name="description" content="Question link Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). For &hellip;">
    	
    	<meta name="viewport" content="width=device-width; initial-scale=1; maximum-scale=1">
    
		<link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
	    <link href="/favicon.png" rel="shortcut icon">
	    <link rel="canonical" href="">
		<link rel="stylesheet" type="text/css" href="/stylesheets/style.css" />
		<link rel="stylesheet" type="text/css" href="/stylesheets/syntax.css" />
		<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
		
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


	</head>

	<body>
		<div id="logo">
	<span id="tags"> 编程 / 思考 / 阅读 / 生活 </span>
	<h1><a href="/">Woodstock Blog</a></h1>
</div>
		<div id="wrapper">
			<div id="content">
				<a target="_blank" style="float:right;margin-top:15px" href="http://twitter.com/share?url=http://blog.libingcun.com/blog/2014/05/21/Minimum-Window-Substring/&via=libingcun&text=[LeetCode 76] Minimum Window Substring"><span class="balloon">retweet</span></a>
				<h2>[LeetCode 76] Minimum Window Substring</h2>
				<div class="cnt">
					<h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/minimum-window-substring/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
</p>

<p>
For example,<br>
<b>S</b> = <code>"ADOBECODEBANC"</code><br>
<b>T</b> = <code>"ABC"</code><br>
</p>
<p>
Minimum window is <code>"BANC"</code>.
</p>

<p>
<b>Note:</b><br>
If there is no such window in S that covers all characters in T, return the emtpy string <code>""</code>.
</p>
<p>
If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very difficult string matching question</strong>.</p>

<p>The sliding window solution is very well explained in <a href="http://leetcode.com/2010/11/finding-minimum-window-in-s-which.html">this post</a> (the best solution).</p>

<blockquote cite="http://fisherlei.blogspot.sg/2013/01/leetcode-simplify-path.html">
    <p>To help illustrate this approach, I use a different example: <b>S</b> = “<b>acbbaca</b>” and <b>T</b> = “<b>aba</b>“. The idea is mainly based on the help of two pointers (begin and end position of the window) and two tables (<i>needToFind </i>and <i>hasFound</i>) while traversing <b>S</b>. <i>needToFind</i> stores the total count of a character in <b>T</b> and <i>hasFound</i> stores the total count of a character met so far. We also use a <i>count</i> variable to store the total characters in <b>T</b> that’s met so far (not counting characters where hasFound[<i>x</i>]<i> </i>exceeds needToFind[<i>x</i>]). When count equals <b>T</b>‘s length, we know a valid window is found.</p><p>Each time we advance the end pointer (pointing to an element <i>x</i>), we increment hasFound[<i>x</i>] by one. We also increment <i>count </i>by one if hasFound[<i>x</i>] is less than or equal to needToFind[<i>x</i>]. Why? When the constraint is met (that is, <i>count</i> equals to <b>T</b>‘s size), we immediately advance begin pointer as far right as possible while maintaining the constraint.</p><p>How do we check if it is maintaining the constraint? Assume that begin points to an element <i>x</i>, we check if hasFound[<i>x</i>] is greater than needToFind[<i>x</i>]. If it is, we can decrement hasFound[<i>x</i>] by one and advancing begin pointer without breaking the constraint. On the other hand, if it is not, we stop immediately as advancing begin pointer breaks the window constraint.</p><p>Finally, we check if the minimum window length is less than the current minimum. Update the current minimum if a new minimum is found.</p><p>Essentially, the algorithm finds the first window that satisfies the constraint, then continue maintaining the constraint throughout.</p><p></p><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/_UElib2WLeDE/TOBuvjG6exI/AAAAAAAACYE/uludVXtJ8OY/s1600/sliding.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="83" src="http://2.bp.blogspot.com/_UElib2WLeDE/TOBuvjG6exI/AAAAAAAACYE/uludVXtJ8OY/s400/sliding.gif" width="400"></a></div><div style="text-align: center;"><span style="font-size: x-small;">i) <b>S</b> = “<b>acbbaca</b>” and <b>T</b> = “<b>aba</b>“.<br></span></div><p></p><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/_UElib2WLeDE/TOBvHRLbOAI/AAAAAAAACYI/38QLgUIMePU/s1600/sliding_2.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="79" src="http://4.bp.blogspot.com/_UElib2WLeDE/TOBvHRLbOAI/AAAAAAAACYI/38QLgUIMePU/s400/sliding_2.gif" width="400"></a></div><div style="text-align: center;"><span style="font-size: x-small;">ii) The first minimum window is found. Notice that we cannot advance begin pointer as hasFound[&#8216;a&#8217;] == needToFind[&#8216;a&#8217;] == 2. Advancing would mean breaking the constraint.<br></span></div><p></p><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/_UElib2WLeDE/TOBvLH1aLcI/AAAAAAAACYM/pbJLl7qoduo/s1600/sliding_3.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="79" src="http://3.bp.blogspot.com/_UElib2WLeDE/TOBvLH1aLcI/AAAAAAAACYM/pbJLl7qoduo/s400/sliding_3.gif" width="400"></a></div><div style="text-align: center;"><span style="font-size: x-small;">iii) The second window is found. begin pointer still points to the first element ‘a’. hasFound[&#8216;a&#8217;] (<b>3</b>) is greater than needToFind[&#8216;a&#8217;] (<b>2</b>). We decrement hasFound[&#8216;a&#8217;] by one and advance begin pointer to the right.<br></span></div><p></p><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/_UElib2WLeDE/TOBvOljpz0I/AAAAAAAACYQ/TxuWgWGTOF4/s1600/sliding_4.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="79" src="http://2.bp.blogspot.com/_UElib2WLeDE/TOBvOljpz0I/AAAAAAAACYQ/TxuWgWGTOF4/s400/sliding_4.gif" width="400"></a></div><div style="text-align: center;"><span style="font-size: x-small;">iv) We skip ‘c’ since it is not found in <b>T</b>. Begin pointer now points to ‘b’. hasFound[&#8216;b&#8217;] (<b>2</b>) is greater than needToFind[&#8216;b&#8217;] (<b>1</b>). We decrement hasFound[&#8216;b&#8217;] by one and advance begin pointer to the right.<br></span></div><p></p><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/_UElib2WLeDE/TOBvSOl6RdI/AAAAAAAACYU/R4O1dPXVvBQ/s1600/sliding_5.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="79" src="http://2.bp.blogspot.com/_UElib2WLeDE/TOBvSOl6RdI/AAAAAAAACYU/R4O1dPXVvBQ/s400/sliding_5.gif" width="400"></a></div><div style="text-align: center;"><span style="font-size: x-small;">v) Begin pointer now points to the next ‘b’. hasFound[&#8216;b&#8217;] (1) is equal to needToFind[&#8216;b&#8217;] (1). We stop immediately and this is our newly found minimum window.<br></span></div><p>Both the begin and end pointers can advance at most <i>N</i> steps (where <i>N</i> is <b>S</b>‘s size) in the worst case, adding to a total of 2<i>N</i> times. Therefore, the run time complexity must be in <i>O</i>(<i>N</i>).</p>
</blockquote>


<h3>Solution</h3>

<p>Best code is from <a href="http://answer.ninechapter.com/solutions/minimum-window-substring/">this post</a>.</p>

<p>First of all, keep a HashMap to store all letters and occurrance. Then declare a &lsquo;count&rsquo; variable. This is an important varaible. It helps us to check whether we have successfully achieve at least 1 window. After we found the first window, the &lsquo;count&rsquo; variable shall always equals to total number of letters in &rsquo;T&#8217;.</p>

<p>Now the looping part. Basically we assume that the window end at one point, and we find the correct starting position and calculate corresponding length.</p>

<p>The coding part is very difficult. Try to practise more.</p>

<h3>Code</h3>

<p><strong>Updated on July 7th</strong>, code:</p>

<pre><code>public String minWindow(String S, String T) {
    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();
    HashMap&lt;Character, Integer&gt; map2 = new HashMap&lt;Character, Integer&gt;();
    for (Character ch: T.toCharArray()) {
        if (map.containsKey(ch)) {
            map.put(ch, map.get(ch) + 1);
        } else {
            map.put(ch, 1);
            map2.put(ch, 0);
        }
    }
    int count = 0;
    int start = 0;
    int end = 0;
    String result = "";
    while (end &lt; S.length()) {
        char cur = S.charAt(end);
        if (!map.containsKey(cur)) {
            end++;
            continue;
        }
        map2.put(cur, map2.get(cur) + 1);
        if (map2.get(cur) &lt;= map.get(cur)) {
            count++;
        }

        if (count == T.length()) {
            // locate start point
            while(true) {
                char ll = S.charAt(start);
                if (!map.containsKey(ll)) {
                    start++;
                    continue;
                }
                if (map2.get(ll) &gt; map.get(ll)) {
                    map2.put(ll, map2.get(ll) - 1);
                    start++;
                    continue;
                } else {
                    break;
                }
            }
            if (result.equals("") || result.length() &gt; end - start + 1) {
                result = S.substring(start, end + 1);
            }
        }
        end++;
    }
    return result;
}
</code></pre>

<p><strong>Updated on July 19th</strong>, rewrite the code changing all while-loop to for-loop:</p>

<pre><code>public String minWindow(String S, String T) {
    if (S.length() &lt; T.length()) {
        return "";
    }
    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();
    HashMap&lt;Character, Integer&gt; found = new HashMap&lt;Character, Integer&gt;();
    for (Character ch: T.toCharArray()) {
        if (map.containsKey(ch)) {
            map.put(ch, map.get(ch) + 1);
        } else {
            map.put(ch, 1);
            found.put(ch, 0);
        }
    }

    String window = S;
    int count = 0;
    int start  = 0;

    char[] letters = S.toCharArray();
    for (int i = 0; i &lt; letters.length; i++) {
        char ch  = letters[i];
        if (!map.containsKey(ch)) {
            continue;
        }
        if (found.get(ch) &lt; map.get(ch)) {
            count++;
        }
        found.put(ch, found.get(ch) + 1);
        if (count == T.length()) {
            // update the start pointer
            for (; start &lt;= i; start++) {
                char sChar = letters[start];
                if (!map.containsKey(sChar)) {
                    continue;
                }
                if (found.get(sChar) &lt;= map.get(sChar)) {
                    break;
                } else {
                    found.put(sChar, found.get(sChar) - 1);
                }
            }
            if (window.length() &gt; i - start + 1) {
                window = S.substring(start, i + 1);
            }
        }
    }
    return count == T.length() ? window : "";
}
</code></pre>

					<br />
					--EOF--
					<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
				</div>
				<div id="disqus_thread"></div>
				

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://okckd.github.io/blog/2014/05/21/Minimum-Window-Substring/';
        var disqus_url = 'http://okckd.github.io/blog/2014/05/21/Minimum-Window-Substring/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>


			</div>
			
			<div id="footer">
				<span style="color:#bbb;font-size:12px">To do less than best is a sin.</span>
<p style="clear:both"></p>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.1/jquery.min.js"></script>
			</div>
		</div>
	</body>
</html>

