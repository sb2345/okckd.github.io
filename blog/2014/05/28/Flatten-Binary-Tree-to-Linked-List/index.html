<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8" />
		<title>[LeetCode 114] Flatten Binary Tree to Linked List - Woodstock Blog</title>
		<meta name="author" content="Charlie Brown">
		
		<meta name="description" content="Question link Given a binary tree, flatten it to a linked list in-place. For example,
Given 1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like &hellip;">
    	
    	<meta name="viewport" content="width=device-width; initial-scale=1; maximum-scale=1">
    
		<link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
	    <link href="/favicon.png" rel="shortcut icon">
	    <link rel="canonical" href="">
		<link rel="stylesheet" type="text/css" href="/stylesheets/style.css" />
		<link rel="stylesheet" type="text/css" href="/stylesheets/syntax.css" />
		<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
		
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


	</head>

	<body>
		<div id="logo">
	<span id="tags"> 编程 / 思考 / 阅读 / 生活 </span>
	<h1><a href="/">Woodstock Blog</a></h1>
</div>
		<div id="wrapper">
			<div id="content">
				<a target="_blank" style="float:right;margin-top:15px" href="http://twitter.com/share?url=http://blog.libingcun.com/blog/2014/05/28/Flatten-Binary-Tree-to-Linked-List/&via=libingcun&text=[LeetCode 114] Flatten Binary Tree to Linked List"><span class="balloon">retweet</span></a>
				<h2>[LeetCode 114] Flatten Binary Tree to Linked List</h2>
				<div class="cnt">
					<h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a binary tree, flatten it to a linked list in-place.
</p>

<p>
For example,<br>
Given
</p><pre>         1
        / \
       2   5
      / \   \
     3   4   6
</pre>
<p></p>

The flattened tree should look like:<br>
<pre>   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
</pre>

<div class="spoilers" ><b>Hints:</b>
<p>If you notice carefully in the flattened tree, each node&#8217;s right child points to the next node of a pre-order traversal.</p>
</div><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very difficult question</strong>, and there are many solutions.</p>

<h3>Solution</h3>

<p><strong>Analysis of all solutions (except first one) is found in <a href="http://n00tc0d3r.blogspot.sg/2013/03/flatten-binary-tree-to-linked-list-in.html">this great article</a></strong>.</p>

<p><strong>Solution 1 is my code</strong>, I am make use of a &lsquo;pre&rsquo; pointer in this recursive method. This idea is actually quite good, but is never seen in any other people&rsquo;s blogs.</p>

<p><strong>Solution 2 is the most standard recursive solution</strong>. It passes in a node, flatten it and return the last node after it&rsquo;s flattened. So we can flatten root node&rsquo;s left and right node respectively, and then connect it.</p>

<blockquote cite="http://n00tc0d3r.blogspot.sg/2013/03/flatten-binary-tree-to-linked-list-in.html">
To flatten a binary tree, according to the given example, is to recursively insert the left subtree to the right subtree and append the original right subtree to the end of the left subtree, i.e.<br>
<pre>     root                        root
     /  \            -&gt;            \
  left  right                      left
                                     \
                                    right
</pre>
Since we need to append the original right-tree to the end of the left subtree, we let the recursion function return the last node after flatten.
</blockquote>


<p>I missed &ldquo;root.left = null&rdquo; while coding, and it resulted in long long time debugging. I think this is a very silly mistake.</p>

<p><strong>Solution 3 is making use of a stack</strong>. I have to say, although I can figure how it works, I am still blur about the thinking process of this entire idea. Which is to say, I can&rsquo;t keep it in mind even after learning it.</p>

<p>I shall try write this code in the future.</p>

<blockquote>
We can also solve the problem without recursion.<br>
<br>
To do that, we can use a stack to store all right subtrees when we prune them temporarily, and append each of them back after we go through the corresponding left subtree.<br>
<br>
Basically, given a non-empty tree,<br>
<ul>
<li>if it has left subtree, store the right subtree (if not null) to stack, move the left subtree to right;</li>
<li>if not, append back a subtree from stack to the current node&#8217;s right;</li>
<li>continue to the right node until finish.</li>
</ul>
</blockquote>


<p><strong>Solution 4 is what I believe the best solution</strong>. It simple uses while loop to put all nodes in the correct position, without recursion or stack.</p>

<blockquote><p>Each time when we prune a right subtree, we use while-loop to find the right-most leaf of the current left subtree, and append the subtree there.</p></blockquote>

<p><strong>Analysis of all solutions (except first one) is found in <a href="http://n00tc0d3r.blogspot.sg/2013/03/flatten-binary-tree-to-linked-list-in.html">this great article</a></strong>.</p>

<h3>Code</h3>

<p><strong>First, my solution</strong>, a kind of recursive solution</p>

<pre><code>public void flatten(TreeNode root) {
    helper(new TreeNode(1234), root);
}

private TreeNode helper(TreeNode pre, TreeNode node) { 
    // pre cannot be null, this function return the last node of the flatten list
    if (node == null) return pre;
    pre.left = null;
    pre.right = node;
    TreeNode a = node.left;
    TreeNode b = node.right;
    TreeNode temp = helper(node, a);
    return helper(temp, b);
}
</code></pre>

<p><strong>Second, standard recursive solution</strong></p>

<pre><code>public void flatten(TreeNode root) {
    helper(root);
}

private TreeNode helper(TreeNode root) {
    if (root == null) return null;
    TreeNode oldRight = root.right;
    if (root.left != null) {
        root.right = root.left;
        // I missed this line of code: 
        root.left = null;
        root = helper(root.right);
    }
    if (oldRight != null) {
        root.right = oldRight;
        root = helper(root.right);
    }
    // return value is the last element of the flatten tree
    return root;
}
</code></pre>

<p><strong>Third, stack non-recursive solution</strong></p>

<pre><code>public void flatten(TreeNode root) {
    TreeNode cur = root;
    Stack&lt;TreeNode&gt; rtrees = new Stack&lt;TreeNode&gt;();
    while (cur != null) {
        while (cur.left != null) {
            if (cur.right != null)
                rtrees.push(cur.right);
            cur.right = cur.left;
            cur.left = null;
            cur = cur.right;
        }
        if (cur != null &amp;&amp; cur.right == null &amp;&amp; !rtrees.isEmpty()) {
            cur.right = rtrees.pop();
        }
        cur = cur.right;
    }
}
</code></pre>

<p><strong>Fourth, non-stack non-recursive solution</strong></p>

<pre><code>public void flatten(TreeNode root) {
    TreeNode cur = root;
    while (cur != null) {
        if (cur.left != null) {
            if (cur.right != null) { // if we need to prune a right subtree
                TreeNode next = cur.left;
                while (next.right != null)
                    next = next.right;
                next.right = cur.right;
            }
            cur.right = cur.left;
            cur.left = null;
        }
        cur = cur.right;
    }
}
</code></pre>

					<br />
					--EOF--
					<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
				</div>
				<div id="disqus_thread"></div>
				

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://okckd.github.io/blog/2014/05/28/Flatten-Binary-Tree-to-Linked-List/';
        var disqus_url = 'http://okckd.github.io/blog/2014/05/28/Flatten-Binary-Tree-to-Linked-List/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>


			</div>
			
			<div id="footer">
				<span style="color:#bbb;font-size:12px">To do less than best is a sin.</span>
<p style="clear:both"></p>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.1/jquery.min.js"></script>
			</div>
		</div>
	</body>
</html>

