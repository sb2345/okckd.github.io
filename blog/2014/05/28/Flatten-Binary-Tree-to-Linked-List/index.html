
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>[LeetCode 114] Flatten Binary Tree to Linked List - My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="Question link Given a binary tree, flatten it to a linked list in-place. For example,
Given 1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/blog/2014/05/28/Flatten-Binary-Tree-to-Linked-List">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">[LeetCode 114] Flatten Binary Tree to Linked List</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


<div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a binary tree, flatten it to a linked list in-place.
</p>

<p>
For example,<br>
Given
</p><pre>         1
        / \
       2   5
      / \   \
     3   4   6
</pre>
<p></p>

The flattened tree should look like:<br>
<pre>   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
</pre>

<div class="spoilers" ><b>Hints:</b>
<p>If you notice carefully in the flattened tree, each node&#8217;s right child points to the next node of a pre-order traversal.</p>
</div><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very difficult question</strong>, and there are many solutions.</p>

<h3>Solution</h3>

<p><strong>Analysis of all solutions (except first one) is found in <a href="http://n00tc0d3r.blogspot.sg/2013/03/flatten-binary-tree-to-linked-list-in.html">this great article</a></strong>.</p>

<p><strong>Solution 1 is my code</strong>, I am make use of a &lsquo;pre&rsquo; pointer in this recursive method. This idea is actually quite good, but is never seen in any other people&rsquo;s blogs.</p>

<p><strong>Solution 2 is the most standard recursive solution</strong>. It passes in a node, flatten it and return the last node after it&rsquo;s flattened. So we can flatten root node&rsquo;s left and right node respectively, and then connect it.</p>

<blockquote cite="http://n00tc0d3r.blogspot.sg/2013/03/flatten-binary-tree-to-linked-list-in.html">
To flatten a binary tree, according to the given example, is to recursively insert the left subtree to the right subtree and append the original right subtree to the end of the left subtree, i.e.<br>
<pre>     root                        root
     /  \            -&gt;            \
  left  right                      left
                                     \
                                    right
</pre>
Since we need to append the original right-tree to the end of the left subtree, we let the recursion function return the last node after flatten.
</blockquote>


<p>I missed &ldquo;root.left = null&rdquo; while coding, and it resulted in long long time debugging. I think this is a very silly mistake.</p>

<p><strong>Solution 3 is making use of a stack</strong>. I have to say, although I can figure how it works, I am still blur about the thinking process of this entire idea. Which is to say, I can&rsquo;t keep it in mind even after learning it.</p>

<p>I shall try write this code in the future.</p>

<blockquote>
We can also solve the problem without recursion.<br>
<br>
To do that, we can use a stack to store all right subtrees when we prune them temporarily, and append each of them back after we go through the corresponding left subtree.<br>
<br>
Basically, given a non-empty tree,<br>
<ul>
<li>if it has left subtree, store the right subtree (if not null) to stack, move the left subtree to right;</li>
<li>if not, append back a subtree from stack to the current node&#8217;s right;</li>
<li>continue to the right node until finish.</li>
</ul>
</blockquote>


<p><strong>Solution 4 is what I believe the best solution</strong>. It simple uses while loop to put all nodes in the correct position, without recursion or stack.</p>

<blockquote><p>Each time when we prune a right subtree, we use while-loop to find the right-most leaf of the current left subtree, and append the subtree there.</p></blockquote>

<p><strong>Analysis of all solutions (except first one) is found in <a href="http://n00tc0d3r.blogspot.sg/2013/03/flatten-binary-tree-to-linked-list-in.html">this great article</a></strong>.</p>

<h3>Code</h3>

<p><strong>First, my solution</strong>, a kind of recursive solution</p>

<pre><code>public void flatten(TreeNode root) {
    helper(new TreeNode(1234), root);
}

private TreeNode helper(TreeNode pre, TreeNode node) { 
    // pre cannot be null, this function return the last node of the flatten list
    if (node == null) return pre;
    pre.left = null;
    pre.right = node;
    TreeNode a = node.left;
    TreeNode b = node.right;
    TreeNode temp = helper(node, a);
    return helper(temp, b);
}
</code></pre>

<p><strong>Second, standard recursive solution</strong></p>

<pre><code>public void flatten(TreeNode root) {
    helper(root);
}

private TreeNode helper(TreeNode root) {
    if (root == null) return null;
    TreeNode oldRight = root.right;
    if (root.left != null) {
        root.right = root.left;
        // I missed this line of code: 
        root.left = null;
        root = helper(root.right);
    }
    if (oldRight != null) {
        root.right = oldRight;
        root = helper(root.right);
    }
    // return value is the last element of the flatten tree
    return root;
}
</code></pre>

<p><strong>Third, stack non-recursive solution</strong></p>

<pre><code>public void flatten(TreeNode root) {
    TreeNode cur = root;
    Stack&lt;TreeNode&gt; rtrees = new Stack&lt;TreeNode&gt;();
    while (cur != null) {
        while (cur.left != null) {
            if (cur.right != null)
                rtrees.push(cur.right);
            cur.right = cur.left;
            cur.left = null;
            cur = cur.right;
        }
        if (cur != null &amp;&amp; cur.right == null &amp;&amp; !rtrees.isEmpty()) {
            cur.right = rtrees.pop();
        }
        cur = cur.right;
    }
}
</code></pre>

<p><strong>Fourth, non-stack non-recursive solution</strong></p>

<pre><code>public void flatten(TreeNode root) {
    TreeNode cur = root;
    while (cur != null) {
        if (cur.left != null) {
            if (cur.right != null) { // if we need to prune a right subtree
                TreeNode next = cur.left;
                while (next.right != null)
                    next = next.right;
                next.right = cur.right;
            }
            cur.right = cur.left;
            cur.left = null;
        }
        cur = cur.right;
    }
}
</code></pre>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Your Name</span></span>

      








  


<time datetime="2014-05-28T00:00:00+08:00" pubdate data-updated="true"></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/leetcode/'>leetcode</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://okckd.github.io/blog/2014/05/28/Flatten-Binary-Tree-to-Linked-List/" data-via="" data-counturl="http://okckd.github.io/blog/2014/05/28/Flatten-Binary-Tree-to-Linked-List/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/05/28/Binary-Tree-Maximum-Path-Sum/" title="Previous Post: [LeetCode 124] Binary Tree Maximum Path Sum">&laquo; [LeetCode 124] Binary Tree Maximum Path Sum</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/05/28/Valid-Palindrome/" title="Next Post: [LeetCode 125] Valid Palindrome">[LeetCode 125] Valid Palindrome &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150/'>cc150 (4)</a></li>
<li class='category'><a href='/blog/categories/collection/'>collection (5)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (43)</a></li>
<li class='category'><a href='/blog/categories/facebook/'>facebook (2)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (20)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (155)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (80)</a></li>
<li class='category'><a href='/blog/categories/thoughts/'>thoughts (5)</a></li>
<li class='category'><a href='/blog/categories/twitter/'>twitter (1)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/08/23/stack-and-heap/">[Design] Stack and Heap</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/23/Web-hosting-shared-and-vps/">[Design] Shared Hosting vs. VPS Hosting</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/23/Design-scalable-system/">[Design] Designing Scalable Systems (`)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/23/BST-over-hashmap/">[Design] Binary Search Trees Over Hash Tables</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/22/design-deck-card/">[CC150] v4.7.1 Design a Generic Deck of Cards</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
