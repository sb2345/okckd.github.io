<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8" />
		<title>[LeetCode 99] Recover Binary Search Tree - Woodstock Blog</title>
		<meta name="author" content="Charlie Brown">
		
		<meta name="description" content="Question link Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Note:
A solution &hellip;">
    	
    	<meta name="viewport" content="width=device-width; initial-scale=1; maximum-scale=1">
    
		<link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
	    <link href="/favicon.png" rel="shortcut icon">
	    <link rel="canonical" href="">
		<link rel="stylesheet" type="text/css" href="/stylesheets/style.css" />
		<link rel="stylesheet" type="text/css" href="/stylesheets/syntax.css" />
		<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
		
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


	</head>

	<body>
		<div id="logo">
	<span id="tags"> 编程 / 思考 / 阅读 / 生活 </span>
	<h1><a href="/">Woodstock Blog</a></h1>
</div>
		<div id="wrapper">
			<div id="content">
				<a target="_blank" style="float:right;margin-top:15px" href="http://twitter.com/share?url=http://blog.libingcun.com/blog/2014/05/25/Recover-Binary-Search-Tree/&via=libingcun&text=[LeetCode 99] Recover Binary Search Tree"><span class="balloon">retweet</span></a>
				<h2>[LeetCode 99] Recover Binary Search Tree</h2>
				<div class="cnt">
					<h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/recover-binary-search-tree/">link</a></p>

<div class="question-content">
            <p></p><p>
Two elements of a binary search tree (BST) are swapped by mistake.</p>

<p>Recover the tree without changing its structure.
</p>

<b>Note:</b><br>
A solution using O(<i>n</i>) space is pretty straight forward. Could you devise a constant space solution?
<p></p>

<p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is one of the most difficult questions that I have solved</strong>.</p>

<p>The question can be solved using 2 pointers to point to the 2 misplaced nodes, and swap them. I solved the problem with this approach, and I found a good explanation <a href="http://chaoren.is-programmer.com/posts/42931.html">here</a>.</p>

<blockquote><p>Only two variables (first, second) are enough to record nodes to be exchanged.</p>

<p>If there&rsquo;s only one descending order pair (e.g. 20, 10, 30, 40, 50), use first &amp; second to record it.</p>

<p>If there are two descending order pairs (e.g. 10, 40, 30, 20, 50 or 50, 20, 30, 40, 10), use the smaller number in second pair to update variable &lsquo;second&rsquo;.</p>

<p>In the end, swap first and second.</p></blockquote>

<p>This is a popular solution on the Internet, which <strong>uses O(1) space, plus average case O(lgn) stack space</strong> (because recursion always incur stack usage). So this solution is actually not fulfilling the requirements.</p>

<blockquote><p>中序遍历二叉树的空间复杂度是O(logN) on average case</p></blockquote>

<p><strong>So finally I found a solution with constent space, and it&rsquo;s using Treaded Binary Tree again</strong>! Look below for details.</p>

<h3>Solution</h3>

<p><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/">This</a> is a systematic analysis of <strong>Morris Traversal</strong> based on <strong>Threaded Binary Tree</strong>.</p>

<p><strong>A solution of using Morris Traversal is explained <a href="http://www.cnblogs.com/TenosDoIt/p/3445682.html">here</a></strong>. Don&rsquo;t worry about the tree structure being changed, because it&rsquo;s reverted back after the traversal.</p>

<blockquote><p>算法2：为了满足O(1)空间复杂度，我们就要使用非递归且不使用栈的中序遍历算法，在leetcode另一个题目Binary Tree Inorder Traversal中，我们提到了Morris Traversal中序遍历算法，它既没有递归，也没有使用栈，而是用了线索二叉树的思想，用闲置的右节点指向中序序列中该节点的后缀，遍历后再恢复树的原始指针。其主要算法步骤如下：</p>

<p>重复以下1、2直到当前节点为空。</p></blockquote>

<p><strong><a href="http://fisherlei.blogspot.sg/2012/12/leetcode-recover-binary-search-tree.html">Another person</a></strong> have a very good (maybe better) English version of analysis and code:</p>

<pre><code>1. Initialize current as root 
2. While current is not NULL
   If current does not have left child
      a) Print current’s data
      b) Go to the right, i.e., current = current-&amp;gt;right
   Else
      a) Make current as right child of the rightmost node in current's left subtree
      b) Go to this left child, i.e., current = current-&amp;gt;left
</code></pre>

<h3>Code</h3>

<p><strong>First, my code (2 pointer solution)</strong></p>

<pre><code>TreeNode first = null, second = null;
TreeNode pre = new TreeNode(Integer.MIN_VALUE);

public void recoverTree(TreeNode root) {
    helper(root);
    // now first and second are both found
    int temp = first.val;
    first.val = second.val;
    second.val = temp;
}

private void helper(TreeNode root) {
    if (root == null) return;
    helper(root.left);
    if (pre.val &gt; root.val) {
        if (first == null) {
            first = pre;
            second = root;
        }
        else second = root;
    }
    pre = root;
    helper(root.right);
}
</code></pre>

<p><strong>Second, real O(1) space solution</strong> using Threaded Binary Tree (i.e. Morris Traversal) in C++. I could not memorize this code.</p>

<pre><code>void recoverTree(TreeNode *root) {
       TreeNode *f1=NULL, *f2=NULL;
       TreeNode  *current,*pre, *parent=NULL;

       if(root == NULL)
             return;
       bool found = false;
       current = root;
       while(current != NULL)
       {                
             if(current-&gt;left == NULL)
             {
                    if(parent &amp;&amp; parent-&gt;val &gt; current-&gt;val)
                    {
                           if(!found)
                           {
                                 f1 = parent;
                                 found = true;
                           }
                           f2 = current;
                    }
                    parent = current;
                    current = current-&gt;right;     
             }   
             else
             {
                    /* Find the inorder predecessor of current */
                    pre = current-&gt;left;
                    while(pre-&gt;right != NULL &amp;&amp; pre-&gt;right != current)
                           pre = pre-&gt;right;

                    /* Make current as right child of its inorder predecessor */
                    if(pre-&gt;right == NULL)
                    {
                           pre-&gt;right = current;
                           current = current-&gt;left;
                    }

                    /* Revert the changes made in if part to restore the original
                    tree i.e., fix the right child of predecssor */  
                    else
                    {
                           pre-&gt;right = NULL;
                           if(parent-&gt;val &gt; current-&gt;val)
                           {
                                 if(!found)
                                 {
                                        f1 = parent;       
                                        found = true;
                                 }
                                 f2 = current;
                           }
                           parent = current;
                           current = current-&gt;right;     
                    } /* End of if condition pre-&gt;right == NULL */
             } /* End of if condition current-&gt;left == NULL*/
       } /* End of while */

       if(f1 &amp;&amp; f2)
             swap(f1-&gt;val, f2-&gt;val);
}
</code></pre>

					<br />
					--EOF--
					<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
				</div>
				<div id="disqus_thread"></div>
				

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://okckd.github.io/blog/2014/05/25/Recover-Binary-Search-Tree/';
        var disqus_url = 'http://okckd.github.io/blog/2014/05/25/Recover-Binary-Search-Tree/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>


			</div>
			
			<div id="footer">
				<span style="color:#bbb;font-size:12px">To do less than best is a sin.</span>
<p style="clear:both"></p>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.1/jquery.min.js"></script>
			</div>
		</div>
	</body>
</html>

