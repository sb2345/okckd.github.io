
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>[NineChap 6] Graph and Search - Woodstock Blog</title>
  <meta name="author" content="Charlie Brown">

  
  <meta name="description" content="Graph For graph, there are only 2 high-frequency questions, which is &lsquo;clone graph&rsquo; and &lsquo;topology sorting&rsquo;. Question list &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/blog/2014/06/26/NineChap-Graph">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Woodstock Blog</a></h1>
  
    <h2>What's the good of living if you don't try a few things?</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">[NineChap 6] Graph and Search</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-26T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://okckd.github.io">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><h2>Graph</h2>

<p>For graph, there are only 2 high-frequency questions, which is &lsquo;clone graph&rsquo; and &lsquo;topology sorting&rsquo;.</p>

<h3>Question list</h3>

<ol>
<li><p><strong><a href="/blog/2014/05/30/Clone-Graph/">Clone Graph</a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="/blog/2014/06/27/Topology-sorting/">Topology Sorting</a></strong></p></li>
</ol>


<h2>Search</h2>

<p>Search have either DFS or BFS.</p>

<p>First, we will cover permutations and combinations using DFS. In this section we solve the famous N-queens question.</p>

<p>Then, there&rsquo;s a few BFS questions. Graph traversal is BFS, and Word ladder is also a classic BFS question.</p>

<h3>Question list</h3>

<ol>
<li><p><strong><a href="/blog/2014/05/22/Subsets/">Subsets</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/22/Subsets-II/">Subsets II</a></strong></p>

<p> difficult</p></li>
<li><p><strong><a href="/blog/2014/05/14/Permutations/">Permutations</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/14/Permutations-II/">Permutations II</a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="/blog/2014/05/16/N-Queens/">N-Queens</a></strong></p>

<p> how to use hashmap (and some space) to make it faster? 3 hashmaps to store the row, the (x,y) diff and sum. This will make isValid() method O(1).</p></li>
<li><p><strong><a href="/blog/2014/05/16/N-Queens-II/">N-Queens II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/12/Next-Permutation/">Next Permutation</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/27/Previous-Permutation/">Previous Permutation</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/29/Palindrome-Partitioning/">Palindrome Partitioning</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/30/Palindrome-Partitioning-II/">Palindrome Partitioning II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/13/Combination-Sum/">Combination Sum</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/13/Combination-Sum/">Combination Sum II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/29/Word-Ladder/">Word Ladder</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/30/Word-Ladder-II/">Word Ladder II</a></strong></p></li>
</ol>


<h3>Additional questions</h3>

<ol>
<li><p><strong><a href="/blog/2014/05/24/Restore-IP-Addresses/">Restore IP Addresses</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/22/Combinations/">Combinations</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/02/Letter-Combinations-of-a-Phone-Number/">Letter Combinations of a Phone Number</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/19/Permutation-Sequence/">Permutation Sequence</a></strong></p></li>
</ol>


<h2>Code</h2>

<h3>Graph</h3>

<p><strong>Clone Graph</strong></p>

<pre><code>public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if (node == null) return null;
    HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = 
            new HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt;();
    Queue&lt;UndirectedGraphNode&gt; queue = new LinkedList&lt;UndirectedGraphNode&gt;();
    map.put(node, new UndirectedGraphNode(node.label));
    queue.add(node);
    while (!queue.isEmpty()) {
        UndirectedGraphNode cur = queue.remove();
        UndirectedGraphNode copy = map.get(cur);
        // here the 'copy' must exist. why? because all neighbors 
        // has been added to the map when they're pushed to queue.
        // so 'cur' must have a corresponding copy in the hashmap. 
        for (UndirectedGraphNode neib: cur.neighbors) {
            if (!map.containsKey(neib)) {
                queue.add(neib);
                map.put(neib, new UndirectedGraphNode(neib.label));
            }
            copy.neighbors.add(map.get(neib));
        }
    }
    return map.get(node);
}
</code></pre>

<p><strong>Topology Sorting</strong></p>

<p>A new post is written for it.</p>

<h3>Search</h3>

<p><strong>Subsets</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; subsets(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (num == null || num.length == 0) {
        return ans;
    }
    Arrays.sort(num);
    helper(ans, new LinkedList&lt;Integer&gt;(), num, 0);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num, int pos) {
    ans.add(new LinkedList&lt;Integer&gt;(path));
    for (int i = pos; i &lt; num.length; i++) {
        path.add(num[i]);
        helper(ans, path, num, i + 1);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Subsets II</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (num == null || num.length == 0) {
        return ans;
    }
    Arrays.sort(num);
    helper(ans, new LinkedList&lt;Integer&gt;(), num, 0);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num, int pos) {
    ans.add(new LinkedList&lt;Integer&gt;(path));
    for (int i = pos; i &lt; num.length; i++) {
        if (i &gt; pos &amp;&amp; num[i - 1] == num[i]) {
            continue;
        }
        path.add(num[i]);
        helper(ans, path, num, i + 1);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Permutations</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (num == null || num.length == 0) {
        return ans;
    }
    helper(ans, new LinkedList&lt;Integer&gt;(), num);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num){
    if (path.size() == num.length) {
        ans.add(new LinkedList&lt;Integer&gt;(path));
    }
    for (int i = 0; i &lt; num.length; i++) {
        if (path.contains(num[i])) {
            continue;
        }
        path.add(num[i]);
        helper(ans, path, num);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Permutations II</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (num == null || num.length == 0) {
        return ans;
    }
    Arrays.sort(num);
    helper(ans, new LinkedList&lt;Integer&gt;(), num, new int[num.length]);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num, int[] visited){
    if (path.size() == num.length) {
        ans.add(new LinkedList&lt;Integer&gt;(path));
        return;
    }
    for (int i = 0; i &lt; num.length; i++) {
        if (visited[i] == 1) {
            continue;
        }
        if (i &gt; 0 &amp;&amp; visited[i - 1] == 1 &amp;&amp; visited[i] == 0 &amp;&amp; num[i - 1] == num[i]) {
            // if current number is same as previous, then don't visit current
            continue;
        }
        path.add(num[i]);
        visited[i] = 1;

        helper(ans, path, num, visited);

        path.remove(path.size() - 1);
        visited[i] = 0;
    }
}
</code></pre>

<p><strong>N-Queens</strong></p>

<p>一次通关！高兴。</p>

<pre><code>public List&lt;String[]&gt; solveNQueens(int n) {
    List&lt;String[]&gt; ans = new LinkedList&lt;String[]&gt;();
    if (n &lt;= 0) {
        return ans;
    }
    helper(ans, new int[n], n, 0);
    return ans;
}

private void helper(List&lt;String[]&gt; ans, int[] path, int n, int pos) {
    if (pos &gt;= n) {
        ans.add(convert(path, n));
        return;
    }
    for (int i = 0; i &lt; n; i++) {
        path[pos] = i;
        if (!isValid(path, pos)) {
            continue;
        }
        helper(ans, path, n, pos + 1);
    }
}

private String[] convert(int[] path, int n) {
    String[] ans = new String[n];
    for (int j = 0; j &lt; n; j++) {
        ans[j] = "";
        for (int i = 0; i &lt; n; i++) {
            ans[j] += (j == path[i]) ? 'Q' : '.';
        }
    }
    return ans;
}

private boolean isValid(int[] path, int pos) {
    for (int i = 0; i &lt; pos; i++) {
        // check path[i] and path[pos]
        if (path[i] == path[pos]) {
            return false;
        }
        if (path[i] - path[pos] == pos - i) {
            return false;
        }
        if (path[pos] - path[i] == pos - i) {
            return false;
        }
    }
    return true;
}
</code></pre>

<p><strong>N-Queens II</strong></p>

<pre><code>int total;

public int totalNQueens(int n) {
    if (n &lt;= 0) {
        return 0;
    }
    helper(new int[n], n, 0);
    return total;
}

private void helper(int[] path, int n, int pos) {
    if (pos &gt;= n) {
        total++;
        return;
    }
    for (int i = 0; i &lt; n; i++) {
        path[pos] = i;
        if (!isValid(path, pos)) {
            continue;
        }
        helper(path, n, pos + 1);
    }
}

private boolean isValid(int[] path, int pos) {
    for (int i = 0; i &lt; pos; i++) {
        // check path[i] and path[pos]
        if (path[i] == path[pos]) {
            return false;
        }
        if (path[i] - path[pos] == pos - i) {
            return false;
        }
        if (path[pos] - path[i] == pos - i) {
            return false;
        }
    }
    return true;
}
</code></pre>

<p><strong>Next Permutation</strong></p>

<pre><code>public void nextPermutation(int[] num) {
    if (num == null || num.length &lt;= 1) {
        return;
    }
    int len = num.length;
    int p = len - 2;
    while (p &gt;= 0 &amp;&amp; num[p] &gt;= num[p + 1]) {
        p--;
    }
    if (p &lt; 0) {
        Arrays.sort(num);
    } else {
        int k = len - 1;
        while (k &gt;= 0 &amp;&amp; num[k] &lt;= num[p]) {
            k--;
        }
        swap(num, p, k);
        reverse(num, p + 1, len - 1);
    }
}

private void swap(int[] num, int p, int k) {
    num[p] = num[p] + num[k];
    num[k] = num[p] - num[k];
    num[p] = num[p] - num[k];
}

private void reverse(int[] num, int s, int d) {
    while (s &lt; d) {
        swap(num, s++, d--);
    }
}
</code></pre>

<p><strong>Previous Permutation</strong></p>

<p>Plz look at the new post.</p>

<p><strong>Palindrome Partitioning</strong></p>

<p>一次通关 again！very 高兴。</p>

<pre><code>public ArrayList&lt;ArrayList&lt;String&gt;&gt; partition(String s) {
    ArrayList&lt;ArrayList&lt;String&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;String&gt;&gt;();
    if (s == null || s.length() == 0) {
        return ans;
    }
    boolean[][] map = palinMap(s);
    helper(ans, new ArrayList&lt;String&gt;(), s, map, 0);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;String&gt;&gt; ans, ArrayList&lt;String&gt; path, String s, boolean[][] map, int pos) {
    int len = s.length();
    if (pos == len) {
        ans.add(new ArrayList&lt;String&gt;(path));
        return;
    }
    for (int i = pos; i &lt; len; i++) {
        if (!map[pos][i]) {
            continue;
        }
        path.add(s.substring(pos, i + 1));
        helper(ans, path, s, map, i + 1);
        path.remove(path.size() - 1);
    }
}

private boolean[][] palinMap(String s) {
    int len = s.length();
    boolean[][] map = new boolean[len][len];
    for (int i = len - 1; i &gt;= 0; i--) {
        for (int j = 0; j &lt; len; j++) {
            if (i &gt; j) {
                continue;
            } else if (i == j) {
                map[i][j] = true;
            } else if (j - i == 1) {
                map[i][j] = s.charAt(i) == s.charAt(j);
            } else {
                map[i][j] = map[i + 1][j - 1] &amp; 
                        s.charAt(i) == s.charAt(j);
            }
        }
    }
    return map;
}
</code></pre>

<p><strong>Palindrome Partitioning II</strong></p>

<p>This is DP, not Graph &amp; Search.</p>

<p><strong>Combination Sum</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (candidates == null || candidates.length == 0) {
        return ans;
    }
    Arrays.sort(candidates);
    helper(ans, new ArrayList&lt;Integer&gt;(), candidates, target, 0);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans, ArrayList&lt;Integer&gt; path, 
        int[] candidates, int target, int pos) {
    if (target == 0) {
        ans.add(new ArrayList&lt;Integer&gt;(path));
        return;
    } else if (target &lt; 0) {
        return;
    }
    for (int i = pos; i &lt; candidates.length; i++) {
        if (target &lt; candidates[i]) {
            continue;
        }
        path.add(candidates[i]);
        helper(ans, path, candidates, target - candidates[i], i);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Combination Sum II</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (candidates == null || candidates.length == 0) {
        return ans;
    }
    Arrays.sort(candidates);
    helper(ans, new ArrayList&lt;Integer&gt;(), candidates, target, 0);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans, ArrayList&lt;Integer&gt; path, 
        int[] candidates, int target, int pos) {
    if (target == 0) {
        ans.add(new ArrayList&lt;Integer&gt;(path));
        return;
    } else if (target &lt; 0) {
        return;
    }
    for (int i = pos; i &lt; candidates.length; i++) {
        if (target &lt; candidates[i]) {
            continue;
        }
        if (i &gt; pos &amp;&amp; candidates[i - 1] == candidates[i]) {
            continue;
        }
        path.add(candidates[i]);
        helper(ans, path, candidates, target - candidates[i], i + 1);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Word Ladder</strong></p>

<p>Note that this is a <strong>BFS question, not DFS</strong>. I made it wrong and it took me a long time.</p>

<pre><code>public int ladderLength(String start, String end, Set&lt;String&gt; dict) {
    Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();
    queue.add(start);
    int length = 1;

    while (!queue.isEmpty()) {
        int currentSize = queue.size();
        for (int k = 0; k &lt; currentSize; k++) {
            String word = queue.remove();
            // insert all adjacent strings of word
            if (word.equals(end)) {
                return length;
            }
            for (int i = 0; i &lt; word.length(); i++) {
                char[] letters = word.toCharArray();
                char originalLetter = letters[i];
                for (char c = 'a'; c &lt;= 'z'; c++) {
                    if (c == originalLetter) continue;
                    letters[i] = c;
                    String newLetters = String.valueOf(letters);
                    if (dict.contains(newLetters)) {
                        queue.add(newLetters);
                        dict.remove(newLetters);
                    }
                }
                letters[i] = originalLetter;
            }
        }
        length++;
    }
    return 0;
}
</code></pre>

<p><strong>Word Ladder II</strong></p>

<p>unsolvable</p>

<h3>Additional questions</h3>

<p><strong>Restore IP Addresses</strong></p>

<pre><code>public List&lt;String&gt; restoreIpAddresses(String s) {
    List&lt;String&gt; ans = new ArrayList&lt;String&gt;();
    if (s == null || s.length() == 0) {
        return ans;
    }
    helper(ans, new ArrayList&lt;String&gt;(), s, 0);
    return ans;
}

private void helper(List&lt;String&gt; ans, List&lt;String&gt; path, String s, int pos) {
    if (path.size() == 4) {
        if (pos == s.length()) {
            ans.add(convert(path));
        }
        return;
    }
    for (int i = pos + 1; i &lt;= s.length() &amp;&amp; i &lt;= pos + 3; i++) {
        String nextNum = s.substring(pos, i);
        if (!isValid(nextNum)) {
            continue;
        }
        path.add(nextNum);
        helper(ans, path, s, i);
        path.remove(path.size() - 1);
    }
}

private boolean isValid(String str) {
    if (str.length() == 1) {
        return true;
    } else if (str.charAt(0) == '0') {
        return false;
    } else {
        int num = Integer.parseInt(str);
        return 0 &lt;= num &amp;&amp; num &lt;= 255;
    }
}

private String convert(List&lt;String&gt; path) {
    String str = "";
    for (String s: path) {
        str += "." + s;
    }
    return str.substring(1);
}
</code></pre>

<p><strong>Combinations</strong></p>

<p>skip</p>

<p><strong>Letter Combinations of a Phone Number</strong></p>

<p>skip</p>

<p><strong>Permutation Sequence</strong></p>

<pre><code>public String getPermutation(int n, int k) {
    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
    int fact = 1;
    for (int i = 1; i &lt;= n; i++) {
        list.add(i);
        fact *= i;
    }
    String ans = "";
    for (int i = n; i &gt; 0; i--) {
        fact = fact / i;
        int rank = (k - 1) / fact;
        k = (k - 1) % fact + 1;

        int curNum = list.remove(rank);
        ans += String.valueOf(curNum);
    }
    return ans;
}
</code></pre>

<h2>Conclusion</h2>

<h4>DFS (O(2<sup>n</sup>), O(n!))</h4>

<ol>
<li>Find all possible solutions</li>
<li>Permutations / Subsets</li>
</ol>


<h4>BFS (O(m), O(n))</h4>

<ol>
<li>Graph traversal</li>
<li>Find shortest path in a simple graph</li>
</ol>


<p><strong>Two most canonical BFS questions</strong>:</p>

<ol>
<li>Graph traversal and toposort</li>
<li>Word Ladder</li>
</ol>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Charlie Brown</span></span>

      








  


<time datetime="2014-06-26T00:00:00+08:00" pubdate data-updated="true"></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/ninechap/'>ninechap</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://okckd.github.io/blog/2014/06/26/NineChap-Graph/" data-via="" data-counturl="http://okckd.github.io/blog/2014/06/26/NineChap-Graph/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/06/26/Khan-academy-8-brain-teasers/" title="Previous Post: [Brain teaser] Khan Academy 8 brain teasers">&laquo; [Brain teaser] Khan Academy 8 brain teasers</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/06/27/Previous-Permutation/" title="Next Post: [LintCode] Previous Permutation">[LintCode] Previous Permutation &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/classic/'>classic (3)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (56)</a></li>
<li class='category'><a href='/blog/categories/epic/'>epic (1)</a></li>
<li class='category'><a href='/blog/categories/experience/'>experience (2)</a></li>
<li class='category'><a href='/blog/categories/facebook/'>facebook (7)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (35)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (153)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (85)</a></li>
<li class='category'><a href='/blog/categories/string-search/'>string search (5)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (7)</a></li>
<li class='category'><a href='/blog/categories/top-k/'>top k (5)</a></li>
<li class='category'><a href='/blog/categories/twitter/'>twitter (3)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/12/22/overload-override-java-main-method/">[Design] Override/overload Java Main Method</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/12/22/common-root-java-class/">[Design] Common Root of Java Classes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/12/22/can-interface-extend-interface/">[Design] Interface Extend Another Interface</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/12/22/RubyGems-gem-other/">[Ruby] RubyGems, Gem and Other</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/12/22/Maximum-sum-no-adjacent/">[Facebook] Maximum Sum Such That No Two Elements Are Adjacent</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Charlie Brown -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://okckd.github.io/blog/2014/06/26/NineChap-Graph/';
        var disqus_url = 'http://okckd.github.io/blog/2014/06/26/NineChap-Graph/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
