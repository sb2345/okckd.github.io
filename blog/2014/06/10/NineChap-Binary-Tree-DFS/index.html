<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8" />
		<title>[NineChap 3.1] Binary Tree DFS and Divide Conquer - Woodstock Blog</title>
		<meta name="author" content="Charlie Brown">
		
		<meta name="description" content="DFS Recursion or While-Loop? We can use recursion, because unless it&rsquo;s pre-order traverse, binary tree questions can be difficult. Solving the &hellip;">
    	
    	<meta name="viewport" content="width=device-width; initial-scale=1; maximum-scale=1">
    
		<link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
	    <link href="/favicon.png" rel="shortcut icon">
	    <link rel="canonical" href="">
		<link rel="stylesheet" type="text/css" href="/stylesheets/style.css" />
		<link rel="stylesheet" type="text/css" href="/stylesheets/syntax.css" />
		<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
		
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


	</head>

	<body>
		<div id="logo">
	<span id="tags"> 编程 / 思考 / 阅读 / 生活 </span>
	<h1><a href="/">Woodstock Blog</a></h1>
</div>
		<div id="wrapper">
			<div id="content">
				<a target="_blank" style="float:right;margin-top:15px" href="http://twitter.com/share?url=http://blog.libingcun.com/blog/2014/06/10/NineChap-Binary-Tree-DFS/&via=libingcun&text=[NineChap 3.1] Binary Tree DFS and Divide Conquer"><span class="balloon">retweet</span></a>
				<h2>[NineChap 3.1] Binary Tree DFS and Divide Conquer</h2>
				<div class="cnt">
					<h2>DFS</h2>

<h4>Recursion or While-Loop?</h4>

<p>We can use recursion, because unless it&rsquo;s pre-order traverse, binary tree questions can be difficult.</p>

<p>Solving the problem is more important.</p>

<h4>Divide &amp; Conquer Algorithm</h4>

<ol>
<li>Merge Sort</li>
<li>Quick Sort</li>
<li>Most of Binary tree questions</li>
</ol>


<h4>Solution modal</h4>

<p>Generally, D&amp;C questions would do 2 things at same time:</p>

<ol>
<li>Divide &ndash; For binary tree, it mean solve left child, and solve right child</li>
<li>Conquer &ndash; return result value</li>
</ol>


<p>A very common type would be validating the left/right children and return -1 if the validation failed. Otherwise, a result value is returned. In this way, by checking the positive/negative sign, we know whether this node is valid, and if valid, we know the returned value.</p>

<p>This idea is extensivelly used among all binary tree questions. See &ldquo;Lowest Common Ancestor (LCA)&rdquo; for more details.</p>

<h4>Template</h4>

<p><strong>Divide &amp; Conquer</strong>, <a href="http://answer.ninechapter.com/solutions/dfs-template/">link</a></p>

<pre><code>public class Solution {
    public ResultType traversal(TreeNode root) {
        // null or leaf
        if (root == null) {
            // do something and return;
        }

        // Divide
        ResultType left = traversal(root.left);
        ResultType right = traversal(root.right);

        // Conquer
        ResultType result = Merge from left and right.
        return result;
    }
}
</code></pre>

<h2>Question list</h2>

<p><strong>Traversal</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/06/02/Binary-Tree-Preorder-Traversal/">Binary Tree Preorder Traversal</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/24/Binary-Tree-Inorder-Traversal/">Binary Tree Inorder Traversal</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/03/Binary-Tree-Postorder-Traversal/">Binary Tree Postorder Traversal</a></strong></p></li>
</ol>


<p><strong>Divide &amp; Conquer</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/25/Maximum-Depth-of-Binary-Tree/">Maximum Depth of Binary Tree</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/25/Minimum-Depth-of-Binary-Tree/">Minimum Depth of Binary Tree</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/26/Balanced-Binary-Tree/">Balanced Binary Tree</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/28/Binary-Tree-Maximum-Path-Sum/">Binary Tree Maximum Path Sum</a></strong> &ndash; the most important question for this category</p></li>
</ol>


<h4>Additional</h4>

<ol>
<li><p><strong>Lowest Common Ancestor Problem</strong></p>

<p> <a href="/blog/2014/06/10/Lowest-Common-Ancestor-BST/">problem one</a></p>

<p> <a href="/blog/2014/06/10/Lowest-Common-Ancestor-Tree/">problem two</a></p>

<p> <a href="/blog/2014/06/10/Lowest-Common-Ancestor-Tree-II/">problem three</a></p></li>
</ol>


<h2>Code</h2>

<p><strong>Binary Tree Preorder Traversal</strong></p>

<pre><code>public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; ans = new LinkedList&lt;Integer&gt;();
    if (root == null) return ans;
    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode cur = stack.pop();
        ans.add(cur.val);
        if (cur.right != null) {
            stack.push(cur.right);
        } 
        if (cur.left != null) {
            stack.push(cur.left);
        }
    }
    return ans;
}
</code></pre>

<p>There is a not-recommended but good-to-know solution of Divide &amp; Conquer (not written by me)</p>

<pre><code>public class Solution {
    public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) {
        ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        // null or leaf
        if (root == null) {
            return result;
        }

        // Divide
        ArrayList&lt;Integer&gt; left = preorderTraversal(root.left);
        ArrayList&lt;Integer&gt; right = preorderTraversal(root.right);

        // Conquer
        result.add(root.val);
        result.addAll(left);
        result.addAll(right);
        return result;
    }
}
</code></pre>

<p><strong>Binary Tree Inorder Traversal</strong></p>

<p>Keep traversing left until a NULL is found. When it happens, pop one and traverse right once. <strong>Remember this solution</strong>!</p>

<pre><code>public ArrayList&lt;Integer&gt; inorderTraversal(TreeNode root) {
    ArrayList&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();
    if (root == null) {
        return ans;
    }
    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
    TreeNode p = root;
    while (p != null || !stack.isEmpty()) {
        if (p != null) {
            stack.push(p);
            p = p.left;
        }
        else {
            p = stack.pop();
            ans.add(p.val);
            p = p.right;
        }
    }
    return ans;
}
</code></pre>

<p><strong>Binary Tree Postorder Traversal</strong></p>

<p>I failed to write the code even after reading the solution. I need to memorize this solution by heart.</p>

<pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();
    if (root == null) {
        return ans;
    }
    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
    stack.push(root);
    TreeNode pre = null;
    TreeNode cur = null;
    while (!stack.isEmpty()) {
        cur = stack.peek();
        if (pre == null || pre.left == cur || pre.right == cur) {
            if (cur.left != null) {
                stack.push(cur.left);
            } else if (cur.right != null) {
                stack.push(cur.right);
            }
        } else if (cur.left == pre) {
            if (cur.right != null) {
                stack.push(cur.right);
            }
        } else if (cur.right == pre || cur == pre) {
            // note that 'pre' and 'cur' are never going to be apart
            // for more then 1 edge (they can overlap) 
            ans.add(stack.pop().val);
        }
        pre = cur;
    }
    return ans;
}
</code></pre>

<p><strong>Maximum Depth of Binary Tree</strong></p>

<pre><code>// 1 minute
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
</code></pre>

<p><strong>Minimum Depth of Binary Tree</strong></p>

<pre><code>public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return checkLeaf(root);
}

private int checkLeaf(TreeNode node) {
    if (node.left == null &amp;&amp; node.right == null) {
        return 1;
    }
    int ll = Integer.MAX_VALUE;
    int rr = Integer.MAX_VALUE;
    if (node.left != null) ll = checkLeaf(node.left);
    if (node.right != null) rr = checkLeaf(node.right);
    return 1 + Math.min(ll, rr);
}
</code></pre>

<p>After checking <a href="http://answer.ninechapter.com/solutions/minimum-depth-of-binary-tree/">the answer</a>, the code above can be optimized:</p>

<pre><code>public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return getMin(root);
}

public int getMin(TreeNode root){
    if (root == null) {
        return Integer.MAX_VALUE; // important
    }

    if (root.left == null &amp;&amp; root.right == null) {
        return 1;
    }

    return Math.min(getMin(root.left), getMin(root.right)) + 1;
}
</code></pre>

<p><strong>Balanced Binary Tree</strong></p>

<pre><code>// 4 minutes
public boolean isBalanced(TreeNode root) {
    return getDepth(root) != -1;
}

private int getDepth(TreeNode node) {
    if (node == null) {
        return 0;
    }
    int ll = getDepth(node.left);
    int rr = getDepth(node.right);
    if (ll == -1 || rr == -1 || Math.abs(ll - rr) &gt; 1) {
        return -1;
    }
    return 1 + Math.max(ll, rr);
}
</code></pre>

<p><strong>Binary Tree Maximum Path Sum</strong></p>

<p>Although the following code works:</p>

<pre><code>int max = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) {
    maxDepth(root);
    return max;
}

private int maxDepth(TreeNode node) {
    if (node == null) {
        return 0;
    }
    int ll = maxDepth(node.left);
    int rr = maxDepth(node.right);
    int currentMaxPath = ll + rr + node.val;
    max = Math.max(max, currentMaxPath);
    return Math.max(0, node.val + Math.max(ll, rr));
}
</code></pre>

<p>Mr. Huang said it&rsquo;s AN EXTREMELY BAD IDEA TO USE GLOBAL VARIABLE in Java. It&rsquo;s just terrible. Don&rsquo;t do it.</p>

<p>According to Mr. Huang&rsquo;s <a href="http://answer.ninechapter.com/solutions/binary-tree-maximum-path-sum/">suggestion</a>, I added another class called &ldquo;ResultType&rdquo;. This can help me return 2 values at 1 single traversal.</p>

<p>Code is below. One &lsquo;catch-ya&rsquo; is when NULL is found, the maxPath should return Integer.MIN_VALUE instead of 0.</p>

<p>This code is much easier for both me and anyone else to understand, so <strong>stick to this solution, and never use global variable in Java</strong>!</p>

<pre><code>private class ResultType {
    int singlePath, maxPath;
    ResultType(int singlePath, int maxPath) {
        this.singlePath = singlePath;
        this.maxPath = maxPath;
    }
}

public int maxPathSum(TreeNode root) {
    ResultType result = helper(root);
    return result.maxPath;
}

private ResultType helper(TreeNode node) {
    // null case
    if (node == null) {
        return new ResultType(0, Integer.MIN_VALUE);
    }
    // divide
    ResultType ll = helper(node.left);
    ResultType rr = helper(node.right);
    // conquer
    int curSinglePath = Math.max(0, node.val + 
            Math.max(ll.singlePath, rr.singlePath));
    int childMaxPath = Math.max(ll.maxPath, rr.maxPath);
    int curMaxPath = Math.max(childMaxPath, node.val + 
            ll.singlePath + rr.singlePath);
    // done
    return new ResultType(curSinglePath, curMaxPath);
}
</code></pre>

<p><strong>Lowest Common Ancestor</strong> &ndash; I wrote three new posts on this topic:</p>

<p>Problem 1: BST: top-down O(height) solution</p>

<p>Problem 2: Binary Tree: bottom-up O(n) solution</p>

<p>Problem 3: Binary Tree with a link to parent</p>

					<br />
					--EOF--
					<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
				</div>
				<div id="disqus_thread"></div>
				

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://okckd.github.io/blog/2014/06/10/NineChap-Binary-Tree-DFS/';
        var disqus_url = 'http://okckd.github.io/blog/2014/06/10/NineChap-Binary-Tree-DFS/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>


			</div>
			
			<div id="footer">
				<span style="color:#bbb;font-size:12px">To do less than best is a sin.</span>
<p style="clear:both"></p>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.1/jquery.min.js"></script>
			</div>
		</div>
	</body>
</html>

