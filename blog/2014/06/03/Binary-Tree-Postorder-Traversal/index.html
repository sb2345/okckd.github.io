
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>[LeetCode 145] Binary Tree Postorder Traversal - Shuatiblog.com</title>
  <meta name="author" content="codemonkey">

  
  <meta name="description" content="Question link Given a binary tree, return the postorder traversal of its nodes&#8217; values. For example:
Given binary tree {1,#,2,3}, 1 \ 2 / 3 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/blog/2014/06/03/Binary-Tree-Postorder-Traversal/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Shuatiblog.com" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="blue_light">
            Shuatiblog.com
        </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">[LeetCode 145] Binary Tree Postorder Traversal</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-03T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/binary-tree-postorder-traversal/">link</a></p>

<div class="question-content bg-color bg-img font-color">
            <p class="font-color"></p><p class="font-color">Given a binary tree, return the <i>postorder</i> traversal of its nodes&#8217; values.</p>

<p class="font-color">
For example:<br>
Given binary tree <code>{1,#,2,3}</code>,<br>
</p><pre>   1
    \
     2
    /
   3
</pre>
<p class="font-color"></p>
<p class="font-color">
return <code>[3,2,1]</code>.
</p>

<p class="font-color"><b>Note:</b> Recursive solution is trivial, could you do it iteratively?</p><p class="font-color"></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>Unlike pre-order traversal, <strong>this is a very difficult question</strong>.</p>

<h3>Solution</h3>

<p><strong>First, I wrote the solution using a HashSet, and it works</strong>. However, this solution is not good because it uses some space.
For more generalized way to write DFS code, read another post <strong>Implement DFS using a Stack</strong>.</p>

<p><strong>The best and most popular solution is proposed by <a href="http://leetcode.com/2010/10/binary-tree-post-order-traversal.html">1337c0d3r</a></strong>. It basically uses 1 more pointer to track the current status (whether I&rsquo;m traversing down, or up, and in which direction etc.). The extra pointer is called &lsquo;prev&rsquo;.</p>

<blockquote><p>We use a prev variable to keep track of the previously-traversed node. Let’s assume curr is the current node that’s on top of the stack. When prev is curr‘s parent, we are traversing down the tree. In this case, we try to traverse to curr‘s left child if available (ie, push left child to the stack). If it is not available, we look at curr‘s right child. If both left and right child do not exist (ie, curr is a leaf node), we print curr‘s value and pop it off the stack.</p>

<p>If prev is curr‘s left child, we are traversing up the tree from the left. We look at curr‘s right child. If it is available, then traverse down the right child (ie, push right child to the stack), otherwise print curr‘s value and pop it off the stack.</p>

<p>If prev is curr‘s right child, we are traversing up the tree from the right. In this case, we print curr‘s value and pop it off the stack.</p></blockquote>

<p>Referring to his code, I wrote the 2nd piece of code below and it works.</p>

<p><strong>Amazingly, that code can be simplified, which becomes the 3rd code</strong> (I thought it won&rsquo;t pass at first). The way that code got simplified is by keeping current pointer steady, so that the 2 pointers can meet. Altough program logic is exactly same, this interesting code is worth reading.</p>

<h3>Code</h3>

<p><strong>First, my solution using HashSet</strong></p>

<pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; ans = new LinkedList&lt;Integer&gt;();
    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
    if (root != null) stack.push(root);
    HashSet&lt;TreeNode&gt; visited = new HashSet&lt;TreeNode&gt;();
    while (!stack.isEmpty()) {
        TreeNode cur = stack.pop();
        if (visited.contains(cur))
            ans.add(cur.val);
        else {
            stack.push(cur);
            visited.add(cur);
            if (cur.right != null) stack.push(cur.right);
            if (cur.left != null) stack.push(cur.left);
        }
    }
    return ans;
}
</code></pre>

<p><strong>Second, using 2 pointers</strong></p>

<pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; ans = new LinkedList&lt;Integer&gt;();
    if (root == null) {
        return ans;
    }
    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
    stack.push(root);
    TreeNode pre = null, cur = null;
    while (!stack.isEmpty()) {
        cur = stack.peek();
        if (pre == null || pre.left == cur || pre.right == cur) {
            if (cur.left == null &amp;&amp; cur.right == null) {
                ans.add(stack.pop().val);
            }
            else if (cur.left != null) {
                stack.push(cur.left);
            }
            else if (cur.right != null) {
                stack.push(cur.right);
            }
        }
        else if (cur.left == pre) {
            if (cur.right != null) {
                stack.push(cur.right);
            }
            else {
                ans.add(stack.pop().val);
            }
        }
        else if (cur.right == pre) {
            ans.add(stack.pop().val);
        }
        pre = cur;
    }
    return ans;
}
</code></pre>

<p><strong>Third, simplified version of 2nd code</strong></p>

<p><strong>Commented on June 10th</strong>: Note that &lsquo;pre&rsquo; and &lsquo;cur&rsquo; are never going to be apart for more then 1 edge (they can overlap)</p>

<pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
    TreeNode prev = null; // previously traversed node
    TreeNode curr = root;
    if (root == null) {
        return result;
    }
    stack.push(root);
    while (!stack.empty()) {
        curr = stack.peek();
        if (prev == null || prev.left == curr || prev.right == curr) {
        // traverse down the tree
            if (curr.left != null) {
                stack.push(curr.left);
            } else if (curr.right != null) {
                stack.push(curr.right);
            }
        } else if (curr.left == prev) {
        // traverse up the tree from the left
            if (curr.right != null) {
                stack.push(curr.right);
            }
        } else if (curr.right == prev || curr == prev){
        // traverse up the tree from the right
        // or at a leaf point
            result.add(curr.val);
            stack.pop();
        }
        prev = curr;
    }
    return result;
}
</code></pre>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">codemonkey</span></span>

      








  


<time datetime="2014-06-03T00:00:00+08:00" pubdate data-updated="true"></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/leetcode/'>leetcode</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://okckd.github.io/blog/2014/06/03/Binary-Tree-Postorder-Traversal/" data-via="" data-counturl="http://okckd.github.io/blog/2014/06/03/Binary-Tree-Postorder-Traversal/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/06/03/Big-endian-little-endian/" title="Previous Post: [Design] Big Endian and Little Endian">&laquo; [Design] Big Endian and Little Endian</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/06/03/Evaluate-Reverse-Polish-Notation/" title="Next Post: [LeetCode 150] Evaluate Reverse Polish Notation">[LeetCode 150] Evaluate Reverse Polish Notation &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
      
      
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- adad -->
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-5312789273887679"
         data-ad-slot="8425093949"
         data-ad-format="auto"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
      
      
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- adad -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-5312789273887679"
     data-ad-slot="8425093949"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script><section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (72)</a></li>
<li class='category'><a href='/blog/categories/experience/'>experience (3)</a></li>
<li class='category'><a href='/blog/categories/facebook/'>facebook (10)</a></li>
<li class='category'><a href='/blog/categories/fundamental/'>fundamental (11)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (63)</a></li>
<li class='category'><a href='/blog/categories/java-oop/'>java oop (28)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (156)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (16)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (119)</a></li>
<li class='category'><a href='/blog/categories/string-search/'>string search (17)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (7)</a></li>
<li class='category'><a href='/blog/categories/top-k/'>top k (7)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/04/07/Min-Stack/">[LeetCode 155] Min Stack </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/04/07/Maximum-Product-Subarray/">[LeetCode 152] Maximum Product Subarray </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/04/07/Find-Minimum-in-Rotated-Sorted-Array-II/">[LeetCode 154] Find Minimum in Rotated Sorted Array II </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/04/07/Find-Minimum-in-Rotated-Sorted-Array/">[LeetCode 153] Find Minimum in Rotated Sorted Array </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/15/HBase-and-HDFS/">[Design] HBase and HDFS</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
    Copyright &copy; 2015 - <a href="/about">codemonkey</a> -  All posts are my original writing, based uppon my personal view. <a href="/policy">Privacy Policy</a> - 
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://okckd.github.io/blog/2014/06/03/Binary-Tree-Postorder-Traversal/';
        var disqus_url = 'http://okckd.github.io/blog/2014/06/03/Binary-Tree-Postorder-Traversal/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
