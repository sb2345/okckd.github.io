<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: design | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/design/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-24T18:46:38+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Design] Distributed Caching - memcached ]]></title>
    <link href="http://okckd.github.io/blog/2015/01/24/distributed-caching-memcached/"/>
    <updated>2015-01-24T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/24/distributed-caching-memcached</id>
    <content type="html"><![CDATA[<h3>What is Memcached?</h3>

<p><a href="http://memcached.org/">Memcached</a> is an <strong>in-memory key-value store for small chunks of arbitrary data</strong> (strings, objects) from results of database calls, API calls, or page rendering.</p>

<ol>
<li>Free &amp; open source</li>
<li>high-performance, distributed memory object caching system</li>
<li>generic in nature</li>
<li>intended for use in speeding up dynamic web applications by alleviating database load</li>
</ol>


<p>Definition from <a href="http://en.wikipedia.org/wiki/Memcached">wiki</a>:</p>

<blockquote><p>Memcached is a <strong>general-purpose distributed memory caching system</strong>. It is often used to speed up dynamic database-driven websites by <strong>caching data and objects in RAM</strong> to reduce the number of times an <strong>external data source</strong> (such as a database or API) must be read.</p></blockquote>

<h3>Who uses Memcached?</h3>

<ol>
<li>Facebook</li>
<li>YouTube</li>
<li>Twitter</li>
<li>Amazon</li>
<li>Reddit</li>
<li>Yahoo</li>
<li>Zynga</li>
</ol>


<h3>Why Memcached?</h3>

<p>Run memcached on one or more hosts and then use the shared cache to store objects. Because each host’s RAM is storing information, the access speed <a href="http://www.blogs.zeenor.com/category/interview-questions/page/9">will be much faster than</a> having to load the information from disk. This can provide <strong>a significant performance boost in retrieving data</strong> versus loading the data natively from a database.</p>

<p>Also, because the cache is just a repository for information, you can use the cache to store <strong>any data, including complex structures</strong> that would normally require a significant amount of effort to create, but in <strong>a ready-to-use format</strong>, helping to reduce the load on your MySQL servers.</p>

<h3>FAQ</h3>

<p><strong>What is Memcached?</strong></p>

<p><a href="http://www.web-technology-experts-notes.in/2014/09/memcached-interview-questions-and-answers.html">It is component</a> which stored the data temporary for 1 Hour/ 6 Hour/1 Day etc. When we integrate the Memcached with our application, performance of application increased.</p>

<p>Memcached is open source, high-performance distributed memory object used for caching so that execution can be enhanced at nth level.</p>

<p><strong>Where Memcached can be used?</strong></p>

<p>•  Social Networking &ndash;> Profile Caching
•  Content Aggregation &ndash;> HTML/ Page Caching
•  Ad targeting &ndash;> Cookie/profile tracking
•  Relationship &ndash;> Session caching
•  E-commerce &ndash;> Session and HTML caching
•  Location-based services &ndash;> Data-base query scaling
•  Gaming and entertainment &ndash;> Session caching</p>

<p><strong>Why use Memcached?</strong></p>

<p>•  Speed up application processes
•  It determines what to store and what not to
•  Reduce the number of retrieval requests to the database
•  Cuts down the I/O ( Input/Output) access (hard disk)</p>

<p><strong>In what condition does retrieving cache fail?</strong></p>

<p>•  Memory allocated for the cache is exhausted
•  Item from cache is deleted
•  Individual item in the cache is expired</p>

<p><strong>What is the drawback of Memcached?</strong></p>

<p>•  It is not a persistent data store
•  Not a database
•  It is not an application specific
•  It cannot cache large object</p>

<p><strong>Give more details about memcached failures</strong></p>

<p><a href="http://programmers.stackexchange.com/a/187101">Memcached servers</a> are indeed independent of each other. Memcached server is just an efficient key-value store implemented as in-memory hash table.</p>

<p><strong>What makes memcached distributed is the client</strong>, which in most implementations can connect to a pool of servers. Typical implementations use consistent hashing, which means that when you add or remove server to/from a pool of N servers, you only have to remap 1/N keys.</p>

<p>Typically keys are <strong>not duplicated</strong> on various hosts, as memcached is <strong>not meant to be persistent store</strong> and gives no guarantees that your value will persist (for example when running out of assigned memory, memcached server drops least recently used (LRU) elements). Thus it&rsquo;s assumed that your application should handle missing keys.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Design Google Suggest (autocomplete) ]]></title>
    <link href="http://okckd.github.io/blog/2015/01/24/design-google-suggest-autocomplete/"/>
    <updated>2015-01-24T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/24/design-google-suggest-autocomplete</id>
    <content type="html"><![CDATA[<h3>Overview</h3>

<p><strong>Google Suggest</strong> was <a href="http://googleblog.blogspot.sg/2004/12/ive-got-suggestion.html">launched in 2004</a> as a 20% time project from Google engineer Kevin Gibbs. He developed the idea on a <a href="http://www.theatlantic.com/technology/archive/2013/08/how-googles-autocomplete-was-created-invented-born/278991/">Google shuttle bus</a>.</p>

<h3>Design</h3>

<ol>
<li>Use trie.</li>
<li>Use cache (distributed cache)</li>
</ol>


<h4>Trie</h4>

<p><a href="http://stackoverflow.com/questions/7058724/how-to-create-an-efficient-auto-complete">http://stackoverflow.com/questions/7058724/how-to-create-an-efficient-auto-complete</a></p>

<h4>Memcached</h4>

<p>Distributed caching + LRU replacement algorithm. Refer to <strong>[Design] Distributed Caching &ndash; memcached</strong> for more.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Difference between HTTP and HTTPS ]]></title>
    <link href="http://okckd.github.io/blog/2015/01/20/difference-http-https/"/>
    <updated>2015-01-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/20/difference-http-https</id>
    <content type="html"><![CDATA[<p><a href="http://stackoverflow.com/a/8375247">ref</a></p>

<h4>1: What are benefits of using HTTPS over HTTP?</h4>

<p>HTTPS means that you <strong>tunnel the HTTP protocol over TLS/SSL</strong> which encrypts the HTTP payload.</p>

<p>So the benefit is that HTTP requests and responses are transmitted securely over the wire, e.g. your Internet Service Provider does not know what you&rsquo;re doing.</p>

<p><a href="http://stackoverflow.com/a/548042">When Google switched Gmail to use HTTPS</a>, no additional resources were required; no network hardware, no new hosts. It only increased CPU load by about 1%.</p>

<h4>2: How to use HTTPS?</h4>

<p>Enable it at your endpoint, in general <strong>a web server in front of your application server</strong>. Most web servers (e.g. IIS, Apache) support this by configuration. Depending on your confidentiality requirements this may not be enough.</p>

<h4>3: Can we use HTTPS for only login purpose and then onwords HTTP?</h4>

<p>Technically this is possible, but it introduces some security risks. Example: After a secured login you transmit session IDs identifying the user. If you transmit those session IDs unsecurely (no SSL), session hijacking becomes a risk (&lsquo;man-in-the-middle&rsquo;)</p>

<h4>4: What settings needs to be done for making website HTTPS?</h4>

<p>See #2. In public internet scenarios you should request (buy) a certificate from a certain Certificate Authority (CA), so that end user clients can verify whether they should trust your certificate.</p>

<h4>5: Is there any threat present in HTTPS?</h4>

<p>In the protocol itself there is a slight risk of <strong>man-in-the-middle attacks</strong>. E.g. a proxy between the client and server could pretend to be the server itself (this requires a successful attack to network infrastructure, e.g. DNS). There are several other &lsquo;more obscure&rsquo; risks that do not relate to the protocol itself, e.g.:</p>

<ol>
<li>usage of an outdated encryption key length (e.g. 256 bit)</li>
<li>loss of private keys or unappropriate key management procedures (e.g. send via unencrypted email)</li>
<li>certificate authority failure</li>
</ol>


<h4>6: Is processing time required for HTTPS is greater than HTTP?</h4>

<p>Yes, key negotiation (handshaking) <strong>requires a lot CPU capacity</strong>.</p>

<p>{% img middle /assets/images/http-vs-https.png %}</p>

<h3>Port Number</h3>

<p>HTTP uses <strong>port 80 or 8080</strong>, while HTTPS uses <strong>TCP port 443</strong>.</p>

<p><a href="http://www.coderanch.com/t/168608/java-Web-Component-SCWCD/certification/Diff">The reason</a> that some applications use 8080 (7080, 9080) instead of 80 is that on UNIX, <strong>port numbers below 1024</strong> are reserved for <strong>super-user</strong> processes.</p>

<p>That&rsquo;s why for OS compatibility reasons, some servers use other ports (greater than 1024). But they still have &ldquo;80&rdquo; inside the numner, eg. 7080, 8080, 9080.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Speed Up Webpage for Slow Connection (2) ]]></title>
    <link href="http://okckd.github.io/blog/2015/01/19/speed-up-web-page-2/"/>
    <updated>2015-01-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/19/speed-up-web-page-2</id>
    <content type="html"><![CDATA[<p><a href="www.geeksforgeeks.org/amazon-interview-set-72-campus-sde-1">ref</a></p>

<h3>Question</h3>

<blockquote><p>Suppose you are handling Amazon website and you have 10 MB size home page. Optimize the homepage for a customer who has 100 kbps internet connection.</p>

<p>Further he asked for the customer who has 100 mbps internet connection.</p></blockquote>

<h3>Website KPI</h3>

<p>There are <a href="https://community.compuwareapm.com/community/display/PUB/Best+Practices+on+Web+Site+Performance+Optimization">3 interesting phases</a> of a web site from an end-user performance perspective.</p>

<ol>
<li>First Impression</li>
<li>OnLoad</li>
<li>Fully Loaded Time.</li>
</ol>


<h3>Loading Time</h3>

<p><strong>Question: what percentage of the time a user spends waiting for your page to load is spent after the HTML comes back to their browser</strong>?</p>

<p>It is typically <strong><a href="http://www.sitepoint.com/seven-mistakes-that-make-websites-slow/">over 90%</a></strong>.</p>

<p>Most of the time users spend waiting on your website is spent after the HTML page has been retrieved by their browser.</p>

<h4>Fetching the HTML is just the beginning</h4>

<p><strong>In a nutshell, browsers parse your page’s HTML, sequentially discovering its assets</strong> (such as scripts, stylesheets, and images), requesting and then either parsing and executing them or displaying them as appropriate.</p>

<p>But these assets are not simply fetched all at once. Instead, the <strong>browser opens a limited number of connections to the server(s)</strong> referenced by the page. There is <strong>overhead involved in establishing TCP and HTTP connections</strong>, and some <strong>unavoidable latency</strong> in pushing the request and response bytes back and forth across the network.</p>

<p>So, in general, round trips between the browser and server are expensive. The structure of the HTML markup, the number and the ordering of its assets, are absolutely critical factors in its performance.</p>

<h3>What hijacks your load time</h3>

<h4>1. Too Many HTTP Requests</h4>

<p>This is the single biggest contributor to performance problems in most web pages.</p>

<ol>
<li><p>Concatenate scripts and stylesheets</p></li>
<li><p>Combine images with sprites (put common images into a single large image file, then use CSS to position and selectively display the appropriate portion of the sprite image)</p></li>
<li><p>Use fewer images, more CSS.</p></li>
</ol>


<h4>2. Minimal Client-side Processing</h4>

<ol>
<li><p>Validation on client. (eg. form input)</p></li>
<li><p>Use web standards and MVC separation, making a maintainable, accessible, future-proof and max-performance website.</p>

<p> Think of the HTML as the model, the CSS as the view, and the JavaScript as the controller. This separation tends to make code more efficient and maintainable, and makes many optimization techniques much more practical to apply.</p></li>
<li><p>Push presentation code into the client tier (eg. Charts and graphs — push raw data to the client in JSON format, and use JavaScript and CSS to create pretty graphs.)</p></li>
<li><p>Leverage Ajax techniques (only requiring small parts of the page to change in response to user actions)</p></li>
</ol>


<h4>3. Low Number of Parallel Requests</h4>

<p>Fetch a script, parse and execute it, then fetch another one&hellip; this will use up all the available connections. There are things you can do to your HTML to allow virtually any browser to make many requests at once, which has a huge impact on latency.</p>

<ol>
<li><p>Use browser-appropriate domain sharding</p></li>
<li><p>Use intelligent script loading</p></li>
<li><p>Leverage Keep-Alive (reuse the same TCP connection for multiple HTTP request/response cycles)</p></li>
</ol>


<h4>4. Failure to leverage browser cache / local storage</h4>

<ol>
<li><p><a href="http://www.mnot.net/cache_docs/">HTTP cache overview</a></p></li>
<li><p>Leverage local storage</p></li>
</ol>


<h4>5. Third-party widgets</h4>

<ol>
<li>Avoid third-party widgets!</li>
<li>Try to use widgets that provide asynchronous implementations, so their inevitably terrible performance impacts their widget without dragging down your entire UX with it.</li>
</ol>


<h4>7. Failure to Use a Global Network</h4>

<p>Amazon S3.</p>

<p>Ref: <a href="http://www.sitepoint.com/seven-mistakes-that-make-websites-slow/">http://www.sitepoint.com/seven-mistakes-that-make-websites-slow/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Difference between HTTP protocol and TCP protocol ]]></title>
    <link href="http://okckd.github.io/blog/2015/01/19/difference-http-tcp/"/>
    <updated>2015-01-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/19/difference-http-tcp</id>
    <content type="html"><![CDATA[<p><a href="http://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol">ref</a></p>

<h3>Short Version</h3>

<p>TCP is a <strong>transport-layer</strong> protocol, and HTTP is an <strong>application-layer</strong> protocol that runs over TCP.</p>

<h3>The layers</h3>

<p>At the very bottom of the network stack is the <strong>physical layer</strong>. This is where electrical signals or light pulses or radio waves actually transmit information from place to place. The physical layer doesn&rsquo;t really have protocols, but instead has standards for voltages, frequencies, and other physical properties. You can transmit information directly this way, but you need a lot of power or a dedicated line, and without higher layers you won&rsquo;t be able to share bandwidth.</p>

<p>The next layer up is the <strong>link layer</strong>. This layer covers communication with devices that share a physical communications medium. Here, protocols like Ethernet, 802.11a/b/g/n, and Token Ring specify how to handle multiple concurrent accesses to the physical medium and how to direct traffic to one device instead of another. In a typical home network, this is how your computer talks to your home &ldquo;router.&rdquo;</p>

<p>The third layer is the <strong>network layer</strong>. In the majority of cases, this is dominated by Internet Protocol (IP). This is where the magic of the Internet happens, and you get to talk to a computer halfway around the world, without needing to know where it is. Routers handle directing your traffic from your local network to the network where the other computer lives, where its own link layer handles getting the packets to the right computer.</p>

<p>Now we are getting somewhere. We can talk to a computer somewhere around the world, but that computer is running lots of different programs. How should it know which one to deliver your message to? The <strong>transport layer</strong> takes care of this, usually with <strong>port numbers</strong>. The two most popular transport layer protocols are TCP and UDP. TCP does a lot of interesting things to smooth over the rough spots of network-layer packet-switched communication like reordering packets, retransmitting lost packets, etc. UDP is more unreliable, but has less overhead.</p>

<p>So we&rsquo;ve connected your browser to the web server software on the other end, but how does the server know what page you want? How can you post a question or an answer? These are things that <strong>application-layer</strong> protocols handle. For <strong>web traffic</strong>, this is the HyperText Transfer Protocol (HTTP). There are thousands of application-layer protocols: SMTP, IMAP, and POP3 for email; XMPP, IRC, ICQ for chat; Telnet, SSH, RDP for remote administration; etc.</p>

<p>Ref: <a href="http://qr.ae/3pnJK">http://qr.ae/3pnJK</a></p>
]]></content>
  </entry>
  
</feed>
