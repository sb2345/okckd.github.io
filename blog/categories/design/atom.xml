<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/design/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-06T02:05:11+09:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Design] Database Indexing]]></title>
    <link href="http://okckd.github.io/blog/2014/12/27/database-indexing/"/>
    <updated>2014-12-27T00:00:00+09:00</updated>
    <id>http://okckd.github.io/blog/2014/12/27/database-indexing</id>
    <content type="html"><![CDATA[[ref 1](http://stackoverflow.com/a/1130) [ref 2](http://www.interspire.com/content/2006/02/15/introduction-to-database-indexes/)

### Why Indexing?

In database disks (we're talking about disk-based storage devices), data is stored as blocks. These blocks are accessed atomically. It's like a linked list with pointers to the blocks. 

Because of this, searching in database is linear time. That's why we need indexing. 

__Indexing is a way of sorting a number of records on multiple fields__. Creating an index on a field in a table creates another data structure which holds the field value, and pointer to the record it relates to. This index structure is then sorted, allowing Binary Searches to be performed on it. 

In other words, indexing speed up search. 

### Downside

First disadvantage is __the additional space usage__. For example, in MyISAM engine, indexes are stored together with the data in one table. So the indexing files can quickly reach the size limits if many fields are indexed. 

Second disadvantage is that __using too many indexes can actually slow your database down__. Each time a page or database row is updated or removed, the reference or index also has to be updated. 

So indexes speed up finding data, but slow down inserting, updating or deleting data.

### Primary keys

__Some fields are automatically indexed__. 

A primary key or a field marked as ‘unique’ – for example an email address, a userid or a social security number – are __automatically indexed__ so the database can quickly check to make sure that you’re not going to introduce bad data.

### When to use

Since indexes are __only__ used to speed up the searching, it's not wise to have indexing used only for output. 

__The general rule__ is, anything that is used to limit the number of results you’re trying to find. For more details, read [ref 2](http://www.interspire.com/content/2006/02/15/introduction-to-database-indexes/). 

### How to create index

[The following](http://stackoverflow.com/a/1157) is SQL92 standard that's supported by major RDMBSs:

    CREATE INDEX [index name] ON [table name] ( [column name] )
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] DNS Communication Protocol]]></title>
    <link href="http://okckd.github.io/blog/2014/09/12/DNS-communication-protocol/"/>
    <updated>2014-09-12T00:00:00+09:00</updated>
    <id>http://okckd.github.io/blog/2014/09/12/DNS-communication-protocol</id>
    <content type="html"><![CDATA[### Question 

> What protocol is used for communicating with a DNS? 

### Answer

[Domain Name System](http://en.wikipedia.org/wiki/Domain_Name_System) (DNS) is a hierarchical distributed naming system for computers, services, or any resource connected to the Internet or a private network. It associates various information with domain names assigned to each of the participating entities. Most prominently, it translates easily memorized domain names to the numerical IP addresses needed for the purpose of locating computer services and devices worldwide. The Domain Name System is an essential component of the functionality of the Internet. 

[DNS primarily uses](http://en.wikipedia.org/wiki/Domain_Name_System#Protocol_transport) __User Datagram Protocol (UDP)__ on port number 53 to serve requests. 

DNS queries consist of a single UDP request from the client followed by a single UDP reply from the server. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Leader Election]]></title>
    <link href="http://okckd.github.io/blog/2014/09/03/Leader-election/"/>
    <updated>2014-09-03T00:00:00+09:00</updated>
    <id>http://okckd.github.io/blog/2014/09/03/Leader-election</id>
    <content type="html"><![CDATA[### Question 

(this question is from MIT handouts B)

> Describe a technique to identify a "leader" among a group of 10 identical servers that are all connected to every other server. 

> There are no prior distinguishing characteristics of any of them and the same program to identify the leader starts running on all of them at the same time. After an answer is given, ask how much network traffic it requires and, if "ties" are possible, ask how you can break ties.

### Leader Election 

__[Leader Election](http://en.wikipedia.org/wiki/Leader_election)__ is the process of designating a single process as the organizer of some task distributed among several computers. After running this algorithm, each node throughout the network recognizes a unique node as the task leader. 

The good answer would be: 

Have each server wait a random amount of time and then say "I'm it." The "I'm it" __announcement is time‐stamped__, and the computer that __time‐stamped its announcement first__ is elected the leader. 

This approach requires sending out 9 messages. __If there is a tie__, the computers can repeat the procedure.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Multithreading - Deadlock Prevention]]></title>
    <link href="http://okckd.github.io/blog/2014/09/01/Multithreading-deadlock-prevention/"/>
    <updated>2014-09-01T00:00:00+09:00</updated>
    <id>http://okckd.github.io/blog/2014/09/01/Multithreading-deadlock-prevention</id>
    <content type="html"><![CDATA[### Question

> How to prevent deadlock? (question from MIT handouts 1)

### Analysis

Preventing one of the 4 conditions will prevent deadlock: 

1. Removing the __mutual exclusion condition__, but not very possible. 

1. The __hold and wait__ conditions may be removed by requiring processes to request all the resources they will need before starting up. 

1. The __no preemption condition__ may also be difficult or impossible to avoid as a process has to be able to have a resource for a certain amount of time, or the processing outcome may be inconsistent or thrashing may occur. 

1. The final condition is the __circular wait condition__. Approaches that avoid circular waits include disabling interrupts during critical sections and using a hierarchy to determine a partial ordering of resources. 

### Answer

__Assign an order to our locks__ (require that the locks always acquired in order). 

This prevent 2 thread waiting to get the resource in each other's hand. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Cryptographic Hash Function]]></title>
    <link href="http://okckd.github.io/blog/2014/08/30/Cryptographic-Hash-Function/"/>
    <updated>2014-08-30T00:00:00+09:00</updated>
    <id>http://okckd.github.io/blog/2014/08/30/Cryptographic-Hash-Function</id>
    <content type="html"><![CDATA[### Overview

[Cryptographic hash function](http://en.wikipedia.org/wiki/Cryptographic_hash_function) is a hash function which is considered practically impossible to invert. 

The input is arbitrary length, and output is fixed length. 

The input is called 'message' and output (the hash value) is called '__digest__'. 

Common examples are:

1. MD5
1. SHA-1 (said to be [better than MD5](http://security.stackexchange.com/questions/19705/is-sha1-better-than-md5-only-because-it-generates-a-hash-of-160-bits))

#### Properties

1. Computationally efficient
1. Collision resistant
1. Hide information
1. Look random

#### Examples

> I generated checksum values on an important file I backed up to ensure that everything went OK. [source](http://pcsupport.about.com/od/termsm/g/md5.htm)

> To verify that the latest version of Firefox I was downloading is correct, I ran a cryptographic hash function, SHA-1 to be exact, on the download and compared that checksum with the one published on Mozilla's site. [source](http://pcsupport.about.com/od/termsc/g/cryptographic-hash-function.htm)

### Digital signature

[Digital signature](http://en.wikipedia.org/wiki/Digital_signature) is a mathematical scheme for demonstrating the authenticity of a digital message. It uses public/private keys.

In practice, the signature is not used directly on the file, but rather on the [digest of the file](http://en.wikipedia.org/wiki/Digital_signature#How_they_work). 

<img class="middle" src="/assets/images/Digital-Signature-diagram.png">

[Video](https://www.khanacademy.org/economics-finance-domain/core-finance/money-and-banking/bitcoin/v/bitcoin-digital-signatures) on digital signature. 
]]></content>
  </entry>
  
</feed>
