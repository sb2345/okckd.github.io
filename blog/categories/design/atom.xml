<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/design/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-26T01:35:35+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Design] OOD Design of Elevator]]></title>
    <link href="http://okckd.github.io/blog/2014/08/26/Design-OOD-elevator/"/>
    <updated>2014-08-26T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/26/Design-OOD-elevator</id>
    <content type="html"><![CDATA[### Question 

[link](http://thought-works.blogspot.sg/2012/11/object-oriented-design-for-elevator-in.html)

> Object Oriented design for Elevator in a multi-storied apartment 

### A Single Elevator

Use Case: 

1. User
    1. press a button to summon the lift
    1. press a button to get to a specific floor
1. Button
    1. floor button and level button
    1. illuminates when pressed
    1. place an 'elevator request' when pressed
1. Elevator
    1. moves up/down
    1. open/close the door

<img class="middle" src="/assets/images/elevator-class-diagram.png">

__ElevatorRequests Class__

Each button press results in an elevator request which has to be served. Each of these requests is tracked at a global place. ElevatorRequests, the class which stores elevator requests can use different strategies to schedule the elevator requests. 

__ElevatorController__

The elevator is controlled by a controller class which we call ElevatorController. The elevator controller instructs the elevator what to do and also can shutdown/start up the elevator of the building. The elevator controller reads the next elevator request to be processed and serves it. 

__Button (Abstract) Class__

Button is abstract class defining common behavior like illuminate, doNotIlluminate. FloorButton, ElevatorButton extend Button type and define placeRequest() which is invoked when the button is pressed. 

In conclusion, __ElevatorController__ runs the show by reading the __ElevatorRequests__ to process and instructing the __Elevator__ what to do. User send request by pressing __Buttons__. 

### Extend the answer to multiple elevators

1. Each elevator have 1 controller. 

1. Floor based requests can be served by any elevator, thus these requests are added to a common area accessible by all controllers. 

1. Each elevator controller runs as a separate thread and checks if it can process a floor request. Mind synchronization issues. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Stack and Heap]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/stack-and-heap/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/stack-and-heap</id>
    <content type="html"><![CDATA[### Overview

Value types are created on the stack, and reference types are created on the heap. 

__Both are stored in computer RAM__. 

__Each thread gets a stack__, while there's typically only one heap for the application. 

#### Stack

[When a function](http://stackoverflow.com/a/80113) is called, a block is reserved __on the top of the stack__ for local variables and some bookkeeping data in a LIFO order. Freeing a block from the stack is nothing more than adjusting one pointer. 

#### Heap

Unlike the stack, there's no enforced pattern to the allocation and deallocation of blocks from the heap; you can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time; there are many custom heap allocators available to tune heap performance for different usage patterns. 

### Q & A

#### What is their scope?

The stack is attached to a thread, so __when the thread exits__ the stack is reclaimed. 

The heap is typically allocated at application startup by the runtime, and is reclaimed __when the application (technically process) exits__. 

#### What determines the size of each of them?

The size of the stack is set when a thread is created. 

The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system).

#### What makes one faster? 

__The stack is faster__ because the access pattern makes it trivial to allocate and deallocate memory from it, while the heap has much more complex bookkeeping involved in an allocation or free. 

Each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor's cache, making it very fast. 

Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe, i.e. each allocation and deallocation needs to be (typically) synchronized.

<img class="middle" src="/assets/images/stack-and-heap.png">
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Shared Hosting vs. VPS Hosting]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/Web-hosting-shared-and-vps/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/Web-hosting-shared-and-vps</id>
    <content type="html"><![CDATA[### Shared hosting

[Shared hosting](https://kb.greengeeks.com/3072/shared-hosting-vs-vps-hosting/) is like living in an apartment where you share a common space with your neighbors. You cannot customize anything but you share maintenance cost and responsibility with your neighbors.

1. Economical 
1. Technical maintenance of the server is not required 
1. Limited number of resources 
1. Your website performance may be affected by other websites hosted on the shared server 
1. Possible long term problems with scalability and backup 
1. Possible security issues for sharing a common server 

### Virtual Private Server

Virtual Private Server (VPS) Hosting is like living in a simplex or half-plex where you can customize everything to your own tastes. However, you still need to maintain your own area. Companies that deal with resource-heavy applications and secured data most often use VPS. 

1. Larger space and bandwidth 
1. Can configure anything 
1. Run your own batch files to create multiple services inside the server using shell access 
1. Easy scalability and backup 
1. You need a dedicated system administrator 
1. Costly


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Designing Scalable Systems (`)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/Design-scalable-system/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/Design-scalable-system</id>
    <content type="html"><![CDATA[1. horizontal scaling

load balancer get all requests, and distribute to one of the back-end servers

user sees not DNS, but address of load balancer

all backend server must have identical information (the price you pay for scalability)

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Binary Search Trees Over Hash Tables]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/BST-over-hashmap/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/BST-over-hashmap</id>
    <content type="html"><![CDATA[### Question 

[What are the advantages](http://stackoverflow.com/questions/4128546/advantages-of-binary-search-trees-over-hash-tables) of binary search trees over hash tables? 

### Answer

1. __More memory-efficient__. (They do not reserve more memory than they need to)

    For instance, if a hash function has a range R(h) = 0...100, then you need to allocate an array of 100 (pointers-to) elements, even if you are just hashing 20 elements. 

1. [Inorder traverse](http://stackoverflow.com/a/4128585). 

1. Collision might hamper HashMap's performance. 

1. [Resizing issue](http://stackoverflow.com/a/4129272)

    When the hash table pressure grows too much, you often tend to enlargen and reallocate the hash table. The BST has simpler behavior here and does not tend to suddenly allocate a lot of data and do a rehashing operation. 

1. Binary search tree do range searches efficiently.

### One more thing

__Trees tend to be the [ultimate average data structure](http://stackoverflow.com/a/19896875)__. They can act as lists, can easily be split for parallel operation, have fast removal, insertion and lookup on the order of O(lgn). They do nothing particularly well, but they don't have any excessively bad behavior either. 
]]></content>
  </entry>
  
</feed>
