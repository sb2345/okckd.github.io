<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/design/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-02-08T18:40:21+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Design] Difference: Internet and the Web]]></title>
    <link href="http://okckd.github.io/blog/2015/02/08/difference-internet-and-www/"/>
    <updated>2015-02-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/08/difference-internet-and-www</id>
    <content type="html"><![CDATA[### Internet

[The Internet](http://www.webopedia.com/DidYouKnow/Internet/Web_vs_Internet.asp) is a massive network of networks, a __networking infrastructure__. It connects millions of computers together globally, and computers talk thru __protocols__. 

[The Internet](http://netforbeginners.about.com/od/internet101/f/the_difference_between_internet_and_web.htm) is a Big Collection of Computers and Cables.

### Web

[The World Wide Web](http://www.webopedia.com/DidYouKnow/Internet/Web_vs_Internet.asp), or simply Web, is __a way of accessing information__ over the medium of the Internet. 

It is an information-sharing model that is built on top of the Internet. The Web uses the __HTTP protocol__, only one of the languages spoken over the Internet, to transmit data. 

[The Web](http://netforbeginners.about.com/od/internet101/f/the_difference_between_internet_and_web.htm) Is a Big Collection of HTML Pages on the Internet.

<img class="middle" src="/assets/images/internet-and-web.jpg">
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Big Data - Find Common Elements in 2 Lists]]></title>
    <link href="http://okckd.github.io/blog/2015/02/08/bg-data-common-elements-lists/"/>
    <updated>2015-02-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/08/bg-data-common-elements-lists</id>
    <content type="html"><![CDATA[### Traditional solution

1. 2 pointers
1. Hash

### Big Data

Bloom filter, refer to __[Design] Big Data - Fuzzy Search url (Bloom Filter)__. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Multithreading Async Increment Problem]]></title>
    <link href="http://okckd.github.io/blog/2015/02/07/multithreading-async-increment-problem/"/>
    <updated>2015-02-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/07/multithreading-async-increment-problem</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=18315663)

> If two threads are incrementing a variable 100 times each without synchronization, what would be the possible min and maximum value.

### Solution

Well, max is init+200, and min is init+2. Suggested by the [top answer](http://www.careercup.com/question?id=18315663):

1. P1 & P2 copy var 
1. P1 increments 99 times. so var becomes var + 99 
1. P2 increments once. so var becomes var + 1 
1. P1 copies var (value is var + 1) 
1. P2 increments 99 times. so var becomes var + 100 
1. P1 increments once. so var becomes var + 2
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Winning Games Rank (Pagerank)]]></title>
    <link href="http://okckd.github.io/blog/2015/02/05/winning-game-rank-pagerank/"/>
    <updated>2015-02-05T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/05/winning-game-rank-pagerank</id>
    <content type="html"><![CDATA[### Question

> We have a history of match result of pingpong games, assume each match is <player1, player2, result, timestamp>, player1 and player2 are long type, result is a bit value (1 means player1 win). 

> design a algorithm to sort the players by their possibility to win future games. 

### Solution

For each play, 

> winning score = score_diff * {delay factor^(current time - winning time)}; 

### Pagerank 

[PageRank](http://google.about.com/od/searchengineoptimization/a/pagerankexplain.htm) is what Google uses to __determine the importance of a web page__. 

It determines which pages appear in search results.

Named after Larry Page. 

#### Details

1. PageRank thinks of links as votes to another page.

1. It also looks at the importance of the page that contains the link. 
    
    1. Pages with __higher PageRank__ have more weight in "voting". 
    
    1. Pages with __smaller total number of links__ on the page have more weight.

#### Increase your PageRank?

If you'd like to increase your PageRank, you need to have "back-links," or other people linking to your website. You can __trade links__ with other people, but make sure you only trade relevant links, and make sure you're not trading links with a __link farm__. 

You can register your website with directories, such as the __Open Directory Project__, but use directories with high PageRank whenever possible.

You can create some of __your own back-links__ by linking to relevant pages __within__ your own website. However, remember that the number of links you create counts into the equation. Don't overdo it.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Speed Up Webpage for Slow Connection (2)]]></title>
    <link href="http://okckd.github.io/blog/2015/02/05/speed-up-web-page-2/"/>
    <updated>2015-02-05T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/05/speed-up-web-page-2</id>
    <content type="html"><![CDATA[[ref](www.geeksforgeeks.org/amazon-interview-set-72-campus-sde-1)

### Question

> Suppose you are handling Amazon website and you have 10 MB size home page. Optimize the homepage for a customer who has 100 kbps internet connection.

> Further he asked for the customer who has 100 mbps internet connection.

### Website KPI

There are [3 interesting phases](https://community.compuwareapm.com/community/display/PUB/Best+Practices+on+Web+Site+Performance+Optimization) of a web site from an end-user performance perspective. 

1. First Impression
1. OnLoad 
1. Fully Loaded Time.

### Loading Time

__Question: what percentage of the time a user spends waiting for your page to load is spent after the HTML comes back to their browser__? 

It is typically __[over 90%](http://www.sitepoint.com/seven-mistakes-that-make-websites-slow/)__. 

Most of the time users spend waiting on your website is spent after the HTML page has been retrieved by their browser. 

#### Fetching the HTML is just the beginning

__In a nutshell, browsers parse your page’s HTML, sequentially discovering its assets__ (such as scripts, stylesheets, and images), requesting and then either parsing and executing them or displaying them as appropriate. 

But these assets are not simply fetched all at once. Instead, the __browser opens a limited number of connections to the server(s)__ referenced by the page. There is __overhead involved in establishing TCP and HTTP connections__, and some __unavoidable latency__ in pushing the request and response bytes back and forth across the network.

So, in general, round trips between the browser and server are expensive. The structure of the HTML markup, the number and the ordering of its assets, are absolutely critical factors in its performance.

### What hijacks your load time

#### 1. Too Many HTTP Requests

This is the single biggest contributor to performance problems in most web pages. 

1. Concatenate scripts and stylesheets

1. Combine images with sprites (put common images into a single large image file, then use CSS to position and selectively display the appropriate portion of the sprite image)

1. Use fewer images, more CSS. 

#### 2. Minimal Client-side Processing

1. Validation on client. (eg. form input)

1. Use web standards and MVC separation, making a maintainable, accessible, future-proof and max-performance website. 

    Think of the HTML as the model, the CSS as the view, and the JavaScript as the controller. This separation tends to make code more efficient and maintainable, and makes many optimization techniques much more practical to apply.

1. Push presentation code into the client tier (eg. Charts and graphs — push raw data to the client in JSON format, and use JavaScript and CSS to create pretty graphs.)

1. Leverage Ajax techniques (only requiring small parts of the page to change in response to user actions)

#### 3. Low Number of Parallel Requests

Fetch a script, parse and execute it, then fetch another one... this will use up all the available connections. There are things you can do to your HTML to allow virtually any browser to make many requests at once, which has a huge impact on latency.

1. Use browser-appropriate domain sharding

1. Use intelligent script loading

1. Leverage Keep-Alive (reuse the same TCP connection for multiple HTTP request/response cycles)

#### 4. Failure to leverage browser cache / local storage

1. [HTTP cache overview](http://www.mnot.net/cache_docs/)

1. Leverage local storage

#### 5. Third-party widgets

1. Avoid third-party widgets!
1. Try to use widgets that provide asynchronous implementations, so their inevitably terrible performance impacts their widget without dragging down your entire UX with it.

#### 7. Failure to Use a Global Network

Amazon S3. 

Ref: http://www.sitepoint.com/seven-mistakes-that-make-websites-slow/
]]></content>
  </entry>
  
</feed>
