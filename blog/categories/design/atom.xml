<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/design/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-19T05:21:01+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Design] Speed Up Webpage for Slow Connection (2)]]></title>
    <link href="http://okckd.github.io/blog/2015/01/19/speed-up-web-page-2/"/>
    <updated>2015-01-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/19/speed-up-web-page-2</id>
    <content type="html"><![CDATA[[ref](www.geeksforgeeks.org/amazon-interview-set-72-campus-sde-1)

### Question

> Suppose you are handling Amazon website and you have 10 MB size home page. Optimize the homepage for a customer who has 100 kbps internet connection.

> Further he asked for the customer who has 100 mbps internet connection.

### Website KPI

There are [3 interesting phases](https://community.compuwareapm.com/community/display/PUB/Best+Practices+on+Web+Site+Performance+Optimization) of a web site from an end-user performance perspective. 

1. First Impression
1. OnLoad 
1. Fully Loaded Time.

### Loading Time

__Question: what percentage of the time a user spends waiting for your page to load is spent after the HTML comes back to their browser__? 

It is typically __[over 90%](http://www.sitepoint.com/seven-mistakes-that-make-websites-slow/)__. 

Most of the time users spend waiting on your website is spent after the HTML page has been retrieved by their browser. 

#### Fetching the HTML is just the beginning

__In a nutshell, browsers parse your page’s HTML, sequentially discovering its assets__ (such as scripts, stylesheets, and images), requesting and then either parsing and executing them or displaying them as appropriate. 

But these assets are not simply fetched all at once. Instead, the __browser opens a limited number of connections to the server(s)__ referenced by the page. There is __overhead involved in establishing TCP and HTTP connections__, and some __unavoidable latency__ in pushing the request and response bytes back and forth across the network.

So, in general, round trips between the browser and server are expensive. The structure of the HTML markup, the number and the ordering of its assets, are absolutely critical factors in its performance.

### What hijacks your load time

#### 1. Too Many HTTP Requests

This is the single biggest contributor to performance problems in most web pages. 

1. Concatenate scripts and stylesheets

1. Combine images with sprites (put common images into a single large image file, then use CSS to position and selectively display the appropriate portion of the sprite image)

1. Use fewer images, more CSS. 

#### 2. Minimal Client-side Processing

1. Validation on client. (eg. form input)

1. Use web standards and MVC separation, making a maintainable, accessible, future-proof and max-performance website. 

    Think of the HTML as the model, the CSS as the view, and the JavaScript as the controller. This separation tends to make code more efficient and maintainable, and makes many optimization techniques much more practical to apply.

1. Push presentation code into the client tier (eg. Charts and graphs — push raw data to the client in JSON format, and use JavaScript and CSS to create pretty graphs.)

1. Leverage Ajax techniques (only requiring small parts of the page to change in response to user actions)

#### 3. Low Number of Parallel Requests

Fetch a script, parse and execute it, then fetch another one... this will use up all the available connections. There are things you can do to your HTML to allow virtually any browser to make many requests at once, which has a huge impact on latency.

1. Use browser-appropriate domain sharding

1. Use intelligent script loading

1. Leverage Keep-Alive (reuse the same TCP connection for multiple HTTP request/response cycles)

#### 4. Failure to leverage browser cache / local storage

1. [HTTP cache overview](http://www.mnot.net/cache_docs/)

1. Leverage local storage

#### 5. Third-party widgets

1. Avoid third-party widgets!
1. Try to use widgets that provide asynchronous implementations, so their inevitably terrible performance impacts their widget without dragging down your entire UX with it.

#### 7. Failure to Use a Global Network

Amazon S3. 

Ref: http://www.sitepoint.com/seven-mistakes-that-make-websites-slow/
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Difference Between HTTP Protocol and TCP Protocol]]></title>
    <link href="http://okckd.github.io/blog/2015/01/19/difference-http-tcp/"/>
    <updated>2015-01-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/19/difference-http-tcp</id>
    <content type="html"><![CDATA[[ref](http://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol)

### Short Version

TCP is a __transport-layer__ protocol, and HTTP is an __application-layer__ protocol that runs over TCP. 

### The layers

At the very bottom of the network stack is the __physical layer__. This is where electrical signals or light pulses or radio waves actually transmit information from place to place. The physical layer doesn't really have protocols, but instead has standards for voltages, frequencies, and other physical properties. You can transmit information directly this way, but you need a lot of power or a dedicated line, and without higher layers you won't be able to share bandwidth.

The next layer up is the __link layer__. This layer covers communication with devices that share a physical communications medium. Here, protocols like Ethernet, 802.11a/b/g/n, and Token Ring specify how to handle multiple concurrent accesses to the physical medium and how to direct traffic to one device instead of another. In a typical home network, this is how your computer talks to your home "router."

The third layer is the __network layer__. In the majority of cases, this is dominated by Internet Protocol (IP). This is where the magic of the Internet happens, and you get to talk to a computer halfway around the world, without needing to know where it is. Routers handle directing your traffic from your local network to the network where the other computer lives, where its own link layer handles getting the packets to the right computer.

Now we are getting somewhere. We can talk to a computer somewhere around the world, but that computer is running lots of different programs. How should it know which one to deliver your message to? The __transport layer__ takes care of this, usually with __port numbers__. The two most popular transport layer protocols are TCP and UDP. TCP does a lot of interesting things to smooth over the rough spots of network-layer packet-switched communication like reordering packets, retransmitting lost packets, etc. UDP is more unreliable, but has less overhead.

So we've connected your browser to the web server software on the other end, but how does the server know what page you want? How can you post a question or an answer? These are things that __application-layer__ protocols handle. For __web traffic__, this is the HyperText Transfer Protocol (HTTP). There are thousands of application-layer protocols: SMTP, IMAP, and POP3 for email; XMPP, IRC, ICQ for chat; Telnet, SSH, RDP for remote administration; etc.

Ref: http://qr.ae/3pnJK
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Speed Up Webpage for Slow Connection (1)]]></title>
    <link href="http://okckd.github.io/blog/2015/01/18/speed-up-web-page-1/"/>
    <updated>2015-01-18T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/18/speed-up-web-page-1</id>
    <content type="html"><![CDATA[[ref](www.geeksforgeeks.org/amazon-interview-set-72-campus-sde-1)

### Question

> Suppose you are handling Amazon website and you have 10 MB size home page. Optimize the homepage for a customer who has 100 kbps internet connection.

> Further he asked for the customer who has 100 mbps internet connection.

### Reading

[This](http://sixrevisions.com/web-development/site-speed-performance/) is a very nice article about website speedup. Below is the full quoted text. 

#### 1. Defer Loading Content When Possible

Ajax allows us to build web pages that can be __asynchronously updated__ at any time. This means that instead of reloading an entire page when a user performs an action, we can simply update parts of that page.

We can use an image gallery as an example. Image files are big and heavy; they can slow down page-loading speeds of web pages. Instead of loading all of the images when a user first visits the web page, we can just display thumbnails of the images and then when the user clicks on them, we can asynchronously request the full-size images from the server and update the page. This way, if a user only wants to see a few pictures, they don’t have to suffer waiting for all of the pictures to download. This development pattern is called __lazy loading__.

__Ajax/web development libraries__ like jQuery, Prototype, and MooTools can make deferred content-loading easier to implement.

#### 2. Use External JS and CSS Files

When the user first loads your web page, the browser will cache external resources like CSS and JavaScript files. Thus, instead of inline JavaScript and CSS files, it’s best to __place them in external files__.

Using inline CSS also increases the rendering time of a web page; having everything defined in your main CSS file lets the browser do less work when rendering the page, since it already knows all the style rules that it needs to apply.

__As a bonus__, using external JavaScript and CSS files makes site maintenance easier because you only need to maintain global files instead of code scattered in multiple web pages.

#### 3. Use Caching Systems

If you find that your site is connecting to your database in order to create the same content, it’s time to start using a __caching system__. By having a caching system in place, your site will only have to create the content once instead of creating the content every time the page is visited by your users. Don’t worry, caching systems periodically refresh their caches depending on how you set it up — so even constantly-changing web pages (like a blog post with comments) can be cached.

__Popular content management systems__ like WordPress and Drupal will have __static caching features__ that convert dynamically generated pages to static HTML files to reduce unnecessary server processing. For WordPress, check out [WP Super Cache](https://wordpress.org/plugins/wp-super-cache/) (one of the six critical WordPress plugins which, claimed by the author, enjoyed a improvement by 259.1% for content-heavy pages). Drupal has a page-caching feature in the core.

There are also __database caching and server-side scripts caching systems__ that you can install on your web server (if you have the ability to do so). For example, PHP has extensions called PHP accelerators that optimize performance through caching and various other methods; one example of a [PHP accelerator](http://en.wikipedia.org/wiki/PHP_accelerator) is APC. [Database caching](http://en.wikipedia.org/wiki/Database_caching) improves performance and scalability of your web applications by reducing the work associated with database read/write/access processes; __[memcached](http://www.memcached.org/)__, for example, caches frequently used database queries. 

#### 8. Load JavaScript at the End of Your Document

It’s best if you have your scripts loading at the end of the page rather than at the beginning. It allows for the browser to render everything before getting started with the JavaScript. This makes your web pages feel more responsive because the way JavaScript works is that it blocks anything below it from rendering until it has finished downloading. If possible, reference JavaScript right before the closing (body) tag of your HTML documents. To learn more, read about deferring the loading of JavaScript.

#### 9. Use a Content Delivery Network (CDN)

Your site’s speed is greatly affected by where the user’s location is, relative to your web server. The farther away they are, the more distance the data being transmitted has to travel. Having your content cached __across multiple, strategically placed geographical locations__ helps take care of this problem. 

A CDN will often make your operating cost a little higher, but you definitely gain a speed bonus. Check out MaxCDN or __Amazon Simple Storage Service (Amazon S3)__.

#### 10. Optimize Web Caching

Along with using caching systems, you should create websites that utilize __web caching__ as much as possible. Web caching is when files are __cached by the web browser__ for later use. Things that browsers can cache include CSS files, JavaScript files, and images.

Aside from the basics, such as putting CSS and JavaScript code that are used in multiple pages in external files, there are many ways to make sure that you are caching your files in the most efficient way possible.

For example, you can set HTTP response headers such as Expires and Last-Modified to reduce the need of re-downloading certain files when the user comes back to your site. To learn more, read about [caching in HTTP](http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html) and [leveraging browser caching](https://developers.google.com/speed/docs/insights/LeverageBrowserCaching?csw=1#LeverageBrowserCaching).

To set up HTTP Expires headers in Apache, read this tutorial on adding future expires headers.

#### Other mentions

4. __Avoid Resizing Images in HTML__ (using HTML’s width and height attributes), for the sake of smaller file size. 

6. __Optimize Image Sizes by Using the Correct File Format__. Eg. JPG format often displays photographic images at smaller file sizes than PNG. 

7. __Optimize the Way You Write Code__. For example, instead of using (h1)(em)Your heading(em)(h1), you can easily use CSS to make your headings italics. 

    Writing code efficiently not only reduces file sizes of your HTML and CSS documents, but also makes it easier to maintain.

Ref: http://sixrevisions.com/web-development/site-speed-performance/
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Terminology: N-gram]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/terminology-ngram/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/terminology-ngram</id>
    <content type="html"><![CDATA[### n-gram

In the fields of computational linguistics and probability, an __[n-gram](http://en.wikipedia.org/wiki/N-gram)__ is a contiguous sequence of n items from a given sequence of text or speech. 

The items can be phonemes, syllables, letters, words or base pairs according to the application. The n-grams typically are collected from a text or speech corpus.

#### Example

<table border="1" width="100%" id="table5" cellpadding="3" style="border-collapse: collapse" bordercolor="#89B0D8" cellspacing="0">
				<tbody><tr>
					<td bgcolor="#D9ECFF">
					<p align="center">frequency</p></td>
					<td bgcolor="#D9ECFF">
					<p align="center">word1</p></td>
					<td bgcolor="#D9ECFF">
					<p align="center">word2</p></td>
					<td bgcolor="#D9ECFF">
					<p align="center">word3</p></td>
				</tr>
				<tr>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">1419</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">much</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">the</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">same</p>
					</td>
				</tr>
				<tr>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">461</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">much</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">more</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">likely</p>
					</td>
				</tr>
				<tr>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">432</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">much</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">better</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">than</p>
					</td>
				</tr>
				<tr>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">266</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">much</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">more</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">difficult</p>
					</td>
				</tr>
				<tr>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">235</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">much</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">of</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">the</p>
					</td>
				</tr>
				<tr>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">226</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">much</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">more</p>
					</td>
					<td bgcolor="#F5F9FC">
					<p style="line-height: 150%; margin-top:0; margin-bottom:0" align="center">than</p>
					</td>
				</tr>
</tbody></table>

#### Downloadable n-grams sets for English

1. __[Google n-grams](https://catalog.ldc.upenn.edu/LDC2006T13)__, based on the web as of 2006. 
1. __[COCA n-grams](http://www.ngrams.info/intro.asp)__, based on Corpus of Contemporary American English [COCA]. 450 million words from 1990 to 2012. 

With n-grams data (2, 3, 4, 5-word sequences, with their frequency), we can carry out powerful queries offline. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Big Data - Top K Frequency 3]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/big-data-top-k-frequency-3/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/big-data-top-k-frequency-3</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/a/3262855)

> The input is an endless stream of English words or phrases (we refer them as tokens).

> Output top N tokens we have seen so far (from all the tokens we have seen!) 

### Analysis

We will discuss the following details of implementation and optimization. 

1. String into Integer
2. Data Storage
3. Process Incoming Streams
4. Save result

#### 1. String into Integer

This is a nice trick that improves eficiency a lot. 

> Though there is almost infinite possible words on the Internet, but after accumulating a large set of words, the possibility of finding new words becomes lower and lower.

> We have already found 4 million different words, and assigned a unique ID for each. This is important, because sorting and comparisons on integers is __much much faster__ than on strings.

#### 2. Data Storage

> The system keeps archive data for every token. Basically it's pairs of (Token, Frequency). 

> However, the table that stores the data would be so huge such that we have to partition the table physically. One partition scheme is __based on ngrams__ of the token. If the token is a single word, it is 1gram. If the token is two-word phrase, it is 2gram. 

Of course we can also divide the data by the hash value. For information on __ngrams__, read __[Design] Terminology: n-gram__. 

#### 3. Process Incoming Streams

> The system will absorbs incoming sentences until memory becomes fully utilized (Ya, we need a MemoryManager). After taking N sentences and storing in memory, the system pauses, and starts tokenize each sentence into words and phrases. Each token (word or phrase) is counted. 

This data processing logic runs as a process under Memory-Manager. The next part is another processing running concurrently. 

#### 4. Save result

> Meanwhile, there will be another process that is activated once it finds any disk file generated by the system, then start merging it. Since the disk file is sorted, merging would take __a similar process like merge sort__. 

There is [some more steps](http://stackoverflow.com/a/3262855) afterwards, but they're trivial. I have listed out the basic steps for processing large stream of incoming data (as string), and how to find out the Top K keywords. 

I suggest you read previous __[Design] Big Data - Top k Frequency__ posts before reading this. 
]]></content>
  </entry>
  
</feed>
