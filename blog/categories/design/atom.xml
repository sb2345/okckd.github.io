<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/design/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-23T03:00:27+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Design] Stack and Heap]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/stack-and-heap/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/stack-and-heap</id>
    <content type="html"><![CDATA[### Overview

Value types are created on the stack, and reference types are created on the heap. 

__Both are stored in computer RAM__. 

__Each thread gets a stack__, while there's typically only one heap for the application. 

#### Stack

[When a function](http://stackoverflow.com/a/80113) is called, a block is reserved __on the top of the stack__ for local variables and some bookkeeping data in a LIFO order. Freeing a block from the stack is nothing more than adjusting one pointer. 

#### Heap

Unlike the stack, there's no enforced pattern to the allocation and deallocation of blocks from the heap; you can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time; there are many custom heap allocators available to tune heap performance for different usage patterns. 

### Q & A

#### What is their scope?

The stack is attached to a thread, so __when the thread exits__ the stack is reclaimed. 

The heap is typically allocated at application startup by the runtime, and is reclaimed __when the application (technically process) exits__. 

#### What determines the size of each of them?

The size of the stack is set when a thread is created. 

The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system).

#### What makes one faster? 

__The stack is faster__ because the access pattern makes it trivial to allocate and deallocate memory from it, while the heap has much more complex bookkeeping involved in an allocation or free. 

Each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor's cache, making it very fast. 

Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe, i.e. each allocation and deallocation needs to be (typically) synchronized.

<img class="middle" src="/assets/images/stack-and-heap.png">
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Binary Search Trees Over Hash Tables]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/BST-over-hashmap/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/BST-over-hashmap</id>
    <content type="html"><![CDATA[### Question 

[What are the advantages](http://stackoverflow.com/questions/4128546/advantages-of-binary-search-trees-over-hash-tables) of binary search trees over hash tables? 

### Answer

1. __More memory-efficient__. (They do not reserve more memory than they need to)

    For instance, if a hash function has a range R(h) = 0...100, then you need to allocate an array of 100 (pointers-to) elements, even if you are just hashing 20 elements. 

1. [Inorder traverse](http://stackoverflow.com/a/4128585). 

1. Collision might hamper HashMap's performance. 

1. [Resizing issue](http://stackoverflow.com/a/4129272)

    When the hash table pressure grows too much, you often tend to enlargen and reallocate the hash table. The BST has simpler behavior here and does not tend to suddenly allocate a lot of data and do a rehashing operation. 

1. Binary search tree do range searches efficiently.

__Trees tend to be the [ultimate average data structure](http://stackoverflow.com/a/19896875)__. They can act as lists, can easily be split for parallel operation, have fast removal, insertion and lookup on the order of O(lgn). They do nothing particularly well, but they don't have any excessively bad behavior either. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] About Singleton]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Talk-about-singleton/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Talk-about-singleton</id>
    <content type="html"><![CDATA[### Implement Singlton

[3 ways](http://javarevisited.blogspot.sg/2012/07/why-enum-singleton-are-better-in-java.html) of writing Singleton. 

#### using Enum

This is only available since Java 6.

	public enum Singleton_Enum {
		INSTANCE;
	}

#### using double checked locking

This is __lazy loaded thread-safe__ Singleton, which is popular during Java 5 (with the use of Volatile variable). 

	public class Singleton_DoubleCheckedLocking implements Cloneable {
		private static volatile Singleton_DoubleCheckedLocking INSTANCE;

		private Singleton_DoubleCheckedLocking() {
		}

		public static Singleton_DoubleCheckedLocking getInstance() {
			if (INSTANCE == null) {
				synchronized (Singleton_DoubleCheckedLocking.class) {
					// double checking Singleton instance
					if (INSTANCE == null) {
						INSTANCE = new Singleton_DoubleCheckedLocking();
					}
				}
			}
			return INSTANCE;
		}
	}

#### using static factory method

Singleton instance is [static and final variable](http://javarevisited.blogspot.sg/2012/07/why-enum-singleton-are-better-in-java.html) it initialized when class is first loaded into memeory so creation of instance is inherently __thread-safe__. 

	public class Singleton_StaticFactory {
		// initailzed during class loading
		private static final Singleton_StaticFactory INSTANCE = new Singleton_StaticFactory();

		// to prevent creating another instance of Singleton
		private Singleton_StaticFactory() {
		}

		public static Singleton_StaticFactory getSingleton() {
			return INSTANCE;
		}
	}

### About thread-saft

[Prior to Java 5](http://javarevisited.blogspot.sg/2012/12/how-to-create-thread-safe-singleton-in-java-example.html) __double checked locking__ mechanism is used to create thread-safe singleton in Java, which breaks if one Thread doesn't see instance created by other thread at same time and eventually you will end up with more than one instance of Singleton class. 

From Java 5 onwards __volatile variable__ guarantee can be used to write thread safe singleton by using double checked locking pattern. 

I personally don't prefer that way as there are many other simpler alternatives like: 

1. using static field
1. using Enum 

### Q & A

Question: How do you prevent for creating another instance of Singleton using clone() method?

Answer: Preferred way is not to implement Clonnable interface. And if you do, just throw Exception from clone() method as "Can not create clone of Singleton class". 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Design Pattern - Singleton & Factory]]></title>
    <link href="http://okckd.github.io/blog/2014/08/19/design-pattern-basic-singleton-factory/"/>
    <updated>2014-08-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/19/design-pattern-basic-singleton-factory</id>
    <content type="html"><![CDATA[### First Word

__Singleton__ and __Factory Method__ design pattern are the __2 most frequent topics__ for OOD. 

### Singleton Pattern

__[Singleton pattern](http://en.wikipedia.org/wiki/Singleton_pattern)__ is a design pattern that restricts the instantiation of a class to one object. 

#### in Java

Since Java 5.0, the easiest way to create a Singleton is the __[enum type approach](http://en.wikipedia.org/wiki/Singleton_pattern#The_Enum_way)__. Here the code is not given. 

We will instead cover a very popular implementation: __[Lazy initialization](http://en.wikipedia.org/wiki/Singleton_pattern#Lazy_initialization)__. 

    public class SingletonDemo {
        private static volatile SingletonDemo instance = null;
        private SingletonDemo() { }
        public static SingletonDemo getInstance() {
            if (instance == null) {
                synchronized (SingletonDemo.class) {
                    if (instance == null) {
                        instance = new SingletonDemo();
                    }
                }
            }
            return instance;
        }
    }

An alternate simpler version (non-sync):

    public class SingletonDemo {
        private static SingletonDemo instance = null;
        private SingletonDemo() { }
        public static synchronized SingletonDemo getInstance() {
            if (instance == null) {
                instance = new SingletonDemo();
            }
            return instance;
        }
    }

### Factory Method Pattern

__[Factory method pattern](http://en.wikipedia.org/wiki/Factory_method_pattern)__ is a creational pattern which uses __factory methods__ to deal with the problem of creating objects without specifying the exact class of object that will be created. 

This is done by creating objects via factory method, either:

1. specified in an interface/abstract class and implemente (differently)
1. implemented in a base class, and be overridden in derived classes

#### in Java

A normal [Maze Game](http://en.wikipedia.org/wiki/Factory_method_pattern#Java):

    public class MazeGame {
        public MazeGame() {
            Room room1 = makeRoom();
            Room room2 = makeRoom();
            room1.connect(room2);
            this.addRoom(room1);
            this.addRoom(room2);
        }

        protected Room makeRoom() {
            return new OrdinaryRoom();
        }
    }

A magic game:

    public class MagicMazeGame extends MazeGame {
        @Override
        protected Room makeRoom() {
            return new MagicRoom();
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] From Client/Server to Multi-Tier]]></title>
    <link href="http://okckd.github.io/blog/2014/08/12/From-ClientServer-to-Multi-Tier/"/>
    <updated>2014-08-12T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/12/From-ClientServer-to-Multi-Tier</id>
    <content type="html"><![CDATA[### Client/Server

[link](http://wiki.remobjects.com/wiki/From_Client/Server_to_Multi-Tier)

Client have __direct and full access to the physical database__ based on their login string. This is the major weakness of the Client/Server paradigm. The system is vulnerable to attacks. 

Because all business logic was __implemented on the client application__, changes to business logic means redeploying new client software to all users again. 

Another drawback is that the network interface provided by most back-end database systems has been designed for access over the local network, using fast connections and no firewalls. Nowadays, many clients’ software needs to run from employee's home offices or from airport lounges. In many cases such connections __will be unreliable or inefficient__ to work on. 

### Multi-Tier

The communication between clients and middle-tier server is __no longer tied to a protocol dictated by the database__ (no database drivers or connection string on the client). Client applications can authenticate with __a username and password (compare to login string)__. 

Communication can be done via HTTP or HTTPS, alternatively or additionally, open standards such as __SOAP, OData and JSON can be used to expose a middle tier__ to different clients using protocols that are widely understood. 

Biggest advantage is that __all the business logic is transferred from client application into the middle tier__. And the middle tier holds the final control over what data goes in or out. 

Still, there're still some business logic on the client tier as well. But it only __complement the rules__ that are enforced on the server. Eg. Twitter enforce the 140 character limit locally, and stop you from sending a tweet that is too long (by graying out the Send button). 

That means, client side checks are for convenience, and for convenience only; the middle tier server is and must be authoritative for what is allowed and what is not.

]]></content>
  </entry>
  
</feed>
