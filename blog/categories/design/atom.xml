<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/design/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-28T01:47:48+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Design] Virtual Memory, Page Fault and Thrashing]]></title>
    <link href="http://okckd.github.io/blog/2014/08/26/Virtual-memory-page-fault-thrashing/"/>
    <updated>2014-08-26T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/26/Virtual-memory-page-fault-thrashing</id>
    <content type="html"><![CDATA[### Terminologies

#### Paging

[Paging](http://whatis.techtarget.com/definition/paging) is a method of writing data to, and reading it from, __secondary storage__ for use in __primary storage__, also known as main memory. Paging plays a role in memory management for a operating system.

#### Page table

[A page table](http://en.wikipedia.org/wiki/Page_table) is the data structure used by a virtual memory system to store the mapping between __virtual addresses__ and __physical addresses__. 

#### Page fault

Page fault is an __interrupt__ that occurs when a program requests data that is __not currently in real memory__. The interrupt triggers the operating system to fetch the data from a virtual memory and load it into RAM.

An __invalid page fault__ or __page fault error__ occurs when the operating system cannot find the data in virtual memory. This usually happens when the virtual memory area, or the table that maps virtual addresses to real addresses, becomes corrupt.

#### Logical address

[Logical address](http://en.wikipedia.org/wiki/Logical_address) is the address at which an item (memory cell, storage element, network host) appears to reside from the perspective of an executing application program. 

#### Physical address

[Physical address](http://en.wikipedia.org/wiki/Physical_address) (also real address, or binary address), is a memory address that is represented in the form of a binary number for accessing main memory. 

[In general](http://www.geekinterview.com/question_details/3186), Logical address is the address generated __by the CPU__. Where as physical address is the __actual address of the process in the memory__. The CPU generates the logical address that is added with the __offset value__ to get the actual address of the process inthe memory. 

#### Thrashing

[Thrashing](http://www.computerhope.com/jargon/t/thrash.htm) or disk thrashing is a term used to describe when the hard drive is __being overworked by moving information__ between the system memory and virtual memory excessively. 

### Demand Paging 

Virtual memory is implemented (mostly) using demand paging. __[Demand Paging](http://www.webopedia.com/TERM/D/demand_paging.html)__ is a type of swapping in which pages of data are not copied from disk to RAM until they are needed. This is an example of a [lazy loading technique](http://en.wikipedia.org/wiki/Demand_paging).

Pros:

1. less RAM needed
1. more users
1. less I/O

When a pages is needed, if __invalid referernce__, abort the process. else __if valid__, it's called page fault. 

Page fault time:

1. servicing the page fault interrupt
1. read in new page (major part)
1. restart the process

### Page Replacement

1. FIFO
2. Optimal Algorithm
3. LRU
4. LRU Approximation
	1. Additional-Reference-Bits algorithm
	2. Second-Chance (Clock) algorithm

Refer to another post __"Cache and Page Replacement Algorithms"__. 

### Solution to Thrashing

1. More RAM
1. Less program running together
1. Assign working priorities
1. Improve [spatial locality](http://en.wikipedia.org/wiki/Thrashing_(computer_science)#Solutions) by replacing loops, i.e.

Replace 

	// recall that in C, arrays use Row-major order
	int m[256][256]; 
	for (k=0; k<256; k++) { 
		for (i=0; i<256; i++) { 
			m[i][k] = something(); 
		}
	}

with

	int m[256][256]; 
	for (i=0; i<256; i++) { 
		for (k=0; k<256; k++) {
			// consecutive values of k reside in adjacent memory locations 
			m[i][k] = something(); 
		}
	}

So that the use of data elements is within relatively [close storage locations](http://en.wikipedia.org/wiki/Locality_of_reference). 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] OOD Design of Elevator]]></title>
    <link href="http://okckd.github.io/blog/2014/08/26/Design-OOD-elevator/"/>
    <updated>2014-08-26T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/26/Design-OOD-elevator</id>
    <content type="html"><![CDATA[### Question 

[link](http://thought-works.blogspot.sg/2012/11/object-oriented-design-for-elevator-in.html)

> Object Oriented design for Elevator in a multi-storied apartment 

### A Single Elevator

Use Case: 

1. User
    1. press a button to summon the lift
    1. press a button to get to a specific floor
1. Button
    1. floor button and level button
    1. illuminates when pressed
    1. place an 'elevator request' when pressed
1. Elevator
    1. moves up/down
    1. open/close the door

<img class="middle" src="/assets/images/elevator-class-diagram.png">

__ElevatorRequests Class__

Each button press results in an elevator request which has to be served. Each of these requests is tracked at a global place. ElevatorRequests, the class which stores elevator requests can use different strategies to schedule the elevator requests. 

__ElevatorController__

The elevator is controlled by a controller class which we call ElevatorController. The elevator controller instructs the elevator what to do and also can shutdown/start up the elevator of the building. The elevator controller reads the next elevator request to be processed and serves it. 

__Button (Abstract) Class__

Button is abstract class defining common behavior like illuminate, doNotIlluminate. FloorButton, ElevatorButton extend Button type and define placeRequest() which is invoked when the button is pressed. 

In conclusion, __ElevatorController__ runs the show by reading the __ElevatorRequests__ to process and instructing the __Elevator__ what to do. User send request by pressing __Buttons__. 

### Extend the answer to multiple elevators

1. Each elevator have 1 controller. 

1. Floor based requests can be served by any elevator, thus these requests are added to a common area accessible by all controllers. 

1. Each elevator controller runs as a separate thread and checks if it can process a floor request. Mind synchronization issues. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Stack and Heap]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/stack-and-heap/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/stack-and-heap</id>
    <content type="html"><![CDATA[### Overview

Value types are created on the stack, and reference types are created on the heap. 

__Both are stored in computer RAM__. 

__Each thread gets a stack__, while there's typically only one heap for the application. 

#### Stack

[When a function](http://stackoverflow.com/a/80113) is called, a block is reserved __on the top of the stack__ for local variables and some bookkeeping data in a LIFO order. Freeing a block from the stack is nothing more than adjusting one pointer. 

#### Heap

Unlike the stack, there's no enforced pattern to the allocation and deallocation of blocks from the heap; you can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time; there are many custom heap allocators available to tune heap performance for different usage patterns. 

### Q & A

#### What is their scope?

The stack is attached to a thread, so __when the thread exits__ the stack is reclaimed. 

The heap is typically allocated at application startup by the runtime, and is reclaimed __when the application (technically process) exits__. 

#### What determines the size of each of them?

The size of the stack is set when a thread is created. 

The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system).

#### What makes one faster? 

__The stack is faster__ because the access pattern makes it trivial to allocate and deallocate memory from it, while the heap has much more complex bookkeeping involved in an allocation or free. 

Each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor's cache, making it very fast. 

Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe, i.e. each allocation and deallocation needs to be (typically) synchronized.

<img class="middle" src="/assets/images/stack-and-heap.png">
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Shared Hosting vs. VPS Hosting]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/Web-hosting-shared-and-vps/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/Web-hosting-shared-and-vps</id>
    <content type="html"><![CDATA[### Shared hosting

[Shared hosting](https://kb.greengeeks.com/3072/shared-hosting-vs-vps-hosting/) is like living in an apartment where you share a common space with your neighbors. You cannot customize anything but you share maintenance cost and responsibility with your neighbors.

1. Economical 
1. Technical maintenance of the server is not required 
1. Limited number of resources 
1. Your website performance may be affected by other websites hosted on the shared server 
1. Possible long term problems with scalability and backup 
1. Possible security issues for sharing a common server 

### Virtual Private Server

Virtual Private Server (VPS) Hosting is like living in a simplex or half-plex where you can customize everything to your own tastes. However, you still need to maintain your own area. Companies that deal with resource-heavy applications and secured data most often use VPS. 

1. Larger space and bandwidth 
1. Can configure anything 
1. Run your own batch files to create multiple services inside the server using shell access 
1. Easy scalability and backup 
1. You need a dedicated system administrator 
1. Costly


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Designing Scalable Systems (`)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/Design-scalable-system/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/Design-scalable-system</id>
    <content type="html"><![CDATA[1. horizontal scaling

load balancer get all requests, and distribute to one of the back-end servers

user sees not DNS, but address of load balancer

all backend server must have identical information (the price you pay for scalability)

]]></content>
  </entry>
  
</feed>
