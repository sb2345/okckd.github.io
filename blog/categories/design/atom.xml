<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/design/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-25T20:35:51+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Design] Stack and Heap]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/stack-and-heap/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/stack-and-heap</id>
    <content type="html"><![CDATA[### Overview

Value types are created on the stack, and reference types are created on the heap. 

__Both are stored in computer RAM__. 

__Each thread gets a stack__, while there's typically only one heap for the application. 

#### Stack

[When a function](http://stackoverflow.com/a/80113) is called, a block is reserved __on the top of the stack__ for local variables and some bookkeeping data in a LIFO order. Freeing a block from the stack is nothing more than adjusting one pointer. 

#### Heap

Unlike the stack, there's no enforced pattern to the allocation and deallocation of blocks from the heap; you can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time; there are many custom heap allocators available to tune heap performance for different usage patterns. 

### Q & A

#### What is their scope?

The stack is attached to a thread, so __when the thread exits__ the stack is reclaimed. 

The heap is typically allocated at application startup by the runtime, and is reclaimed __when the application (technically process) exits__. 

#### What determines the size of each of them?

The size of the stack is set when a thread is created. 

The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system).

#### What makes one faster? 

__The stack is faster__ because the access pattern makes it trivial to allocate and deallocate memory from it, while the heap has much more complex bookkeeping involved in an allocation or free. 

Each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor's cache, making it very fast. 

Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe, i.e. each allocation and deallocation needs to be (typically) synchronized.

<img class="middle" src="/assets/images/stack-and-heap.png">
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Shared Hosting vs. VPS Hosting]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/Web-hosting-shared-and-vps/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/Web-hosting-shared-and-vps</id>
    <content type="html"><![CDATA[### Shared hosting

[Shared hosting](https://kb.greengeeks.com/3072/shared-hosting-vs-vps-hosting/) is like living in an apartment where you share a common space with your neighbors. You cannot customize anything but you share maintenance cost and responsibility with your neighbors.

1. Economical 
1. Technical maintenance of the server is not required 
1. Limited number of resources 
1. Your website performance may be affected by other websites hosted on the shared server 
1. Possible long term problems with scalability and backup 
1. Possible security issues for sharing a common server 

### Virtual Private Server

Virtual Private Server (VPS) Hosting is like living in a simplex or half-plex where you can customize everything to your own tastes. However, you still need to maintain your own area. Companies that deal with resource-heavy applications and secured data most often use VPS. 

1. Larger space and bandwidth 
1. Can configure anything 
1. Run your own batch files to create multiple services inside the server using shell access 
1. Easy scalability and backup 
1. You need a dedicated system administrator 
1. Costly


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Designing Scalable Systems (`)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/Design-scalable-system/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/Design-scalable-system</id>
    <content type="html"><![CDATA[1. horizontal scaling

load balancer get all requests, and distribute to one of the back-end servers

user sees not DNS, but address of load balancer

all backend server must have identical information (the price you pay for scalability)

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Binary Search Trees Over Hash Tables]]></title>
    <link href="http://okckd.github.io/blog/2014/08/23/BST-over-hashmap/"/>
    <updated>2014-08-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/23/BST-over-hashmap</id>
    <content type="html"><![CDATA[### Question 

[What are the advantages](http://stackoverflow.com/questions/4128546/advantages-of-binary-search-trees-over-hash-tables) of binary search trees over hash tables? 

### Answer

1. __More memory-efficient__. (They do not reserve more memory than they need to)

    For instance, if a hash function has a range R(h) = 0...100, then you need to allocate an array of 100 (pointers-to) elements, even if you are just hashing 20 elements. 

1. [Inorder traverse](http://stackoverflow.com/a/4128585). 

1. Collision might hamper HashMap's performance. 

1. [Resizing issue](http://stackoverflow.com/a/4129272)

    When the hash table pressure grows too much, you often tend to enlargen and reallocate the hash table. The BST has simpler behavior here and does not tend to suddenly allocate a lot of data and do a rehashing operation. 

1. Binary search tree do range searches efficiently.

### One more thing

__Trees tend to be the [ultimate average data structure](http://stackoverflow.com/a/19896875)__. They can act as lists, can easily be split for parallel operation, have fast removal, insertion and lookup on the order of O(lgn). They do nothing particularly well, but they don't have any excessively bad behavior either. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] About Singleton]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Talk-about-singleton/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Talk-about-singleton</id>
    <content type="html"><![CDATA[### Implement Singlton

[3 ways](http://javarevisited.blogspot.sg/2012/07/why-enum-singleton-are-better-in-java.html) of writing Singleton. 

#### using Enum

This is only available since Java 6.

	public enum Singleton_Enum {
		INSTANCE;
	}

#### using double checked locking

This is __lazy loaded thread-safe__ Singleton, which is popular during Java 5 (with the use of Volatile variable). 

	public class Singleton_DoubleCheckedLocking implements Cloneable {
		private static volatile Singleton_DoubleCheckedLocking INSTANCE;

		private Singleton_DoubleCheckedLocking() {
		}

		public static Singleton_DoubleCheckedLocking getInstance() {
			if (INSTANCE == null) {
				synchronized (Singleton_DoubleCheckedLocking.class) {
					// double checking Singleton instance
					if (INSTANCE == null) {
						INSTANCE = new Singleton_DoubleCheckedLocking();
					}
				}
			}
			return INSTANCE;
		}
	}

#### using static factory method

Singleton instance is [static and final variable](http://javarevisited.blogspot.sg/2012/07/why-enum-singleton-are-better-in-java.html) it initialized when class is first loaded into memeory so creation of instance is inherently __thread-safe__. 

	public class Singleton_StaticFactory {
		// initailzed during class loading
		private static final Singleton_StaticFactory INSTANCE = new Singleton_StaticFactory();

		// to prevent creating another instance of Singleton
		private Singleton_StaticFactory() {
		}

		public static Singleton_StaticFactory getSingleton() {
			return INSTANCE;
		}
	}

### About thread-saft

[Prior to Java 5](http://javarevisited.blogspot.sg/2012/12/how-to-create-thread-safe-singleton-in-java-example.html) __double checked locking__ mechanism is used to create thread-safe singleton in Java, which breaks if one Thread doesn't see instance created by other thread at same time and eventually you will end up with more than one instance of Singleton class. 

From Java 5 onwards __volatile variable__ guarantee can be used to write thread safe singleton by using double checked locking pattern. 

I personally don't prefer that way as there are many other simpler alternatives like: 

1. using static field
1. using Enum 

### Q & A

Question: How do you prevent for creating another instance of Singleton using clone() method?

Answer: Preferred way is not to implement Clonnable interface. And if you do, just throw Exception from clone() method as "Can not create clone of Singleton class". 
]]></content>
  </entry>
  
</feed>
