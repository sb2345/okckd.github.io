<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/design/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-20T12:13:24+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Design] Design Pattern - Singleton & Factory]]></title>
    <link href="http://okckd.github.io/blog/2014/08/19/design-pattern-basic-singleton-factory/"/>
    <updated>2014-08-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/19/design-pattern-basic-singleton-factory</id>
    <content type="html"><![CDATA[### First Word

__Singleton__ and __Factory Method__ design pattern are the __2 most frequent topics__ for OOD. 

### Singleton Pattern

__[Singleton pattern](http://en.wikipedia.org/wiki/Singleton_pattern)__ is a design pattern that restricts the instantiation of a class to one object. 

#### in Java

Since Java 5.0, the easiest way to create a Singleton is the __[enum type approach](http://en.wikipedia.org/wiki/Singleton_pattern#The_Enum_way)__. Here the code is not given. 

We will instead cover a very popular implementation: __[Lazy initialization](http://en.wikipedia.org/wiki/Singleton_pattern#Lazy_initialization)__. 

    public class SingletonDemo {
        private static volatile SingletonDemo instance = null;
        private SingletonDemo() { }
        public static SingletonDemo getInstance() {
            if (instance == null) {
                synchronized (SingletonDemo.class) {
                    if (instance == null) {
                        instance = new SingletonDemo();
                    }
                }
            }
            return instance;
        }
    }

An alternate simpler version (non-sync):

    public class SingletonDemo {
        private static SingletonDemo instance = null;
        private SingletonDemo() { }
        public static synchronized SingletonDemo getInstance() {
            if (instance == null) {
                instance = new SingletonDemo();
            }
            return instance;
        }
    }

### Factory Method Pattern

__[Factory method pattern](http://en.wikipedia.org/wiki/Factory_method_pattern)__ is a creational pattern which uses __factory methods__ to deal with the problem of creating objects without specifying the exact class of object that will be created. 

This is done by creating objects via factory method, either:

1. specified in an interface/abstract class and implemente (differently)
1. implemented in a base class, and be overridden in derived classes

#### in Java

A normal [Maze Game](http://en.wikipedia.org/wiki/Factory_method_pattern#Java):

    public class MazeGame {
        public MazeGame() {
            Room room1 = makeRoom();
            Room room2 = makeRoom();
            room1.connect(room2);
            this.addRoom(room1);
            this.addRoom(room2);
        }

        protected Room makeRoom() {
            return new OrdinaryRoom();
        }
    }

A magic game:

    public class MagicMazeGame extends MazeGame {
        @Override
        protected Room makeRoom() {
            return new MagicRoom();
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] From Client/Server to Multi-Tier]]></title>
    <link href="http://okckd.github.io/blog/2014/08/12/From-ClientServer-to-Multi-Tier/"/>
    <updated>2014-08-12T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/12/From-ClientServer-to-Multi-Tier</id>
    <content type="html"><![CDATA[### Client/Server

[link](http://wiki.remobjects.com/wiki/From_Client/Server_to_Multi-Tier)

Client have __direct and full access to the physical database__ based on their login string. This is the major weakness of the Client/Server paradigm. The system is vulnerable to attacks. 

Because all business logic was __implemented on the client application__, changes to business logic means redeploying new client software to all users again. 

Another drawback is that the network interface provided by most back-end database systems has been designed for access over the local network, using fast connections and no firewalls. Nowadays, many clients’ software needs to run from employee's home offices or from airport lounges. In many cases such connections __will be unreliable or inefficient__ to work on. 

### Multi-Tier

The communication between clients and middle-tier server is __no longer tied to a protocol dictated by the database__ (no database drivers or connection string on the client). Client applications can authenticate with __a username and password (compare to login string)__. 

Communication can be done via HTTP or HTTPS, alternatively or additionally, open standards such as __SOAP, OData and JSON can be used to expose a middle tier__ to different clients using protocols that are widely understood. 

Biggest advantage is that __all the business logic is transferred from client application into the middle tier__. And the middle tier holds the final control over what data goes in or out. 

Still, there're still some business logic on the client tier as well. But it only __complement the rules__ that are enforced on the server. Eg. Twitter enforce the 140 character limit locally, and stop you from sending a tweet that is too long (by graying out the Send button). 

That means, client side checks are for convenience, and for convenience only; the middle tier server is and must be authoritative for what is allowed and what is not.

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] TCP 3-Way Handshake]]></title>
    <link href="http://okckd.github.io/blog/2014/08/11/Tcp-3way-handshake/"/>
    <updated>2014-08-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/11/Tcp-3way-handshake</id>
    <content type="html"><![CDATA[### Handshaking

__[Handshaking](http://en.wikipedia.org/wiki/Handshaking) is an automated process of negotiation__ that dynamically sets parameters of a communications channel established between two entities before normal communication over the channel begins. 

It is usually a process that takes place when a computer is about to communicate with a foreign device to establish rules for communication. 

### TCP three-way handshake

__[TCP three-way handshake](http://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml)__ is the method used by TCP set up a TCP/IP connection over an Internet Protocol based network. 

It's commonly referred to as "__SYN-SYN-ACK__". 

<img class="middle" src="/assets/images/3way-Tcp-handshake.png">

### Process

1. Host A sends a TCP __SYN__chronize packet to Host B
1. Host B receives A's SYN
1. Host B sends a __SYN__chronize-__ACK__nowledgement 
1. Host A receives B's SYN-ACK
1. Host A sends __ACK__nowledge
1. Host B receives ACK. 
1. TCP socket connection is ESTABLISHED.

Alternatively, there's a good illustration on [wiki](http://en.wikipedia.org/wiki/Handshaking): 

> Establishing a normal TCP connection requires three separate steps:

> 1. The first host (Alice) sends the second host (Bob) a "synchronize" (SYN) message with its own sequence number x, which Bob receives.
>
> 1. Bob replies with a synchronize-acknowledgment (SYN-ACK) message with its own sequence number y and acknowledgement number x + 1, which Alice receives.
>
> 1. Alice replies with an acknowledgment message with acknowledgement number y + 1, which Bob receives and to which he doesn't need to reply.

### Two more thing

Note that __FTP, Telnet, HTTP, HTTPS, SMTP, POP3, IMAP, SSH__ and any other protocol that rides over TCP __also has a three way handshake__ performed as connection is opened.

TCP 'rides' on top of Internet Protocol (IP) in the protocol stack. IP handles __IP addressing and routing__ and gets the packets from one place to another, but TCP manages the __actual communication sockets__ between endpoints. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Big Data - Top K Questions (Summarize)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/10/big-data-top-k-questions-summarize/"/>
    <updated>2014-08-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/10/big-data-top-k-questions-summarize</id>
    <content type="html"><![CDATA[### Question 

[link](http://dongxicheng.org/big-data/select-ten-from-billions/)

> 在海量数据中找出出现频率最高的前K个数，或者从海量数据中找出最大的前K个数，这类问题通常称为“top K”问题，

> 1. top K value
> 1. top K frequency

### Analysis

__Standard solution__ is 【分治+trie树/hash+小顶堆】, which I covered in another post [Big Data - Top k Frequency](/blog/2014/07/25/big-data-Top-k-frequency/). Briefly it is 3 steps: 

1. 先将数据集按照hash方法分解成多个小数据集，
1. 使用trie树或者hash统计每个小数据集中的query词频，
1. 用小顶堆求出每个数据集中出频率最高的前K个数

But, there're other senarios where different solutions may apply. Consider: 

1. Single core vs. multiple core

1. Single PC vs. multiple PC

1. Large RAM vs. limited RAM

1. Distributed system

### 1. 单机+单核+足够大内存

设每个查询词平均占8Byte，则10亿个查询词所需的内存大约是10^9*8=8G内存。如果你有这么大的内存，直接在内存中对查询词进行排序，顺序遍历找出10个出现频率最大的10个即可。这种方法简单快速，更加实用。当然，也可以先用HashMap求出每个词出现的频率，然后求出出现频率最大的10个词。

### 2. 单机+单核+受限内存

这种情况下，需要将原数据文件切割成一个一个小文件，如，采用hash(x)%M，将原文件中的数据切割成M小文件，如果小文件仍大于内存大小，继续采用hash的方法对数据文件进行切割，直到每个小文件小于内存大小，这样，每个文件可放到内存中处理。采用3.1节的方法依次处理每个小文件。

### 3. 单机+多核+足够大内存

这时可以直接在内存中实用hash方法将数据划分成n个partition，每个partition交给一个线程处理，线程的处理逻辑是同[1]节类似，最后一个线程将结果归并。

该方法存在一个瓶颈会明显影响效率，即数据倾斜，每个线程的处理速度可能不同，快的线程需要等待慢的线程，最终的处理速度取决于慢的线程。解决方法是，__将数据划分成 (c x n)个partition（c>1），每个线程处理完当前partition后主动取下一个partition继续处理__，直到所有数据处理完毕，最后由一个线程进行归并。

### 4. 多机+受限内存

这种情况下，为了合理利用多台机器的资源，可将数据分发到多台机器上，每台机器采用[3]节中的策略解决本地的数据。可采用__hash + socket__方法进行数据分发。

### 5. Distributed

Top k问题很适合采用__MapReduce框架__解决，用户只需编写一个map函数和两个reduce 函数，然后提交到Hadoop（采用mapchain和reducechain）上即可解决该问题。

A map function. 对于map函数，采用hash算法，将hash值相同的数据交给同一个reduce task. 

2 reduce functions. 对于__第一个reduce函数__，采用HashMap统计出每个词出现的频率，对于__第二个reduce函数__，统计所有reduce task输出数据中的top k即可。

### 6. Other

公司一般不会自己写个程序进行计算，而是提交到自己核心的数据处理平台上计算，该平台的计算效率可能不如直接写程序高，但它具有__良好的扩展性和容错性__，而这才是企业最看重的。
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Big Data - Top K Frequency 2]]></title>
    <link href="http://okckd.github.io/blog/2014/08/10/big-data-top-k-frequency-2/"/>
    <updated>2014-08-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/10/big-data-top-k-frequency-2</id>
    <content type="html"><![CDATA[### Question 

[link](http://blog.csdn.net/v_july_v/article/details/7382693)

> 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。

### Analysis

__The basic solution for 'Top K' questions__ is 【分治+trie树/hash+小顶堆】. 

In the previous post [Big Data - Top k Frequency](/blog/2014/07/25/big-data-Top-k-frequency/), we used HashMap for calculating query frequency. Now we __use Trie to do it__. 

> 这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n x le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n x lg10)。所以总的时间复杂度，是O(n x le)与O(n x lg10)中较大的哪一个。

#### How to use Trie to calculate word frequency? 

在Trie的node节点中[添加count域后](http://blog.csdn.net/ohmygirl/article/details/7953814)，可以统计单词出现的次数。统计的方法就是在插入单词的时候，令相应的count域加1（初始化为0）. 
]]></content>
  </entry>
  
</feed>
