<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: fundamental | Shuatiblog.com]]></title>
  <link href="http://www.shuatiblog.com/blog/categories/fundamental/atom.xml" rel="self"/>
  <link href="http://www.shuatiblog.com/"/>
  <updated>2015-10-11T22:09:15-05:00</updated>
  <id>http://www.shuatiblog.com/</id>
  <author>
    <name><![CDATA[CodeMonkey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Fundamental] Segment Tree ]]></title>
    <link href="http://www.shuatiblog.com/blog/2015/10/08/segment-tree/"/>
    <updated>2015-10-08T00:00:00-05:00</updated>
    <id>http://www.shuatiblog.com/blog/2015/10/08/segment-tree</id>
    <content type="html"><![CDATA[# Overview

__[Segment tree](https://en.wikipedia.org/wiki/Segment_tree)__ is a tree data structure for storing intervals, or segments. 

Can be used to search the max/min values, or the sum values. 

1. modify = O(log n)

1. query = O(log n)

1. build = O(n)




Interval minimum number
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Fundamental] The 7 Bridges Problem ]]></title>
    <link href="http://www.shuatiblog.com/blog/2015/10/04/seven-bridge/"/>
    <updated>2015-10-04T00:00:00-05:00</updated>
    <id>http://www.shuatiblog.com/blog/2015/10/04/seven-bridge</id>
    <content type="html"><![CDATA[# Overview

In East Prussia(普鲁士), people try to walk all [7 bridges](https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg) w/o crossing a bridge twice.

Leonhard Euler (pronounced "oiler") – Swiss

# Euler path

An Euler path, also called an Eulerian trail, is a walk on the graph edges of a graph which uses each graph edge in the original graph exactly once.

## Degree

Node degree of a vertex: the number of edges incident with it.

## Euler Theorem

A graph contains an euler path iffeither of the following cases hold:

1. All except for two nodes have even degrees – the 2 odd-degree nodes must be start and end points
1. all nodes have even degrees.

# Application

networks, distributed systems, coding theory
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Fundamental] Implement Trie and Suffix Tree ]]></title>
    <link href="http://www.shuatiblog.com/blog/2015/01/28/implement-trie-suffix-tree/"/>
    <updated>2015-01-28T00:00:00-06:00</updated>
    <id>http://www.shuatiblog.com/blog/2015/01/28/implement-trie-suffix-tree</id>
    <content type="html"><![CDATA[### Trie Node

    public class TrieNode {
        boolean isLeaf;
        TrieNode[] child;

        public TrieNode(boolean isLeaf) {
            this.isLeaf = isLeaf;
            this.child = new TrieNode[26];
        }

        public void insert(String str) {
            if (str == null || str.length() == 0) {
                this.isLeaf = true;
                return;
            }
            char cur = str.charAt(0);
            if (child[cur - 'a'] == null) {
                child[cur - 'a'] = new TrieNode(str.length() == 1);
            }
            child[cur - 'a'].insert(str.substring(1));
        }

        public boolean trieSearch(String str) {
            // have to consider leaf node
            if (str == null || str.length() == 0) {
                return isLeaf;
            }
            char cur = str.charAt(0);
            if (child[cur - 'a'] == null) {
                return false;
            }
            return child[cur - 'a'].trieSearch(str.substring(1));
        }

        public boolean suffixTreeSearch(String str) {
            // suffixTreeSearch don't consider leaf node
            // cuz we search for prefix of suffixes
            if (str == null || str.length() == 0) {
                return true;
            }
            char cur = str.charAt(0);
            if (child[cur - 'a'] == null) {
                return false;
            }
            return child[cur - 'a'].suffixTreeSearch(str.substring(1));
        }
    }

### Trie

    public class Trie {
        TrieNode root;

        public Trie(String[] input) {
            root = new TrieNode(false);

            for (String str : input) {
                root.insert(str);
            }
        }

        public boolean search(String query) {
            return root.trieSearch(query);
        }
    }

#### Suffix Tree

Suffix tree might also consider the __List of indexes__ thing, which I do not take into consideration in my code. 

    public class SuffixTree {
        TrieNode root;

        public SuffixTree(String input) {
            root = new TrieNode(false);

            for (int i = 0; i < input.length(); i++) {
                root.insert(input.substring(i));
            }
        }

        public boolean search(String query) {
            return root.suffixTreeSearch(query);
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Fundamental] Suffix Tree ]]></title>
    <link href="http://www.shuatiblog.com/blog/2015/01/27/suffix-tree/"/>
    <updated>2015-01-27T00:00:00-06:00</updated>
    <id>http://www.shuatiblog.com/blog/2015/01/27/suffix-tree</id>
    <content type="html"><![CDATA[[ref](http://www.geeksforgeeks.org/pattern-searching-set-8-suffix-tree-introduction/)

### Suffix tree

Both KMP Algorithm and Rabin Karp Algorithm __pre-process the pattern__ to make the pattern searching faster. The best time complexity that we could get by preprocessing pattern is __O(n), where n is length of the text__. 

Now we will discuss an approach that __pre-processes the text__. A suffix tree is built of the text. After preprocessing text (building suffix tree of text), we can __search any pattern in O(m) time__ where m is length of the pattern.

Though search is very fast - just proportional to length of the pattern, it may become costly if __the text changes frequently__. It is good for fixed text or less frequently changing text though.

#### Suffix Tree VS. Trie

__A Suffix Tree is a compressed trie of all suffixes of the given text__. 

#### Compressed Trie

__A Compressed Trie__ is obtained from standard trie by joining chains of single nodes. 

Example, a standard trie: 

<img class="middle" src="/assets/images/standardtrieNew.png">

A Compressed Trie: 

<img class="middle" src="/assets/images/CompressedTrieNew.png">

#### build a Suffix Tree

1. Generate all suffixes of given text.
1. Consider all suffixes as individual words and build a compressed trie.

Eg.

    banana\0
    anana\0
    nana\0
    ana\0
    na\0
    a\0
    \0

Example question: __[CC150v4] 20.8 Full Text Search (Suffix Tree)__
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Fundamental] Suffix Array ]]></title>
    <link href="http://www.shuatiblog.com/blog/2015/01/27/suffix-array/"/>
    <updated>2015-01-27T00:00:00-06:00</updated>
    <id>http://www.shuatiblog.com/blog/2015/01/27/suffix-array</id>
    <content type="html"><![CDATA[[ref](http://www.geeksforgeeks.org/suffix-array-set-1-introduction/)

### Suffix Array

A suffix array is a sorted array of all suffixes of a given string. 

__Any suffix tree based algorithm__ can be replaced with an algorithm __that uses a suffix array__ enhanced with additional information and solves the same problem in the same time complexity. 

__Naive algorithm__ for construction of suffix array is to consider all suffixes, sort them using a O(nLogn) sorting algorithm and while sorting, maintain original indexes. Time complexity is _O(n^2 * Logn)__. 

There is an advanced __nLogn Algorithm__ algorithm available to read [here](http://www.geeksforgeeks.org/suffix-array-set-2-a-nlognlogn-algorithm/). Basic idea is to "Sort according to first two characters" and then "according to first four character". 

Example question: __[Facebook] Query Search (HashMap, suffix array)__. 
]]></content>
  </entry>
  
</feed>
