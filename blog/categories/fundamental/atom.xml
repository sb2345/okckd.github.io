<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: fundamental | Shuatiblog.com]]></title>
  <link href="http://www.shuatiblog.com/blog/categories/fundamental/atom.xml" rel="self"/>
  <link href="http://www.shuatiblog.com/"/>
  <updated>2015-10-15T00:04:14-05:00</updated>
  <id>http://www.shuatiblog.com/</id>
  <author>
    <name><![CDATA[CodeMonkey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Fundamental] UML Class Diagrams ]]></title>
    <link href="http://www.shuatiblog.com/blog/2015/10/14/UML-diagrams/"/>
    <updated>2015-10-14T00:00:00-05:00</updated>
    <id>http://www.shuatiblog.com/blog/2015/10/14/UML-diagrams</id>
    <content type="html"><![CDATA[# Overview

A UML class diagram describes the object and information structures used by your application, both internally and in communication with its users. 

## example

Taken from [here](https://msdn.microsoft.com/en-us/library/dd409437.aspx).

<img class="middle" src="/assets/images/IC315445.png">

<tbody><tr><th><p><span class="label">Shape</span></p></th><th><p><span class="label">Element</span></p></th><th><p><span class="label">Description</span></p></th></tr><tr><td><p>1</p></td><td><p><strong>Class</strong></p></td><td><p>A definition of objects that share given structural or behavioral characteristics. For more information, see <a href="https://msdn.microsoft.com/en-us/library/dd323860.aspx">Properties of types on UML class diagrams</a>.</p></td></tr><tr><td><p>1</p></td><td><p>Classifier</p></td><td><p>The general name for a class, interface, or enumeration. Components, use cases, and actors are also classifiers.</p></td></tr><tr><td><p>2</p></td><td><p>Collapse/ Expand control</p></td><td><p>If you cannot see the details of a classifier, click the expander at upper-left of the classifier. You might also have to click the [+] on each segment.</p></td></tr><tr><td><p>3</p></td><td><p><strong>Attribute</strong></p></td><td><p>A typed value attached to each instance of a classifier. </p><p>To add an attribute, click the <strong>Attributes</strong> section and then press <strong>ENTER</strong>. Type the signature of the attribute. For more information, see <a href="https://msdn.microsoft.com/en-us/library/dd323861.aspx">Properties of attributes on UML class diagrams</a>.</p></td></tr><tr><td><p>4</p></td><td><p><strong>Operation</strong></p></td><td><p>A method or function that can be performed by instances of a classifier. To add an operation, click the <strong>Operations</strong> section and then press <strong>ENTER</strong>. Type the signature of the operation. For more information, see <a href="https://msdn.microsoft.com/en-us/library/dd323859.aspx">Properties of operations on UML class diagrams</a>. </p></td></tr><tr><td><p>5</p></td><td><p><strong>Association</strong></p></td><td><p>A relationship between the members of two classifiers. For more information, see <a href="https://msdn.microsoft.com/en-us/library/dd323862.aspx">Properties of associations on UML class diagrams</a>. </p></td></tr><tr><td><p>5a</p></td><td><p><strong>Aggregation</strong></p></td><td><p>An association representing a shared ownership relationship. The <strong>Aggregation</strong> property of the owner role is set to <strong>Shared</strong>.</p></td></tr><tr><td><p>5b</p></td><td><p><strong>Composition</strong></p></td><td><p>An Association representing a whole-part relationship. The <strong>Aggregation</strong> property of the owner role is set to <strong>Composite</strong>.</p></td></tr><tr><td><p>6</p></td><td><p><strong>Association Name</strong></p></td><td><p>The name of an association. The name can be left empty.</p></td></tr><tr><td><p>7</p></td><td><p><strong>Role Name</strong></p></td><td><p>The name of a role, that is, one end of an association. Can be used to refer to the associated object. In the previous illustration, for any Order <span class="code">O</span>, <span class="code">O.ChosenMenu</span> is its associated Menu.</p><p>Each role has its own properties, listed under the properties of the association.</p></td></tr><tr><td><p>8</p></td><td><p><strong>Multiplicity</strong></p></td><td><p>Indicates how many of the objects at this end can be linked to each object at the other. In the example, each Order must be linked to exactly one Menu. </p><p><strong>*</strong> means that there is no upper limit to the number of links that can be made.</p></td></tr><tr><td><p>9</p></td><td><p><strong>Generalization</strong></p></td><td><p>The <em>specific</em> classifier inherits part of its definition from the <em>general</em> classifier. The general classifier is at the arrow end of the connector. Attributes, associations, and operations are inherited by the specific classifier.</p><p>Use the <strong>Inheritance</strong> tool to create a generalization between two classifiers.</p></td></tr></tbody>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Fundamental] Segment Tree ]]></title>
    <link href="http://www.shuatiblog.com/blog/2015/10/08/segment-tree/"/>
    <updated>2015-10-08T00:00:00-05:00</updated>
    <id>http://www.shuatiblog.com/blog/2015/10/08/segment-tree</id>
    <content type="html"><![CDATA[# Overview

__[Segment tree](https://en.wikipedia.org/wiki/Segment_tree)__ is a tree data structure for storing intervals, or segments. 

Can be used to search __the max/min or sum values in a range__. 

1. modify = O(log n)

1. query = O(log n)

1. build = O(n)

## question list

1. [LintCode] Segment Tree Build

1. [LintCode] Segment Tree Build II

1. [LintCode] Segment Tree Modify

1. [LintCode] Segment Tree Query

1. [LintCode] Segment Tree Query II
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Fundamental] The 7 Bridges Problem ]]></title>
    <link href="http://www.shuatiblog.com/blog/2015/10/04/seven-bridge/"/>
    <updated>2015-10-04T00:00:00-05:00</updated>
    <id>http://www.shuatiblog.com/blog/2015/10/04/seven-bridge</id>
    <content type="html"><![CDATA[# Overview

In East Prussia(普鲁士), people try to walk all [7 bridges](https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg) w/o crossing a bridge twice.

Leonhard Euler (pronounced "oiler") – Swiss

# Euler path

An Euler path, also called an Eulerian trail, is a walk on the graph edges of a graph which uses each graph edge in the original graph exactly once.

## Degree

Node degree of a vertex: the number of edges incident with it.

## Euler Theorem

A graph contains an euler path iffeither of the following cases hold:

1. All except for two nodes have even degrees – the 2 odd-degree nodes must be start and end points
1. all nodes have even degrees.

# Application

networks, distributed systems, coding theory
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Fundamental] Implement Trie and Suffix Tree ]]></title>
    <link href="http://www.shuatiblog.com/blog/2015/01/28/implement-trie-suffix-tree/"/>
    <updated>2015-01-28T00:00:00-06:00</updated>
    <id>http://www.shuatiblog.com/blog/2015/01/28/implement-trie-suffix-tree</id>
    <content type="html"><![CDATA[### Trie Node

    public class TrieNode {
        boolean isLeaf;
        TrieNode[] child;

        public TrieNode(boolean isLeaf) {
            this.isLeaf = isLeaf;
            this.child = new TrieNode[26];
        }

        public void insert(String str) {
            if (str == null || str.length() == 0) {
                this.isLeaf = true;
                return;
            }
            char cur = str.charAt(0);
            if (child[cur - 'a'] == null) {
                child[cur - 'a'] = new TrieNode(str.length() == 1);
            }
            child[cur - 'a'].insert(str.substring(1));
        }

        public boolean trieSearch(String str) {
            // have to consider leaf node
            if (str == null || str.length() == 0) {
                return isLeaf;
            }
            char cur = str.charAt(0);
            if (child[cur - 'a'] == null) {
                return false;
            }
            return child[cur - 'a'].trieSearch(str.substring(1));
        }

        public boolean suffixTreeSearch(String str) {
            // suffixTreeSearch don't consider leaf node
            // cuz we search for prefix of suffixes
            if (str == null || str.length() == 0) {
                return true;
            }
            char cur = str.charAt(0);
            if (child[cur - 'a'] == null) {
                return false;
            }
            return child[cur - 'a'].suffixTreeSearch(str.substring(1));
        }
    }

### Trie

    public class Trie {
        TrieNode root;

        public Trie(String[] input) {
            root = new TrieNode(false);

            for (String str : input) {
                root.insert(str);
            }
        }

        public boolean search(String query) {
            return root.trieSearch(query);
        }
    }

#### Suffix Tree

Suffix tree might also consider the __List of indexes__ thing, which I do not take into consideration in my code. 

    public class SuffixTree {
        TrieNode root;

        public SuffixTree(String input) {
            root = new TrieNode(false);

            for (int i = 0; i < input.length(); i++) {
                root.insert(input.substring(i));
            }
        }

        public boolean search(String query) {
            return root.suffixTreeSearch(query);
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Fundamental] Suffix Tree ]]></title>
    <link href="http://www.shuatiblog.com/blog/2015/01/27/suffix-tree/"/>
    <updated>2015-01-27T00:00:00-06:00</updated>
    <id>http://www.shuatiblog.com/blog/2015/01/27/suffix-tree</id>
    <content type="html"><![CDATA[[ref](http://www.geeksforgeeks.org/pattern-searching-set-8-suffix-tree-introduction/)

### Suffix tree

Both KMP Algorithm and Rabin Karp Algorithm __pre-process the pattern__ to make the pattern searching faster. The best time complexity that we could get by preprocessing pattern is __O(n), where n is length of the text__. 

Now we will discuss an approach that __pre-processes the text__. A suffix tree is built of the text. After preprocessing text (building suffix tree of text), we can __search any pattern in O(m) time__ where m is length of the pattern.

Though search is very fast - just proportional to length of the pattern, it may become costly if __the text changes frequently__. It is good for fixed text or less frequently changing text though.

#### Suffix Tree VS. Trie

__A Suffix Tree is a compressed trie of all suffixes of the given text__. 

#### Compressed Trie

__A Compressed Trie__ is obtained from standard trie by joining chains of single nodes. 

Example, a standard trie: 

<img class="middle" src="/assets/images/standardtrieNew.png">

A Compressed Trie: 

<img class="middle" src="/assets/images/CompressedTrieNew.png">

#### build a Suffix Tree

1. Generate all suffixes of given text.
1. Consider all suffixes as individual words and build a compressed trie.

Eg.

    banana\0
    anana\0
    nana\0
    ana\0
    na\0
    a\0
    \0

Example question: __[CC150v4] 20.8 Full Text Search (Suffix Tree)__
]]></content>
  </entry>
  
</feed>
