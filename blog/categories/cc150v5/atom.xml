<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cc150v5 | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/cc150v5/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-15T21:10:49+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 3.7 Stack of Animals]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/stack-of-animals/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/15/stack-of-animals</id>
    <content type="html"><![CDATA[### Question

> An animal shelter holds only dogs and cats. People must adopt either the "oldest" animals, or they can select whether they would prefer a dog or a cat (and will receive the oldest animal of that type). They cannot select which specific animal they would like. 

> Create the data structures to maintain this system and implement operations such as enqueue, dequeueAny, dequeueDog and dequeueCat. You may use the built-in LinkedList data structure. 

### Solution

There are 2 solutions.

__First one is using a single queue__. This makes 'dequeueAny' easy, but 'dequeueCat' and 'dequeueDog' difficult. 

__Second approach would be using 2 queues for dogs and cats__. We need something like timestamp to be stored (more space usage). 

When we return, we peek both queues are choose the older one. __This is recommended solution in the book__. 

### Code

__from the book__

Animal.java

	public abstract class Animal {
		int order;
		String name;

		public Animal(String n) {
			name = n;
		}

		public abstract String name();

		public boolean isOlderThan(Animal a) {
			return this.order < a.order;
		}
	}

	class Cat extends Animal {
		public Cat(String n) {
			super(n);
		}

		public String name() {
			return "Cat: " + name;
		}
	}

	class Dog extends Animal {
		public Dog(String n) {
			super(n);
		}

		public String name() {
			return "Dog: " + name;
		}
	}

AnimalQueue.java

	public class AnimalQueue {
		LinkedList<Dog> dogs = new LinkedList<Dog>();
		LinkedList<Cat> cats = new LinkedList<Cat>();
		private int order = 0;

		public void enqueue(Animal a) {
			a.order = order;
			order++;
			if (a instanceof Dog) {
				dogs.addLast((Dog) a);
			} else if (a instanceof Cat) {
				cats.addLast((Cat) a);
			}
		}

		public Animal dequeueAny() {
			if (dogs.size() == 0) {
				return dequeueCats();
			} else if (cats.size() == 0) {
				return dequeueDogs();
			}
			Dog dog = dogs.peek();
			Cat cat = cats.peek();
			if (dog.isOlderThan(cat)) {
				return dogs.poll();
			} else {
				return cats.poll();
			}
		}

		public Animal peek() {
			if (dogs.size() == 0) {
				return cats.peek();
			} else if (cats.size() == 0) {
				return dogs.peek();
			}
			Dog dog = dogs.peek();
			Cat cat = cats.peek();
			if (dog.isOlderThan(cat)) {
				return dog;
			} else {
				return cat;
			}
		}

		public int size() {
			return dogs.size() + cats.size();
		}

		public Dog dequeueDogs() {
			return dogs.poll();
		}

		public Dog peekDogs() {
			return dogs.peek();
		}

		public Cat dequeueCats() {
			return cats.poll();
		}

		public Cat peekCats() {
			return cats.peek();
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 3.2 Stack Min Value]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/stack-get-min-value/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/15/stack-get-min-value</id>
    <content type="html"><![CDATA[### Question

> How would you design a stack which, in addition to push and pop, also has a function min which returns the minimum element? 

> Push, pop and min should all operate in 0(1) time. 

### Solution

This is __a very tricky question__. 

The key is how to use the minimum space to achieve O(1) query min operation. The trick is to count how many times the same min-value occur. Eg. 

> input: 5,3,3,1,1,2,2,2,2,2,2,2.
>
> stack: 5,3,3,1,1.

So we can pop '1' twice, pop '3' twice, and pop '5' once. Read the code! 

### Code

	public class StackMyAnswer extends Stack<Integer> {

		Stack<Integer> min = new Stack<Integer>();

		public void push(int value) {
			if (min.isEmpty() || value <= min.peek()) {
				min.push(value);
			}
			super.push(value);
		}

		public Integer pop() {
			int val = super.pop();
			if (!min.isEmpty() && val == min.peek()) {
				min.pop();
			}
			return val;
		}

		public int min() {
			if (min.isEmpty()) {
				return Integer.MAX_VALUE;
			}
			return min.peek();
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 2.7 Linked List Palindrome]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/linked-list-palindrome/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/15/linked-list-palindrome</id>
    <content type="html"><![CDATA[### Question

> Implement a function to check if a linked list is a palindrome. 

### Solution

There are multiple solutions for this question. 

__First, maybe the simplest solution of all__, is to compare the list with the reversed list (compare first half would be enough). This is a very nice idea. 

__Second solution is iterative approach__. My code below is to first get the total length, then __use a Stack__. Alternatively, we can also use __fast/slow pointer__ to find the mid point. This solution is easiest to write. 

__Third solution is recursive__. We basically uses a public pointer to: 

1. get starting value
1. check middle parts
1. get ending value
1. if starting == ending and middle part is valid, then true.

This code is not easy to write, and hard to think. 

It's best to know both iterative and recursive solution. 

### Code

Iterative

	public static boolean isPalindrome1(LinkedListNode head) {
		int len = getListLength(head);
		int half = len / 2;
		Stack<Integer> stack = new Stack<Integer>();
		for (int i = 0; i < half; i++) {
			stack.push(head.data);
			head = head.next;
		}
		if (len % 2 == 1) {
			head = head.next;
		}
		for (int i = 0; i < half; i++) {
			if (head.data != stack.pop()) {
				return false;
			}
			head = head.next;
		}
		return true;
	}

Recursive

	private static LinkedListNode p;

	public static boolean isPalindrome2(LinkedListNode head) {
		p = head;
		int len = getListLength(head);
		return helper2(0, len - 1);
	}

	public static boolean helper2(int from, int to) {
		if (from > to) {
			return true;
		} else if (from == to) {
			p = p.next;
			return true;
		} else {
			// first get fromVal, then check middlep part, last, get toVal
			int fromVal = p.data;
			p = p.next;
			if (!helper2(from + 1, to - 1)) {
				return false;
			}
			int toVal = p.data;
			p = p.next;
			if (fromVal != toVal) {
				return false;
			}
		}
		return true;
	}

Shared method:

	private static int getListLength(LinkedListNode node) {
		int count = 0;
		while (node != null) {
			count++;
			node = node.next;
		}
		return count;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] Chap 3 Example - Implement Stack]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/implement-stack/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/15/implement-stack</id>
    <content type="html"><![CDATA[### Question

> Implement a stack. 

### Solution

__Stack uses LinkedNode to implement__. 

### Code

    public class MyStack {

        Node top;

        public int pop() {
            if (top == null) {
                return -1;
            }
            int returnVal = top.val;
            top = top.next;
            return returnVal;
        }

        public int peek() {
            if (top == null) {
                return -1;
            }
            return top.val;

        }

        public void push(int val) {
            Node newNode = new Node(val);
            newNode.next = top;
            top = newNode;
        }

        class Node {

            int val;
            Node next;

            Node(int value) {
                val = value;
            }
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 2.]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/</id>
    <content type="html"><![CDATA[### Question

> 

### Solution



### Code


]]></content>
  </entry>
  
</feed>
