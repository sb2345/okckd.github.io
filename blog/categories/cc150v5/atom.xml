<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cc150v5 | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/cc150v5/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-29T19:02:11+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 14.]]></title>
    <link href="http://okckd.github.io/blog/2014/09/29/"/>
    <updated>2014-09-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/</id>
    <content type="html"><![CDATA[### Question

> 

### Solution



### Code


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 11.8 Get Rank in Stream of Integers]]></title>
    <link href="http://okckd.github.io/blog/2014/09/28/get-rank-stream-integers/"/>
    <updated>2014-09-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/28/get-rank-stream-integers</id>
    <content type="html"><![CDATA[### Question

> Imagine you are reading in a stream of integers. Periodically, you wish to be able to look up the rank of a number x (the number of values less than or equal to x). 

> Implement the data structures and algorithms to support these operations. That is,implement the method __track(int x)__, which is called when each number is generated, and the method __getRankOfNumber(int x)__, which returns the number of values less than or equal to x (not including x itself). 

### Solution

__This question requires a special type of Data Structure__. It basically is a modified BST like this: 

> The tree node stores both number value and the __count of node on left subtree__

<img class="middle" src="/assets/images/get-rank-number-stream.png">

Suppose we want to find the rank of 24 in the tree above. We would compare 24 with the root, 20, and find that 24 must reside on the right. The root has 4 nodes in its left subtree, and when we include the root itself, this gives us five total nodes smaller than 24. We set counter to 5.

Then, we compare 24 with node 25 and find that 24 must be on the left. The value of counter does not update, since we're not "passing over" any smaller nodes. The value of counter is still 5. 

Next, we compare 24 with node 23,and find that 24 must be on the right. Counter gets incremented by just 1 (to 6), since 23 has no left nodes.

Finally, we find 24 and we return counter: 6.

### Code

I did not write code myself. It's too complex! 

__RankNode.java__

    public class RankNode {
        public int left_size = 0;
        public RankNode left;
        public RankNode right;
        public int data = 0;
        public RankNode(int d) {
            data = d;
        }

        public void insert(int d) {
            if (d <= data) {
                if (left != null) {
                    left.insert(d);
                } else {
                    left = new RankNode(d);
                }
                left_size++;
            } else {
                if (right != null) {
                    right.insert(d);
                } else {
                    right = new RankNode(d);
                }
            }
        }

        public int getRank(int d) {
            if (d == data) {
                return left_size;
            } else if (d < data) {
                if (left == null) {
                    return -1;
                } else {
                    return left.getRank(d);
                }
            } else {
                int right_rank = right == null ? -1 : right.getRank(d);
                if (right_rank == -1) {
                    return -1;
                } else {
                    return left_size + 1 + right_rank;
                }
            }
        }
    }

__Main Class__: 

    public class Question {
        private static RankNode root = null;

        public static void track(int number) {
            if (root == null) {
                root = new RankNode(number);
            } else {
                root.insert(number);
            }
        }

        public static int getRankOfNumber(int number) {
            return root.getRank(number);
        }

        public static void main(String[] args) {
            int size = 100;
            int[] list = AssortedMethods.randomArray(size, -100, 100);
            for (int i = 0; i < list.length; i++) {
                track(list[i]);
            }

            int[] tracker = new int[size];
            for (int i = 0; i < list.length; i++) {
                int v = list[i];
                int rank1 = root.getRank(list[i]);
                tracker[rank1] = v;
            }

            for (int i = 0; i < tracker.length - 1; i++) {
                if (tracker[i] != 0 && tracker[i + 1] != 0) {
                    if (tracker[i] > tracker[i + 1]) {
                        System.out.println("ERROR at " + i);
                    }
                }
            }

            System.out.println("Array: " + AssortedMethods.arrayToString(list));
            System.out.println("Ranks: " + AssortedMethods.arrayToString(tracker));
        }

    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 17.6 Order an Array by Sorting Middle]]></title>
    <link href="http://okckd.github.io/blog/2014/09/27/Order-array-by-sorting-middle/"/>
    <updated>2014-09-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/27/Order-array-by-sorting-middle</id>
    <content type="html"><![CDATA[### Question

> Given an array of integers, write a method to find indices m and n such that if you sorted elements m through n, the entire array would be sorted. Minimize n-m (that is, find the smallest such sequence).

### Solution

Referring to [this guy](http://www.mitbbs.com/article_t/JobHunting/32772399.html): 

> 1. 找到heading的最长递增序列.
>
> 1. 找到tailing的最长的递增序列.

After that: 

> 1. 用中间部分的min去shrink左边.
>
> 1. 用中间部分的max去shrink右边.

### Code

__written by me__

	public static void findUnsortedSequence(int[] array, int[] ans) {
		int len = array.length;
		ans[0] = 0;
		ans[1] = 0;

		// find increasing sequence on left and on right
		int leftPeak = 0;
		while (leftPeak < len - 1) {
			if (array[leftPeak] < array[leftPeak + 1]) {
				leftPeak++;
			} else {
				break;
			}
		}
		if (leftPeak == len - 1) {
			return;
		}
		int rightBottom = len - 1;
		while (rightBottom > 0) {
			if (array[rightBottom] > array[rightBottom - 1]) {
				rightBottom--;
			} else {
				break;
			}
		}

		// leftPeak and rightBottom are found, now read mid part
		int midMin = Integer.MAX_VALUE;
		int midMax = Integer.MIN_VALUE;
		for (int i = leftPeak; i <= rightBottom; i++) {
			midMin = Math.min(midMin, array[i]);
			midMax = Math.max(midMax, array[i]);
		}

		// find left boudary and right boundary
		int leftBound = leftPeak;
		while (leftBound >= 0) {
			if (array[leftBound] < midMin) {
				break;
			}
			leftBound--;
		}
		int rightBound = rightBottom;
		while (rightBound < len) {
			if (array[rightBound] > midMax) {
				break;
			}
			rightBound++;
		}

		// finish it up
		ans[0] = leftBound + 1;
		ans[1] = rightBound - 1;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 14.6 Implement CircularArray in Java]]></title>
    <link href="http://okckd.github.io/blog/2014/09/26/implement-circular-array-java/"/>
    <updated>2014-09-26T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/26/implement-circular-array-java</id>
    <content type="html"><![CDATA[### Question

> Implement a __CircularArray__ class that supports an array-like data structure which can be efficiently rotated. 

> The class should use a generic type, and should support iteration via the standard for (Object : circuLarArray) notation. 

### Solution

__First part of the question is solved by using an array and a pointer__. The solution simplifies the question by fixing the array size (not a dynamic-resizing array). 

__The difficult part is how to write iterator__.

Note that we should support __Java Generics__:

    class MyCircularArray<T>

Implement __Iterable Interface__:

    public class MyCircularArray<T> implements Iterable<T> {
    }

Override __iterator() method__:

	@Override
	public Iterator<T> iterator() {
		return new MyIterator<T>(this);
	}

Write our own __Iterator Class__:

	class MyIterator<T> implements Iterator<T> {
    }

Finish it up

    public class MyCircularArray<T> implements Iterable<T> {

        @Override
        public Iterator<T> iterator() {
            return new MyIterator<T>(this);
        }

        class MyIterator<T> implements Iterator<T> {
            @Override
            public boolean hasNext() {
            }

            @Override
            public T next() {
            }

            @Override
            public void remove() {
            }
        }
    }

It might be confusing when implementing __Iterable__ and __Iterator__ Class.

### Code

    public class MyCircularArray<T> implements Iterable<T> {

        T[] items;

        int head;
        int cur;

        public MyCircularArray(int size) {
            // this is really important (casting the type)
            items = (T[]) new Object[size];

            head = 0;
            cur = 0;
        }

        public void put(T item) {
            items[cur++] = item;
            cur = cur % items.length;
        }

        public T get(int i) {
            int newIndex = (i + head) % items.length;
            return items[newIndex];
        }

        public void rotate(int shiftRight) {
            head += shiftRight;
            head = head % items.length;
        }

        @Override
        public Iterator<T> iterator() {
            return new MyIterator<T>(this);
        }

        class MyIterator<T> implements Iterator<T> {

            T[] items;
            int head;
            int count;

            public MyIterator(MyCircularArray<T> array) {
                this.items = array.items;
                this.head = array.head;
                this.count = 0;
            }

            @Override
            public boolean hasNext() {
                return this.count != items.length;
            }

            @Override
            public T next() {
                if (hasNext()) {
                    return items[(head + count++) % items.length];
                }
                return null;
            }

            @Override
            public void remove() {
            }
        }

    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] Chap12 Example - Troubleshoot Google Chrome]]></title>
    <link href="http://okckd.github.io/blog/2014/09/24/troubleshoot-google-chrome/"/>
    <updated>2014-09-24T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/24/troubleshoot-google-chrome</id>
    <content type="html"><![CDATA[### Question

> You'reworking on the Google Chrome team when you receivea bug report: Chrome crashes on launch. What would you do? 

### Step 1: Understand the Scenario

1. How long has user seen this issue?
1. version of browser and OS?
1. Does this happen consistently? How often, and when?

### Step 2: Break Down the Problem

Flow of situation:

1. start menu
1. click chrome
1. browser starts
1. browser load settings
1. browser issues HTTP response
1. browser get HTTP response
1. browser parses webpage
1. browser displays content

__At some points in this process, something fails__. A good tester would iterate thru the elements of this scenario and diagnose the problem. 

### Step 3: Create Specific, Manageable Tests

Come up with realistic instructions. 
]]></content>
  </entry>
  
</feed>
