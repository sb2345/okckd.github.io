<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cc150v5 | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/cc150v5/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-18T01:06:26+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 9.10 Stack Up the Boxes]]></title>
    <link href="http://okckd.github.io/blog/2014/09/17/stack-up-boxes/"/>
    <updated>2014-09-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/17/stack-up-boxes</id>
    <content type="html"><![CDATA[### Question

> You have a stack of n boxes, with widths w., heights h, and depths d. The boxes can only be stacked on top of one another if each box is strictly larger than the box above it in width, height, and depth. 

> Implement a method to build the tallest stack possible, where the height of a stack is the sum of the heights of each box. 

### Solution

This is appearantly a DP question. I did it in the normal way, and the solution turns out to be very good: 

	DP solution is        2638ms
	Recursive solution is 1322ms
	My solution is         370ms

I could not understand the 2 solutions given in the book. Sorry.

The coding is a bit lengthy, and we keeps 2 DP arrays. __Not an easy question of course__, but the solution is actually standard. 

### Code

	public static ArrayList<Box> createStack(Box[] boxes) {
		ArrayList<Box> ans = new ArrayList<Box>();
		int len = boxes.length;
		int[] heights = new int[len];
		int[] preMap = new int[len];
		int maxIndex = 0;

		// start DP
		for (int i = 0; i < len; i++) {
			heights[i] = boxes[i].height;
			preMap[i] = -1;
			for (int j = 0; j < i; j++) {
				if (boxes[j].canBeAbove(boxes[i])) {
					int newHeight = heights[j] + boxes[i].height;
					if (newHeight > heights[i]) {
						heights[i] = newHeight;
						preMap[i] = j;
					}
				}
			}
			// now updated maxIndex
			if (heights[i] > heights[maxIndex]) {
				maxIndex = i;
			}
		}

		// print from maxIndex all the way backwards
		while (maxIndex != -1) {
			ans.add(boxes[maxIndex]);
			// the print order is reversed, so...
			maxIndex = preMap[maxIndex];
		}
		return ans;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 9.11 Parenthesize the Expression]]></title>
    <link href="http://okckd.github.io/blog/2014/09/17/parenthesize-expression/"/>
    <updated>2014-09-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/17/parenthesize-expression</id>
    <content type="html"><![CDATA[### Question

> Given a boolean expression consisting of the symbols 0, 1, '&', '|', and '^', and a desired boolean result value 'result'. 

> Now implement a function to count the number of ways of __parenthesizing the expression__ such that it evaluates to 'result'.

### Solution



### Code


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 9.7 Paint Fill in Map]]></title>
    <link href="http://okckd.github.io/blog/2014/09/17/paint-fill-map/"/>
    <updated>2014-09-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/17/paint-fill-map</id>
    <content type="html"><![CDATA[### Question

> Implement the "paint fill" function that one might see on many image editing programs. 

> That is, given a screen (represented by a two-dimensional array of colors), a point, and a new color, __fill in the surrounding area__ until the color changes from the original color. 

### Solution

This is a BFS/DFS question, very similar to __[LeetCode 130] Surrounded Regions__. 

__However, this question is not same as surrounding region__, because no temporary storage of state is needed, __and we DO NOT NEED TO keep track of the visited positions__! 

Why is this? 

1. This question, we simple change the color __from A to B__. 
1. Surrounding Region is __change A to B, and B to A__. 

That's why, the nature of 2 questions are different. 

Code 1 is my first solution, and Code 2 is doing a BFS and set color directly to expected value. This type of questions is highly frequent and sometimes may cause confusions. 

### Code

__my code 1__, with 'temp' state

	public static void PaintFill1(Color[][] screen, int posX, int posY,
			Color ncolor) {
		// the queue keeps the list of positions that I'm going to visit
		Queue<Position> q = new LinkedList<Position>();
		int len = screen.length;
		Color original = screen[posX][posY];
		// visited origin node first
		q.offer(new Position(posX, posY));
		while (!q.isEmpty()) {
			// visit positions in q one by one (mark color as 'Temp')
			Position p = q.poll();
			if (p.x < 0 || p.x >= len || p.y < 0 || p.y >= len) {
				// invalid pos coordinate
				continue;
			} else if (screen[p.x][p.y] == Color.Temp
					|| screen[p.x][p.y] != original) {
				continue;
			}
			screen[p.x][p.y] = Color.Temp;
			q.offer(new Position(p.x - 1, p.y));
			q.offer(new Position(p.x + 1, p.y));
			q.offer(new Position(p.x, p.y - 1));
			q.offer(new Position(p.x, p.y + 1));
		}
		// finish visiting all positions that's original color
		for (int i = 0; i < len; i++) {
			for (int j = 0; j < len; j++) {
				if (screen[i][j] == Color.Temp) {
					screen[i][j] = ncolor;
				}
			}
		}
	}

__my code 2__, without 'temp' state

	public static void PaintFill2(Color[][] screen, int posX, int posY,
			Color ncolor) {
		// the queue keeps the list of positions that I'm going to visit
		Queue<Position> q = new LinkedList<Position>();
		int len = screen.length;
		Color original = screen[posX][posY];
		// visited origin node first
		q.offer(new Position(posX, posY));
		while (!q.isEmpty()) {
			// visit positions in q one by one (mark color as 'Temp')
			Position p = q.poll();
			if (p.x < 0 || p.x >= len || p.y < 0 || p.y >= len) {
				// invalid pos coordinate
				continue;
			} else if (screen[p.x][p.y] != original) {
				continue;
			}
			screen[p.x][p.y] = ncolor;
			q.offer(new Position(p.x - 1, p.y));
			q.offer(new Position(p.x + 1, p.y));
			q.offer(new Position(p.x, p.y - 1));
			q.offer(new Position(p.x, p.y + 1));
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 9.3 Find Magic Index]]></title>
    <link href="http://okckd.github.io/blog/2014/09/17/find-magic-index/"/>
    <updated>2014-09-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/17/find-magic-index</id>
    <content type="html"><![CDATA[### Question 1 

> A magic index in an array A[l.. .n-l] is defined to be an index such that A[i] = i. 

> Given a sorted array of distinct integers, write a method to find a magic index, if one exists, in array A. 

### Question 2 

> FOLLOW UP: What if the values are not distinct? 

### Solution

__This is a difficult binary search question__! 

__Question 1 is slightly easier__: we simplyl use binary search, and we are able to discard half of the array each time. 

1. if (array[mid] > mid), then we discard the right half.
1. if (array[mid] < mid), then we discard the left half.

__Question 2 is difficult__. We cannot discard half of the input any more. Instead, we discard a range between (mid) and (array[mid]). Then check left and right part seperately. 

So, I wrote the following code:

	int mid = left + (right - left) / 2;
	if (array[mid] == mid) {
		return mid;
	} else {
		int smaller = Math.min(array[mid], mid);
		int larger = Math.max(array[mid], mid);
		int leftResult = helper(array, left, smaller);
		if (leftResult != -1) {
			return leftResult;
		} else {
			return helper(array, larger, right);
		}
	}

This becomes an endless loop. We did not discard point 'mid' in the code above. The correct code is posted below. 

### Code

__code for non-duplicate input__

	public static int myAnswerNonDup(int[] array) {
		int len = array.length;
		return helper(array, 0, len - 1);
	}

	public static int helper(int[] array, int left, int right) {
		if (right < left) {
			return -1;
		}
		int mid = left + (right - left) / 2;
		if (array[mid] == mid) {
			return mid;
		} else if (array[mid] < mid) {
			// discard all element to the left of array[mid]
			return helper(array, mid + 1, right);
		} else {
			return helper(array, left, mid - 1);
		}
	}

__code for have-duplicate input__

	public static int myAnswerWithDup(int[] array) {
		int len = array.length;
		return helper(array, 0, len - 1);
	}

	public static int helper(int[] array, int left, int right) {
		if (right < left) {
			return -1;
		}
		int mid = left + (right - left) / 2;
		if (array[mid] == mid) {
			return mid;
		} else {
			int smaller = 0;
			int larger = 0;
			if (array[mid] < mid) {
				smaller = array[mid];
				larger = mid + 1;
			} else if (array[mid] > mid) {
				smaller = mid - 1;
				larger = array[mid];
			}
			int leftResult = helper(array, left, smaller);
			if (leftResult != -1) {
				return leftResult;
			} else {
				return helper(array, larger, right);
			}
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 9.]]></title>
    <link href="http://okckd.github.io/blog/2014/09/17/"/>
    <updated>2014-09-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/</id>
    <content type="html"><![CDATA[### Question

> 

### Solution



### Code


]]></content>
  </entry>
  
</feed>
