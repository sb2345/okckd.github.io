<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cc150v5 | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/cc150v5/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-15T10:38:38+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 2.7 Linked List Palindrome]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/linked-list-palindrome/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/15/linked-list-palindrome</id>
    <content type="html"><![CDATA[### Question

> Implement a function to check if a linked list is a palindrome. 

### Solution

There are multiple solutions for this question. 

__First, maybe the simplest solution of all__, is to compare the list with the reversed list (compare first half would be enough). This is a very nice idea. 

__Second solution is iterative approach__. My code below is to first get the total length, then __use a Stack__. Alternatively, we can also use __fast/slow pointer__ to find the mid point. This solution is easiest to write. 

__Third solution is recursive__. We basically uses a public pointer to: 

1. get starting value
1. check middle parts
1. get ending value
1. if starting == ending and middle part is valid, then true.

This code is not easy to write, and hard to think. 

It's best to know both iterative and recursive solution. 

### Code

Iterative

	public static boolean isPalindrome1(LinkedListNode head) {
		int len = getListLength(head);
		int half = len / 2;
		Stack<Integer> stack = new Stack<Integer>();
		for (int i = 0; i < half; i++) {
			stack.push(head.data);
			head = head.next;
		}
		if (len % 2 == 1) {
			head = head.next;
		}
		for (int i = 0; i < half; i++) {
			if (head.data != stack.pop()) {
				return false;
			}
			head = head.next;
		}
		return true;
	}

Recursive

	private static LinkedListNode p;

	public static boolean isPalindrome2(LinkedListNode head) {
		p = head;
		int len = getListLength(head);
		return helper2(0, len - 1);
	}

	public static boolean helper2(int from, int to) {
		if (from > to) {
			return true;
		} else if (from == to) {
			p = p.next;
			return true;
		} else {
			// first get fromVal, then check middlep part, last, get toVal
			int fromVal = p.data;
			p = p.next;
			if (!helper2(from + 1, to - 1)) {
				return false;
			}
			int toVal = p.data;
			p = p.next;
			if (fromVal != toVal) {
				return false;
			}
		}
		return true;
	}

Shared method:

	private static int getListLength(LinkedListNode node) {
		int count = 0;
		while (node != null) {
			count++;
			node = node.next;
		}
		return count;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] Chap 3 Example - Implement Stack]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/implement-stack/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/15/implement-stack</id>
    <content type="html"><![CDATA[### Question

> Implement a stack. 

### Solution

__Stack uses LinkedNode to implement__. 

### Code

    public class MyStack {

        Node top;

        public int pop() {
            if (top == null) {
                return -1;
            }
            int returnVal = top.val;
            top = top.next;
            return returnVal;
        }

        public int peek() {
            if (top == null) {
                return -1;
            }
            return top.val;

        }

        public void push(int val) {
            Node newNode = new Node(val);
            newNode.next = top;
            top = newNode;
        }

        class Node {

            int val;
            Node next;

            Node(int value) {
                val = value;
            }
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 2.]]></title>
    <link href="http://okckd.github.io/blog/2014/09/15/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/</id>
    <content type="html"><![CDATA[### Question

> 

### Solution



### Code


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 2.2 Kth Last Element (Recursive)]]></title>
    <link href="http://okckd.github.io/blog/2014/09/14/kth-last-element-recursive/"/>
    <updated>2014-09-14T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/14/kth-last-element-recursive</id>
    <content type="html"><![CDATA[### Question

> Implement an algorithm to find the kth to last element of a singly linked list.

> Do it recursively.

### Solution

Iterative solution is easy, __recursive is not__. 

### Code

	private static int myAns = -1;

	public static int nthToLastMe(LinkedListNode head, int n) {
		if (head == null) {
			return 0;
		} else if (nthToLastMe(head.next, n) < n - 1) {
			return nthToLastMe(head.next, n) + 1;
		} else if (nthToLastMe(head.next, n) == n - 1) {
			myAns = head.data;
			return Integer.MAX_VALUE;
		}
		return Integer.MAX_VALUE;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 17.6 Order an Array by Sorting Middle]]></title>
    <link href="http://okckd.github.io/blog/2014/09/02/Order-array-by-sorting-middle/"/>
    <updated>2014-09-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/02/Order-array-by-sorting-middle</id>
    <content type="html"><![CDATA[### Question

> Given an array of integers, write a method to find indices m and n such that if you sorted elements m through n, the entire array would be sorted. Minimize n-m (that is, find the smallest such sequence).

### Solution

Referring to [this guy](http://www.mitbbs.com/article_t/JobHunting/32772399.html): 

> 1. 找到heading的最长递增序列
>
> 1. 找到tailing的最长的递增序列

After that: 

> 1. 用中间部分的min去shrink左边 更新max
>
> 1. 根据更新后的max shrink右边 更新min
>
> 1. 再一次shrink左边

### Code

	public static int findEndOfLeftSubsequence(int[] array) {
		for (int i = 1; i < array.length; i++) {
			if (array[i] < array[i - 1]) {
				return i - 1;
			}
		}
		return array.length - 1;
	}

	public static int findStartOfRightSubsequence(int[] array) {
		for (int i = array.length - 2; i >= 0; i--) {
			if (array[i] > array[i + 1]) {
				return i + 1;
			}
		}
		return 0;
	}

	public static int shrinkLeft(int[] array, int min_index, int start) {
		int comp = array[min_index];
		for (int i = start - 1; i >= 0; i--) {
			if (array[i] <= comp) {
				return i + 1;
			}
		}
		return 0;
	}

	public static int shrinkRight(int[] array, int max_index, int start) {
		int comp = array[max_index];
		for (int i = start; i < array.length; i++) {
			if (array[i] >= comp) {
				return i - 1;
			}
		}
		return array.length - 1;
	}

	public static void findUnsortedSequence(int[] array) {
		// find left subsequence
		int end_left = findEndOfLeftSubsequence(array);

		if (end_left >= array.length - 1) {
			// System.out.println("The array is already sorted.");
			return; // Already sorted
		}

		// find right subsequence
		int start_right = findStartOfRightSubsequence(array);

		int max_index = end_left; // max of left side
		int min_index = start_right; // min of right side
		for (int i = end_left + 1; i < start_right; i++) {
			if (array[i] < array[min_index]) {
				min_index = i;
			}
			if (array[i] > array[max_index]) {
				max_index = i;
			}
		}

		// slide left until less than array[min_index]
		int left_index = shrinkLeft(array, min_index, end_left);

		// slide right until greater than array[max_index]
		int right_index = shrinkRight(array, max_index, start_right);

		if (validate(array, left_index, right_index)) {
			System.out.println("TRUE: " + left_index + " " + right_index);
		} else {
			System.out.println("FALSE: " + left_index + " " + right_index);
		}
	}
]]></content>
  </entry>
  
</feed>
