<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cc150v5 | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/cc150v5/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-15T08:38:06+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 2.2 Kth Last Element (Recursive)]]></title>
    <link href="http://okckd.github.io/blog/2014/09/14/kth-last-element-recursive/"/>
    <updated>2014-09-14T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/14/kth-last-element-recursive</id>
    <content type="html"><![CDATA[### Question

> Implement an algorithm to find the kth to last element of a singly linked list.

> Do it recursively.

### Solution

Iterative solution is easy, __recursive is not__. 

### Code

	private static int myAns = -1;

	public static int nthToLastMe(LinkedListNode head, int n) {
		if (head == null) {
			return 0;
		} else if (nthToLastMe(head.next, n) < n - 1) {
			return nthToLastMe(head.next, n) + 1;
		} else if (nthToLastMe(head.next, n) == n - 1) {
			myAns = head.data;
			return Integer.MAX_VALUE;
		}
		return Integer.MAX_VALUE;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 2.]]></title>
    <link href="http://okckd.github.io/blog/2014/09/14/"/>
    <updated>2014-09-14T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/</id>
    <content type="html"><![CDATA[### Question

> 

### Solution



### Code


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 17.6 Order an Array by Sorting Middle]]></title>
    <link href="http://okckd.github.io/blog/2014/09/02/Order-array-by-sorting-middle/"/>
    <updated>2014-09-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/02/Order-array-by-sorting-middle</id>
    <content type="html"><![CDATA[### Question

> Given an array of integers, write a method to find indices m and n such that if you sorted elements m through n, the entire array would be sorted. Minimize n-m (that is, find the smallest such sequence).

### Solution

Referring to [this guy](http://www.mitbbs.com/article_t/JobHunting/32772399.html): 

> 1. 找到heading的最长递增序列
>
> 1. 找到tailing的最长的递增序列

After that: 

> 1. 用中间部分的min去shrink左边 更新max
>
> 1. 根据更新后的max shrink右边 更新min
>
> 1. 再一次shrink左边

### Code

	public static int findEndOfLeftSubsequence(int[] array) {
		for (int i = 1; i < array.length; i++) {
			if (array[i] < array[i - 1]) {
				return i - 1;
			}
		}
		return array.length - 1;
	}

	public static int findStartOfRightSubsequence(int[] array) {
		for (int i = array.length - 2; i >= 0; i--) {
			if (array[i] > array[i + 1]) {
				return i + 1;
			}
		}
		return 0;
	}

	public static int shrinkLeft(int[] array, int min_index, int start) {
		int comp = array[min_index];
		for (int i = start - 1; i >= 0; i--) {
			if (array[i] <= comp) {
				return i + 1;
			}
		}
		return 0;
	}

	public static int shrinkRight(int[] array, int max_index, int start) {
		int comp = array[max_index];
		for (int i = start; i < array.length; i++) {
			if (array[i] >= comp) {
				return i - 1;
			}
		}
		return array.length - 1;
	}

	public static void findUnsortedSequence(int[] array) {
		// find left subsequence
		int end_left = findEndOfLeftSubsequence(array);

		if (end_left >= array.length - 1) {
			// System.out.println("The array is already sorted.");
			return; // Already sorted
		}

		// find right subsequence
		int start_right = findStartOfRightSubsequence(array);

		int max_index = end_left; // max of left side
		int min_index = start_right; // min of right side
		for (int i = end_left + 1; i < start_right; i++) {
			if (array[i] < array[min_index]) {
				min_index = i;
			}
			if (array[i] > array[max_index]) {
				max_index = i;
			}
		}

		// slide left until less than array[min_index]
		int left_index = shrinkLeft(array, min_index, end_left);

		// slide right until greater than array[max_index]
		int right_index = shrinkRight(array, max_index, start_right);

		if (validate(array, left_index, right_index)) {
			System.out.println("TRUE: " + left_index + " " + right_index);
		} else {
			System.out.println("FALSE: " + left_index + " " + right_index);
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 8.4 Design a Parking Lot]]></title>
    <link href="http://okckd.github.io/blog/2014/08/25/design-parking-lot/"/>
    <updated>2014-08-25T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/25/design-parking-lot</id>
    <content type="html"><![CDATA[### Question

> Design a Parking Lot. 

### Solution

Class hierarchy:

1. A parking lot has multiple Levels.
1. A Level has multiple Parking Spot.
1. A Spot can park motorcycle, car or bus, which all belongs to Vehicle. 

Implement methods:

1. Vehicle.parkInSpot(Spot s)
1. Vehicle.leaveSpot(Spot s)
1. Vehicle.canFitIn(Spot s)
1. ParkingLot.parkVehicle(Vehicle v)
1. Level.parkVehicle(Vehicle v)
1. Level.parkVehicleAtSpot(Vehicle v, Spot s)
1. Level.findAvailableSpot(VehicleType vt)

__ParkingLot Class is just a wrapper class of Levels__. By doing this, we seperated out parking logic from other broader actions (like Spot management). 

The code below is from CC150v5. __Its design is a bit strange__ (a car can occupy multiple spots), so just use this code as a guide but not a reference. 

### Code 

ParkingLot.java

    public class ParkingLot {
        private Level[] levels;
        private final int NUM_LEVELS = 5;
        
        public ParkingLot() {
            levels = new Level[NUM_LEVELS];
            for (int i = 0; i < NUM_LEVELS; i++) {
                levels[i] = new Level(i, 30);
            }
        }
        
        /* Park the vehicle in a spot (or multiple spots). Return false if failed. */
        public boolean parkVehicle(Vehicle vehicle) {
            for (int i = 0; i < levels.length; i++) {
                if (levels[i].parkVehicle(vehicle)) {
                    return true;
                }
            }
            return false;
        }

        public void print() {
            for (int i = 0; i < levels.length; i++) {
                System.out.print("Level" + i + ": ");
                levels[i].print();
                System.out.println("");
            }
            System.out.println("");
        }
    }

Level.java

    /* Represents a level in a parking garage */
    public class Level {
        private int floor;
        private ParkingSpot[] spots;
        private int availableSpots = 0; // number of free spots
        private static final int SPOTS_PER_ROW = 10;

        public Level(int flr, int numberSpots) {
            floor = flr;
            spots = new ParkingSpot[numberSpots];
            int largeSpots = numberSpots / 4;
            int bikeSpots = numberSpots / 4;
            int compactSpots = numberSpots - largeSpots - bikeSpots;
            for (int i = 0; i < numberSpots; i++) {
                VehicleSize sz = VehicleSize.Motorcycle;
                if (i < largeSpots) {
                    sz = VehicleSize.Large;
                } else if (i < largeSpots + compactSpots) {
                    sz = VehicleSize.Compact;
                }
                int row = i / SPOTS_PER_ROW;
                spots[i] = new ParkingSpot(this, row, i, sz);
            }
            availableSpots = numberSpots;
        }

        public int availableSpots() {
            return availableSpots;
        }

        /* Try to find a place to park this vehicle. Return false if failed. */
        public boolean parkVehicle(Vehicle vehicle) {
            if (availableSpots() < vehicle.getSpotsNeeded()) {
                return false;
            }
            int spotNumber = findAvailableSpots(vehicle);
            if (spotNumber < 0) {
                return false;
            }
            return parkStartingAtSpot(spotNumber, vehicle);
        }

        /* Park a vehicle starting at the spot spotNumber, and continuing until vehicle.spotsNeeded. */
        private boolean parkStartingAtSpot(int spotNumber, Vehicle vehicle) {
            vehicle.clearSpots();
            boolean success = true;
            for (int i = spotNumber; i < spotNumber + vehicle.spotsNeeded; i++) {
                 success &= spots[i].park(vehicle);
            }
            availableSpots -= vehicle.spotsNeeded;
            return success;
        }

        /* find a spot to park this vehicle. Return index of spot, or -1 on failure. */
        private int findAvailableSpots(Vehicle vehicle) {
            int spotsNeeded = vehicle.getSpotsNeeded();
            int lastRow = -1;
            int spotsFound = 0;
            for (int i = 0; i < spots.length; i++) {
                ParkingSpot spot = spots[i];
                if (lastRow != spot.getRow()) {
                    spotsFound = 0;
                    lastRow = spot.getRow();
                }
                if (spot.canFitVehicle(vehicle)) {
                    spotsFound++;
                } else {
                    spotsFound = 0;
                }
                if (spotsFound == spotsNeeded) {
                    return i - (spotsNeeded - 1);
                }
            }
            return -1;
        }

        public void print() {
            int lastRow = -1;
            for (int i = 0; i < spots.length; i++) {
                ParkingSpot spot = spots[i];
                if (spot.getRow() != lastRow) {
                    System.out.print("  ");
                    lastRow = spot.getRow();
                }
                spot.print();
            }
        }

        /* When a car was removed from the spot, increment availableSpots */
        public void spotFreed() {
            availableSpots++;
        }
    }

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 8.9 Design a In-memory File System]]></title>
    <link href="http://okckd.github.io/blog/2014/08/25/design-in-memory-file-system/"/>
    <updated>2014-08-25T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/25/design-in-memory-file-system</id>
    <content type="html"><![CDATA[### Question

> Explain the data structures and algorithms that you would use to design an in-memory file system. Illustrate with an example in code where possible. 

### Solution

__A file system consists of Files and Directories__. Each Directory contains a set of Files and Directories. 

Since Files and Directories share so many characteristics, we've implemented them such that they __inherit from the same class__ -- Entry. 

### Code

Entry.java

    public abstract class Entry {
        protected Directory parent;
        protected long created;
        protected long lastUpdated;
        protected long lastAccessed;
        protected String name;

        public Entry(String n, Directory p) {
            name = n;
            parent = p;
            created = System.currentTimeMillis();
        }

        public boolean delete() {
            if (parent == null) {
                return false;
            }
            return parent.deleteEntry(this);
        }

        public abstract int size();

        public String getFullPath() {
            if (parent == null) {
                return name;
            } else {
                return parent.getFullPath() + "/" + name;
            }
        }

        public long getCreationTime() {
            return created;
        }

        public long getLastUpdatedTime() {
            return lastUpdated;
        }

        public long getLastAccessedTime() {
            return lastAccessed;
        }

        public void changeName(String n) {
            name = n;
        }

        public String getName() {
            return name;
        }
    }

Directory.java

    public class Directory extends Entry {
        protected ArrayList<Entry> contents;

        public Directory(String n, Directory p) {
            super(n, p);
            contents = new ArrayList<Entry>();
        }

        protected ArrayList<Entry> getContents() {
            return contents;
        }

        public int size() {
            int size = 0;
            for (Entry e : contents) {
                size += e.size();
            }
            return size;
        }

        public int numberOfFiles() {
            int count = 0;
            for (Entry e : contents) {
                if (e instanceof Directory) {
                    count++; // Directory counts as a file
                    Directory d = (Directory) e;
                    count += d.numberOfFiles();
                } else if (e instanceof File) {
                    count++;
                }
            }
            return count;
        }

        public boolean deleteEntry(Entry entry) {
            return contents.remove(entry);
        }

        public void addEntry(Entry entry) {
            contents.add(entry);
        }
    }

File.java

    public class File extends Entry {
        private String content;
        private int size;

        public File(String n, Directory p, int sz) {
            super(n, p);
            size = sz;
        }

        public int size() {
            return size;
        }

        public String getContents() {
            return content;
        }

        public void setContents(String c) {
            content = c;
        }
    }
]]></content>
  </entry>
  
</feed>
