<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cc150v5 | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/cc150v5/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-16T22:38:56+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 5.6 Swap Odd and Even Bits]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/swap-odd-even-bits/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/swap-odd-even-bits</id>
    <content type="html"><![CDATA[### Question

> Write a program to swap odd and even bits in an integer with as few instructions as possible (e.g., bit 0 and bit 1 are swapped, bit 2 and bit 3 are swapped, and so on). 

### Solution

Mask odd and even bits seperately. 

### Code

	public static int swapOddEvenBits(int x) {
		return (((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1));
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 9.3 Find Magic Index (`)]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/find-magic-index/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/find-magic-index</id>
    <content type="html"><![CDATA[### Question

> A magic index in an array A[l.. .n-l] is defined to be an index such that A[i] = i. 

> Given a sorted array of distinct integers, write a method to find a magic index, if one exists, in array A. 

> FOLLOW UP: What if the values are not distinct? 

### Solution



### Code


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 5.5 Calculate Bits Conversion Required]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/calculate-bits-convertions/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/calculate-bits-convertions</id>
    <content type="html"><![CDATA[### Question

> Write a function to determine the number of bits (change) required to convert integer A to integer B. 

### Solution

The only thing to know is __how to count the number of '1's in a integer__. It's like this: 

> c = c & (c - l) clears the least significant bit of '1'. 
>
> Keep doing this until all '1's are cleared. 

### Code

__code 1__

	public static int calcBitsSwapMe1(int a, int b) {
		int num = a ^ b;
		int count = 0;
		while (num != 0) {
			count += num & 1;
			num = num >>> 1;
		}
		return count;
	}

__code 2__

	public static int calcBitsSwapMe2(int a, int b) {
		int num = a ^ b;
		int count = 0;
		while (num != 0) {
			num = num & (num - 1);
			count++;
		}
		return count;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Brain Teaser] 6.1 Bottles of Pills]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/bottles-of-spills/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/bottles-of-spills</id>
    <content type="html"><![CDATA[### Question

> You have 20 bottles of pills. 19 bottles have 1.0 gram pills, but one has pills of weight 1.1 grams. 

> Given a scale, how to find the heavy bottle __only scaling ONCE__? 

### Solution

Take 1 pill from Bottle 1, 2 pills from Bottle 2, and so on. We'll expect (1 + 2 + ... + 20) = 210 gram of pills. 

The answer would be {(weight - 210 grams) / 0.1}. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 5.1 Binary Merge 2 Numbers]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/binary-merge-two-numbers/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/binary-merge-two-numbers</id>
    <content type="html"><![CDATA[### Question

> You are given two 32-bit numbers, N andM, and two bit positions, i and j. Write a method to insert M into Nsuch that M starts at bit j and ends at bit i. You can assume that the bits j through i have enough space to fit all ofM. That is, ifM= 10011, you can assume that there are at least 5 bits between j and i. You would not, for example, have j-3 and i=2, because M could not fully fit between bit 3 and bit 2.

> EXAMPLE: 
>
> Input: N = 16000000000, M = 10011, i = 2, j = 6
>
> Output: N = 10001001100

### Solution

__This is a basic bit manipulation question__. The key is to use binary maks. Two things to note: 

1. The '~' means negate. So (~0) is a sequence of 1 (the value equals to -1). 

1. When shifting bits, __DO NOT USE '>>' because it's signed shift__. Instead, __use '>>>' (unsigned right shift operator)__. 

### Code

__written by me__

	public static int myAnswer(int n, int m, int i, int j) {
		int rr = (~0 >>> (31 - j));
		int ll = (~0 << i);
		// printBinary(rr);
		// printBinary(ll);

		int middleMask = ll & rr;
		int twoEndMask = ll ^ rr;

		n = n & twoEndMask;
		m = (m << i) & middleMask;

		return n | m;
	}
]]></content>
  </entry>
  
</feed>
