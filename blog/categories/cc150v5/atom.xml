<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cc150v5 | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/cc150v5/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-10-26T17:27:36+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 18.7 Longest Word Made From Other Words]]></title>
    <link href="http://okckd.github.io/blog/2014/10/02/longest-word-made-from-other/"/>
    <updated>2014-10-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/10/02/longest-word-made-from-other</id>
    <content type="html"><![CDATA[### Question

> Given a list of words, write a program to find the longest word made of other words in the list.

> EXAMPLE
>
> Input: cat, banana, dog, nana, walk, walker, dogwalker
>
> Output: dogwalker

### Solution

__Search it recursively from longest to shortest__. Use HashSet to help us search for words quickly. 

This question might look difficult at first, it's actually a very classical recursive search. 

### Code

	public static void printLongestWord(String[] arr) {
		Arrays.sort(arr, new LengthComparator());
		HashSet<String> set = new HashSet<String>();
		for (String str : arr) {
			set.add(str);
		}
		for (String word : arr) {
			if (canDivide(word, 0, set)) {
				System.out.println(word);
				return;
			}
		}
		System.out.println("can not find such word");
	}

	private static boolean canDivide(String word, int from, HashSet<String> set) {
		if (from == word.length()) {
			return true;
		}
		for (int i = from; i < word.length(); i++) {
			String str = word.substring(from, i + 1);
			if (from == 0 && i == word.length() - 1) {
				continue;
			} else if (!set.contains(str)) {
				continue;
			}
			if (canDivide(word, i + 1, set)) {
				return true;
			}
		}
		return false;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 17.14 Optimal Way to Unconcatenate Doc]]></title>
    <link href="http://okckd.github.io/blog/2014/10/01/optimal-unconcatenate-doc/"/>
    <updated>2014-10-01T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/10/01/optimal-unconcatenate-doc</id>
    <content type="html"><![CDATA[### Question

> Given a lengthy document without spaces, punctuation, and capitalization:

> eg: iresetthecomputeritstilldidntboot

> Now add back in the punctation and capitalization. 

> Most of the words will be in a dictionary, but some strings, like proper names, will not. Given a dictionary (a list of words), design an algorithm to find the optimal way of "unconcatenating" a sequence of words (by minimizing unrecognized sequences of characters).

> For example, the string "jesslookedjustliketimherbrother" would be optimally parsed as "JESS looked just like TIM her brother". This parsing has seven unrecognized characters, which we have capitalized for clarity. 

### Solution

The solution given in the book is very hard to understand. It uses HashMap to memorize the previous result. 

After long time of struggle, I finally solved it with traditional DP approach. The key idea is to consider: "__whether I insert a space after this char, or not__". 

The code is concise and easy to read. 

### Code

	public static int parse(String doc, Trie dict) {
		int len = doc.length();
		int[] dp = new int[len + 1];
		// dp[i] denotes the number of special chars in first i chars of docs
		for (int i = 1; i <= len; i++) {
			dp[i] =  Integer.MAX_VALUE;
			for (int j = 0; j < i; j++) {
				String str = doc.substring(j, i);
				if (dict.contains(str, true)) {
					// consider (i to j) a valid word
					dp[i] = Math.min(dp[i], dp[j]);
				} else {
					// consider (i to j) special chars
					dp[i] = Math.min(dp[i], dp[j] + i - j);
				}
			}
		}
		return dp[len];
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 17.13 Convert BST to Doubly-Linked List]]></title>
    <link href="http://okckd.github.io/blog/2014/09/30/convert-bst-doubly-linked-list/"/>
    <updated>2014-09-30T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/30/convert-bst-doubly-linked-list</id>
    <content type="html"><![CDATA[### Question

> Consider a simple node-like data structure called BiNode, which has pointers to two other nodes.

    public class BiNode {
        public BiNode node1, node2;
        public int data;
    }

> The data structure BiNode could be used to represent both a binary tree (where node1 is the left node and node2 is the right node) or a doubly linked list (where node1 is the previous node and node2 is the next node). Implement a method to convert a binary search tree (implemented with BiNode) into a doubly linked list. The values should be kept in order and the operation should be performed in place (that is, on the original data structure). 

### Solution

At another post __[LeetCode Plus] Convert BST to Doubly-Linked List__, we already discussed 2 approaches: 

1. in-order traversal approach
1. divide and conquer approach

First approach isn't intuitive. We will further discuss D&C approach here. 

__The key of the solution is how we return both HEAD and TAIL__. The book suggests 3 ways: 

1. Build a __data structure__ to store both head and tail
1. __Just return head__, and retrieve tail by traversing thru - bad time complexity O(n^2)
1. __Use circular linked-list__! Time O(n). 

I wrote the code for 2nd suggestion. 

__The circular list is a great idea__. It's already covered in previous post. Do keep in mind __why we need the list to be circular__! 

### Code

__Just return head approach__

	public static BiNode convert(BiNode root) {
		if (root == null) {
			return null;
		}
		return helper(root);
	}

	private static BiNode helper(BiNode node) {
		// node is not null
		BiNode newHead = node;
		// do left part
		if (node.node1 != null) {
			newHead = helper(node.node1);
			BiNode leftTail = getListTail(newHead);
			leftTail.node2 = node;
			node.node1 = leftTail;
		}
		// do right part
		if (node.node2 != null) {
			BiNode rightHead = helper(node.node2);
			node.node2 = rightHead;
			rightHead.node1 = node;
		}
		return newHead;
	}

	private static BiNode getListTail(BiNode head) {
		// head is not null
		while (head.node2 != null) {
			head = head.node2;
		}
		return head;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 11.8 Get Rank in Stream of Integers]]></title>
    <link href="http://okckd.github.io/blog/2014/09/28/get-rank-stream-integers/"/>
    <updated>2014-09-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/28/get-rank-stream-integers</id>
    <content type="html"><![CDATA[### Question

> Imagine you are reading in a stream of integers. Periodically, you wish to be able to look up the rank of a number x (the number of values less than or equal to x). 

> Implement the data structures and algorithms to support these operations. That is,implement the method __track(int x)__, which is called when each number is generated, and the method __getRankOfNumber(int x)__, which returns the number of values less than or equal to x (not including x itself). 

### Solution

__This question requires a special type of Data Structure__. It basically is a modified BST like this: 

> The tree node stores both number value and the __count of node on left subtree__

<img class="middle" src="/assets/images/get-rank-number-stream.png">

Suppose we want to find the rank of 24 in the tree above. We would compare 24 with the root, 20, and find that 24 must reside on the right. The root has 4 nodes in its left subtree, and when we include the root itself, this gives us five total nodes smaller than 24. We set counter to 5.

Then, we compare 24 with node 25 and find that 24 must be on the left. The value of counter does not update, since we're not "passing over" any smaller nodes. The value of counter is still 5. 

Next, we compare 24 with node 23,and find that 24 must be on the right. Counter gets incremented by just 1 (to 6), since 23 has no left nodes.

Finally, we find 24 and we return counter: 6.

### Code

I did not write code myself. It's too complex! 

__RankNode.java__

    public class RankNode {
        public int left_size = 0;
        public RankNode left;
        public RankNode right;
        public int data = 0;
        public RankNode(int d) {
            data = d;
        }

        public void insert(int d) {
            if (d <= data) {
                if (left != null) {
                    left.insert(d);
                } else {
                    left = new RankNode(d);
                }
                left_size++;
            } else {
                if (right != null) {
                    right.insert(d);
                } else {
                    right = new RankNode(d);
                }
            }
        }

        public int getRank(int d) {
            if (d == data) {
                return left_size;
            } else if (d < data) {
                if (left == null) {
                    return -1;
                } else {
                    return left.getRank(d);
                }
            } else {
                int right_rank = right == null ? -1 : right.getRank(d);
                if (right_rank == -1) {
                    return -1;
                } else {
                    return left_size + 1 + right_rank;
                }
            }
        }
    }

__Main Class__: 

    public class Question {
        private static RankNode root = null;

        public static void track(int number) {
            if (root == null) {
                root = new RankNode(number);
            } else {
                root.insert(number);
            }
        }

        public static int getRankOfNumber(int number) {
            return root.getRank(number);
        }

        public static void main(String[] args) {
            int size = 100;
            int[] list = AssortedMethods.randomArray(size, -100, 100);
            for (int i = 0; i < list.length; i++) {
                track(list[i]);
            }

            int[] tracker = new int[size];
            for (int i = 0; i < list.length; i++) {
                int v = list[i];
                int rank1 = root.getRank(list[i]);
                tracker[rank1] = v;
            }

            for (int i = 0; i < tracker.length - 1; i++) {
                if (tracker[i] != 0 && tracker[i + 1] != 0) {
                    if (tracker[i] > tracker[i + 1]) {
                        System.out.println("ERROR at " + i);
                    }
                }
            }

            System.out.println("Array: " + AssortedMethods.arrayToString(list));
            System.out.println("Ranks: " + AssortedMethods.arrayToString(tracker));
        }

    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 14.6 Implement CircularArray in Java]]></title>
    <link href="http://okckd.github.io/blog/2014/09/26/implement-circular-array-java/"/>
    <updated>2014-09-26T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/26/implement-circular-array-java</id>
    <content type="html"><![CDATA[### Question

> Implement a __CircularArray__ class that supports an array-like data structure which can be efficiently rotated. 

> The class should use a generic type, and should support iteration via the standard for (Object : circuLarArray) notation. 

### Solution

__First part of the question is solved by using an array and a pointer__. The solution simplifies the question by fixing the array size (not a dynamic-resizing array). 

__The difficult part is how to write iterator__.

Note that we should support __Java Generics__:

    class MyCircularArray<T>

Implement __Iterable Interface__:

    public class MyCircularArray<T> implements Iterable<T> {
    }

Override __iterator() method__:

	@Override
	public Iterator<T> iterator() {
		return new MyIterator<T>(this);
	}

Write our own __Iterator Class__:

	class MyIterator<T> implements Iterator<T> {
    }

Finish it up

    public class MyCircularArray<T> implements Iterable<T> {

        @Override
        public Iterator<T> iterator() {
            return new MyIterator<T>(this);
        }

        class MyIterator<T> implements Iterator<T> {
            @Override
            public boolean hasNext() {
            }

            @Override
            public T next() {
            }

            @Override
            public void remove() {
            }
        }
    }

It might be confusing when implementing __Iterable__ and __Iterator__ Class.

### Code

    public class MyCircularArray<T> implements Iterable<T> {

        T[] items;

        int head;
        int cur;

        public MyCircularArray(int size) {
            // this is really important (casting the type)
            items = (T[]) new Object[size];

            head = 0;
            cur = 0;
        }

        public void put(T item) {
            items[cur++] = item;
            cur = cur % items.length;
        }

        public T get(int i) {
            int newIndex = (i + head) % items.length;
            return items[newIndex];
        }

        public void rotate(int shiftRight) {
            head += shiftRight;
            head = head % items.length;
        }

        @Override
        public Iterator<T> iterator() {
            return new MyIterator<T>(this);
        }

        class MyIterator<T> implements Iterator<T> {

            T[] items;
            int head;
            int count;

            public MyIterator(MyCircularArray<T> array) {
                this.items = array.items;
                this.head = array.head;
                this.count = 0;
            }

            @Override
            public boolean hasNext() {
                return this.count != items.length;
            }

            @Override
            public T next() {
                if (hasNext()) {
                    return items[(head + count++) % items.length];
                }
                return null;
            }

            @Override
            public void remove() {
            }
        }

    }
]]></content>
  </entry>
  
</feed>
