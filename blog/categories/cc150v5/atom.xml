<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cc150v5 | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/cc150v5/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-24T22:51:36+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[CC150v5] Chap12 Example - Troubleshoot Google Chrome]]></title>
    <link href="http://okckd.github.io/blog/2014/09/24/troubleshoot-google-chrome/"/>
    <updated>2014-09-24T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/24/troubleshoot-google-chrome</id>
    <content type="html"><![CDATA[### Question

> You'reworking on the Google Chrome team when you receivea bug report: Chrome crashes on launch. What would you do? 

### Step 1: Understand the Scenario

1. How long has user seen this issue?
1. version of browser and OS?
1. Does this happen consistently? How often, and when?

### Step 2: Break Down the Problem

Flow of situation:

1. start menu
1. click chrome
1. browser starts
1. browser load settings
1. browser issues HTTP response
1. browser get HTTP response
1. browser parses webpage
1. browser displays content

__At some points in this process, something fails__. A good tester would iterate thru the elements of this scenario and diagnose the problem. 

### Step 3: Create Specific, Manageable Tests

Come up with realistic instructions. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 11.4 Sort 20GB File]]></title>
    <link href="http://okckd.github.io/blog/2014/09/24/sort-20GB-file/"/>
    <updated>2014-09-24T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/24/sort-20GB-file</id>
    <content type="html"><![CDATA[### Question

> Imagine you have a 20 GB file with one string per line. 

> Explain how you would sort the file. 

### Solution

__External Sort__

1. First divide the file into chunks which are x megabytes each, where x is the amount of memory we have available. 

1. Each chunk is sorted separately and then saved back to the file system.

1. Once all the chunks are sorted, we then merge the chunks, one by one.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 11.8 Get Rank in Stream of Integers (`)]]></title>
    <link href="http://okckd.github.io/blog/2014/09/24/get-rank-stream-integers/"/>
    <updated>2014-09-24T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/24/get-rank-stream-integers</id>
    <content type="html"><![CDATA[### Question

> Imagine you are reading in a stream of integers. Periodically, you wish to be able to look up the rank of a number x (the number of values less than or equal to x). 

> Implement the data structures and algorithms to support these operations. That is,implement the method __track(int x)__, which is called when each number is generated, and the method __getRankOfNumber(int x)__, which returns the number of values less than or equal to x (not including x itself). 

### Solution

Too sleepy to do this. 

### Code


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 14.]]></title>
    <link href="http://okckd.github.io/blog/2014/09/24/"/>
    <updated>2014-09-24T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/</id>
    <content type="html"><![CDATA[### Question

> 

### Solution



### Code


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v5] 9.10 Stack Up the Boxes]]></title>
    <link href="http://okckd.github.io/blog/2014/09/17/stack-up-boxes/"/>
    <updated>2014-09-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/17/stack-up-boxes</id>
    <content type="html"><![CDATA[### Question

> You have a stack of n boxes, with widths w., heights h, and depths d. The boxes can only be stacked on top of one another if each box is strictly larger than the box above it in width, height, and depth. 

> Implement a method to build the tallest stack possible, where the height of a stack is the sum of the heights of each box. 

### Solution

This is appearantly a DP question. I did it in the normal way, and the solution turns out to be very good: 

	DP solution is        2638ms
	Recursive solution is 1322ms
	My solution is         370ms

I could not understand the 2 solutions given in the book. Sorry.

The coding is a bit lengthy, and we keeps 2 DP arrays. __Not an easy question of course__, but the solution is actually standard. 

### Code

	public static ArrayList<Box> createStack(Box[] boxes) {
		ArrayList<Box> ans = new ArrayList<Box>();
		int len = boxes.length;
		int[] heights = new int[len];
		int[] preMap = new int[len];
		int maxIndex = 0;

		// start DP
		for (int i = 0; i < len; i++) {
			heights[i] = boxes[i].height;
			preMap[i] = -1;
			for (int j = 0; j < i; j++) {
				if (boxes[j].canBeAbove(boxes[i])) {
					int newHeight = heights[j] + boxes[i].height;
					if (newHeight > heights[i]) {
						heights[i] = newHeight;
						preMap[i] = j;
					}
				}
			}
			// now updated maxIndex
			if (heights[i] > heights[maxIndex]) {
				maxIndex = i;
			}
		}

		// print from maxIndex all the way backwards
		while (maxIndex != -1) {
			ans.add(boxes[maxIndex]);
			// the print order is reversed, so...
			maxIndex = preMap[maxIndex];
		}
		return ans;
	}
]]></content>
  </entry>
  
</feed>
