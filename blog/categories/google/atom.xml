<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-02-08T18:40:21+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Transform a Unbalanced Tree Into Balanced Tree]]></title>
    <link href="http://okckd.github.io/blog/2015/02/08/unbalanced-tree-into-balanced-tree/"/>
    <updated>2015-02-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/08/unbalanced-tree-into-balanced-tree</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t/JobHunting/32043661.html)

> How to transform a unbalanced tree into balanced tree?

### Solution 

Solution 1, do AVL tree balancing. Refer to __[Design] BST Node Insertion / Deletion__. This is of course, pretty difficult to code. 

Best solution is to __convert to DLL and then build a new tree__! 



### Code

not written
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Max Prodcut of Strings That Have No Common Char]]></title>
    <link href="http://okckd.github.io/blog/2015/02/07/max-product-string-no-common-char/"/>
    <updated>2015-02-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/07/max-product-string-no-common-char</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t1/JobHunting/32868775_0_1.html)

> Given a dictionary of wrods,find the pair of word with following property: 

> 1. the two word don't have same letter. 
>
> 2. the multiple of the two word's length is maximum. 

> I give a simple O(n*n*k)(k is the average length of word) method.but i think there will be better one.

### Solution 

[Best answer](http://www.careercup.com/question?id=4951409057333248) suggest as top comment: 

> Assuming the word is A-Z/a-z only, use a bitmap to set which letters it contains. 

> e.g. ca => 000....101 
>
> bb => 000...010 

This is called __Bitmask__ of string. Read __[Question] Check string with no common letters (Bitmask)__.

Then: 

> Iterate over the words in decreasing order of length. 

> for each pair of words, AND the bitmaps. 

> Return the first pair that gives a 0 result. 

> This should be n*k + n*n

#### Be cautious

For the second part of the solution above, is this code going to work? 

    Arrays.sort(strs) in descending order;
    for (int i = 0; i < strs.length; i++) {
        for (int j = 0; j < i; j++) {
            if (strs[i].bitmask & strs[j].bitmask == 0) {
                // this pair do not have common char
                // since strs in descending order, and i, j start from 0
                // the product of length should be max
                return i + ' ' + j;
            }
        }
    }

Well, this is wrong. For example: {"ababa", "aaa", "bbb", "cc"}, if we do longest-string to shorest-string, we would return "aaa", "bbb" immediately when we found it. __However, 5 * 2 > 3 * 3__. 

So, we have to find largest product using max-heap, like we did in __[Google] Top N Values From Sum of 2 Arrays__, "pop 1 and push 2". 

### Another solution

__DP__: for each string, find the reversed set of char, and then find the max string using the reversed set. This idea is great, too, but less intuitive. 

It is explained [here](http://qr.ae/BYGHK). 

### Code

not written
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] First Unique URL]]></title>
    <link href="http://okckd.github.io/blog/2015/02/07/first-unique-url/"/>
    <updated>2015-02-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/07/first-unique-url</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=11856466)

> Given a very long list of URLs, find the first URL which is unique ( occurred exactly once ). 

> Must do it in one traversal.

### Solution 

Suggested by the [top answer and second answer](http://www.careercup.com/question?id=11856466), using __a combination of trie and linked list__. 

1. The leaf node of a trie maintains a flag to record duplicate urls and pointer to a node in a link list. 

1. Use a doubly linked list to link all the unique ones
1. Remove the URL from the list if its count goes over 1
1. So after one traversal, the first one of your linked list is the desired one. 

Alternatively, we can also use __Hash__ instead of Trie. 

### Code

not written
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Continental Divider]]></title>
    <link href="http://okckd.github.io/blog/2015/02/07/continental-divider/"/>
    <updated>2015-02-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/07/continental-divider</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t1/JobHunting/32882153_0_1.html)

> 给一个矩阵，其中0代表海洋，其他数字代表高度，秉着水往低处流的原则，求出能够流向任意海洋的点。 比如说

    0 0 0 1 2 3 0
    0 1 2 2 4 3 2
    2 1 1 3 3 2 0
    0 3 3 3 2 3 3

> 那么就要给出 第二行的4 （这有这点出发，能够找到连通道四个0的区域的一条__非递增
路线__），当然也有可能找不到这样的点，或者找到多个点。

### Solution 

I read online and the best solution I come up with is Brute Force. I did not really understand the [online discussions](http://www.mitbbs.com/article_t1/JobHunting/32882153_0_1.html). 

So if you are reading this and want to discuss with me, kindly leave me a comment! 

### Code

brute force

	public void findSuperPeak(int[][] map) {
		int m = map.length;
		int n = map[0].length;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (check(map, new Pair(i, j), m, n)) {
					System.out.println("Found point (" + i + ", " + j
							+ ") with height of " + map[i][j]);
				}
			}
		}
	}

	private boolean check(int[][] originalMap, Pair p, int m, int n) {
		// check if point can flow to all oceans
		if (originalMap[p.x][p.y] == 0) {
			return false;
		}

		int[][] map = new int[m][n];
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				map[i][j] = originalMap[i][j];
			}
		}

		Queue<Pair> q = new LinkedList<Pair>();
		q.offer(p);

		while (!q.isEmpty()) {
			Pair top = q.poll();
			int x = top.x;
			int y = top.y;
			if (map[x][y] == -1) {
				continue;
			}
			// add neighbor nodes who are visitable from here
			if (x - 1 >= 0 && map[x - 1][y] <= map[x][y]) {
				// water can flow from:
				// 1. high altitude to lower
				// 2. from ocean to ocean
				q.offer(new Pair(x - 1, y));
			}
			if (x + 1 < m && map[x + 1][y] <= map[x][y]) {
				q.offer(new Pair(x + 1, y));
			}
			if (y - 1 >= 0 && map[x][y - 1] <= map[x][y]) {
				q.offer(new Pair(x, y - 1));
			}
			if (y + 1 < n && map[x][y + 1] <= map[x][y]) {
				q.offer(new Pair(x, y + 1));
			}

			// visit this point
			map[x][y] = -1;
		}

		// now we finished BFS and the entire map with lower altitude is visited
		// (including all ocean points). We now check if there exists a 0 in map
		for (int[] arr : map)
			for (int i : arr)
				if (i == 0) // found an unvisited ocean point
					return false;
		return true;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Set Cover Problem]]></title>
    <link href="http://okckd.github.io/blog/2015/02/05/set-cover-problem/"/>
    <updated>2015-02-05T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/05/set-cover-problem</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t/JobHunting/32547841.html)

> Give a list of documents, find the minimal document set that can 
cover all the characters in all the documents. 

> eg. 

    “a b c h j”,  
    "c d”, 
    “a b c” 
    “a f g” 
    “a h j”

> The result should be 

    "a b c h j" 
    "c d" and 
    "a f g"

### Solution 

[Set cover problem](http://en.wikipedia.org/wiki/Set_cover_problem) is NP. 

__DP solution is available__ [here](http://www.mimuw.edu.pl/~malcin/dydaktyka/2012-13/fpt/fpt_04_FSC-kociumaka.pdf), with O(2 ^ n) time complexity. 

> T[i][X] denotes the minimal number of sets out of {S1, S2, . . . , Si} that covers X.

> So we have: 

> T[i][X] = min(1 + T[i − 1][X - Si], T[i − 1][X])

### Code

not written
]]></content>
  </entry>
  
</feed>
