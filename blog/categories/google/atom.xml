<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-02-05T23:59:04+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Implement a Blocking Queue]]></title>
    <link href="http://okckd.github.io/blog/2015/02/05/implement-blocking-q/"/>
    <updated>2015-02-05T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/05/implement-blocking-q</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=14622668)

> Implement a Blocking queue. 

### Solution 

First thing first, the most important characteristic of a BlockingQueue is:

> __thread-safe__ BlockingQueue

Second, we need to make sure to handle the following 2 methods: 

> __notifyAll();__
>
> __wait();__

Last, remember that __wait()__ has got a __checked exception__(InterruptedException). We end up with the code: 

	public synchronized void enqueue(Object item) throws InterruptedException {
		while (this.queue.size() == this.size) {
			wait();
		}
		if (this.queue.size() == 0) {
			notifyAll();
		}
		this.queue.add(item);
	}

### Code

The entire class, refer to __[Java OOP] Java BlockingQueue (2)__: 

    public class MyBlockingQueue {

        private List<Object> queue = new LinkedList<Object>();
        private int size = 10;

        public MyBlockingQueue(int size) {
            this.size = size;
        }

        public synchronized void enqueue(Object item) throws InterruptedException {
            while (this.queue.size() == this.size) {
                wait();
            }
            if (this.queue.size() == 0) {
                notifyAll();
            }
            this.queue.add(item);
        }

        public synchronized Object dequeue() throws InterruptedException {
            while (this.queue.size() == 0) {
                wait();
            }
            if (this.queue.size() == this.size) {
                notifyAll();
            }

            return this.queue.remove(0);
        }

        public boolean isEmpty() {
            return this.queue.isEmpty();
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Snakes and Ladders]]></title>
    <link href="http://okckd.github.io/blog/2015/02/04/snakes-and-ladders/"/>
    <updated>2015-02-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/04/snakes-and-ladders</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=14955106)

> Given a board of snakes and ladders game, provide an algorithm to find the minimum number of dice rolls required to reach 100 from 1.

### Solution 1

Recommended: __Graph (shortest path)__. [ref](http://www.careercup.com/question?id=14955106): 

1. k is linked to k + 1 k + 2, k + 3, k + 4, k + 5, k +6. 

2. If has a ladder, connect it too. 

3. Find shortest path.

Solution 2 is __DP__. 

### Variant

If the question asks: find the way to climb as many ladder as possible. Then this question would be solved differently.

Any ideas? 

Solution below. 

...

...

...

Read __[Greedy] Activity Selection Problem__. 

### Code

not written
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Number of Subtrees With Even Nodes]]></title>
    <link href="http://okckd.github.io/blog/2015/02/04/number-of-subtree-with-even-nodes/"/>
    <updated>2015-02-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/04/number-of-subtree-with-even-nodes</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t0/JobHunting/32348573.html)

> an arbitrary tree. split it into as many subtrees as you can. the 
number of nodes of the subtree must be even.

### Solution

__This is a difficult question__. The idea is recursive solution, but be cautious deadling with NULL. 

__NULL can be regarded as a child branch of even node (0)__, but NULL could not be seen as a subtreee. 

1. traverse each and every node in the tree
1. for each node, take it as root, and find left and right branch with total sum of odd count of nodes. 
1. we do above step recursively
1. include NULL as a subtree of EVEN number of nodes. 

The code below is my code and I haven't seen any reference to this question. If you read this, please comment and discuss with me! 

### Code

	public void traverseAndFindEvenSubstrees(List<TreeNode> ans, TreeNode node) {
		if (node == null) {
			return;
		}
		List<TreeNode> evenSubtrees = this.getSubtrees(node, true);
		evenSubtrees.remove(null);
		ans.addAll(evenSubtrees);

		traverseAndFindEvenSubstrees(ans, node.left);
		traverseAndFindEvenSubstrees(ans, node.right);
	}

	private List<TreeNode> getSubtrees(TreeNode root, boolean isEven) {
		List<TreeNode> ans = new ArrayList<TreeNode>();
		if (root == null) {
			if (isEven) {
				// NULL is considered as a subtree with even number (0) of nodes
				ans.add(null);
			}
			return ans;
		}
		if (isEven) {
			// we need 2 subtrees to have a combined nodes of odd numbers
			for (int i = 0; i <= 1; i++) {
				List<TreeNode> leftGroup = getSubtrees(root.left, i == 0);
				List<TreeNode> rightGroup = getSubtrees(root.right, i != 0);
				// what we do here, is to make leftGroup and rightGroup have
				// different boolean parameter, thus a total of odd count
				for (TreeNode ln : leftGroup) {
					for (TreeNode rn : rightGroup) {
						// note that NULL is included in either leftGroup or
						// rightGroup. we'll use that
						TreeNode newSubtree = new TreeNode(root.val);
						newSubtree.left = ln;
						newSubtree.right = rn;
						ans.add(newSubtree);
					}
				}
			}
			// now we've added all subtrees into ans, whose head is the root
			// this means we does not inlcude NULL
		} else {
			for (int i = 0; i <= 1; i++) {
				List<TreeNode> leftGroup = getSubtrees(root.left, i == 0);
				List<TreeNode> rightGroup = getSubtrees(root.right, i == 0);
				for (TreeNode ln : leftGroup) {
					for (TreeNode rn : rightGroup) {
						TreeNode newSubtree = new TreeNode(root.val);
						newSubtree.left = ln;
						newSubtree.right = rn;
						ans.add(newSubtree);
					}
				}
			}
		}
		// now last step, add NULL (important)
		if (isEven) {
			ans.add(null);
		}
		return ans;
	}

Test data:

    Test start
    Input is a BST with this structure: 
    4 
    2 6 
    1 3 5 7 

    Total subtree count = 16
    They are: 
    Tree 1:
    4 
    2 6 
    3 
    Tree 2:
    4 
    2 6 
    3 5 7 
    Tree 3:
    4 
    2 6 
    1 
    Tree 4:
    4 
    2 6 
    1 5 7 
    Tree 5:
    4 
    6 
    Tree 6:
    4 
    6 
    5 7 
    Tree 7:
    4 
    2 6 
    7 
    Tree 8:
    4 
    2 6 
    5 
    Tree 9:
    4 
    2 
    Tree 10:
    4 
    2 6 
    1 3 7 
    Tree 11:
    4 
    2 6 
    1 3 5 
    Tree 12:
    4 
    2 
    1 3 
    Tree 13:
    2 
    3 
    Tree 14:
    2 
    1 
    Tree 15:
    6 
    7 
    Tree 16:
    6 
    5 
    Total time = 0.006
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Data Structure of Insert, Remove, GetRandom]]></title>
    <link href="http://okckd.github.io/blog/2015/02/04/ds-insert-remove-getrandom/"/>
    <updated>2015-02-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/04/ds-insert-remove-getrandom</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=11353907)

> Design a data structure where the following 3 functions at O(1): 

    1. Insert(n) 
    2. GetRandomElement() 
    3. Remove(n) 

### Solution

Array is best for: 

1. random access

HashMap is best for: 

1. Searching
    1. insert
    1. remove

[So the answer is](http://stackoverflow.com/a/22083895) __array + hashmap__: 

1. Insertion can be done by appending to the array and adding to the hash-map.

1. Deletion can be done by first looking up and removing the array index in the hash-map, then __swapping the last element with that element in the array__. 

1. Get random can be done by returning a random index from the array.

1. All operations take O(1).

Note [how hashmap is used](http://stackoverflow.com/a/5684892):

> insert(value): append the value to array and let i be it's index in A. Set H[value]=i.

Hashmap stores value's index in the array - that is to say: __this DS does not support inserting duplicating values__. 

Finally, when we delete, we swap the last element to replace the gap. This is an nice idea! 

#### follow-up

> what if we want to get the top x% number?

Well, heap of course. And note that __Heap size is [auto-increasing](http://stackoverflow.com/a/9115884)__: 

> PriorityQueue is unbounded, it can grow as big as your memory allows, and it will grow automatically when needed. The initialCapacity parameter is just a hint to reserve room for that many elements initially.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Collatz Conjecture (Oneness Property)]]></title>
    <link href="http://okckd.github.io/blog/2015/02/04/Collatz-Conjecture-oneness/"/>
    <updated>2015-02-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/04/Collatz-Conjecture-oneness</id>
    <content type="html"><![CDATA[### Collatz Conjecture

The [Collatz conjecture](http://en.wikipedia.org/wiki/Collatz_conjecture) is a conjecture in mathematics known as the 3n + 1 conjecture. 

Take any natural number n. 

1. If n is even, divide it by 2 to get n / 2. 
1. If n is odd, multiply it by 3 and add 1 to obtain 3n + 1. 

Repeat the process (which has been called "Half Or Triple Plus One", or HOTPO) indefinitely. The conjecture is that no matter what number you start with, __you will always eventually reach 1__. 

The property has also been called __oneness__. 

### Question 

[link](http://stackoverflow.com/questions/5437445/collatz-conjecture-related-interview)

> Collatz conjecture says that if you do the following

    If n is even, replace n by n/2.
    If n is odd, replace n by 3n+1.
    You ultimately end up with 1.

> For instance, 5 -> 16 -> 8 -> 4 -> 2 -> 1

> Chain length is the number of steps required to get to 1. (The chain length of 1 is 0).

> Now, the problem is given natural numbers n and k, find all numbers between 1 and n, such that the chain length is <= k. 

### Solution

Generate all numbers in backwards fashion, suggest by [templatetypedef](http://stackoverflow.com/a/5437672): 

                      1
                      |
                      2
                      |
                      4
                      |
                      8
                      |
                      16
                      | \
                      32 \
                      |   5
                      64  |
                     /|   10
                    / 128 | \
                   21     20 3

__Implementation__: using a queue and keep appending numbers. 

__Duplication handling__? 

> Assuming that the Collatz conjecture holds true, we'll never get any duplicates this way.

__Time complexity__ is O(S) time, where S is the number of numbers we need to output.

### Code

not written
]]></content>
  </entry>
  
</feed>
