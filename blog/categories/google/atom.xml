<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-11T19:01:38+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Crazy Distance Between Strings]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/crazy-distance-string/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/crazy-distance-string</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/15061908/google-interview-find-crazy-distance-between-strings)

> X and Y are strings formed by 0 or 1. Distance is define as: 

    D(X,Y) = Remove chars common at the start from both X & Y. 
    Then add the remaining lengths from both the strings.

> For e.g.

    D(1111, 1000) = Only First alphabet is common. So the remaining string is 111 & 000. Therefore the result length("111") & length("000") = 3 + 3 = 6

> For e.g.

    D(0101, 01100) = Only First two alphabets are common. So the remaining string is 01 & 100. Therefore the result length("01") & length("100") = 2 + 3 = 5

> Now given n input, say like

    1111
    1000
    101
    1100

> Find out the maximum crazy distance between 2 strings.

> __n is__ the number of input strings. __m is__ the max length of any input string. 

### Solution

This is the [source](http://stackoverflow.com/a/15062640). 

> Put the strings into a tree, where 0 means go left and 1 means go right. __O(m*n) time__. 

Example: 

                Root
                 1
              0      1
             0 1*   0  1
            0*     0*    1*

> where the * means that an element ends there. Constructing this tree clearly takes O(n m).

> Now we have to find __the diameter of the tree__ (the longest path between two nodes). 

How to find out longest path between 2 leaf nodes? Please refer to __[Google] Diameter of a Binary Tree__ for explanation.  

Total time complexity is __O(m*n) time__.

### Code

	public int crazyDist(String[] input) {
		TreeNode root = this.buildTree(input);
		return this.findMaxPath(root).path - 1;
	}

	private Result findMaxPath(TreeNode node) {
		if (node == null) {
			return new Result(Integer.MIN_VALUE, 0);
		}
		Result lr = this.findMaxPath(node.left);
		Result rr = this.findMaxPath(node.right);
		int path = Math.max(lr.path, rr.path);
		if (lr.depth != 0 && rr.depth != 0) {
			// this check is important, because if any of the child node is
			// NULL, this root will not be eligible for computing the path
			path = Math.max(path, lr.depth + rr.depth + 1);
			// Why? cuz diameter must go from one leaf, thru root, and reach
			// another leaf. This is different from "Maximum Path Sum" leetcode
		}
		return new Result(path, 1 + Math.max(lr.depth, rr.depth));
	}

	private TreeNode buildTree(String[] input) {
		TreeNode root = new TreeNode(123);
		// share a common root. this root is deducted from the final calculation
		for (String str : input) {
			// insert str under the root
			TreeNode p = root;
			for (char c : str.toCharArray()) {
				if (c == '0') {
					if (p.left == null) {
						p.left = new TreeNode(124);
						// if 0, go to left; otherwise go to right
						// thus value of TreeNodes does not really matter
					}
					p = p.left;
				} else {
					if (p.right == null) {
						p.right = new TreeNode(125);
					}
					p = p.right;
				}
			}
		}
		return root;
	}

	class Result {
		int path;
		int depth;

		public Result(int a, int b) {
			path = a;
			depth = b;
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Diameter of a Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/Diameter-of-Binary-Tree/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/Diameter-of-Binary-Tree</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/diameter-of-a-binary-tree/)

> The diameter of a tree (sometimes called the width) is the number of nodes on the longest path between two leaves in the tree. 

<img class="middle" src="/assets/images/tree-diameter-1.gif">

### Solution

This is a similar question to __[LeetCode 124] Binary Tree Maximum Path Sum__. __However there's a significant difference__ which might be overlooked while coding. 

Look at this example: 

         0
           1
            1
           0  1
               1

If we only want to find the max path, that would return result of 5, which is root-to-rightmost-leaf. However, the diameter should be 4, which is the distance between 2 leaf nodes. 

A solution is available for reading [here](http://stackoverflow.com/a/3124575). 

For __[Google] Crazy Distance Between Strings__, there is another special case: {"1", "11", "10"}. The program will not output correct result (1), because this is not really the diameter of a tree, but instead, a max path from a non-leaf to a leaf. I leave this part for you to finish. 

### Code

Refer to __[Google] Crazy Distance Between Strings__ for complete code. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Reverse a Stack Without DS]]></title>
    <link href="http://okckd.github.io/blog/2015/01/10/reverse-a-stack/"/>
    <updated>2015-01-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/10/reverse-a-stack</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/reverse-a-stack-using-recursion/)

> Reverse a stack using recursion. You are not allowed to use loops or data structure, and you can only use the following functions:

    isEmpty(S)
    push(S)
    pop(S)

### Solution

Well since we are not allowed to use additional DS or loop, we have to use system stack to help us! 

We add a new method: __insert at stack bottom__. Then we can solve this question recursively. Nice question, and tricky answer! 

### Code

	public void reverse(Stack<Integer> stack) {
		if (stack.isEmpty() || stack.size() == 1) {
			return;
		}
		int top = stack.pop();
		this.reverse(stack);
		this.insertAtBottom(stack, top);
	}

	private void insertAtBottom(Stack<Integer> stack, int val) {
		if (stack.isEmpty()) {
			stack.push(val);
			return;
		}
		int temp = stack.pop();
		this.insertAtBottom(stack, val);
		stack.push(temp);
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Maximum Count Array in a Queue]]></title>
    <link href="http://okckd.github.io/blog/2015/01/10/max-count-array-in-queue/"/>
    <updated>2015-01-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/10/max-count-array-in-queue</id>
    <content type="html"><![CDATA[### Question 

[link1](http://www.mitbbs.com/article_t1/JobHunting/32856675_0_1.html#top)

> 给一个数组a[n]，令s[i]为a[i+1..n-1]中比a[i]大的数的数量。

> 求最大的s[i]。要求O(nlogn)

### Solution

This is very similar question to __[Google] Form a Queue Given Heights__. The idea is to insert elements into BST and count number of larger elements. 

Naitive solution can be reached with a list. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Form a Queue Given Heights]]></title>
    <link href="http://okckd.github.io/blog/2015/01/10/form-queue-given-heights/"/>
    <updated>2015-01-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/10/form-queue-given-heights</id>
    <content type="html"><![CDATA[### Question 

[link1](http://www.geeksforgeeks.org/reverse-a-stack-using-recursion/), [link2](http://www.weiming.info/zhuti/JobHunting/31903469/), [link3](http://www.mitbbs.com/article_t1/JobHunting/32856675_0_1.html#top). 

> There is an array of integers which represent heights of persons. 

> Given another array... Let's call it count-array. It contain how many persons in front of him are greater than him in height. 

> 求原数组。(原数组中元素是从1到n。)

> Example: 

    Input(Count array): 0, 0, 2, 0
    Output(原数组): 2, 3, 1, 4

> 求nlogn的算法。

### Solution

This is naive solution from floor 29 of [this thread](http://www.weiming.info/zhuti/JobHunting/31903469/): 

>总结一下，用一个List存放1...n。
>
>从头到尾扫描给定的数组，每得到一个值，从List里删掉。
>
>因为List里数据是有序的，因此remove操作可以使用二分法，复杂度为O(logn).
>
>这样本算法复杂度为O(nlogn).

Example: 

    count array 
    i C[0,0,2,0]   N[4, 3, 2, 1]
    3 C[3] = 0     在N里面删除N[0]=4, N=[3, 2, 1],   Ans=[4]
    2 C[2] = 2     在N里面删除N[2]=1, N=[3, 2],   Ans=[1, 4]
    1 C[1] = 0     在N里面删除N[0]=3, N=[2],   Ans=[3, 1, 4]
    0 C[0] = 0     在N里面删除N[0]=2, N=[], Ans=[2, 3, 1, 4]

But there is a problm here, since removing item from list requires O(n), we will achieve O(n^2) time. How do we optimize this? 

__The answer is BST__ with each node keeping track of how many nodes is on the left branch, and how many on right branch. 

The conclusion: 

>可以化归为这样一道题：
>
>设计一个有序的数据结构，最初里头有自然数1到n这n个元素，
>
>随后这些元素可以被删除，但剩下元素仍然保持有序。
>
>要求实现方法GetKthElement(int k)和RemoveKthElemenet(int k)，
>
>使得它们在任意时刻都不超过O(lgN), N为当前的元素个数
>
>感觉要结合BST之类

### Code

Naive approach, O(n^2): 

	public int[] form(int peopleCount, int[] countArray) {
		int len = peopleCount;
		int[] heightQueue = new int[len];
		List<Integer> list = new ArrayList<Integer>();
		for (int i = peopleCount; i > 0; i--) {
			list.add(i);
		}
		for (int i = len - 1; i >= 0; i--) {
			heightQueue[i] = list.remove(countArray[i]);
		}
		return heightQueue;
	}
]]></content>
  </entry>
  
</feed>
