<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-08T01:53:11+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Form a Palindrome With Insertion]]></title>
    <link href="http://okckd.github.io/blog/2014/09/06/Form-palindrome-with-insertion/"/>
    <updated>2014-09-06T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/06/Form-palindrome-with-insertion</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.glassdoor.com/Interview/Given-a-string-convert-it-into-a-palindrome-with-the-lease-number-of-insertions-possible-QTN_729122.htm)

> Given a string, convert it into a palindrome with the lease number of insertions possible.

### Solution

This is a DP question. There're 2 approaches. 

__First, is direct DP__. This is the nicest solution, not intuitive at first, but actually good. 

> P[i, j] = P[i+1, j-1], if S[i] = S[j] 
>
> P[i, j] = 1 + min(P[i,j-1], P[i+1,j]), otherwise

contributed by [this guy](http://stackoverflow.com/a/10732879).

__Second approach is to calculate the longest palindrome subsequence__, and the answer would be string length minus this value. 

I wrote code for both apporaches. 

According to [G4G](http://www.geeksforgeeks.org/dynamic-programming-set-28-minimum-insertions-to-form-a-palindrome/), we can actually calculate the __Longest Common Subsequence of the string and its reverse__, and this value shall be same as the longest palindrome subsequence that we got in second approach. It's nice to know this idea.

### Code

__direct__

	public int solve1(String str) {
		// direct dp
		if (str == null)
			return 0;
		int len = str.length();
		int[][] dp = new int[len][len];
		for (int i = len - 1; i >= 0; i--) {
			for (int j = i; j < len; j++) {
				if (i == j) {
					dp[i][j] = 0;
				} else if (i + 1 == j) {
					dp[i][j] = str.charAt(i) == str.charAt(j) ? 0 : 1;
				} else {
					dp[i][j] = str.charAt(i) == str.charAt(j) ? dp[i + 1][j - 1]
							: 1 + Math.min(dp[i + 1][j], dp[i][j - 1]);
				}
			}
		}
		return dp[0][len - 1];
	}

__longest palindrome subsequence__

	public int solve2(String str) {
		// longest palindrome subsequence
		if (str == null)
			return 0;
		int len = str.length();
		int[][] dp = new int[len][len];
		for (int i = len - 1; i >= 0; i--) {
			for (int j = i; j < len; j++) {
				if (i == j) {
					dp[i][j] = 1;
				} else if (i + 1 == j) {
					dp[i][j] = str.charAt(i) == str.charAt(j) ? 2 : 1;
				} else {
					dp[i][j] = str.charAt(i) == str.charAt(j) ? 2 + dp[i + 1][j - 1]
							: Math.max(dp[i + 1][j], dp[i][j - 1]);
				}
			}
		}
		return len - dp[0][len - 1];
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Unsolved Mystery of UTF8 Encoding]]></title>
    <link href="http://okckd.github.io/blog/2014/09/04/unsolved-mystery-of-utf8/"/>
    <updated>2014-09-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/04/unsolved-mystery-of-utf8</id>
    <content type="html"><![CDATA[### Question 

[link](http://algorithmguru.com/blog/?p=148)

> UTF-8 is a variable-length encoding of letters or runes. If the most significant bit of the first byte is 0, the letter is 1 byte long. Otherwise, its length is the number of leading 1’s in the first byte. If a letter is more than one byte long, all subsequent runes start with 10. Here’s a chart:

> UTF-8 encoding scheme is described below:

	0XXXXXXX = this is the entire rune
	10XXXXXX = this is a continuation of the rune from the previous byte
	110XXXXX = this is the start of a 2-byte rune.
	1110XXXX = this is the start of a 3-byte rune.
	11110XXX = this is the start of a 4-byte rune.
	111110XX = this is the start of a 5-byte rune.
	1111110X = this is the start of a 6-byte rune.
	11111110 = this is the start of a 7-byte rune.
	11111111 = this is the start of a 8-byte rune.

> For example, a 3-byte rune would be 1110XXXX 10XXXXXX 10XXXXXX.

> Write a function that decides whether a given byte array (or string) is valid UTF-8 encoded text. 

### Solution

This is an easy question, just put here for reference. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Find Second Shortest Path]]></title>
    <link href="http://okckd.github.io/blog/2014/09/04/Find-second-shortest-path/"/>
    <updated>2014-09-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/04/Find-second-shortest-path</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=16922663)

> You are given a graph and an algorithm that can find the shortest path b/w any two nodes. 

> Now you have to find the second shortest path between same two nodes. 

### Solution

From the top answer: 

> __Find the shortest path__ between any two nodes. Let them be A and B. 

> Now to get second shortest path between the same nodes, __remove any one edge that is involved in the shortest path__ between the same nodes and calculate the shortest path. 

> Do the above process for each of the node involved in shortest path and keep track of the minimum second shortest path found.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Code a HashMap]]></title>
    <link href="http://okckd.github.io/blog/2014/09/04/Code-a-hashmap/"/>
    <updated>2014-09-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/04/Code-a-hashmap</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.glassdoor.com/Interview/Code-a-hashmap-which-you-would-be-happy-to-place-into-a-production-environment-QTN_725885.htm)

> Code a hashmap which you would be happy to place into a production environment.

### Solution

We already write 2 post before:

1. __[Question] Implement a HashMap__

1. __[CC150v5] 8.10 Implement a Hashmap__

But still, this is not an easy question when asked at an interview. It won't harm to do a little recap: 

1. The basic structure is an array. It can be: 
    1. An array of linked nodes (with a next pointer). 
    1. An array of linked list. 
1. There should be a hash function. 
1. There should be a function to convert the hash value to corresponding array index. 
1. Remember there's __a concept of Load factor__. It means to what percentage the hashmap is filled. 
1. h & (length – 1) means h % length, which maps a hashcode to an array index. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Weird Sort Array]]></title>
    <link href="http://okckd.github.io/blog/2014/09/03/weird-sort-array/"/>
    <updated>2014-09-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/03/weird-sort-array</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t0/JobHunting/32772813.html)

> 数组排序， 排成 a1<a2>a3<a4>a5。。。这种形式。

### Solution

__The are 2 solutions__. The easy one is this: 

> sort first, then 把临近的奇数换到偶数(index)上, O(nlog n). 

__There's a great O(n) solution however__, not easy to think: 

> 两两比较相邻数字，把大的数字放到下标为奇数的位置。 O(n). 

### Code

__O(nlgn) solution__

	public void solutionOnlgn(int[] A) {
		// this is a O(nlgn) solution
		Arrays.sort(A);
		for (int i = 2; i < A.length; i += 2) {
			swap(A, i - 1, i);
		}
	}

	private void swap(int[] A, int a, int b) {
		A[a] ^= A[b];
		A[b] ^= A[a];
		A[a] ^= A[b];
	}

__O(n) solution__

	public void solutionOn(int[] A) {
		// this is a O(n) solution
		for (int i = 1; i < A.length; i++) {
			// compare (i)th with (i-1)th, and put the large value
			// at odd-indexed positions
			if ((A[i - 1] < A[i] && i % 2 == 0)
					|| (A[i - 1] > A[i] && i % 2 == 1)) {
				swap(A, i - 1, i);
			}
		}
	}

	private void swap(int[] A, int a, int b) {
		A[a] ^= A[b];
		A[b] ^= A[a];
		A[a] ^= A[b];
	}
]]></content>
  </entry>
  
</feed>
