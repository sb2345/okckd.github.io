<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-12-04T16:28:43+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Code a HashMap]]></title>
    <link href="http://okckd.github.io/blog/2014/11/04/Code-a-hashmap/"/>
    <updated>2014-11-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/11/04/Code-a-hashmap</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.glassdoor.com/Interview/Code-a-hashmap-which-you-would-be-happy-to-place-into-a-production-environment-QTN_725885.htm)

> Code a hashmap which you would be happy to place into a production environment.

### Solution

We already write 2 post before:

1. __[Question] Implement a HashMap__

1. __[CC150v5] 8.10 Implement a Hashmap__

But still, this is not an easy question when asked at an interview. It won't harm to do a little recap: 

1. The basic structure is an array. It can be: 
    1. An array of linked nodes (with a next pointer). 
    1. An array of linked list. 
1. There should be a hash function. 
1. There should be a function to convert the hash value to corresponding array index. 
1. Remember there's __a concept of Load factor__. It means to what percentage the hashmap is filled. 
1. h & (length – 1) means h % length, which maps a hashcode to an array index. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Guess Password]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/google-guess-password/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/google-guess-password</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t/JobHunting/32658281.html)

> 给你一个password 假定6位

> 有个function, 每call一次就给你一个triplet 是password 里的随即三位(order不变)。比如google, 可能返回: ggl, goe, oog, ool...

> 问如何最有效破译这个密码? 

### Solution

This is just a rough idea suggested by Level 6 of [this post](http://www.mitbbs.com/article_t/JobHunting/32658281.html). 

> 六位密码随机给三位，应该有C(6, 3) = 20个bucket。 

> 如果密码是abcdef，那么以a开头的bucket应该是 C(5, 2) = 10个。以b开头的buckt应该是C(4, 2) = 6个，以c开头的是3个，以d开头的是1个.... from this, we know the probability of the occurrance of each letter. 

In this case, we generate many triplets, and calculate based on their frequencies. However, the guy also wrote about this condition: 

> 如果abcd中间有相同(there are same letters in the 6-char password)，那么就会出现以a开头的是11个（abca)，13个(abad)，14个(abaa)，16个(aacd)，17个(aaca),19个(aaad)或者20个(aaaa). 

> 思路是比较清楚，不过算法还要想想。

### Code

__not written__
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Barrier, Goods Van and Distance]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/barrier-goods-van-and-distance/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/barrier-goods-van-and-distance</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t1/JobHunting/32631467_0_1.html)

> 2d array ＊代表障碍物 ＃代表货物 空白就是正常的路 

> 问如何找到一个点为出发点 能实现总共取货路径最短？ 每次只能拿一个货物，遇到障碍需要绕开，拿到以后要放回出发点，然后再取另一个. 

    ＊＊＊＊＊＊＊＊＊＊
    ＊  #           ＊
    ＊  ＊＊＊  ＊   ＊
    ＊              ＊
    ＊     ＊＊   ＊ ＊
    ＊  #    # # ＊＊＊
    ＊＊＊＊＊＊＊＊＊＊

### Solution

This looks like a very difficult question, especially during a phone interview. 

__The 10th floor gives the best solution__: 

> __BFS from every box__. in each box, a non-blocking cell (include box position, but exclude hazard position) will have a weight value, stand for the distance to the box. 

> after bfs from all the boxes, each cell will have k weight, k is the number of boxes. sum all the weight in each cell, and find the cell with smallest sum of weight. 

> One problem of this solution may lead to a cell of a box. We can then sort the cell by sum of weight and find the first position that is not a box. 

> complexity O(k*n^2)

### Code

__not written__
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Arithmetic Progression Triplet]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/arithmetic-progression-triplet/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/arithmetic-progression-triplet</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/)

> Given a sorted set, find if there exist three elements in Arithmetic Progression or not. 

### Solution

__This is a rather simple Arithmetic Progression question__. 

> [To find the three elements](http://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/), we first fix an element as middle element and search for other two (one smaller and one greater). 

O(n^2) time. 

### Code

__written by me__

	public boolean longest(int[] A) {
		int len = A.length;
		for (int i = 1; i < len - 1; i++) {
			int left = i - 1;
			int right = i + 1;
			while (left >= 0 && right < len) {
				int total = A[left] + A[right];
				if (total > 2 * A[i]) {
					left--;
				} else if (total < 2 * A[i]) {
					right++;
				} else {
					return true;
				}
			}
		}
		return false;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Arithmetic Progression Longest]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/arithmetic-progression-longest/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/arithmetic-progression-longest</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=8211177)

> Given an array of integers A, give an algorithm to find the longest Arithmetic progression in it, i.e find a sequence i1 < i2 < … < ik, such that 

> A[i1], A[i2], …, A[ik] forms an arithmetic progression, and k is the largest possible. 

> The sequence S1, S2, …, Sk is called an arithmetic progression if S(j+1) – S(j) is a constant. 

### Solution

__This is a rather difficult Arithmetic Progression question__. 

The solution is 2-D DP. 

> [The idea is](http://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/) to create a 2D table dp[n][n]. An entry dp[i][j] in this table stores LLAP with input[i] and input[j] as first two elements of AP(j > i). 

> The last column of the table is always 2. Rest of the table is filled __from bottom right to top left__. 

> To fill rest of the table, j (second element in AP) is first fixed. i and k are searched for a fixed j. If i and k are found such that i, j, k form an AP, then __the value of dp[i][j] is set as dp[j][k] + 1__. 

> __Note that the value of dp[j][k] must have been filled__ before as the loop traverses from right to left columns. 

The 2 difficult points of this question:

1. how to come up with the transation formula. (i.e. __dp[i][j] = dp[j][k] + 1__, when (i, j, k) forms a AP). 
1. how to fill up all dp[i][j] in each loop of j. (Once inside the if-else, once outside the main while-loop) 

### Code

__written by me__

	public int longest(int[] A) {
		int len = A.length;
		int[][] dp = new int[len][len];
		for (int i = 0; i < len; i++) {
			// the pair ending at last position is always a progression
			dp[i][len - 1] = 2;
		}
		int longest = 1;
		for (int j = len - 2; j >= 0; j--) {
			// for each j, find i and k that makes 1 progression
			int i = j - 1;
			int k = j + 1;
			while (i >= 0 && k < len) {
				int total = A[i] + A[k];
				if (total > 2 * A[j]) {
					// this is important!
					dp[i][j] = 2;
					i--;
				} else if (total < 2 * A[j]) {
					k++;
				} else {
					// found a valid progression triplet A(i, j, k)
					dp[i][j] = dp[j][k] + 1;
					longest = Math.max(longest, dp[i][j]);
					i--;
					k++;
				}
			}
			// this is important!
			while (i >= 0) {
				dp[i][j] = 2;
				i--;
				// If the loop was stopped due to k becoming more than
				// n-1, set the remaining dp[i][j] as 2
			}
		}
		return longest;
	}
]]></content>
  </entry>
  
</feed>
