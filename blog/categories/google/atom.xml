<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-05T03:50:31+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Write a Random Number Generator]]></title>
    <link href="http://okckd.github.io/blog/2014/08/05/Write-a-RNG/"/>
    <updated>2014-08-05T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/05/Write-a-RNG</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5173972006076416)

### Solution

Basically, the formula is as follows:

> number = (previous_number * constant + other_constant) mod third_constant

The three constants are carefully selected, and a typical choice is:

> number = (previous_number * 214013 + 2531011) mod 2^15
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Replace Question Mark With Number]]></title>
    <link href="http://okckd.github.io/blog/2014/08/05/Replace-Question-Mark-WIth-Number/"/>
    <updated>2014-08-05T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/05/Replace-Question-Mark-WIth-Number</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5192571630387200)

> Given a string (for example: "a?bc?def?g"), write a program to generate all the possible strings by replacing ? with 0 and 1. 

> Input : a?b?c? 
>
> Output: a0b0c0, a0b0c1, a0b1c0, a0b1c1, a1b0c0, a1b0c1, a1b1c0, a1b1c1.

### Solution

DFS search, but do not forget to set "__letters[pos] = '?';__" at the end. I made this error once. 

### Code

	public List<String> solution(String str) {
		List<String> result = new ArrayList<String>();
		helper(result, str.toCharArray(), 0);
		return result;
	}

	private void helper(List<String> result, char[] letters, int pos) {
		if (pos == letters.length) {
			result.add(String.valueOf(letters));
			return;
		} else if (letters[pos] != '?') {
			helper(result, letters, pos + 1);
			return;
		}
		for (char i = '0'; i <= '1'; i++) {
			// put char i in letters[] to replace the '?'
			letters[pos] = i;
			helper(result, letters, pos + 1);
			letters[pos] = '?';
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Traveller Path Problem]]></title>
    <link href="http://okckd.github.io/blog/2014/08/04/Traveller-Path-Problem/"/>
    <updated>2014-08-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/04/Traveller-Path-Problem</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5147801809846272)

> Traveler wants to travel from city “A” to city “D”. There is a path from city “A” to city “D”. Path consists of steps, i.e. travel from city “A” to city “B”. Path is encoded as sequence of steps. 

> Sequence is in incorrect order. Your task is to restore order of steps in the path. 

> Input (unordered sequence): 

    C -> D 
    A -> B 
    B -> C 

> Output (Correctly ordered list which represents path): 

    A, B, C, D 

> Implement following API:

    class Step {
        String start;
        String finish;
    };

    class Node {
        String value;
        Node next;
    }

    List<String> findPath(List<Step> steps) {
    }

### Solution

This question is not stated clear enough. I found one tentative algorithm: 

> First, initialize a result - sortedPath, and build 2 maps (String to String) - startsToFinishes and finishesToStarts (O(N)) 

> Then, find the one key on startsToFinishes, that is not a key in finishesToStarts - this is the city from which the path begins. (O(N)) 

> Then, iteratively, city by city, build the path. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Find Occurance Greater Than Index]]></title>
    <link href="http://okckd.github.io/blog/2014/08/04/Find-occurance-greater-than-index/"/>
    <updated>2014-08-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/04/Find-occurance-greater-than-index</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5094709806497792)

> Given an unsorted array of integers, you need to return maximum possible n such that the array consists at least n values greater than or equals to n. Array can contain duplicate values. 

> Sample input : [1, 2, 3, 4] -- output : 2 

> Sample input : [900, 2, 901, 3, 1000] -- output: 3

### Solution

The idea of 'couting sort', solves in O(n) time. 

> Lets say the array has M numbers. So, __we can count the number of existing values between 1 and M__. 

> Then, process the values backwards (M to 1) to find the answer, adding the counts of the values processed so far. 

This is not an easy question. 

### Code

__not written by me__

    int Solve(const vector<int>& values) {
        int n = values.size();
        vector<int> count(n+1, 0);
        for (auto val: values)
            if (val >= n)
                count[n]++;
            else if (val > 0) // ignore negative values
                count[val]++;
        int am = 0;
        for (int i = n; i > 0; i--) {
            am += count[i];  // amount of numbers >= i
            if (am >= i)
                return i;
        }
        return 0;
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Find Nearest Point in a 2D Space]]></title>
    <link href="http://okckd.github.io/blog/2014/08/04/Find-Nearest-Point-in-2D-Space/"/>
    <updated>2014-08-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/04/Find-Nearest-Point-in-2D-Space</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5634947435986944)

> You are given information about hotels in a country/city. X and Y coordinates of each hotel are known. You need to suggest the list of nearest hotels to a user who is querying from a particular point (X and Y coordinates of the user are given). Distance is calculated as the straight line distance between the user and the hotel coordinates. 

### Solution

__Build a 2-D Tree (by using Binary Tree)__. 

First find the root, then divide the rest of nodes by left-side and right-side. Then, divide by up-side and down-side. 

There's a very good example video [here](http://www.youtube.com/watch?v=T9h2KKJ_Pl8), which talked about how to construct a 2-D tree. 

After this __preprocessing__, the search for nearest hotels in about O(lgn). However, if we were to return a list of nearest nodes, I've got no idea. 
]]></content>
  </entry>
  
</feed>
