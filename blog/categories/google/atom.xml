<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-01T02:52:10+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Boggle Solver (Search Words From Matrix)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/29/Boggle-solver/"/>
    <updated>2014-08-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/29/Boggle-solver</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/746082/how-to-find-list-of-possible-words-from-a-letter-matrix-boggle-solver)

> Boggle Game: 

    F X I E
    A M L O
    E W B X
    A S T U

> The goal of the game is to find as many words as you can that can be formed by chaining letters together. You are given a dictionary of words are reference. 

### Solution

__[The best solution](http://stackoverflow.com/a/4314056) is to use Trie__, then do DFS search. However it might not be as intuitive as it seems. 

The idea is from [this answer](http://stackoverflow.com/a/746102) (However this guy admits that his solution does not handle 'visited' nodes properly, means the same char might be visited again to produce a word). 

We need to first define a class called Item: 

    class Item {
        public final int x, y;
        public final String prefix;

        public Item(int row, int column, String prefix) {
            this.x = row;
            this.y = column;
            this.prefix = prefix;
        }
    }

So when we start doing DFS, we pass in an Item object which stores 2 information: 

1. The next position that we're going to visit.
1. The prefix string that we have validated so far (before visiting this position).

For example: 

    F X I E
    A M L O
    E W B X
    A S T U

We'll have Items objects like (0, 0, ""), (0, 1, "F"), (0, 2, "FA") ... We guarantee that the prefix must be a valid prefix by searching them in the Trie. 

How to tell whether a string is a prefix of word, or it's an actual word? We have a property in TrieNode called TrieNode.isWord() to help us. 

That's about it. I spend quite some time writing the code below, by refering to the Java solution by [zouzhile](http://stackoverflow.com/a/11698898). 

### Code

BoggleSolver.java

    public class BoggleSolver {

        private static BufferedReader in = null;
        private static final String INPUT_FILE = "dictionary.txt";

        public static void beginFileReader() {
            try {
                in = new BufferedReader(new FileReader(new File(BoggleSolver.class
                        .getResource(INPUT_FILE).toURI())));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (URISyntaxException e) {
                e.printStackTrace();
            }
        }

        private Trie buildTrie() {
            Trie trie = new Trie();
            beginFileReader();
            String line = null;
            try {
                while ((line = in.readLine()) != null) {
                    String[] words = line.split(" ");
                    for (String word : words) {
                        word = word.trim().toLowerCase();
                        trie.addWord(word);
                    }
                }
                if (in != null) {
                    in.close();
                }
            } catch (IOException e1) {
                e1.printStackTrace();
            }
            return trie;
        }

        public Set<String> findWords(char[][] map, Trie dict) {
            Set<String> ans = new TreeSet<String>();
            int m = map.length;
            int n = map[0].length;
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    boolean[][] visited = new boolean[m][n];
                    findWordsDfs(ans, dict, map, visited, new Item(i, j, ""));
                    // item have 3 parameters:
                    // location x,y and the prefix string before reaching (i.j)
                }
            }
            return ans;
        }

        public void findWordsDfs(Set<String> ans, Trie dict, char[][] map,
                boolean[][] visited, Item item) {
            // item: the location that we're going to test
            // item.prefix is the word prefix before reaching (x, y)

            int m = map.length;
            int n = map[0].length;
            int x = item.x;
            int y = item.y;

            // check whether cur.(x,y) is a valid position
            if (x < 0 || x >= m || y < 0 || y >= n) {
                return;
            } else if (visited[x][y]) {
                return;
            }
            String newWord = item.prefix + map[x][y];
            // check whether cur.prefix is a valid prefix
            TrieNode findWord = dict.match(newWord);
            if (findWord == null) {
                // up to this position (x, y), the word dont' exists
                return;
            }
            // now cur is in a valid position, with a valid prefix
            if (findWord.isWord()) {
                ans.add(newWord);
            }
            // visit this position, and continue in 4 different directions
            visited[x][y] = true;
            findWordsDfs(ans, dict, map, visited, new Item(x, y - 1, newWord));
            findWordsDfs(ans, dict, map, visited, new Item(x, y + 1, newWord));
            findWordsDfs(ans, dict, map, visited, new Item(x - 1, y, newWord));
            findWordsDfs(ans, dict, map, visited, new Item(x + 1, y, newWord));
            visited[x][y] = false;
        }

        public static void main(String[] args) {
            String[] rows = "eela,elps,weut,korn".split(",");
            char[][] input = new char[4][4];
            for (int i = 0; i < 4; i++) {
                input[i] = rows[i].toCharArray();
            }

            // prepare test data
            BoggleSolver solver = new BoggleSolver();
            Trie dictionary = solver.buildTrie();
            // start finding words
            Set<String> set = solver.findWords(input, dictionary);
            // present the result
            System.out.println(set.size() + " words are found, they are: ");
            for (String str : set) {
                System.out.println(str);
            }
        }

        class Item {
            public final int x, y;
            public final String prefix;

            public Item(int row, int column, String prefix) {
                this.x = row;
                this.y = column;
                this.prefix = prefix;
            }
        }
    }

Trie.java

    public class Trie {
        private TrieNode root;

        public Trie() {
            this.root = new TrieNode();
        }

        public void addWord(String word) {
            TrieNode node = this.root;
            for (char c : word.toCharArray()) {
                node = node.addChild(c);
                if (node == null)
                    return;
            }
            node.setWord(true);
        }

        public TrieNode match(String s) {
            TrieNode node = this.root;
            for (char c : s.toCharArray()) {
                node = node.get(c);
                if (node == null)
                    return null;
            }
            return node;
        }
    }

TrieNode.java

    public class TrieNode {
        private TrieNode[] children;
        private boolean isWord = false;

        public TrieNode() {
            this.children = new TrieNode[26];
        }

        public TrieNode addChild(char child) {
            if (child < 'a' || child > 'z')
                return null;

            int offset = child - 'a';
            if (this.children[offset] == null) {
                this.children[offset] = new TrieNode();
            }
            return this.children[offset];
        }

        public boolean isWord() {
            return isWord;
        }

        public void setWord(boolean isWord) {
            this.isWord = isWord;
        }

        public TrieNode get(char c) {
            int offset = c - 'a';
            return this.children[offset];
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Google Pre-interview Coaching]]></title>
    <link href="http://okckd.github.io/blog/2014/08/28/google-pre-interview-coaching/"/>
    <updated>2014-08-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/28/google-pre-interview-coaching</id>
    <content type="html"><![CDATA[### Question

> Write a program that breaks up a string of words with no spaces into a string with the appropriate spaces. 

Follow the following process:

1. Clarify the problem
1. Refine the solution
1. Code it
1. Last words

### Clarify the problem

1. Consider a general case, like "fastman"
1. Disambiguate expected result
1. State the key assumptions
1. clarify function signature

2 words? null input? where is the words from? We might use a dictionary. 

### Refine the solution

1. what if the dictionary cannot fit in RAM
1. how would you print the most likely of multiple choices
1. what if the words are not spelled correctly?
1. Testing 

### Code it

Write code now, skip.

### Last words

Talk naive solution, then come up with a reasonably better one. 

Time/Space tradeoff. (like pre-processing or something) 

For very big/small input. 

White-board practise is important! 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Google API Read4096 (read4K)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/27/google-api-read-4096/"/>
    <updated>2014-08-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/27/google-api-read-4096</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=14424684)

> Given API: int Read4096(char* buf); 

> It reads data from a file and records the position so that the next time when it is called it read the next 4k chars (or the rest of the file, whichever is smaller) from the file. The return is the number of chars read. 

> Use above API to Implement API "int Read(char* buf, int n)" which reads any number of chars from the file. 

### Solution

Since the nature of C++ and Java is different, I changed the api to: 

	GoogleApi.read4096(){}
	GoogleRead4096.read(int n){}

As [suggested](http://www.careercup.com/question?id=14424684), the solution is to keep __one local buffer__, and 1 pointer within the buffer. 

### Code

	String buffer = null;
	int p = 0;

	public String read(int n) {
		if (n < 0) {
			return null;
		} else if (n == 0) {
			return "";
		}
		StringBuilder sb = new StringBuilder();
		while (n > 0) {
			// there is (LENGTH - p) chars left in the local buffer
			if (buffer == null || p == buffer.length()) {
				// no char left in buffer, update buffer
				buffer = GoogleApi.read4096();
				p = 0;
				if (buffer.length() == 0) {
					// finish reading the file (no more input chars)
					break;
				}
			} else {
				int numChars = buffer.length() - p;
				if (numChars >= n) {
					sb.append(buffer.substring(p, p + n));
					p = p + n;
					n = 0;
				} else {
					sb.append(buffer.substring(p));
					p = buffer.length();
					n -= numChars;
				}
			}
		}
		return sb.toString();
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Orthogonal Traverse the Map (`)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/16/orthogonal-traverse-map/"/>
    <updated>2014-08-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/16/orthogonal-traverse-map</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#22)

> 有一个n*m（n和m都不超过50）的棋盘，有k个目标格子需要访问。需要访问的格子的横纵坐标存放在数组x[]和y[]中(0<=x[i]<n, 0<=y[i]<m)。

> 遍历的规则为：
>
> 每一步只能从一个目标格子水平或者竖直跳跃移动到另一个目标格子。
>
> 连续的两步必须形成直角。即如果前一步是水平移动，那么下一步只能竖直移动。
>
> 问是否存在一种遍历顺序，使得每个目标格子有且仅被访问一次。

> 样例：k=8, x=[0, 0, 0, 0, 2, 2, 4, 4], y=[0, 2, 4, 6, 4, 6, 2, 4],对应于下图中A, B, C, D, F, E, G, H 8个目标格子，存在满足条件的遍历A->D->E->F->C->B->G->H。

<img class="middle" src="/assets/images/orthogonal-map.jpg">

### Solution

> n,m的棋盘，[建一个包含n+m个顶点的图G](http://www.itint5.com/discuss/22/%E7%9B%B4%E8%A7%92%E8%B7%AF%E7%BA%BF%E9%81%8D%E5%8E%86%E6%A3%8B%E7%9B%98)（为了方便说明，类似二分图将其分为两列，左边n个顶点，右边m个顶点，分别代表n行和n列）。

> 对于目标格子(i,j)，左边第i个顶点和右边第j个顶点连一条边。最后的问题其实就是问转换之后的图G是否存在欧拉欧拉回路或者欧拉路径。
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Product All 1s]]></title>
    <link href="http://okckd.github.io/blog/2014/08/15/Product-all-ones/"/>
    <updated>2014-08-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/15/Product-all-ones</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#18)

> 给定一个非负整数a（不超过10^6），是否存在整数b，使得a和b的乘积全为1。如果存在，返回最小的乘积的位数。如果不存在，返回-1。

> 样例：a=3，存在b=37，使得3*37=111，则函数应返回3（111的位数）。

### Solution

There's 1 equation of mod operation, which is helpful: 

> (a * b) mod x = ((mx+a') * (nx+b')) mod x = (a' mod x) * (b' mod x) = (a mod x) * (b mod x)
>
> i.e.  (a * b) mod x = (a mod x) * (b mod x)

Altough [I don't understand why](http://www.itint5.com/discuss/136/%E8%BF%99%E9%A2%98%E6%88%91%E8%B6%85%E6%97%B6%E4%BA%86%EF%BC%8C%E8%AF%B7%E9%97%AE%E5%A6%82%E4%BD%95%E7%BC%A9%E7%9F%AD%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4) does it contribute to the incredibly short solution code posted below. I can't solve this question, freakly speaking. 

### Code

	int findMinAllOne(int a) {
		if (a < 0 || (a % 10) % 2 == 0 || a % 10 == 5)
			return -1;

		int ans = 1;
		for (int p = 1; p != 0; p %= a) {
			p = 10 * p + 1;
			++ans;
		}
		return a == 1 ? ans - 1 : ans;
	}
]]></content>
  </entry>
  
</feed>
