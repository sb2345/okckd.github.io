<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-09T13:14:55+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Number of Distinct Substrings]]></title>
    <link href="http://okckd.github.io/blog/2015/01/08/number-of-distinct-substrings/"/>
    <updated>2015-01-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/08/number-of-distinct-substrings</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.quora.com/Given-a-string-how-do-I-find-the-number-of-distinct-substrings-of-the-string)

> Given a string, find the number of distinct substrings of the string. Example:

>input = "aaaa", 
>
>output = 4 (the 4 substrings are "a", "aa", "aaa", "aaaa")

>input = "abcd", 
>
>output = 10 ("a", "b", "c", "d", "ab", "bc", "cd", "abc", "bcd", "abcd")

>input = "banana", 
>
>output = 15 ("a", "an", "ana", "anan", "anana", "b", "ba", "ban", "bana", "banan", "banana", "n", "na", "nan", "nana")

This is also a question on [SPOJ](http://www.spoj.com/problems/DISUBSTR/). 

### Solution

This is a very good question, which tests Suffix tree, LCP and string manipulation knowledges. 

__The solution is to build a suffix tree__. This is because: 

> If you look through the __[prefixes of each suffix](http://qr.ae/6o6Nk)__ of a string, you have covered all substrings of that string. 

There are 2 implementations. First one is slightly simpler. 

#### Implementation 1

__Suffix array + LCP__ (longest common prefix). Take "Banana" as input, then the suffixes: 

    0) BANANA
    1) ANANA
    2) NANA
    3) ANA
    4) NA
    5) A

Sort it: 

    5) A
    3) ANA
    1) ANANA
    0) BANANA
    4) NA
    2) NANA

Then we start calculate number of substring (that is prefixes of suffix). After removing duplicated prefix, the count is: 

    5) A - 1
    3) ANA - 2
    1) ANANA - 2
    0) BANANA - 6
    4) NA - 2
    2) NANA - 2

Total number is: 

    1 + 2 + 2 + 6 + 2 + 2 = 15

But wait, realize something? "A" is simply duplicate substring in "ANA", which appers in "ANANA". Keep this in mind, cuz we need to observe this in the 2nd implementation, too.

Finally, the total number is calculated like this: 

    for each suffix
        ans += length(suffix) - LCP(suffix, previous suffix)

For more details, read [here](http://qr.ae/6o6Nk).

#### Implementation 2

Build a suffix tree, like this: 

<img class="middle" src="/assets/images/suffix-tree-banana.png">

Number of substrings is simply the __sum of levels of each leaf__. For the 3 branches of the suffix tree, number of levels are: 6, 5 and 4 respectively. Total = 15. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Check All Numbers Given the Decimal Scale]]></title>
    <link href="http://okckd.github.io/blog/2015/01/08/all-number-given-decimal-scale/"/>
    <updated>2015-01-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/08/all-number-given-decimal-scale</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t/JobHunting/32859887.html)

> 检查一个字符串是否包含k位a进制数的所有表示形式。

> 保证原字符串的所有字串都是合法的k位a进制数。

> "00110, a=2, k=2" => true （包括了00，01，10，11）

### Solution

First find all substrings with length == k, then generate all numbers in a scale. This is not a difficult question. 

We may want to score the substrings in a HashMap/HashSet. __The hashing procedure is preferrably using [Rolling hash](http://en.wikipedia.org/wiki/Rolling_hash)__. 

> Rolling Hash

> A rolling hash is a hash function where the input is hashed in a window that moves through the input.

> A few hash functions allow a rolling hash to be computed very quickly—the new hash value is rapidly calculated given only the old hash value, the old value removed from the window, and the new value added to the window—similar to the way a moving average function can be computed much more quickly than other low-pass filters.

The people in the origin post - they discuss about "__slide window check__" algorithm. I do not understand what's the benefit of this. If you read this and would like to help me, please leave a comment. Thanks! 

### A similar question

[This](http://www.mitbbs.com/article_t/JobHunting/32860321.html) is simply the reverse of the question above: 

> 给出最短的字符串, which is used to 表示k位a进制数的所有表示形式. 

This question is solved using __[De Bruijn sequence](http://en.wikipedia.org/wiki/De_Bruijn_sequence)__. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Code a HashMap]]></title>
    <link href="http://okckd.github.io/blog/2014/11/04/Code-a-hashmap/"/>
    <updated>2014-11-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/11/04/Code-a-hashmap</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.glassdoor.com/Interview/Code-a-hashmap-which-you-would-be-happy-to-place-into-a-production-environment-QTN_725885.htm)

> Code a hashmap which you would be happy to place into a production environment.

### Solution

We already write 2 post before:

1. __[Question] Implement a HashMap__

1. __[CC150v5] 8.10 Implement a Hashmap__

But still, this is not an easy question when asked at an interview. It won't harm to do a little recap: 

1. The basic structure is an array. It can be: 
    1. An array of linked nodes (with a next pointer). 
    1. An array of linked list. 
1. There should be a hash function. 
1. There should be a function to convert the hash value to corresponding array index. 
1. Remember there's __a concept of Load factor__. It means to what percentage the hashmap is filled. 
1. h & (length – 1) means h % length, which maps a hashcode to an array index. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Guess Password]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/google-guess-password/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/google-guess-password</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t/JobHunting/32658281.html)

> 给你一个password 假定6位

> 有个function, 每call一次就给你一个triplet 是password 里的随即三位(order不变)。比如google, 可能返回: ggl, goe, oog, ool...

> 问如何最有效破译这个密码? 

### Solution

This is just a rough idea suggested by Level 6 of [this post](http://www.mitbbs.com/article_t/JobHunting/32658281.html). 

> 六位密码随机给三位，应该有C(6, 3) = 20个bucket。 

> 如果密码是abcdef，那么以a开头的bucket应该是 C(5, 2) = 10个。以b开头的buckt应该是C(4, 2) = 6个，以c开头的是3个，以d开头的是1个.... from this, we know the probability of the occurrance of each letter. 

In this case, we generate many triplets, and calculate based on their frequencies. However, the guy also wrote about this condition: 

> 如果abcd中间有相同(there are same letters in the 6-char password)，那么就会出现以a开头的是11个（abca)，13个(abad)，14个(abaa)，16个(aacd)，17个(aaca),19个(aaad)或者20个(aaaa). 

> 思路是比较清楚，不过算法还要想想。

### Code

__not written__
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Barrier, Goods Van and Distance]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/barrier-goods-van-and-distance/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/barrier-goods-van-and-distance</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t1/JobHunting/32631467_0_1.html)

> 2d array ＊代表障碍物 ＃代表货物 空白就是正常的路 

> 问如何找到一个点为出发点 能实现总共取货路径最短？ 每次只能拿一个货物，遇到障碍需要绕开，拿到以后要放回出发点，然后再取另一个. 

    ＊＊＊＊＊＊＊＊＊＊
    ＊  #           ＊
    ＊  ＊＊＊  ＊   ＊
    ＊              ＊
    ＊     ＊＊   ＊ ＊
    ＊  #    # # ＊＊＊
    ＊＊＊＊＊＊＊＊＊＊

### Solution

This looks like a very difficult question, especially during a phone interview. 

__The 10th floor gives the best solution__: 

> __BFS from every box__. in each box, a non-blocking cell (include box position, but exclude hazard position) will have a weight value, stand for the distance to the box. 

> after bfs from all the boxes, each cell will have k weight, k is the number of boxes. sum all the weight in each cell, and find the cell with smallest sum of weight. 

> One problem of this solution may lead to a cell of a box. We can then sort the cell by sum of weight and find the first position that is not a box. 

> complexity O(k*n^2)

### Code

__not written__
]]></content>
  </entry>
  
</feed>
