<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-10-26T18:11:43+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Guess Password]]></title>
    <link href="http://okckd.github.io/blog/2014/09/16/google-guess-password/"/>
    <updated>2014-09-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/16/google-guess-password</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t/JobHunting/32658281.html)

> 给你一个password 假定6位

> 有个function, 每call一次就给你一个triplet 是password 里的随即三位(order不变)。比如google, 可能返回: ggl, goe, oog, ool...

> 问如何最有效破译这个密码? 

### Solution

This is just a rough idea suggested by Level 6 from the post. 

> 六位密码随机给三位，应该有C(6, 3) = 20个bucket。 

> 如果密码是abcdef，那么以a开头的bucket应该是10个。以b开头的buckt应该是6个，以c开头的是3个，以d开头的是1个。

> 如果abcd中间有相同，那么就会出现以a开头的是11个（abca)，13个(abad)，14个(abaa)，16个(aacd)，17个(aaca),19个(aaad)或者20个(aaaa). 

So we generate many triplets, and calculate based on their frequencies. 

### Code

__not written__
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Barrier, Goods Van and Distance]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/barrier-goods-van-and-distance/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/barrier-goods-van-and-distance</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t1/JobHunting/32631467_0_1.html)

> 2d array ＊代表障碍物 ＃代表货物 空白就是正常的路 

> 问如何找到一个点为出发点 能实现总共取货路径最短？ 每次只能拿一个货物，遇到障碍需要绕开，拿到以后要放回出发点，然后再取另一个. 

    ＊＊＊＊＊＊＊＊＊＊
    ＊  #           ＊
    ＊  ＊＊＊  ＊   ＊
    ＊              ＊
    ＊     ＊＊   ＊ ＊
    ＊  #    # # ＊＊＊
    ＊＊＊＊＊＊＊＊＊＊

### Solution

This looks like a very difficult question, especially during a phone interview. 

__The 10th floor gives the best solution__: 

> __BFS from every box__. in each box, a non-blocking cell (include box position, but exclude hazard position) will have a weight value, stand for the distance to the box. 

> after bfs from all the boxes, each cell will have k weight, k is the number of boxes. sum all the weight in each cell, and find the cell with smallest sum of weight. 

> One problem of this solution may lead to a cell of a box. We can then sort the cell by sum of weight and find the first position that is not a box. 

> complexity O(k*n^2)

### Code

__not written__
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Arithmetic Progression Triplet]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/arithmetic-progression-triplet/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/arithmetic-progression-triplet</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/)

> Given a sorted set, find if there exist three elements in Arithmetic Progression or not. 

### Solution

__This is a rather simple Arithmetic Progression question__. 

> [To find the three elements](http://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/), we first fix an element as middle element and search for other two (one smaller and one greater). 

O(n^2) time. 

### Code

__written by me__

	public boolean longest(int[] A) {
		int len = A.length;
		for (int i = 1; i < len - 1; i++) {
			int left = i - 1;
			int right = i + 1;
			while (left >= 0 && right < len) {
				int total = A[left] + A[right];
				if (total > 2 * A[i]) {
					left--;
				} else if (total < 2 * A[i]) {
					right++;
				} else {
					return true;
				}
			}
		}
		return false;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Arithmetic Progression Longest]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/arithmetic-progression-longest/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/arithmetic-progression-longest</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=8211177)

> Given an array of integers A, give an algorithm to find the longest Arithmetic progression in it, i.e find a sequence i1 < i2 < … < ik, such that 

> A[i1], A[i2], …, A[ik] forms an arithmetic progression, and k is the largest possible. 

> The sequence S1, S2, …, Sk is called an arithmetic progression if S(j+1) – S(j) is a constant. 

### Solution

__This is a rather difficult Arithmetic Progression question__. 

The solution is 2-D DP. 

> [The idea is](http://www.geeksforgeeks.org/length-of-the-longest-arithmatic-progression-in-a-sorted-array/) to create a 2D table dp[n][n]. An entry dp[i][j] in this table stores LLAP with input[i] and input[j] as first two elements of AP(j > i). 

> The last column of the table is always 2. Rest of the table is filled __from bottom right to top left__. 

> To fill rest of the table, j (second element in AP) is first fixed. i and k are searched for a fixed j. If i and k are found such that i, j, k form an AP, then __the value of dp[i][j] is set as dp[j][k] + 1__. 

> __Note that the value of dp[j][k] must have been filled__ before as the loop traverses from right to left columns. 

The 2 difficult points of this question:

1. how to come up with the transation formula. (i.e. __dp[i][j] = dp[j][k] + 1__, when (i, j, k) forms a AP). 
1. how to fill up all dp[i][j] in each loop of j. (Once inside the if-else, once outside the main while-loop) 

### Code

__written by me__

	public int longest(int[] A) {
		int len = A.length;
		int[][] dp = new int[len][len];
		for (int i = 0; i < len; i++) {
			// the pair ending at last position is always a progression
			dp[i][len - 1] = 2;
		}
		int longest = 1;
		for (int j = len - 2; j >= 0; j--) {
			// for each j, find i and k that makes 1 progression
			int i = j - 1;
			int k = j + 1;
			while (i >= 0 && k < len) {
				int total = A[i] + A[k];
				if (total > 2 * A[j]) {
					// this is important!
					dp[i][j] = 2;
					i--;
				} else if (total < 2 * A[j]) {
					k++;
				} else {
					// found a valid progression triplet A(i, j, k)
					dp[i][j] = dp[j][k] + 1;
					longest = Math.max(longest, dp[i][j]);
					i--;
					k++;
				}
			}
			// this is important!
			while (i >= 0) {
				dp[i][j] = 2;
				i--;
				// If the loop was stopped due to k becoming more than
				// n-1, set the remaining dp[i][j] as 2
			}
		}
		return longest;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Winner of Tic-tac-toe]]></title>
    <link href="http://okckd.github.io/blog/2014/09/09/Winner-tic-tac-toe/"/>
    <updated>2014-09-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/09/Winner-tic-tac-toe</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.glassdoor.com/Interview/How-would-you-determine-if-someone-has-won-a-game-of-tic-tac-toe-on-a-board-of-any-size-QTN_1104.htm)

> How would you determine if someone has won a game of tic-tac-toe on a board of any size? 

(This is also on CC150v4 19.2 and CC150v4 17.2)

### Solution

First, confirm that when the number of pieces in a line equals to the dimension of the board, one person wins. Eg. for 10 * 10 board, 10 pieces need to be in 1 line. 

__[We can determine](http://www.glassdoor.com/Interview/How-would-you-determine-if-someone-has-won-a-game-of-tic-tac-toe-on-a-board-of-any-size-QTN_1104.htm) if someone has won during a game in real time__, as in checking after every move. 

> Create an array of size 2n+2 at the beginning of the game and fill it with zeros. Each spot in the array will be a sum of X's or O's horizontally (the first n places in the array), vertically (the second n places in the array) and diagonally (the last 2 places). Then with every move, you add 1 to the 2 places (or 3 if on a diagnol) of the array if X, and subtract 1 if its an O. After adding you check and see if the value of the array is equal to n or -n, if it is, n mean X has won and -n means O has won.

This is uses O(2n+2) space, but it's the best solution I can find online. I wrote code posted below. 

### Code

__written by me__

	enum Piece {
		Empty, Red, Blue
	};
    
	public static Piece hasWon3(Piece[][] board) {

		int N = board.length;

		// O(2n+2) space to store count info
		int[] rowCnt = new int[N];
		int[] colCnt = new int[N];
		int[] digCnt = new int[2];

		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {

				int pieceValue = 0;
				if (board[i][j] == Piece.Blue) {
					pieceValue = 1;
				} else if (board[i][j] == Piece.Red) {
					pieceValue = -1;
				}

				// if empty, pieceValue is 0
				// if blue, add 1 in count
				// if red, subtract 1 in count
				rowCnt[i] += pieceValue;
				if (checkFinish(rowCnt[i], N) != null) {
					return checkFinish(rowCnt[i], N);
				}

				// after adding the count, check if the game finishes
				colCnt[j] += pieceValue;
				if (checkFinish(colCnt[j], N) != null) {
					return checkFinish(colCnt[j], N);
				}

				if (i == j) {
					digCnt[0] += pieceValue;
					if (checkFinish(digCnt[0], N) != null) {
						return checkFinish(digCnt[0], N);
					}
				} else if (i + j == N) {
					digCnt[1] += pieceValue;
					if (checkFinish(digCnt[1], N) != null) {
						return checkFinish(digCnt[1], N);
					}
				}
			}
		}
		// game not finished, continue
		return Piece.Empty;
	}

	private static Piece checkFinish(int count, int N) {
		if (count == N)
			return Piece.Blue;
		else if (count == -1 * N)
			return Piece.Red;
		else
			return null;
	}
]]></content>
  </entry>
  
</feed>
