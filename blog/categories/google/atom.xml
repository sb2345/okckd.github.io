<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-10T19:36:19+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Reverse a Stack Without DS]]></title>
    <link href="http://okckd.github.io/blog/2015/01/10/reverse-a-stack/"/>
    <updated>2015-01-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/10/reverse-a-stack</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/reverse-a-stack-using-recursion/)

> Reverse a stack using recursion. You are not allowed to use loops or data structure, and you can only use the following functions:

    isEmpty(S)
    push(S)
    pop(S)

### Solution

Well since we are not allowed to use additional DS or loop, we have to use system stack to help us! 

We add a new method: __insert at stack bottom__. Then we can solve this question recursively. Nice question, and tricky answer! 

### Code

	public void reverse(Stack<Integer> stack) {
		if (stack.isEmpty() || stack.size() == 1) {
			return;
		}
		int top = stack.pop();
		this.reverse(stack);
		this.insertAtBottom(stack, top);
	}

	private void insertAtBottom(Stack<Integer> stack, int val) {
		if (stack.isEmpty()) {
			stack.push(val);
			return;
		}
		int temp = stack.pop();
		this.insertAtBottom(stack, val);
		stack.push(temp);
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Maximum Count Array in a Queue]]></title>
    <link href="http://okckd.github.io/blog/2015/01/10/max-count-array-in-queue/"/>
    <updated>2015-01-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/10/max-count-array-in-queue</id>
    <content type="html"><![CDATA[### Question 

[link1](http://www.mitbbs.com/article_t1/JobHunting/32856675_0_1.html#top)

> 给一个数组a[n]，令s[i]为a[i+1..n-1]中比a[i]大的数的数量。

> 求最大的s[i]。要求O(nlogn)

### Solution

This is very similar question to __[Google] Form a Queue Given Heights__. The idea is to insert elements into BST and count number of larger elements. 

Naitive solution can be reached with a list. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Form a Queue Given Heights]]></title>
    <link href="http://okckd.github.io/blog/2015/01/10/form-queue-given-heights/"/>
    <updated>2015-01-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/10/form-queue-given-heights</id>
    <content type="html"><![CDATA[### Question 

[link1](http://www.geeksforgeeks.org/reverse-a-stack-using-recursion/), [link2](http://www.weiming.info/zhuti/JobHunting/31903469/), [link3](http://www.mitbbs.com/article_t1/JobHunting/32856675_0_1.html#top). 

> There is an array of integers which represent heights of persons. 

> Given another array... Let's call it count-array. It contain how many persons in front of him are greater than him in height. 

> 求原数组。(原数组中元素是从1到n。)

> Example: 

    Input(Count array): 0, 0, 2, 0
    Output(原数组): 2, 3, 1, 4

> 求nlogn的算法。

### Solution

This is naive solution from floor 29 of [this thread](http://www.weiming.info/zhuti/JobHunting/31903469/): 

>总结一下，用一个List存放1...n。
>
>从头到尾扫描给定的数组，每得到一个值，从List里删掉。
>
>因为List里数据是有序的，因此remove操作可以使用二分法，复杂度为O(logn).
>
>这样本算法复杂度为O(nlogn).

Example: 

    count array 
    i C[0,0,2,0]   N[4, 3, 2, 1]
    3 C[3] = 0     在N里面删除N[0]=4, N=[3, 2, 1],   Ans=[4]
    2 C[2] = 2     在N里面删除N[2]=1, N=[3, 2],   Ans=[1, 4]
    1 C[1] = 0     在N里面删除N[0]=3, N=[2],   Ans=[3, 1, 4]
    0 C[0] = 0     在N里面删除N[0]=2, N=[], Ans=[2, 3, 1, 4]

But there is a problm here, since removing item from list requires O(n), we will achieve O(n^2) time. How do we optimize this? 

__The answer is BST__ with each node keeping track of how many nodes is on the left branch, and how many on right branch. 

The conclusion: 

>可以化归为这样一道题：
>
>设计一个有序的数据结构，最初里头有自然数1到n这n个元素，
>
>随后这些元素可以被删除，但剩下元素仍然保持有序。
>
>要求实现方法GetKthElement(int k)和RemoveKthElemenet(int k)，
>
>使得它们在任意时刻都不超过O(lgN), N为当前的元素个数
>
>感觉要结合BST之类

### Code

Naive approach, O(n^2): 

	public int[] form(int peopleCount, int[] countArray) {
		int len = peopleCount;
		int[] heightQueue = new int[len];
		List<Integer> list = new ArrayList<Integer>();
		for (int i = peopleCount; i > 0; i--) {
			list.add(i);
		}
		for (int i = len - 1; i >= 0; i--) {
			heightQueue[i] = list.remove(countArray[i]);
		}
		return heightQueue;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Number of Distinct Substrings]]></title>
    <link href="http://okckd.github.io/blog/2015/01/08/number-of-distinct-substrings/"/>
    <updated>2015-01-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/08/number-of-distinct-substrings</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.quora.com/Given-a-string-how-do-I-find-the-number-of-distinct-substrings-of-the-string)

> Given a string, find the number of distinct substrings of the string. Example:

>input = "aaaa", 
>
>output = 4 (the 4 substrings are "a", "aa", "aaa", "aaaa")

>input = "abcd", 
>
>output = 10 ("a", "b", "c", "d", "ab", "bc", "cd", "abc", "bcd", "abcd")

>input = "banana", 
>
>output = 15 ("a", "an", "ana", "anan", "anana", "b", "ba", "ban", "bana", "banan", "banana", "n", "na", "nan", "nana")

This is also a question on [SPOJ](http://www.spoj.com/problems/DISUBSTR/). 

### Solution

This is a very good question, which tests Suffix tree, LCP and string manipulation knowledges. 

__The solution is to build a suffix tree__. This is because: 

> If you look through the __[prefixes of each suffix](http://qr.ae/6o6Nk)__ of a string, you have covered all substrings of that string. 

There are 2 implementations. First one is slightly simpler. 

#### Implementation 1

__Suffix array + LCP__ (longest common prefix). Take "Banana" as input, then the suffixes: 

    0) BANANA
    1) ANANA
    2) NANA
    3) ANA
    4) NA
    5) A

Sort it: 

    5) A
    3) ANA
    1) ANANA
    0) BANANA
    4) NA
    2) NANA

Then we start calculate number of substring (that is prefixes of suffix). After removing duplicated prefix, the count is: 

    5) A - 1
    3) ANA - 2
    1) ANANA - 2
    0) BANANA - 6
    4) NA - 2
    2) NANA - 2

Total number is: 

    1 + 2 + 2 + 6 + 2 + 2 = 15

But wait, realize something? "A" is simply duplicate substring in "ANA", which appers in "ANANA". Keep this in mind, cuz we need to observe this in the 2nd implementation, too.

Finally, the total number is calculated like this: 

    for each suffix
        ans += length(suffix) - LCP(suffix, previous suffix)

For more details, read [here](http://qr.ae/6o6Nk).

#### Implementation 2

Build a suffix tree, like this: 

<img class="middle" src="/assets/images/suffix-tree-banana.png">

Number of substrings is simply the __sum of levels of each leaf__. For the 3 branches of the suffix tree, number of levels are: 6, 5 and 4 respectively. Total = 15. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Check All Numbers Given the Decimal Scale]]></title>
    <link href="http://okckd.github.io/blog/2015/01/08/all-number-given-decimal-scale/"/>
    <updated>2015-01-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/08/all-number-given-decimal-scale</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t/JobHunting/32859887.html)

> 检查一个字符串是否包含k位a进制数的所有表示形式。

> 保证原字符串的所有字串都是合法的k位a进制数。

> "00110, a=2, k=2" => true （包括了00，01，10，11）

### Solution

First find all substrings with length == k, then generate all numbers in a scale. This is not a difficult question. 

We may want to score the substrings in a HashMap/HashSet. __The hashing procedure is preferrably using [Rolling hash](http://en.wikipedia.org/wiki/Rolling_hash)__. 

> Rolling Hash

> A rolling hash is a hash function where the input is hashed in a window that moves through the input.

> A few hash functions allow a rolling hash to be computed very quickly—the new hash value is rapidly calculated given only the old hash value, the old value removed from the window, and the new value added to the window—similar to the way a moving average function can be computed much more quickly than other low-pass filters.

The people in the origin post - they discuss about "__slide window check__" algorithm. I do not understand what's the benefit of this. If you read this and would like to help me, please leave a comment. Thanks! 

### A similar question

[This](http://www.mitbbs.com/article_t/JobHunting/32860321.html) is simply the reverse of the question above: 

> 给出最短的字符串, which is used to 表示k位a进制数的所有表示形式. 

This question is solved using __[De Bruijn sequence](http://en.wikipedia.org/wiki/De_Bruijn_sequence)__. 
]]></content>
  </entry>
  
</feed>
