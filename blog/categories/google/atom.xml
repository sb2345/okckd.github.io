<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-04T12:20:21+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Weird Sort Array]]></title>
    <link href="http://okckd.github.io/blog/2014/09/03/weird-sort-array/"/>
    <updated>2014-09-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/03/weird-sort-array</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t0/JobHunting/32772813.html)

> 数组排序， 排成 a1<a2>a3<a4>a5。。。这种形式。

### Solution

__The are 2 solutions__. The easy one is this: 

> sort first, then 把临近的奇数换到偶数(index)上, O(nlog n). 

__There's a great O(n) solution however__, not easy to think: 

> 两两比较相邻数字，把大的数字放到下标为奇数的位置。 O(n). 

### Code

__O(nlgn) solution__

	public void solutionOnlgn(int[] A) {
		// this is a O(nlgn) solution
		Arrays.sort(A);
		for (int i = 2; i < A.length; i += 2) {
			swap(A, i - 1, i);
		}
	}

	private void swap(int[] A, int a, int b) {
		A[a] ^= A[b];
		A[b] ^= A[a];
		A[a] ^= A[b];
	}

__O(n) solution__

	public void solutionOn(int[] A) {
		// this is a O(n) solution
		for (int i = 1; i < A.length; i++) {
			// compare (i)th with (i-1)th, and put the large value
			// at odd-indexed positions
			if ((A[i - 1] < A[i] && i % 2 == 0)
					|| (A[i - 1] > A[i] && i % 2 == 1)) {
				swap(A, i - 1, i);
			}
		}
	}

	private void swap(int[] A, int a, int b) {
		A[a] ^= A[b];
		A[b] ^= A[a];
		A[a] ^= A[b];
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] String Replacement Question]]></title>
    <link href="http://okckd.github.io/blog/2014/09/03/String-replacement-question/"/>
    <updated>2014-09-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/03/String-replacement-question</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t/JobHunting/32766461.html)

> String replace, 给一个原string，一个target，一个替换的新str，把所有出现
target str的地方都换成新的str， 长度可以任意. 

### Solution

If the question asks for an in-place algo, then we can refer to __Question 1.5 in CC150v4__. 

### Question 

> 1.5 Write a method to replace all spaces in a string with ‘%20’. 

### Solution

1. __pre-processing__, count the number of spaces in string
2. parse the string from end to beginning. 

Need 2 pass.

### Code

__not written by me__

	public static void ReplaceFun(char[] str, int length) {
		int spaceCount = 0, newLength, i = 0;
		for (i = 0; i < length; i++) {
			if (str[i] == ' ') {
				spaceCount++;
			}
		}
		newLength = length + spaceCount * 2;
		str[newLength] = '\0';
		for (i = length - 1; i >= 0; i--) {
			if (str[i] == ' ') {
				str[newLength - 1] = '0';
				str[newLength - 2] = '2';
				str[newLength - 3] = '%';
				newLength = newLength - 3;
			} else {
				str[newLength - 1] = str[i];
				newLength = newLength - 1;
			}
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Find Anagrams in Dictionary]]></title>
    <link href="http://okckd.github.io/blog/2014/09/02/Find-anagrams-in-dictionary/"/>
    <updated>2014-09-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/02/Find-anagrams-in-dictionary</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=3088)

> Imagine you had a dictionary. How would you print all anagrams of a word? What if you had to do this repeatedly? Could you optimize it?

### Solution

A very [nice solution](http://stackoverflow.com/a/12477976): 

1. Open dictionary

1. Create empty hashmap H

1. For each word in dictionary:

    1. Create a key that is the word's letters sorted alphabetically (and forced to one case)
    
    1. Add the word to the list of words accessed by the hash key in H

There's another [very interesting idea](http://karmaandcoding.blogspot.sg/2012/02/print-all-anagrams-for-word-from.html), if the length of the word is not too long. 

> Another approach could be we can assign each letters from a..z a prime numbers (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, .. so on)
>
> and then for any word, we can calculate its key as the multiples of all the prime number corresponding to characters in the word. 
>
> The char -> int assignment may look like: 

    a=2, b=3, c=5, d=7, e=11, f=13, g=17, h=19, i=23, j=29, 
    k=31, l=37, m=41, n=43, o=47, p=53, q=59, r=61, s=67, t=71, 
    u=73, v=79, w=83, x=89, y=97, z=101

### Code

__not written by me__, [link](http://karmaandcoding.blogspot.sg/2012/02/print-all-anagrams-for-word-from.html)

	private static HashMap<String, ArrayList<String>> anagramMap = new HashMap<String, ArrayList<String>>();

	public static void findAnagrams(String[] dictionary) {
		int len = dictionary.length;

		for (int i = 0; i < len; i++) {
			String sortedWord = sortWordLexicographically(dictionary[i]);
			ArrayList<String> wordList = anagramMap.get(sortedWord);
			if (wordList == null) {
				wordList = new ArrayList<String>();
			}
			wordList.add(dictionary[i]);
			anagramMap.put(sortedWord, wordList);
		}
	}

	public ArrayList<String> getAnagrams(String word) {
		if (word == null) {
			return null;
		}

		String sortedWord = sortWordLexicographically(word);
		return anagramMap.get(sortedWord);
	}

	public void printAnagrams(String word) {
		if (word == null) {
			System.out.println("Input word is null!");
		} else {
			ArrayList<String> wordList = getAnagrams(word);
			if (wordList == null) {
				System.out.println("No anagrams exists for : " + word);
			} else {
				Iterator<String> iter = wordList.iterator();
				while (iter.hasNext()) {
					System.out.print(iter.next());
				}
			}
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Array Distance A(i)+A(j)+(j-i)]]></title>
    <link href="http://okckd.github.io/blog/2014/09/02/Array-distance-A(i)+A(j)+(j-i)/"/>
    <updated>2014-09-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/02/Array-distance-A(i)+A(j)+(j-i)</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article/JobHunting/32772225_3.html)

> Given an int array A[], define: 

> distance = A[i] + A[j] + (j-i), j >= i. 

> Find max distance in A[]

### Solution

Solution suggested on floor 8 of [this post](http://www.mitbbs.com/mitbbs_article_t.php?board=JobHunting&gid=32772225&ftype=0). 

1. distance = (A[i] - i) + (A[j] + j), so we do 2 iteration in the array and calculate (A[i] - i) and (A[j] + j) respectively. 

1. save the max value of (A[i] - i) from left to right

1. save the max value of (A[j] + j) from right to left

1. last iteration, calculate result. 

Eg. input = {3, 3, 3, 5, 6, 4}

> max value of (A[i] - i) from left to right: {3, 3, 3, 3, 3, 3}
>
> max value of (A[j] + j) from right to left: {10, 10, 10, 10, 10, 9}
>
> final result: 13

### Code

__written by me__

	public int distance(int[] A) {
		int len = A.length;
		int[] arrayI = new int[len];
		int[] arrayJ = new int[len];

		arrayI[0] = A[0] - 0;
		// arrayI stores max value of (A[i]-i) from left to right
		arrayJ[len - 1] = A[len - 1] + (len - 1);
		// arrayJ stores max value of (A[i]+i) from right to left

		for (int i = 1; i < len; i++) {
			arrayI[i] = Math.max(arrayI[i - 1], A[i] - i);
		}

		for (int i = len - 2; i >= 0; i--) {
			arrayJ[i] = Math.max(arrayJ[i + 1], A[i] + i);
		}

		Common.printArray(arrayI);
		Common.printArray(arrayJ);

		int max = Integer.MIN_VALUE;
		for (int i = 0; i < len; i++) {
			max = Math.max(max, arrayI[i] + arrayJ[i]);
		}
		return max;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Crosswod Solver]]></title>
    <link href="http://okckd.github.io/blog/2014/09/01/Crossword-solver/"/>
    <updated>2014-09-01T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/01/Crossword-solver</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/8585090/algorithm-for-crossword-puzzle-with-given-grid)

> Given a wordlist like this:

    1. ccaa
    1. baca
    1. baaa
    1. bbbb

> and a Grid like this: 

    X X 
    XXXX
    X X 
    XXXX

> Now solve this crossword. One possible solution: 

    b c 
    baca
    b a 
    baaa

### Solution

[The corssword problem](http://stackoverflow.com/a/8586102) is NP-Complete, so your best shot is brute force: just try all possibilities, and stop when a possibility is a valid. Return failure when you exhausted all possible solutions.

### Code

__Pseudo code for brute force__. (this just serve as a guide, not a complete/correct solution)

    solve(words,grid):
       if words is empty:
           if grid.isValudSol():
              return grid
           else:
              return None
       for each word in words:
           possibleSol <- grid.fillFirst(word)
           ret <- solve(words\{word},possibleSol)
           if (ret != None):
              return ret
       return None
]]></content>
  </entry>
  
</feed>
