<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-11T22:58:10+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Crazy Distance Between Strings]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/crazy-distance-string/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/crazy-distance-string</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/15061908/google-interview-find-crazy-distance-between-strings)

> X and Y are strings formed by 0 or 1. Distance is define as: 

    D(X,Y) = Remove chars common at the start from both X & Y. 
    Then add the remaining lengths from both the strings.

> For e.g.

    D(1111, 1000) = Only First alphabet is common. So the remaining string is 111 & 000. Therefore the result length("111") & length("000") = 3 + 3 = 6

> For e.g.

    D(0101, 01100) = Only First two alphabets are common. So the remaining string is 01 & 100. Therefore the result length("01") & length("100") = 2 + 3 = 5

> Now given n input, say like

    1111
    1000
    101
    1100

> Find out the maximum crazy distance between 2 strings.

> __n is__ the number of input strings. __m is__ the max length of any input string. 

### Solution

This is the [source](http://stackoverflow.com/a/15062640). 

> Put the strings into a tree, where 0 means go left and 1 means go right. __O(m*n) time__. 

Example: 

                Root
                 1
              0      1
             0 1*   0  1
            0*     0*    1*

> where the * means that an element ends there. Constructing this tree clearly takes O(n m).

> Now we have to find __the diameter of the tree__ (the longest path between two nodes). 

How to find out longest path between 2 leaf nodes? Please refer to __[Google] Diameter of a Binary Tree__ for explanation.  

Total time complexity is __O(m*n) time__.

### Code

	public int crazyDist(String[] input) {
		TreeNode root = this.buildTree(input);
		return this.findMaxPath(root).path - 1;
	}

	private Result findMaxPath(TreeNode node) {
		if (node == null) {
			return new Result(Integer.MIN_VALUE, 0);
		}
		Result lr = this.findMaxPath(node.left);
		Result rr = this.findMaxPath(node.right);
		int path = Math.max(lr.path, rr.path);
		if (lr.depth != 0 && rr.depth != 0) {
			// this check is important, because if any of the child node is
			// NULL, this root will not be eligible for computing the path
			path = Math.max(path, lr.depth + rr.depth + 1);
			// Why? cuz diameter must go from one leaf, thru root, and reach
			// another leaf. This is different from "Maximum Path Sum" leetcode
		}
		return new Result(path, 1 + Math.max(lr.depth, rr.depth));
	}

	private TreeNode buildTree(String[] input) {
		TreeNode root = new TreeNode(123);
		// share a common root. this root is deducted from the final calculation
		for (String str : input) {
			// insert str under the root
			TreeNode p = root;
			for (char c : str.toCharArray()) {
				if (c == '0') {
					if (p.left == null) {
						p.left = new TreeNode(124);
						// if 0, go to left; otherwise go to right
						// thus value of TreeNodes does not really matter
					}
					p = p.left;
				} else {
					if (p.right == null) {
						p.right = new TreeNode(125);
					}
					p = p.right;
				}
			}
		}
		return root;
	}

	class Result {
		int path;
		int depth;

		public Result(int a, int b) {
			path = a;
			depth = b;
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Check if Repeating Subsequence Exists]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/check-if-repeating-subsequence-exist/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/check-if-repeating-subsequence-exist</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5931067269709824)

> Given a string, find if there is any sub-sequence that repeats itself. Do not reuse any char. 

> Eg: 

    1. abab <------yes, ab is repeated
    2. abba <---- No, a and b follow different order 
    3. acbdaghfb <-------- yes, a followed by b twice 
    4. abcdacb <----- yes, a followed by b twice 

> Note that no char should be reused. I.e. "aab" is a false. 

### Solution

This looks like a question without any clue. However, this actually is a modified version of __[LintCode] Longest Common Subsequence__. 

Look at that question: there's 2 input string, and they match char-by-char. For this question, we are simply __matching input string with input string itself__. And chars should be match __ONLY__ at different positions, that's the key. As pointed out by the [top comment](http://www.careercup.com/question?id=5931067269709824): 

> Now we can modify the longest_common_subsequence(a, a) to find the value of the longest repeated subsequence in a by excluding the cases when i == j

### Code

to do
http://www.careercup.com/question?id=5931067269709824]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Diameter of a Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/Diameter-of-Binary-Tree/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/Diameter-of-Binary-Tree</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/diameter-of-a-binary-tree/)

> The diameter of a tree (sometimes called the width) is the number of nodes on the longest path between two leaves in the tree. 

<img class="middle" src="/assets/images/tree-diameter-1.gif">

### Solution

This is a similar question to __[LeetCode 124] Binary Tree Maximum Path Sum__. __However there's a significant difference__ which might be overlooked while coding. 

Look at this example: 

         0
           1
            1
           0  1
               1

If we only want to find the max path, that would return result of 5, which is root-to-rightmost-leaf. However, the diameter should be 4, which is the distance between 2 leaf nodes. 

A solution is available for reading [here](http://stackoverflow.com/a/3124575). 

For __[Google] Crazy Distance Between Strings__, there is another special case: {"1", "11", "10"}. The program will not output correct result (1), because this is not really the diameter of a tree, but instead, a max path from a non-leaf to a leaf. I leave this part for you to finish. 

### Code

Refer to __[Google] Crazy Distance Between Strings__ for complete code. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Reverse a Stack Without DS]]></title>
    <link href="http://okckd.github.io/blog/2015/01/10/reverse-a-stack/"/>
    <updated>2015-01-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/10/reverse-a-stack</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/reverse-a-stack-using-recursion/)

> Reverse a stack using recursion. You are not allowed to use loops or data structure, and you can only use the following functions:

    isEmpty(S)
    push(S)
    pop(S)

### Solution

Well since we are not allowed to use additional DS or loop, we have to use system stack to help us! 

We add a new method: __insert at stack bottom__. Then we can solve this question recursively. Nice question, and tricky answer! 

### Code

	public void reverse(Stack<Integer> stack) {
		if (stack.isEmpty() || stack.size() == 1) {
			return;
		}
		int top = stack.pop();
		this.reverse(stack);
		this.insertAtBottom(stack, top);
	}

	private void insertAtBottom(Stack<Integer> stack, int val) {
		if (stack.isEmpty()) {
			stack.push(val);
			return;
		}
		int temp = stack.pop();
		this.insertAtBottom(stack, val);
		stack.push(temp);
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Maximum Count Array in a Queue]]></title>
    <link href="http://okckd.github.io/blog/2015/01/10/max-count-array-in-queue/"/>
    <updated>2015-01-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/10/max-count-array-in-queue</id>
    <content type="html"><![CDATA[### Question 

[link1](http://www.mitbbs.com/article_t1/JobHunting/32856675_0_1.html#top)

> 给一个数组a[n]，令s[i]为a[i+1..n-1]中比a[i]大的数的数量。

> 求最大的s[i]。要求O(nlogn)

### Solution

This is very similar question to __[Google] Form a Queue Given Heights__. The idea is to insert elements into BST and count number of larger elements. 

Naitive solution can be reached with a list. 
]]></content>
  </entry>
  
</feed>
