<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-27T02:17:34+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Orthogonal Traverse the Map (`)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/16/orthogonal-traverse-map/"/>
    <updated>2014-08-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/16/orthogonal-traverse-map</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#22)

> 有一个n*m（n和m都不超过50）的棋盘，有k个目标格子需要访问。需要访问的格子的横纵坐标存放在数组x[]和y[]中(0<=x[i]<n, 0<=y[i]<m)。

> 遍历的规则为：
>
> 每一步只能从一个目标格子水平或者竖直跳跃移动到另一个目标格子。
>
> 连续的两步必须形成直角。即如果前一步是水平移动，那么下一步只能竖直移动。
>
> 问是否存在一种遍历顺序，使得每个目标格子有且仅被访问一次。

> 样例：k=8, x=[0, 0, 0, 0, 2, 2, 4, 4], y=[0, 2, 4, 6, 4, 6, 2, 4],对应于下图中A, B, C, D, F, E, G, H 8个目标格子，存在满足条件的遍历A->D->E->F->C->B->G->H。

<img class="middle" src="/assets/images/orthogonal-map.jpg">

### Solution

> n,m的棋盘，[建一个包含n+m个顶点的图G](http://www.itint5.com/discuss/22/%E7%9B%B4%E8%A7%92%E8%B7%AF%E7%BA%BF%E9%81%8D%E5%8E%86%E6%A3%8B%E7%9B%98)（为了方便说明，类似二分图将其分为两列，左边n个顶点，右边m个顶点，分别代表n行和n列）。

> 对于目标格子(i,j)，左边第i个顶点和右边第j个顶点连一条边。最后的问题其实就是问转换之后的图G是否存在欧拉欧拉回路或者欧拉路径。
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Product All 1s]]></title>
    <link href="http://okckd.github.io/blog/2014/08/15/Product-all-ones/"/>
    <updated>2014-08-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/15/Product-all-ones</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#18)

> 给定一个非负整数a（不超过10^6），是否存在整数b，使得a和b的乘积全为1。如果存在，返回最小的乘积的位数。如果不存在，返回-1。

> 样例：a=3，存在b=37，使得3*37=111，则函数应返回3（111的位数）。

### Solution

There's 1 equation of mod operation, which is helpful: 

> (a * b) mod x = ((mx+a') * (nx+b')) mod x = (a' mod x) * (b' mod x) = (a mod x) * (b mod x)
>
> i.e.  (a * b) mod x = (a mod x) * (b mod x)

Altough [I don't understand why](http://www.itint5.com/discuss/136/%E8%BF%99%E9%A2%98%E6%88%91%E8%B6%85%E6%97%B6%E4%BA%86%EF%BC%8C%E8%AF%B7%E9%97%AE%E5%A6%82%E4%BD%95%E7%BC%A9%E7%9F%AD%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4) does it contribute to the incredibly short solution code posted below. I can't solve this question, freakly speaking. 

### Code

	int findMinAllOne(int a) {
		if (a < 0 || (a % 10) % 2 == 0 || a % 10 == 5)
			return -1;

		int ans = 1;
		for (int p = 1; p != 0; p %= a) {
			p = 10 * p + 1;
			++ans;
		}
		return a == 1 ? ans - 1 : ans;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Alphabet Table (`)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/15/Alphabet-table/"/>
    <updated>2014-08-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/15/Alphabet-table</id>
    <content type="html"><![CDATA[### Question 

[link](http://blog.sina.com.cn/s/blog_979956cc0101i67x.html)

> 每一种语言，都有自己的字母表，类似英文的a-z，但是顺序不相同。例如，有的语言可能是z是第一个之类的。现在给定这个语言的字典，请分析这个字典，得到这个语言的字母表的顺序。 

> 例如：有如下的字母：C CAC CB BCC BA。 经过分析，得到字母表为C->A->B。

### Solution

http://page.renren.com/601882592/channel-noteshow-927705419

1. C 2. CAC 3. CB 4. BCC 5. BA 经过分析，得到字母表为C->A->B。 

分析 字典序相邻的位置的字符串，只会有如下两种情况： 

（1）排在前面的字符串是下一个串的子串，如C与CAC

（2）两个字符串具有第一对不相同的字符对，如CAC和CBB，第一个不相同的字符对为（A，B），这是就要求A在字母表中的顺序在B前面。对于后面字符并没有要求，如并不要求第二个不相同的字符对（C，B）中的C在字母表中的顺序在B前面。

所以按照第（2）种情况建图，然后对该有向无环图求拓扑排序即可。

So this becomes a Topology Sorting question. 

### Code

__not written by me__

    pair<char,char>  constructEdge(const string & src1, const string & src2)
    {
         int min_len = min(src1.length(), src2.length());
         int i = 0;
         while(i < min_len && src1[i] == src2[i]){
               i++;
         }
         if(i < min_len){
               return  make_pair(src1[i], src2[i]);
         }else{
               return  make_pair('\0','\0');
         }
    }
    //-1, 0, 1
    int  alphaTable(const vector<string> &  dict, vector<char> & alpha_table)
    {
         unordered_map<char,set<char> >  edges;
         set<char> nodes;
         for(const string & word : dict){
              for(char c : word){
                  nodes.insert(c);
              }
         }
         unordered_map<char,int>  in_degree;
         for(int i = 1; i < dict.length(); i++){
              pair edge = constructEdge(dict[i-1],dict[i]);
              if(edge.first != '\0'){
                  edges[edge.first].insert(edge.second);
                  in_degree[edge.second]++;
              }
         }
         queue<char>  q;
         for(char node : nodes){
             if(in_degree[node] == 0){
                  q.push(node);
             }
         }
         alpha_table.clear();
         int result = 0;
         while(!q.empty()){
            if(q.size() > 1){
                result = 1;
            }
            char  c = q.front();
            q.pop();
            alpha_table.push_back(c);
            for(char node : edges[c]){
                 in_degree[node] --;
                 if(in_degree[node] == 0){
                      q.push(node);
                 }
             }
         }//while
         if(alpha_table.size() < nodes.size()){
             result = -1;
         }
         return result;    
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Count Complete Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/08/11/Count-complete-binary-tree/"/>
    <updated>2014-08-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/11/Count-complete-binary-tree</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#4)

> 给定一棵[完全二叉树](http://baike.baidu.com/view/427107.htm)（complete binary tree）的根结点，统计该树的结点总数。

> 提示：使用O(n)的递归算法统计二叉树的结点数是一种显而易见的方法，此题中请利用完全二叉树的性质，想出效率更高的算法。

### Solution

Similar to binary search, O(lgn) complexity. 

The idea is, sum up 1 branch of nodes at a time. Do it recursively. The following code is refactored and written by me. 

### Code

__read it from [here](http://www.itint5.com/discuss/125/%E5%A4%A7%E7%89%9B%E8%AF%B7%E6%8C%87%E7%82%B9%EF%BC%8C%E6%95%B0%E6%8D%AE37%E8%BF%90%E8%A1%8C%E8%B6%85%E6%97%B6%EF%BC%88%E9%99%84%E4%BB%A3%E7%A0%81%EF%BC%89)__

	//使用TreeNodeUtil.getLeftChildNode(TreeNode)获得左儿子结点
	//使用TreeNodeUtil.getRightChildNode(TreeNode)获得右儿子结点
	//使用TreeNodeUtil.isNullNode(TreeNode)判断结点是否为空
	public class CountCompleteBinayTreeNodes {
	    public int countNodes(TreeNode root) {
			if (TreeNodeUtil.isNullNode(root)) {
				return 0;
			}
			int hl = height(TreeNodeUtil.getLeftChildNode(root));
			int hr = height(TreeNodeUtil.getRightChildNode(root));
			if (hl == hr) {
				return (int) Math.pow(2, hl) + countNodes(TreeNodeUtil.getRightChildNode(root));
			} else {
				return (int) Math.pow(2, hr) + countNodes(TreeNodeUtil.getLeftChildNode(root));
			}
	    }
		
		private int height(TreeNode root) {
			int count = 0;
			while (!TreeNodeUtil.isNullNode(root)) {
				root = TreeNodeUtil.getLeftChildNode(root);
				count++;
			}
			return count;
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Million Phone Numbers]]></title>
    <link href="http://okckd.github.io/blog/2014/08/07/Million-phone-numbers/"/>
    <updated>2014-08-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/07/Million-phone-numbers</id>
    <content type="html"><![CDATA[### Question 1

[link](http://www.glassdoor.com/Interview/How-would-you-store-1-million-phone-numbers-QTN_456.htm)

> How would you store 1 million phone numbers? 

### Solution

BitMap.

> The key here is that 1 million phone numbers will be within some range, likely 10 million or so. 10 million bits = 10^7 bits ~ 0.12 GB. Just have a bit array where the first bit being set implies that the first phone number is set (e.g., 10 000 000) and the last bit indicates the last phone number (10 999 999). If you find a number in the list, just set the appropriate bit. You now have a bit vector of size 1million bits, sorted, and to check for a particular number, you just check whether the corresponding bit is set.

### Question 2

[link](http://www.careercup.com/question?id=7997766)

> How would you sort 1 million phone numbers? 

### Solution

BitMap or radix sort, both are O(n) complexity.

Read more [here](http://www.vex.net/~trebla/compsci/sorting-phone-numbers.html). 
]]></content>
  </entry>
  
</feed>
