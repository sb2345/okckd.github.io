<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-04T21:09:10+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Traveller Path Problem]]></title>
    <link href="http://okckd.github.io/blog/2014/08/04/Traveller-Path-Problem/"/>
    <updated>2014-08-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/04/Traveller-Path-Problem</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5147801809846272)

> Traveler wants to travel from city “A” to city “D”. There is a path from city “A” to city “D”. Path consists of steps, i.e. travel from city “A” to city “B”. Path is encoded as sequence of steps. 

> Sequence is in incorrect order. Your task is to restore order of steps in the path. 

> Input (unordered sequence): 

    C -> D 
    A -> B 
    B -> C 

> Output (Correctly ordered list which represents path): 

    A, B, C, D 

> Implement following API:

    class Step {
        String start;
        String finish;
    };

    class Node {
        String value;
        Node next;
    }

    List<String> findPath(List<Step> steps) {
    }

### Solution

This question is not stated clear enough. I found one tentative algorithm: 

> First, initialize a result - sortedPath, and build 2 maps (String to String) - startsToFinishes and finishesToStarts (O(N)) 

> Then, find the one key on startsToFinishes, that is not a key in finishesToStarts - this is the city from which the path begins. (O(N)) 

> Then, iteratively, city by city, build the path. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Design Solar System]]></title>
    <link href="http://okckd.github.io/blog/2014/08/03/Design-Solar-System/"/>
    <updated>2014-08-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/03/Design-Solar-System</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=14761735)

> Design a web application to represent hierarchy of solar system. 

> Give details of Persistence layer, business layer, presentation layer and Client-server protocol. 

### Solution

__First, OOD part__ is very well covered in [this site](http://www.ehow.com/how_5579338_build-own-solar-system-java.html). There're 2 abstract class: __OrbitalSystem__, where 'Star/Sun' is an instance, and __GravityObject__, where 'Planet/Earch' is an instance. Though this does not take satellite into consideration. 

__Second, the multi-layer structure__. It's cover in another post __[Multilayered architecture](/blog/2014/08/03/Multilayered-architecture/)__

__Third, the protocol__. We [use HTTP protocol](http://stackoverflow.com/a/4279218), because: 

> HTTP(S) is the best protocol to use. The overhead (i.e. headers) is pretty small, the transfer can be gzipped, the connection can be secured (via SSL). Also, ports 80 (HTTP) and 443 (HTTPS) will be open in 99% of cases. Other ports are not -- for example some carriers block all other ports unless you pay extra. 

More info on HTTP communication comes later. 

### Code

from [here](http://www.ehow.com/how_5579338_build-own-solar-system-java.html)

    public abstract class GravityObject {
        double xPosition;
        double yPosition;
        double degreeInOrbit;
        double distanceFromParent;

        GravityObject() {
        this.distance = 0;
        }

        GravityObject(double distance) {
        this.distance = distance;
        }
    }

    import java.util.ArrayList;

    public abstract class OrbitalSystem extends GravityObject {
        private ArrayList children = new ArrayList(); // Objects within the system. They will orbit the parent.

        public void add(GravityObject child) { children.add(child); }

        public void tick() {
            for (int x = 0; x < children.size(); x++) {
                GravityObject current = children.get(x);
                current.degree += 1
                current.xPosition = this.xPosition + Math.cos(degree/180 * Math.PI)* current.distance;
                current.yPosition = this.yPosition - Math.sin(degree/180 * Math.PI) * current.distance;
            }
        }
    }

    public class Star extends OrbitalSystem { 

    };

    public class Planet extends GravityObject { 

    };

    public static int main(String[] args) {
        Star s = new Star(); // Create a new star.
        s.add(new Planet(20)); // Add a planet to the star's orbital system which orbits at a distance of 20 units.
        s.add(new Planet(66)); // Add another planet to the star's orbital system which orbits at a distance of 66 units.

        while (true) {
            s.tick();
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Data Structure for 3 Keys]]></title>
    <link href="http://okckd.github.io/blog/2014/08/03/Data-Structure-3-Keys/"/>
    <updated>2014-08-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/03/Data-Structure-3-Keys</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5763793837621248)

> Give efficient implementation of the following problem. 

> An item consist of different keys say k1, k2, k3. User can insert any number of items in database, search for item using __any (one) key__, delete it using any key and iterate through all the items in sorted order __using any key__. Give the most efficient way such that it supports insertion, search based on a key, iteration and deletion.

### Solution

There're 3 keys, so we need 3 maps to store search map for 3 types of keys. For example, the DS is like this: 

> (date, name, country) -> ItemObject

Then we would have: 

> date -> a list of ItemObject
>
> name -> a list of ItemObject
>
> country -> a list of ItemObject

Since we need to iterate in order, we choose TreeMap over HashMap. 

For scalability purpose, we use another HashMap<KeyType, TreeMap> and put 3 items in. 

### Final Data Structure

3 DS needed. [source](http://www.careercup.com/question?id=5763793837621248)

1. ArrayList<ItemObject> list;
1. TreeMap<KeyValue, List<ItemObject>> index; 
1. HashMap<KeyType, TreeMap<KeyValue, List<ItemObject>>> mapOfIndexes;

#### Method add(item): void 

1. add item in ArrayList. 
1. For each key, get TreeMap from HashMap and add into TreeMap. 

#### Method search(key): List<Item> 

1. Get TreeMap from HashMap for provided key.
1. Search the TreeMap
1. Return List Of Items 

#### Method delete(key): List<Item> 

1. Using search method get List Of item 
2. Delete items from ArrayList and __also delete its mapping from all (3) TreeMap__

#### Method orderedIterator(keytype): Iterator 

1. Get TreeMap from HashMap for provided key 
2. Get EntrySet from TreeMap 
3. Return EntrySet.iterator(); 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Winner of Tic-tac-toe]]></title>
    <link href="http://okckd.github.io/blog/2014/08/02/Winner-tic-tac-toe/"/>
    <updated>2014-08-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/02/Winner-tic-tac-toe</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.glassdoor.com/Interview/How-would-you-determine-if-someone-has-won-a-game-of-tic-tac-toe-on-a-board-of-any-size-QTN_1104.htm)

> How would you determine if someone has won a game of tic-tac-toe on a board of any size? 

### Solution

First, confirm that when the number of pieces in a line equals to the dimension of the board, one person wins. Eg. for 10 * 10 board, 10 pieces need to be in 1 line. 

__[We can determine](http://www.glassdoor.com/Interview/How-would-you-determine-if-someone-has-won-a-game-of-tic-tac-toe-on-a-board-of-any-size-QTN_1104.htm) if someone has won during a game in real time, as in checking after every move. 

> Create an array of size 2n+2 at the beginning of the game and fill it with zeros. Each spot in the array will be a sum of X's or O's horizontally (the first n places in the array), vertically (the second n places in the array) and diagonally (the last 2 places). Then with every move, you add 1 to the 2 places (or 3 if on a diagnol) of the array if X, and subtract 1 if its an O. After adding you check and see if the value of the array is equal to n or -n, if it is, n mean X has won and -n means O has won.

### Code

__not written__
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Special Increasing Adjacent Sequence]]></title>
    <link href="http://okckd.github.io/blog/2014/08/02/Special-increasing-adjacent-sequence/"/>
    <updated>2014-08-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/02/Special-increasing-adjacent-sequence</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5147801809846272)

> Given a NxN matrix which contains all distinct 1 to n^2 numbers, write code to print sequence of increasing adjacent sequential numbers. 

    ex: 
    1 5 9 
    2 3 8 
    4 6 7 

> should print: 6 7 8 9

### Solution

> Make an array of booleans (or bits) of same size as the input, where arr[i-1] indicates whether i is adjacent to i+1. Then, iterate over the matrix, checking for each cell the four neighbors and populating the relevant entry in the boolean array. 

Last, look for the longest run of "true" values in the boolean array, which can be done with one pass. O(n) time. 

__Note that this algorithm is valid only if input integers are distinct__, which is true here. 

### Code

__not written__
]]></content>
  </entry>
  
</feed>
