<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-05T02:42:48+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Write a Random Number Generator]]></title>
    <link href="http://okckd.github.io/blog/2014/08/05/Write-RNG/"/>
    <updated>2014-08-05T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/05/Write-RNG</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5173972006076416)

### Solution

Basically, the formula is as follows:

> number = (previous_number * constant + other_constant) mod third_constant

The three constants are carefully selected, and a typical choice is:

> number = (previous_number * 214013 + 2531011) mod 2^15
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Traveller Path Problem]]></title>
    <link href="http://okckd.github.io/blog/2014/08/04/Traveller-Path-Problem/"/>
    <updated>2014-08-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/04/Traveller-Path-Problem</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5147801809846272)

> Traveler wants to travel from city “A” to city “D”. There is a path from city “A” to city “D”. Path consists of steps, i.e. travel from city “A” to city “B”. Path is encoded as sequence of steps. 

> Sequence is in incorrect order. Your task is to restore order of steps in the path. 

> Input (unordered sequence): 

    C -> D 
    A -> B 
    B -> C 

> Output (Correctly ordered list which represents path): 

    A, B, C, D 

> Implement following API:

    class Step {
        String start;
        String finish;
    };

    class Node {
        String value;
        Node next;
    }

    List<String> findPath(List<Step> steps) {
    }

### Solution

This question is not stated clear enough. I found one tentative algorithm: 

> First, initialize a result - sortedPath, and build 2 maps (String to String) - startsToFinishes and finishesToStarts (O(N)) 

> Then, find the one key on startsToFinishes, that is not a key in finishesToStarts - this is the city from which the path begins. (O(N)) 

> Then, iteratively, city by city, build the path. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Find Occurance Greater Than Index]]></title>
    <link href="http://okckd.github.io/blog/2014/08/04/Find-occurance-greater-than-index/"/>
    <updated>2014-08-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/04/Find-occurance-greater-than-index</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5094709806497792)

> Given an unsorted array of integers, you need to return maximum possible n such that the array consists at least n values greater than or equals to n. Array can contain duplicate values. 

> Sample input : [1, 2, 3, 4] -- output : 2 

> Sample input : [900, 2, 901, 3, 1000] -- output: 3

### Solution

The idea of 'couting sort', solves in O(n) time. 

> Lets say the array has M numbers. So, __we can count the number of existing values between 1 and M__. 

> Then, process the values backwards (M to 1) to find the answer, adding the counts of the values processed so far. 

This is not an easy question. 

### Code

__not written by me__

    int Solve(const vector<int>& values) {
        int n = values.size();
        vector<int> count(n+1, 0);
        for (auto val: values)
            if (val >= n)
                count[n]++;
            else if (val > 0) // ignore negative values
                count[val]++;
        int am = 0;
        for (int i = n; i > 0; i--) {
            am += count[i];  // amount of numbers >= i
            if (am >= i)
                return i;
        }
        return 0;
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Find Nearest Point in a 2D Space]]></title>
    <link href="http://okckd.github.io/blog/2014/08/04/Find-Nearest-Point-in-2D-Space/"/>
    <updated>2014-08-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/04/Find-Nearest-Point-in-2D-Space</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5634947435986944)

> You are given information about hotels in a country/city. X and Y coordinates of each hotel are known. You need to suggest the list of nearest hotels to a user who is querying from a particular point (X and Y coordinates of the user are given). Distance is calculated as the straight line distance between the user and the hotel coordinates. 

### Solution

__Build a 2-D Tree (by using Binary Tree)__. 

First find the root, then divide the rest of nodes by left-side and right-side. Then, divide by up-side and down-side. 

There's a very good example video [here](http://www.youtube.com/watch?v=T9h2KKJ_Pl8), which talked about how to construct a 2-D tree. 

After this __preprocessing__, the search for nearest hotels in about O(lgn). However, if we were to return a list of nearest nodes, I've got no idea. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Design Solar System （`)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/03/Design-Solar-System/"/>
    <updated>2014-08-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/03/Design-Solar-System</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=14761735)

> Design a web application to represent hierarchy of solar system. 

> Give details of Persistence layer, business layer, presentation layer and Client-server protocol. 

### Solution

__First, OOD part__ is very well covered in [this site](http://www.ehow.com/how_5579338_build-own-solar-system-java.html). There're 2 abstract class: __OrbitalSystem__, where 'Star/Sun' is an instance, and __GravityObject__, where 'Planet/Earch' is an instance. Though this does not take satellite into consideration. 

__Second, the multi-layer structure__. It's cover in another post __[Multilayered architecture](/blog/2014/08/03/Multilayered-architecture/)__

__Third, the protocol__. We [use HTTP protocol](http://stackoverflow.com/a/4279218), because: 

> HTTP(S) is the best protocol to use. The overhead (i.e. headers) is pretty small, the transfer can be gzipped, the connection can be secured (via SSL). Also, ports 80 (HTTP) and 443 (HTTPS) will be open in 99% of cases. Other ports are not -- for example some carriers block all other ports unless you pay extra. 

More info on HTTP communication comes later. 

### Code

from [here](http://www.ehow.com/how_5579338_build-own-solar-system-java.html)

    public abstract class GravityObject {
        double xPosition;
        double yPosition;
        double degreeInOrbit;
        double distanceFromParent;

        GravityObject() {
        this.distance = 0;
        }

        GravityObject(double distance) {
        this.distance = distance;
        }
    }

    import java.util.ArrayList;

    public abstract class OrbitalSystem extends GravityObject {
        private ArrayList children = new ArrayList(); // Objects within the system. They will orbit the parent.

        public void add(GravityObject child) { children.add(child); }

        public void tick() {
            for (int x = 0; x < children.size(); x++) {
                GravityObject current = children.get(x);
                current.degree += 1
                current.xPosition = this.xPosition + Math.cos(degree/180 * Math.PI)* current.distance;
                current.yPosition = this.yPosition - Math.sin(degree/180 * Math.PI) * current.distance;
            }
        }
    }

    public class Star extends OrbitalSystem { 

    };

    public class Planet extends GravityObject { 

    };

    public static int main(String[] args) {
        Star s = new Star(); // Create a new star.
        s.add(new Planet(20)); // Add a planet to the star's orbital system which orbits at a distance of 20 units.
        s.add(new Planet(66)); // Add another planet to the star's orbital system which orbits at a distance of 66 units.

        while (true) {
            s.tick();
        }
    }
]]></content>
  </entry>
  
</feed>
