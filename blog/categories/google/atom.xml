<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-20T10:57:26+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Lexicographic Order From Dictionary]]></title>
    <link href="http://okckd.github.io/blog/2015/01/18/lexicographic-order-from-dict/"/>
    <updated>2015-01-18T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/18/lexicographic-order-from-dict</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=13394663)

> Given set of words that are lexicographically sorted, return lexicographic order. E.g:

    abc
    acd
    bcc
    bed
    bdc
    dab

> The order of letters for the given example would be

    a->b->c->e->d

### Solution

> Just form a graph(DAG) and do a topological sort. 

Start from the first pair in the dictionary. Compare two strings in this pair __till first mismatch__. 

Eg: __aad & aab__, in this case create an edge __d -> b__. 

More details is available [here](http://codereview.stackexchange.com/questions/48292/return-the-lexicographic-order). 

### Code

	public String lexicoOrder(String[] dict) {
		String ans = "";

		// for each pair, maintain 2 HashMap
		HashMap<Character, Integer> incount = new HashMap<Character, Integer>();
		HashMap<Character, List<Character>> connection = new HashMap<Character, List<Character>>();
		for (String str : dict) {
			for (char c : str.toCharArray()) {
				incount.put(c, 0);
				connection.put(c, new ArrayList<Character>());
			}
		}
		buildGraph(dict, incount, connection);

		// start topology sorting
		Queue<Character> temp = new LinkedList<Character>();
		for (char c : incount.keySet()) {
			if (incount.get(c) == 0) {
				temp.offer(c);
				incount.remove(c);
				// remove any node whose incount is 0
			}
		}
		while (!temp.isEmpty()) {
			char top = temp.poll();
			ans += top;
			// 'top' is next char in line. remove it and delete connections
			List<Character> inNodes = connection.get(top);
			for (char c : inNodes) {
				// remove incount for all nodes from inNodes
				incount.put(c, incount.get(c) - 1);
				if (incount.get(c) == 0) {
					incount.remove(c);
					temp.offer(c);
				}
			}
		}
		if (incount.size() == 0)
			return ans;
		else
			return "unable to find a valid char sequence.";
	}

	public void buildGraph(String[] dict, HashMap<Character, Integer> incount,
			HashMap<Character, List<Character>> connection) {
		// build the graph map
		// abc
		// acd
		// bcc
		// bed
		// bdc
		// dab
		for (int i = 0; i < dict.length - 1; i++) {
			// compare dict[i] and dict[i+1]
			String str1 = dict[i];
			String str2 = dict[i + 1];
			int p = 0;
			while (p < str1.length() && p < str2.length()) {
				if (str1.charAt(p) == str2.charAt(p)) {
					p++;
				} else {
					break;
				}
			}
			if (p == str1.length()) {
				// this is special case eg. "ab" & "abc"
				// this will not give up any information about lexico order
				continue;
			}
			char from = str1.charAt(p);
			char to = str2.charAt(p);
			// update incount
			incount.put(to, incount.get(to) + 1);
			// update connection
			connection.get(from).add(to);
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Crazy Distance Between Strings]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/crazy-distance-string/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/crazy-distance-string</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/15061908/google-interview-find-crazy-distance-between-strings)

> X and Y are strings formed by 0 or 1. Distance is define as: 

    D(X,Y) = Remove chars common at the start from both X & Y. 
    Then add the remaining lengths from both the strings.

> For e.g.

    D(1111, 1000) = Only First alphabet is common. So the remaining string is 111 & 000. Therefore the result length("111") & length("000") = 3 + 3 = 6

> For e.g.

    D(0101, 01100) = Only First two alphabets are common. So the remaining string is 01 & 100. Therefore the result length("01") & length("100") = 2 + 3 = 5

> Now given n input, say like

    1111
    1000
    101
    1100

> Find out the maximum crazy distance between 2 strings.

> __n is__ the number of input strings. __m is__ the max length of any input string. 

### Solution

This is the [source](http://stackoverflow.com/a/15062640). 

> Put the strings into a tree, where 0 means go left and 1 means go right. __O(m*n) time__. 

Example: 

                Root
                 1
              0      1
             0 1*   0  1
            0*     0*    1*

> where the * means that an element ends there. Constructing this tree clearly takes O(n m).

> Now we have to find __the diameter of the tree__ (the longest path between two nodes). 

How to find out longest path between 2 leaf nodes? Please refer to __[Google] Diameter of a Binary Tree__ for explanation.  

Total time complexity is __O(m*n) time__.

### Code

	public int crazyDist(String[] input) {
		TreeNode root = this.buildTree(input);
		return this.findMaxPath(root).path - 1;
	}

	private Result findMaxPath(TreeNode node) {
		if (node == null) {
			return new Result(Integer.MIN_VALUE, 0);
		}
		Result lr = this.findMaxPath(node.left);
		Result rr = this.findMaxPath(node.right);
		int path = Math.max(lr.path, rr.path);
		if (lr.depth != 0 && rr.depth != 0) {
			// this check is important, because if any of the child node is
			// NULL, this root will not be eligible for computing the path
			path = Math.max(path, lr.depth + rr.depth + 1);
			// Why? cuz diameter must go from one leaf, thru root, and reach
			// another leaf. This is different from "Maximum Path Sum" leetcode
		}
		return new Result(path, 1 + Math.max(lr.depth, rr.depth));
	}

	private TreeNode buildTree(String[] input) {
		TreeNode root = new TreeNode(123);
		// share a common root. this root is deducted from the final calculation
		for (String str : input) {
			// insert str under the root
			TreeNode p = root;
			for (char c : str.toCharArray()) {
				if (c == '0') {
					if (p.left == null) {
						p.left = new TreeNode(124);
						// if 0, go to left; otherwise go to right
						// thus value of TreeNodes does not really matter
					}
					p = p.left;
				} else {
					if (p.right == null) {
						p.right = new TreeNode(125);
					}
					p = p.right;
				}
			}
		}
		return root;
	}

	class Result {
		int path;
		int depth;

		public Result(int a, int b) {
			path = a;
			depth = b;
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Check if Repeating Subsequence Exists]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/check-if-repeating-subsequence-exist/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/check-if-repeating-subsequence-exist</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5931067269709824)

> Given a string, find if there is any sub-sequence that repeats itself. Do not reuse any char. 

> Eg: 

    1. abab <------yes, ab is repeated
    2. abba <---- No, a and b follow different order 
    3. acbdaghfb <-------- yes, a followed by b twice 
    4. abcdacb <----- yes, a followed by b twice 

> Note that no char should be reused. I.e. "aab" is a false. 

### Solution

This looks like a question without any clue. However, this actually is a modified version of __[LintCode] Longest Common Subsequence__. 

Look at that question: there's 2 input string, and they match char-by-char. For this question, we are simply __matching input string with input string itself__. And chars should be match __ONLY__ at different positions, that's the key. As pointed out by the [top comment](http://www.careercup.com/question?id=5931067269709824): 

> Now we can modify the longest_common_subsequence(a, a) to find the value of the longest repeated subsequence in a by excluding the cases when i == j

### Code

	public boolean checkRepeatSubseq(String input) {
		int len = input.length();
		int[][] dp = new int[len + 1][len + 1];
		// dp[i][j] denotes the length of subseq between 2 strings:
		// 1. first i chars of input
		// 2. first j chars of input
		for (int i = 1; i <= len; i++) {
			for (int j = i; j <= len; j++) {
				if (i != j && input.charAt(i - 1) == input.charAt(j - 1)) {
					int temp = Math.max(dp[i - 1][j], dp[i][j - 1]);
					dp[i][j] = Math.max(temp, dp[i - 1][j - 1] + 1);
				} else {
					dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
				}
			}
		}
		return dp[len][len] >= 2;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Diameter of a Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/Diameter-of-Binary-Tree/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/Diameter-of-Binary-Tree</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/diameter-of-a-binary-tree/)

> The diameter of a tree (sometimes called the width) is the number of nodes on the longest path between two leaves in the tree. 

<img class="middle" src="/assets/images/tree-diameter-1.gif">

### Solution

This is a similar question to __[LeetCode 124] Binary Tree Maximum Path Sum__. __However there's a significant difference__ which might be overlooked while coding. 

Look at this example: 

         0
           1
            1
           0  1
               1

If we only want to find the max path, that would return result of 5, which is root-to-rightmost-leaf. However, the diameter should be 4, which is the distance between 2 leaf nodes. 

A solution is available for reading [here](http://stackoverflow.com/a/3124575). 

For __[Google] Crazy Distance Between Strings__, there is another special case: {"1", "11", "10"}. The program will not output correct result (1), because this is not really the diameter of a tree, but instead, a max path from a non-leaf to a leaf. I leave this part for you to finish. 

### Code

Refer to __[Google] Crazy Distance Between Strings__ for complete code. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Reverse a Stack Without DS]]></title>
    <link href="http://okckd.github.io/blog/2015/01/10/reverse-a-stack/"/>
    <updated>2015-01-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/10/reverse-a-stack</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/reverse-a-stack-using-recursion/)

> Reverse a stack using recursion. You are not allowed to use loops or data structure, and you can only use the following functions:

    isEmpty(S)
    push(S)
    pop(S)

### Solution

Well since we are not allowed to use additional DS or loop, we have to use system stack to help us! 

We add a new method: __insert at stack bottom__. Then we can solve this question recursively. Nice question, and tricky answer! 

### Code

	public void reverse(Stack<Integer> stack) {
		if (stack.isEmpty() || stack.size() == 1) {
			return;
		}
		int top = stack.pop();
		this.reverse(stack);
		this.insertAtBottom(stack, top);
	}

	private void insertAtBottom(Stack<Integer> stack, int val) {
		if (stack.isEmpty()) {
			stack.push(val);
			return;
		}
		int temp = stack.pop();
		this.insertAtBottom(stack, val);
		stack.push(temp);
	}
]]></content>
  </entry>
  
</feed>
