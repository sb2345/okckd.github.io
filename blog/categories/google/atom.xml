<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-10T02:30:05+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Million Phone Numbers]]></title>
    <link href="http://okckd.github.io/blog/2014/08/07/Million-phone-numbers/"/>
    <updated>2014-08-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/07/Million-phone-numbers</id>
    <content type="html"><![CDATA[### Question 1

[link](http://www.glassdoor.com/Interview/How-would-you-store-1-million-phone-numbers-QTN_456.htm)

> How would you store 1 million phone numbers? 

### Solution

BitMap.

> The key here is that 1 million phone numbers will be within some range, likely 10 million or so. 10 million bits = 10^7 bits ~ 0.12 GB. Just have a bit array where the first bit being set implies that the first phone number is set (e.g., 10 000 000) and the last bit indicates the last phone number (10 999 999). If you find a number in the list, just set the appropriate bit. You now have a bit vector of size 1million bits, sorted, and to check for a particular number, you just check whether the corresponding bit is set.

### Question 2

[link](http://www.careercup.com/question?id=7997766)

> How would you sort 1 million phone numbers? 

### Solution

BitMap or radix sort, both are O(n) complexity.

Read more [here](http://www.vex.net/~trebla/compsci/sorting-phone-numbers.html). 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Postorder Successor in Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/08/06/Postorder-successor-Binary-Tree/"/>
    <updated>2014-08-06T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/06/Postorder-successor-Binary-Tree</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5173972006076416)

> Write an algorithm to find the ‘next’ post-order successor of a given node in a binary tree and binary search tree.

> 1. where each node has a link to its parent. 
> 1. without parent pointer 

> Implement 2 versions of the algorithm: 1.) binary tree 2.) BST

### Solution

In postorder, any node below current node shall be 'predecessor' of current node. Thus we only care about current node's parent. 

Suggested by a user: 

    1) parent pointer is given. 
    - go to the parent of the current node. 
    - if current node is the right child of its parent => print parent. 
    - else return leftmost node of the right sub-tree of parent. 

    2) parent pointer is not given. 
    - traverse the tree and find the parent of the current node 
    - do the same as method (1). 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Connect Nodes and Avoid Intersect]]></title>
    <link href="http://okckd.github.io/blog/2014/08/06/Connect-nodes-avoid-intersect/"/>
    <updated>2014-08-06T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/06/Connect-nodes-avoid-intersect</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5138832865361920)

> Draw a graph as a graph. Assume there is graphics library to draw lines and all. Just tell how will you order the vertices such that the edges don't intersect and they seem ordered. 

### Solution

There's no clear solution. Someone suggest the following: 

1. printing topological sort result (refer to post 'Topology Sort')
2. edges should not intersect, finding if a graph is planar

There's various [Planarity Testing Algorithms](http://en.wikipedia.org/wiki/Planarity_testing). 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Ambiguous File Matching]]></title>
    <link href="http://okckd.github.io/blog/2014/08/06/Ambiguous-File-Matching/"/>
    <updated>2014-08-06T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/06/Ambiguous-File-Matching</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5678301561487360)

> Given 10 files (text files) each of size of 900 Mb. 

> Given another file named "hello". match the contents of this file with other 10 file and return the file whose contents closely match with the contents of file "hello". 

### Solution

The solution given on the site is not adequate, but I have to choose one that make a little sense. 

> Score each file's contents on several parameters: 
> 
> 1. no. of words 
> 2. no. of letters 
> 3. no. of spaces 
> 4. count of each of the letters 
> 5. count of each words 

> Give weightage to each of the properties and arrive at a number (score). The closest of the scores is the answer.

I think maybe can use [Counting Bloom Filter](http://en.wikipedia.org/wiki/Bloom_filter#Counting_filters), although bloom filter does not record word sequences. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Write a Random Number Generator]]></title>
    <link href="http://okckd.github.io/blog/2014/08/05/Write-a-RNG/"/>
    <updated>2014-08-05T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/05/Write-a-RNG</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5173972006076416)

### Solution

Basically, the formula is as follows:

> number = (previous_number * constant + other_constant) mod third_constant

The three constants are carefully selected, and a typical choice is:

> number = (previous_number * 214013 + 2531011) mod 2^15
]]></content>
  </entry>
  
</feed>
