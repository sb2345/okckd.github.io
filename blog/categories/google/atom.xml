<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-12T20:53:59+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Count Complete Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/08/11/Count-complete-binary-tree/"/>
    <updated>2014-08-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/11/Count-complete-binary-tree</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#4)

> 给定一棵[完全二叉树](http://baike.baidu.com/view/427107.htm)（complete binary tree）的根结点，统计该树的结点总数。

> 提示：使用O(n)的递归算法统计二叉树的结点数是一种显而易见的方法，此题中请利用完全二叉树的性质，想出效率更高的算法。

### Solution

Similar to binary search, O(lgn) complexity. 

The idea is, sum up 1 branch of nodes at a time. Do it recursively. The following code is refactored and written by me. 

### Code

__read it from [here](http://www.itint5.com/discuss/125/%E5%A4%A7%E7%89%9B%E8%AF%B7%E6%8C%87%E7%82%B9%EF%BC%8C%E6%95%B0%E6%8D%AE37%E8%BF%90%E8%A1%8C%E8%B6%85%E6%97%B6%EF%BC%88%E9%99%84%E4%BB%A3%E7%A0%81%EF%BC%89)__

	//使用TreeNodeUtil.getLeftChildNode(TreeNode)获得左儿子结点
	//使用TreeNodeUtil.getRightChildNode(TreeNode)获得右儿子结点
	//使用TreeNodeUtil.isNullNode(TreeNode)判断结点是否为空
	public class CountCompleteBinayTreeNodes {
	    public int countNodes(TreeNode root) {
			if (TreeNodeUtil.isNullNode(root)) {
				return 0;
			}
			int hl = height(TreeNodeUtil.getLeftChildNode(root));
			int hr = height(TreeNodeUtil.getRightChildNode(root));
			if (hl == hr) {
				return (int) Math.pow(2, hl) + countNodes(TreeNodeUtil.getRightChildNode(root));
			} else {
				return (int) Math.pow(2, hr) + countNodes(TreeNodeUtil.getLeftChildNode(root));
			}
	    }
		
		private int height(TreeNode root) {
			int count = 0;
			while (!TreeNodeUtil.isNullNode(root)) {
				root = TreeNodeUtil.getLeftChildNode(root);
				count++;
			}
			return count;
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Million Phone Numbers]]></title>
    <link href="http://okckd.github.io/blog/2014/08/07/Million-phone-numbers/"/>
    <updated>2014-08-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/07/Million-phone-numbers</id>
    <content type="html"><![CDATA[### Question 1

[link](http://www.glassdoor.com/Interview/How-would-you-store-1-million-phone-numbers-QTN_456.htm)

> How would you store 1 million phone numbers? 

### Solution

BitMap.

> The key here is that 1 million phone numbers will be within some range, likely 10 million or so. 10 million bits = 10^7 bits ~ 0.12 GB. Just have a bit array where the first bit being set implies that the first phone number is set (e.g., 10 000 000) and the last bit indicates the last phone number (10 999 999). If you find a number in the list, just set the appropriate bit. You now have a bit vector of size 1million bits, sorted, and to check for a particular number, you just check whether the corresponding bit is set.

### Question 2

[link](http://www.careercup.com/question?id=7997766)

> How would you sort 1 million phone numbers? 

### Solution

BitMap or radix sort, both are O(n) complexity.

Read more [here](http://www.vex.net/~trebla/compsci/sorting-phone-numbers.html). 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Postorder Successor in Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/08/06/Postorder-successor-Binary-Tree/"/>
    <updated>2014-08-06T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/06/Postorder-successor-Binary-Tree</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5173972006076416)

> Write an algorithm to find the ‘next’ post-order successor of a given node in a binary tree and binary search tree.

> 1. where each node has a link to its parent. 
> 1. without parent pointer 

> Implement 2 versions of the algorithm: 1.) binary tree 2.) BST

### Solution

In postorder, any node below current node shall be 'predecessor' of current node. Thus we only care about current node's parent. 

Suggested by a user: 

    1) parent pointer is given. 
    - go to the parent of the current node. 
    - if current node is the right child of its parent => print parent. 
    - else return leftmost node of the right sub-tree of parent. 

    2) parent pointer is not given. 
    - traverse the tree and find the parent of the current node 
    - do the same as method (1). 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Connect Nodes and Avoid Intersect]]></title>
    <link href="http://okckd.github.io/blog/2014/08/06/Connect-nodes-avoid-intersect/"/>
    <updated>2014-08-06T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/06/Connect-nodes-avoid-intersect</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5138832865361920)

> Draw a graph as a graph. Assume there is graphics library to draw lines and all. Just tell how will you order the vertices such that the edges don't intersect and they seem ordered. 

### Solution

There's no clear solution. Someone suggest the following: 

1. printing topological sort result (refer to post 'Topology Sort')
2. edges should not intersect, finding if a graph is planar

There's various [Planarity Testing Algorithms](http://en.wikipedia.org/wiki/Planarity_testing). 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Ambiguous File Matching]]></title>
    <link href="http://okckd.github.io/blog/2014/08/06/Ambiguous-File-Matching/"/>
    <updated>2014-08-06T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/06/Ambiguous-File-Matching</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5678301561487360)

> Given 10 files (text files) each of size of 900 Mb. 

> Given another file named "hello". match the contents of this file with other 10 file and return the file whose contents closely match with the contents of file "hello". 

### Solution

The solution given on the site is not adequate, but I have to choose one that make a little sense. 

> Score each file's contents on several parameters: 
> 
> 1. no. of words 
> 2. no. of letters 
> 3. no. of spaces 
> 4. count of each of the letters 
> 5. count of each words 

> Give weightage to each of the properties and arrive at a number (score). The closest of the scores is the answer.

I think maybe can use [Counting Bloom Filter](http://en.wikipedia.org/wiki/Bloom_filter#Counting_filters), although bloom filter does not record word sequences. 
]]></content>
  </entry>
  
</feed>
