<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-26T17:12:11+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Make a Java Method Thread-safe]]></title>
    <link href="http://okckd.github.io/blog/2015/01/26/make-java-method-thread-safe/"/>
    <updated>2015-01-26T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/26/make-java-method-thread-safe</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.programcreek.com/2014/02/how-to-make-a-method-thread-safe-in-java/)

> Consider the following class: 

    class MyCounter {
        private static int counter = 0;

        public static int getCount() {
            return counter++;
        }
    }

> Is the method thread-safe? How to make it thread-safe?

### Solution 

__No__, it's not. 

> The method is not thread-safe, because the __counter++ operation is not atomic__, which means it consists more than one atomic operations. In this case, one is accessing value and the other is increasing the value by one.

> When Thread 1 accesses the method at t1, Thread 2 may not be done with the method. So the value returned to Thread 1 is the value that has not been increased.

### Approach 1

Adding __synchronized__ to this method. This will synchronize the instance of the static class. 

    class MyCounter {
        private static int counter = 0;

        public static synchronized int getCount() {
            return counter++;
        }
    }

### Approach 2

We actually can make __count++__ atomic by using AtomicInteger from the package "java.util.concurrent.atomic". 

import java.util.concurrent.atomic.AtomicInteger;
 
    public class MyCounter {
        private static AtomicInteger counter = new AtomicInteger(0);

        public static int getCount() {
            return counter.getAndIncrement();
        }
    }

### Follow-up on thread stack

1. Each thread has its own stack (never share stack). 
1. All local variables defined in a method will be allocated memory in stack. 
1. When execution completed by a thread, stack frame will be removed.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Top N Values From Sum of 2 Arrays]]></title>
    <link href="http://okckd.github.io/blog/2015/01/20/top-n-from-sum-2-array/"/>
    <updated>2015-01-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/20/top-n-from-sum-2-array</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=3213705)

> 给定两个数组A，B，长度均为n，求A[0]+B[0],…,A[0]+B[n-1],…,A[n-1]+B[0],…,A[n-1]+B[n]总共n^2个数的最大的n个值。

### Solution

Use a Heap and then iteratively pop 1 and push 2 elements. Until n values has been filled. 

### Code

	public int[] topN(int[] arr1, int[] arr2, int n) {
		int[] ans = new int[n];
		int index = n - 1;

		PriorityQueue<Pair> heap = new PriorityQueue<Pair>(n,
				new SpecialComparator(arr1, arr2));
		Arrays.sort(arr1);
		Arrays.sort(arr2);

		Pair maxPair = new Pair(n - 1, n - 1);
		heap.add(maxPair);

		for (int i = 0; i < n; i++) {
			Pair next = heap.poll();
			ans[index--] = arr1[next.x] + arr2[next.y];
			if (next.y - 1 >= 0) {
				heap.add(new Pair(next.x, next.y - 1));
			}
			if (next.x - 1 >= 0) {
				heap.add(new Pair(next.x - 1, next.y));
			}
		}
		return ans;
	}

	class SpecialComparator implements Comparator<Pair> {

		int[] arr1, arr2;

		public SpecialComparator(int[] a1, int[] a2) {
			arr1 = a1;
			arr2 = a2;
		}

		@Override
		public int compare(Pair p1, Pair p2) {
			// note that larger value shall go up top of the heap, so -1 * ...
			return -1 * (arr1[p1.x] + arr2[p1.y] - arr1[p2.x] - arr2[p2.y]);
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Lexicographic Order From Dictionary]]></title>
    <link href="http://okckd.github.io/blog/2015/01/18/lexicographic-order-from-dict/"/>
    <updated>2015-01-18T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/18/lexicographic-order-from-dict</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=13394663)

> Given set of words that are lexicographically sorted, return lexicographic order. E.g:

    abc
    acd
    bcc
    bed
    bdc
    dab

> The order of letters for the given example would be

    a->b->c->e->d

### Solution

> Just form a graph(DAG) and do a topological sort. 

Start from the first pair in the dictionary. Compare two strings in this pair __till first mismatch__. 

Eg: __aad & aab__, in this case create an edge __d -> b__. 

More details is available [here](http://codereview.stackexchange.com/questions/48292/return-the-lexicographic-order). 

### Code

	public String lexicoOrder(String[] dict) {
		String ans = "";

		// for each pair, maintain 2 HashMap
		HashMap<Character, Integer> incount = new HashMap<Character, Integer>();
		HashMap<Character, List<Character>> connection = new HashMap<Character, List<Character>>();
		for (String str : dict) {
			for (char c : str.toCharArray()) {
				incount.put(c, 0);
				connection.put(c, new ArrayList<Character>());
			}
		}
		buildGraph(dict, incount, connection);

		// start topology sorting
		Queue<Character> temp = new LinkedList<Character>();
		for (char c : incount.keySet()) {
			if (incount.get(c) == 0) {
				temp.offer(c);
				incount.remove(c);
				// remove any node whose incount is 0
			}
		}
		while (!temp.isEmpty()) {
			char top = temp.poll();
			ans += top;
			// 'top' is next char in line. remove it and delete connections
			List<Character> inNodes = connection.get(top);
			for (char c : inNodes) {
				// remove incount for all nodes from inNodes
				incount.put(c, incount.get(c) - 1);
				if (incount.get(c) == 0) {
					incount.remove(c);
					temp.offer(c);
				}
			}
		}
		if (incount.size() == 0)
			return ans;
		else
			return "unable to find a valid char sequence.";
	}

	public void buildGraph(String[] dict, HashMap<Character, Integer> incount,
			HashMap<Character, List<Character>> connection) {
		// build the graph map
		// abc
		// acd
		// bcc
		// bed
		// bdc
		// dab
		for (int i = 0; i < dict.length - 1; i++) {
			// compare dict[i] and dict[i+1]
			String str1 = dict[i];
			String str2 = dict[i + 1];
			int p = 0;
			while (p < str1.length() && p < str2.length()) {
				if (str1.charAt(p) == str2.charAt(p)) {
					p++;
				} else {
					break;
				}
			}
			if (p == str1.length()) {
				// this is special case eg. "ab" & "abc"
				// this will not give up any information about lexico order
				continue;
			}
			char from = str1.charAt(p);
			char to = str2.charAt(p);
			// update incount
			incount.put(to, incount.get(to) + 1);
			// update connection
			connection.get(from).add(to);
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Crazy Distance Between Strings]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/crazy-distance-string/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/crazy-distance-string</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/15061908/google-interview-find-crazy-distance-between-strings)

> X and Y are strings formed by 0 or 1. Distance is define as: 

    D(X,Y) = Remove chars common at the start from both X & Y. 
    Then add the remaining lengths from both the strings.

> For e.g.

    D(1111, 1000) = Only First alphabet is common. So the remaining string is 111 & 000. Therefore the result length("111") & length("000") = 3 + 3 = 6

> For e.g.

    D(0101, 01100) = Only First two alphabets are common. So the remaining string is 01 & 100. Therefore the result length("01") & length("100") = 2 + 3 = 5

> Now given n input, say like

    1111
    1000
    101
    1100

> Find out the maximum crazy distance between 2 strings.

> __n is__ the number of input strings. __m is__ the max length of any input string. 

### Solution

This is the [source](http://stackoverflow.com/a/15062640). 

> Put the strings into a tree, where 0 means go left and 1 means go right. __O(m*n) time__. 

Example: 

                Root
                 1
              0      1
             0 1*   0  1
            0*     0*    1*

> where the * means that an element ends there. Constructing this tree clearly takes O(n m).

> Now we have to find __the diameter of the tree__ (the longest path between two nodes). 

How to find out longest path between 2 leaf nodes? Please refer to __[Google] Diameter of a Binary Tree__ for explanation.  

Total time complexity is __O(m*n) time__.

### Code

	public int crazyDist(String[] input) {
		TreeNode root = this.buildTree(input);
		return this.findMaxPath(root).path - 1;
	}

	private Result findMaxPath(TreeNode node) {
		if (node == null) {
			return new Result(Integer.MIN_VALUE, 0);
		}
		Result lr = this.findMaxPath(node.left);
		Result rr = this.findMaxPath(node.right);
		int path = Math.max(lr.path, rr.path);
		if (lr.depth != 0 && rr.depth != 0) {
			// this check is important, because if any of the child node is
			// NULL, this root will not be eligible for computing the path
			path = Math.max(path, lr.depth + rr.depth + 1);
			// Why? cuz diameter must go from one leaf, thru root, and reach
			// another leaf. This is different from "Maximum Path Sum" leetcode
		}
		return new Result(path, 1 + Math.max(lr.depth, rr.depth));
	}

	private TreeNode buildTree(String[] input) {
		TreeNode root = new TreeNode(123);
		// share a common root. this root is deducted from the final calculation
		for (String str : input) {
			// insert str under the root
			TreeNode p = root;
			for (char c : str.toCharArray()) {
				if (c == '0') {
					if (p.left == null) {
						p.left = new TreeNode(124);
						// if 0, go to left; otherwise go to right
						// thus value of TreeNodes does not really matter
					}
					p = p.left;
				} else {
					if (p.right == null) {
						p.right = new TreeNode(125);
					}
					p = p.right;
				}
			}
		}
		return root;
	}

	class Result {
		int path;
		int depth;

		public Result(int a, int b) {
			path = a;
			depth = b;
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Check if Repeating Subsequence Exists]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/check-if-repeating-subsequence-exist/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/check-if-repeating-subsequence-exist</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5931067269709824)

> Given a string, find if there is any sub-sequence that repeats itself. Do not reuse any char. 

> Eg: 

    1. abab <------yes, ab is repeated
    2. abba <---- No, a and b follow different order 
    3. acbdaghfb <-------- yes, a followed by b twice 
    4. abcdacb <----- yes, a followed by b twice 

> Note that no char should be reused. I.e. "aab" is a false. 

### Solution

This looks like a question without any clue. However, this actually is a modified version of __[LintCode] Longest Common Subsequence__. 

Look at that question: there's 2 input string, and they match char-by-char. For this question, we are simply __matching input string with input string itself__. And chars should be match __ONLY__ at different positions, that's the key. As pointed out by the [top comment](http://www.careercup.com/question?id=5931067269709824): 

> Now we can modify the longest_common_subsequence(a, a) to find the value of the longest repeated subsequence in a by excluding the cases when i == j

### Code

	public boolean checkRepeatSubseq(String input) {
		int len = input.length();
		int[][] dp = new int[len + 1][len + 1];
		// dp[i][j] denotes the length of subseq between 2 strings:
		// 1. first i chars of input
		// 2. first j chars of input
		for (int i = 1; i <= len; i++) {
			for (int j = i; j <= len; j++) {
				if (i != j && input.charAt(i - 1) == input.charAt(j - 1)) {
					int temp = Math.max(dp[i - 1][j], dp[i][j - 1]);
					dp[i][j] = Math.max(temp, dp[i - 1][j - 1] + 1);
				} else {
					dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
				}
			}
		}
		return dp[len][len] >= 2;
	}
]]></content>
  </entry>
  
</feed>
