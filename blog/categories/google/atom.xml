<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/google/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-03T13:39:13+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Google] Winner of Tic-tac-toe]]></title>
    <link href="http://okckd.github.io/blog/2014/08/02/Winner-tic-tac-toe/"/>
    <updated>2014-08-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/02/Winner-tic-tac-toe</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.glassdoor.com/Interview/How-would-you-determine-if-someone-has-won-a-game-of-tic-tac-toe-on-a-board-of-any-size-QTN_1104.htm)

> How would you determine if someone has won a game of tic-tac-toe on a board of any size? 

### Solution

First, confirm that when the number of pieces in a line equals to the dimension of the board, one person wins. Eg. for 10 * 10 board, 10 pieces need to be in 1 line. 

__[We can determine](http://www.glassdoor.com/Interview/How-would-you-determine-if-someone-has-won-a-game-of-tic-tac-toe-on-a-board-of-any-size-QTN_1104.htm) if someone has won during a game in real time, as in checking after every move. 

> Create an array of size 2n+2 at the beginning of the game and fill it with zeros. Each spot in the array will be a sum of X's or O's horizontally (the first n places in the array), vertically (the second n places in the array) and diagonally (the last 2 places). Then with every move, you add 1 to the 2 places (or 3 if on a diagnol) of the array if X, and subtract 1 if its an O. After adding you check and see if the value of the array is equal to n or -n, if it is, n mean X has won and -n means O has won.

### Code

__not written__
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Special Increasing Adjacent Sequence]]></title>
    <link href="http://okckd.github.io/blog/2014/08/02/Special-increasing-adjacent-sequence/"/>
    <updated>2014-08-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/02/Special-increasing-adjacent-sequence</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5147801809846272)

> Given a NxN matrix which contains all distinct 1 to n^2 numbers, write code to print sequence of increasing adjacent sequential numbers. 

    ex: 
    1 5 9 
    2 3 8 
    4 6 7 

> should print: 6 7 8 9

### Solution

> Make an array of booleans (or bits) of same size as the input, where arr[i-1] indicates whether i is adjacent to i+1. Then, iterate over the matrix, checking for each cell the four neighbors and populating the relevant entry in the boolean array. 

Last, look for the longest run of "true" values in the boolean array, which can be done with one pass. O(n) time. 

__Note that this algorithm is valid only if input integers are distinct__, which is true here. 

### Code

__not written__
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Question Collection]]></title>
    <link href="http://okckd.github.io/blog/2014/08/02/Question-collection/"/>
    <updated>2014-08-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/02/Question-collection</id>
    <content type="html"><![CDATA[### Question List

1. [Longest Common Prefix](/blog/2014/05/01/Longest-Common-Prefix/)

1. [Multiply Strings ](/blog/2014/05/14/Multiply-Strings/)

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Print String Comparison Order]]></title>
    <link href="http://okckd.github.io/blog/2014/08/02/Print-string-comparison-order/"/>
    <updated>2014-08-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/02/Print-string-comparison-order</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5680043955060736)

> Output top N positive integer in string comparison order. For example, let's say N=1000, then you need to output in string comparison order as below: 

> 1, 10, 100, 1000, 101, 102, ... 109, 11, 110, ... 998, 999. 

### Solution

Thought for a while, and realize it's stanard DFS. 

### Code

__written by me__

	public static void main(String args[]) {
		for (int i = 1; i < 10; i++) {
			dfs("" + i);
		}
	}

	public static void dfs(String path) {
		if (Integer.parseInt(path) > 1000) {
			return;
		}
		System.out.println(path);
		for (int i = 0; i < 10; i++) {
			dfs(path + i);
		}
	}
]]></content>
  </entry>
  
</feed>
