<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Twitter | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/twitter/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-09T19:58:55+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Twitter] Big Data - Real Time Top K]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/big-data-real-time-top-k/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/big-data-real-time-top-k</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/10189685/realtime-tracking-of-top-100-twitter-words-per-min-hour-day)

> Given a continuous twitter feed, design an algorithm to return the 100 most
frequent words used at this minute, this hour and this day. 

### Analysis

This is a frequent and useful problem for companies like Google and Twitter. 

The first solution below is an approximation method which select keywords that occur more than a certain threthold. 

The second solution is more accurate but RAM-intensive. 

### Lossy Count

__Solution 1 is a modified version of [Lossy Count](http://stackoverflow.com/a/8033083)__. The detailed steps are explained [here](http://stackoverflow.com/a/3260905): 

> Start with an empty map (red-black tree). The keys will be search terms, and the values will be a counter for the term. 
>
> 1. Look at each item in the stream.
>
> 1. If the term exists in the map, increment the associated counter.
>
> 1. Otherwise, if the map has fewer candidates than you're looking for, add it to the map with a count of one.
>
> 1. However, if the map is "full", decrement the counter in each entry. If any counter reaches zero during this process, remove it from the map.

[This slide show](http://www.cse.ust.hk/vldb2002/VLDB2002-proceedings/slides/S10P03slides.pdf) explains __Lossy Count__, which is to divide input data into chunks. Then count elements and decrease counter by 1 after each chunk. 

__Note that the result is NOT the top frequency items__. Instead, the final results are __order-dependent__, giving heavier weight to the counts processed last. It maybe helpful in some cases, cuz we want to check the latest trend. However, if we want more accurate top keywords for all data, we will __do a second pass over the log data__. 

Now let's discuss the threshold. Use "aaabcd" and map size = 2 as example. 'a' will be inserted into map with occurance = 3. Then 'b' is inserted, and removed. 'c' is inserted, and removed. 'd' is inserted. Since we always decrease 1 at each step, 'a' should only have occurance of 1 at the end. As explained [here](http://stackoverflow.com/a/3260905): 

> If we limit the map to 99 entries, we are guaranteed to find any term that occurs more than 1/(1 + 99) (1%) of the time. 

We change the size of the map to change the threshold. The occurance of in the final result does not matter. 

### Solution 2

The lossy count does not actually produce the hourly, daily and monthly result accurately. Solution 2 will discuss how we deal with retiring old data in an accurate way. 

Suggested by [this answer](http://stackoverflow.com/a/3260768), we keep a 30-day list for each keyword, that counts the daily occurance. This list is FIFO. When we remove and insert a new counter value, we update monthly total. 

Alaternatively, [this answer](http://stackoverflow.com/a/10190836) suggests keeping 1440 (24 * 60) HashMaps, each storing the information for one minute. __And another 2 HashMap for the rolling total for the past hour, and past day__. 

> You need an array of 1440 (24*60) word+count hash maps organized the way that you describe; these are your minute-by-minute counts. You need two additional hash maps - for the rolling total of the hour and the day.

> Define two operations on hash maps - add and subtract, with the semantic of merging counts of identical words, and removing words when their count drops to zero.

> Each minute you start a new hash map, and update counts from the feed. At the end of the minute, you place that hash map into the array for the current minute, add it to the rolling total for the hour and for the day, and then subtract the hash map of an hour ago from the hourly running total, and subtract the hash map of 24 hours ago from the daily running total.

This is a very good solution, which I would recommend as the standard solution to this "Real Time Top k" problem. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Twitter] Largest Cycle in Permutation]]></title>
    <link href="http://okckd.github.io/blog/2014/08/27/largest-cycle-in-permutation/"/>
    <updated>2014-08-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/27/largest-cycle-in-permutation</id>
    <content type="html"><![CDATA[### Question 

[link](http://get-that-job-at-google.blogspot.sg/2013/01/twitter-programming-test.html)

> Given a permutation which contains numbers in the range [1, N], return the length of the largest cycle in the permutation. 

> A [permutation cycle](http://mathworld.wolfram.com/PermutationCycle.html) is a subset of a permutation whose elements trade places with one another. 

> Sample Testcases:

> a) longestCycle([2 3 1]) returns 3, since only cycle is (1 2 3) whose length is 3

> b) longestCycle([5 4 3 2 1]) returns 2, since the permutation can be decomposed into (1 5), (2 4), (3) 

### Solution

This is just an idea. 

Now first of all, its important to understand __what is a cycle in permutation__. 

Keeping that in mind, I take (5,4,3,2,1) as an example. First, we fetch 5, and we swap number 5 with the 5th element of the array (which is 1). After this swap, value 1 is in the 1st position, so this cycle is done, the length is 2. 

We continue doing this until __all numbers of value v is in the (v)th position__, we should know the largest length of cycle during this process. 

I did not write code, and I found very little relevant resources. If you did, please leave a comment below. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Twitter] Count Visible Nodes in Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/08/27/Count-visible-nodes-binary-tree/"/>
    <updated>2014-08-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/27/Count-visible-nodes-binary-tree</id>
    <content type="html"><![CDATA[### Question 

[link](http://codesays.com/2014/solution-to-count-visible-nodes-in-binary-tree/)

>  In a binary tree, if in the path from root to the node A, there is no node with greater value than A’s, this node A is visible. We need to count the number of visible nodes in a binary tree. For example, in the following tree:

			5
		 /     \
	   3        10
	  / \      /
	20   21   1

> There are four (4) visible nodes: 5, 20, 21, and 10.

### Solution

This is an easy question. A solution is available [here](http://codesays.com/2014/solution-to-count-visible-nodes-in-binary-tree/). 

### Code

__written by me__

	public int countVisible(TreeNode root) {
		return helper(root, Integer.MIN_VALUE);
	}

	private int helper(TreeNode node, int ancesterMax) {
		if (node == null) {
			return 0;
		}
		int newMax = Math.max(ancesterMax, node.val);
		if (node.val > ancesterMax) {
			return 1 + helper(node.left, newMax) + helper(node.right, newMax);
		} else {
			return helper(node.left, newMax) + helper(node.right, newMax);
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Twitter] Arithmetic Expression Evaluation]]></title>
    <link href="http://okckd.github.io/blog/2014/08/17/Expression-evaluation/"/>
    <updated>2014-08-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/17/Expression-evaluation</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#26)

> 给定一个表达式字符串，其中只包含非负整数，加法，减法以及乘法符号，例如7+3*4*5+2+4-3-1。请写程序计算该表达式的值。

> 提示：可以尝试使用递归算法，程序将非常简洁易写，很适用于面试场合。

### Solution

__Trying to solve this problem iteratively is like suicide__. The code would be lengthy and buggy, and very hard to make it right. 

__The most important point about this question, is how to handle minus(-) sign__. We know that when we see * and /, we evaluate immediately, and when sees + and -, we postpone it. However this case: 

> 1 - 2 - 3

If we postpone the first minus sign, we would end up getting: 

> 1 - (-1)

So it's wrong (outputing 2 in this case). 

__The solution to this issue is, consider (a - b) as (a + (-b))__. That's why later in the code, you'll see a variable __preNum__ being modified. 

[ref](http://www.itint5.com/discuss/50/case%E9%87%8C%E9%9D%A2%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B8%A6%E8%B4%9F%E6%95%B4%E6%95%B0%E7%9A%84%EF%BC%8C%E5%B9%B6%E6%B1%82%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0)

### Code

__written by me__

	int p;

	public int evaluate(String expr) {
		p = 0;
		int firstNum = getNumber(expr);
		return helper(firstNum, expr);
	}

	private int helper(int preNum, String expr) {
		// now p points to a operator (or end of string)
		if (p == expr.length()) {
			return preNum;
		}
		char operator = expr.charAt(p);
		p++;
		int nextNum = getNumber(expr);
		switch (operator) {
		case '+':
			return preNum + helper(nextNum, expr);
		case '-':
			return preNum + helper(-1 * nextNum, expr);
		case '*':
			return helper(preNum * nextNum, expr);
		default:
			return helper(preNum / nextNum, expr);
		}
	}

	private int getNumber(String expr) {
		// now p points to a number
		int num = 0;
		while (p < expr.length() && expr.charAt(p) >= '0'
				&& expr.charAt(p) <= '9') {
			num = num * 10 + expr.charAt(p) - '0';
			p++;
		}
		return num;
	}
]]></content>
  </entry>
  
</feed>
