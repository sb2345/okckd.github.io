<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Twitter | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/twitter/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-11T15:48:26+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Twitter] Largest Cycle in Permutation]]></title>
    <link href="http://okckd.github.io/blog/2014/08/27/largest-cycle-in-permutation/"/>
    <updated>2014-08-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/27/largest-cycle-in-permutation</id>
    <content type="html"><![CDATA[### Question 

[link](http://get-that-job-at-google.blogspot.sg/2013/01/twitter-programming-test.html)

> Given a permutation which contains numbers in the range [1, N], return the length of the largest cycle in the permutation. 

> A [permutation cycle](http://mathworld.wolfram.com/PermutationCycle.html) is a subset of a permutation whose elements trade places with one another. 

> Sample Testcases:

> a) longestCycle([2 3 1]) returns 3, since only cycle is (1 2 3) whose length is 3

> b) longestCycle([5 4 3 2 1]) returns 2, since the permutation can be decomposed into (1 5), (2 4), (3) 

### Solution

This is just an idea. 

Now first of all, its important to understand __what is a cycle in permutation__. 

Keeping that in mind, I take (5,4,3,2,1) as an example. First, we fetch 5, and we swap number 5 with the 5th element of the array (which is 1). After this swap, value 1 is in the 1st position, so this cycle is done, the length is 2. 

We continue doing this until __all numbers of value v is in the (v)th position__, we should know the largest length of cycle during this process. 

I did not write code for this, and there's little resource online that's relevant. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Twitter] Count Visible Nodes in Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/08/27/Count-visible-nodes-binary-tree/"/>
    <updated>2014-08-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/27/Count-visible-nodes-binary-tree</id>
    <content type="html"><![CDATA[### Question 

[link](http://codesays.com/2014/solution-to-count-visible-nodes-in-binary-tree/)

>  In a binary tree, if in the path from root to the node A, there is no node with greater value than A’s, this node A is visible. We need to count the number of visible nodes in a binary tree. For example, in the following tree:

			5
		 /     \
	   3        10
	  / \      /
	20   21   1

> There are four (4) visible nodes: 5, 20, 21, and 10.

### Solution

This is an easy question. A solution is available [here](http://codesays.com/2014/solution-to-count-visible-nodes-in-binary-tree/). 

### Code

__written by me__

	public int countVisible(TreeNode root) {
		return helper(root, Integer.MIN_VALUE);
	}

	private int helper(TreeNode node, int ancesterMax) {
		if (node == null) {
			return 0;
		}
		int newMax = Math.max(ancesterMax, node.val);
		if (node.val > ancesterMax) {
			return 1 + helper(node.left, newMax) + helper(node.right, newMax);
		} else {
			return helper(node.left, newMax) + helper(node.right, newMax);
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Twitter] Arithmetic Expression Evaluation]]></title>
    <link href="http://okckd.github.io/blog/2014/08/17/Expression-evaluation/"/>
    <updated>2014-08-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/17/Expression-evaluation</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#26)

> 给定一个表达式字符串，其中只包含非负整数，加法，减法以及乘法符号，例如7+3*4*5+2+4-3-1。请写程序计算该表达式的值。

> 提示：可以尝试使用递归算法，程序将非常简洁易写，很适用于面试场合。

### Solution

__Trying to solve this problem iteratively is like suicide__. The code would be lengthy and buggy, and very hard to make it right. 

__The most important point about this question, is how to handle minus(-) sign__. We know that when we see * and /, we evaluate immediately, and when sees + and -, we postpone it. However this case: 

> 1 - 2 - 3

If we postpone the first minus sign, we would end up getting: 

> 1 - (-1)

So it's wrong (outputing 2 in this case). 

__The solution to this issue is, consider (a - b) as (a + (-b))__. That's why later in the code, you'll see a variable __preNum__ being modified. 

[ref](http://www.itint5.com/discuss/50/case%E9%87%8C%E9%9D%A2%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B8%A6%E8%B4%9F%E6%95%B4%E6%95%B0%E7%9A%84%EF%BC%8C%E5%B9%B6%E6%B1%82%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0)

### Code

__written by me__

	int p;

	public int evaluate(String expr) {
		p = 0;
		int firstNum = getNumber(expr);
		return helper(firstNum, expr);
	}

	private int helper(int preNum, String expr) {
		// now p points to a operator (or end of string)
		if (p == expr.length()) {
			return preNum;
		}
		char operator = expr.charAt(p);
		p++;
		int nextNum = getNumber(expr);
		switch (operator) {
		case '+':
			return preNum + helper(nextNum, expr);
		case '-':
			return preNum + helper(-1 * nextNum, expr);
		case '*':
			return helper(preNum * nextNum, expr);
		default:
			return helper(preNum / nextNum, expr);
		}
	}

	private int getNumber(String expr) {
		// now p points to a number
		int num = 0;
		while (p < expr.length() && expr.charAt(p) >= '0'
				&& expr.charAt(p) <= '9') {
			num = num * 10 + expr.charAt(p) - '0';
			p++;
		}
		return num;
	}
]]></content>
  </entry>
  
</feed>
