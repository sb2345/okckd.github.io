<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: String Search | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/string-search/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-26T17:12:11+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Number of Occurence of Given Sub-sequence]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/numer-of-occurrence-given-subsequence/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/numer-of-occurrence-given-subsequence</id>
    <content type="html"><![CDATA[### Question

[link](http://stackoverflow.com/questions/6877249/find-the-number-of-occurrences-of-a-subsequence-in-a-string)

> Given a digit '3141592653', find number of occurence of subsequence "123". Note that the sequence occurs twice:

    3141592653
     1    2  3
       1  2  3

> Output 2.

### Solution

Refer to __[LeetCode 115] Distinct Subsequences__. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Amazon] Longest Repeating Substring]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/longest-repeating-substring/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/longest-repeating-substring</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=9182781)

> Finding the longest repeated substring. 

> Example: "banana" ==> "ana"

### Solution

There are 2 solutions: Suffix array, and Suffix tree. 

__1. Suffix array__. Simple code, explained [here](http://www.careercup.com/question?id=9182781).

> Bentley's programming pearl book has the simplest implementation (less than 15 lines code) which sort all suffix, and then check common prefix length among adjacent suffix. The time complexity is O(n^2logn) for sorting the suffix (which has avg length of O(n)). 

A detailed step-by-step [explanation](http://nriverwang.blogspot.com/2013/04/longest-repeated-substring.html): 

    str = banana, its suffixes are:
    banana
    anana
    nana
    ana
    na
    a

after sort, the suffix array looks like:

    a
    ana
    anana
    banana
    na
    nana

Then for each two adjacent suffixes, check the length of the common prefix.

The answer is "ana" (if overlapping is allowed, otherwise, should be "an"). 

__2. Suffix tree__. Suggest by [this post](http://qr.ae/6W9yJ), Or [this](http://www.careercup.com/question?id=9182781):

> a good solution is to create a suffix tree for the given word and then find the deepest internal node in that tree (node with at least 2 descendants under it)...

For a nice PPT presentation about suffix tree, look [here](https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/suffixtrees.pdf). 

### Code

Suffix array approach. 

	public String longestRepeat(String input) {
		int len = input.length();
		String[] suffixArray = new String[len];
		for (int i = 0; i < len; i++) {
			suffixArray[i] = input.substring(i);
		}
		// now sort the suffix array
		Arrays.sort(suffixArray);
		String longest = "";
		// start to compare neighborhood suffixes, and check LCP
		for (int i = 0; i < suffixArray.length - 1; i++) {
			String lcp = longestCommonPrefix(suffixArray[i], suffixArray[i + 1]);
			if (lcp.length() > longest.length()) {
				longest = lcp;
			}
		}
		return longest;
	}

	private String longestCommonPrefix(String s1, String s2) {
		int p = 0;
		while (p < s1.length() && p < s2.length()) {
			if (s1.charAt(p) != s2.charAt(p)) {
				break;
			}
			p++;
		}
		return s1.substring(0, p);
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Crazy Distance Between Strings]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/crazy-distance-string/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/crazy-distance-string</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/15061908/google-interview-find-crazy-distance-between-strings)

> X and Y are strings formed by 0 or 1. Distance is define as: 

    D(X,Y) = Remove chars common at the start from both X & Y. 
    Then add the remaining lengths from both the strings.

> For e.g.

    D(1111, 1000) = Only First alphabet is common. So the remaining string is 111 & 000. Therefore the result length("111") & length("000") = 3 + 3 = 6

> For e.g.

    D(0101, 01100) = Only First two alphabets are common. So the remaining string is 01 & 100. Therefore the result length("01") & length("100") = 2 + 3 = 5

> Now given n input, say like

    1111
    1000
    101
    1100

> Find out the maximum crazy distance between 2 strings.

> __n is__ the number of input strings. __m is__ the max length of any input string. 

### Solution

This is the [source](http://stackoverflow.com/a/15062640). 

> Put the strings into a tree, where 0 means go left and 1 means go right. __O(m*n) time__. 

Example: 

                Root
                 1
              0      1
             0 1*   0  1
            0*     0*    1*

> where the * means that an element ends there. Constructing this tree clearly takes O(n m).

> Now we have to find __the diameter of the tree__ (the longest path between two nodes). 

How to find out longest path between 2 leaf nodes? Please refer to __[Google] Diameter of a Binary Tree__ for explanation.  

Total time complexity is __O(m*n) time__.

### Code

	public int crazyDist(String[] input) {
		TreeNode root = this.buildTree(input);
		return this.findMaxPath(root).path - 1;
	}

	private Result findMaxPath(TreeNode node) {
		if (node == null) {
			return new Result(Integer.MIN_VALUE, 0);
		}
		Result lr = this.findMaxPath(node.left);
		Result rr = this.findMaxPath(node.right);
		int path = Math.max(lr.path, rr.path);
		if (lr.depth != 0 && rr.depth != 0) {
			// this check is important, because if any of the child node is
			// NULL, this root will not be eligible for computing the path
			path = Math.max(path, lr.depth + rr.depth + 1);
			// Why? cuz diameter must go from one leaf, thru root, and reach
			// another leaf. This is different from "Maximum Path Sum" leetcode
		}
		return new Result(path, 1 + Math.max(lr.depth, rr.depth));
	}

	private TreeNode buildTree(String[] input) {
		TreeNode root = new TreeNode(123);
		// share a common root. this root is deducted from the final calculation
		for (String str : input) {
			// insert str under the root
			TreeNode p = root;
			for (char c : str.toCharArray()) {
				if (c == '0') {
					if (p.left == null) {
						p.left = new TreeNode(124);
						// if 0, go to left; otherwise go to right
						// thus value of TreeNodes does not really matter
					}
					p = p.left;
				} else {
					if (p.right == null) {
						p.right = new TreeNode(125);
					}
					p = p.right;
				}
			}
		}
		return root;
	}

	class Result {
		int path;
		int depth;

		public Result(int a, int b) {
			path = a;
			depth = b;
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LinkedIn] Find All Repeating Substring With Given Length]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/all-repeating-substring-given-length/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/all-repeating-substring-given-length</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=6495932900179968)

> Find all the repeating substring of specified length in a large string sequence.

> For e.g. 

    Input String: "ABCACBABC" 
    repeated sub-string length: 3 
    Output: ABC 

> eg. 

    Input String: "ABCABCA" 
    repeated sub-string length: 2 
    Output: AB, BC, CA

### Solution

Similar to __[Amazon] Longest Repeating Substring__, the best solution is to do __Suffix Tree__, or suffix array. We then need to print nodes on a certain level, who has more than 1 descendant. 

However, since the length of substring is given, we can also do simply iteration: insert all substring with given length into a HashSet, and check repetition. [ref](https://github.com/techpanja/interviewproblems/blob/master/src/strings/repeatingstringsofspecifiedlength/RepeatingStringOfSpecificLength.java)

### Code

Suffix tree solution: not written. 

Hashset code:

	public List<String> solve(String input, int k) {
		List<String> ans = new ArrayList<String>();
		HashSet<String> set = new HashSet<String>();
		for (int i = 0; i <= input.length() - k; i++) {
			String sub = input.substring(i, i + k);
			if (set.contains(sub)) {
				ans.add(sub);
			}
			set.add(sub);
		}
		return ans;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Most Frequent Word From a Book]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/most-frequent-word-from-book/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/most-frequent-word-from-book</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=5715664853532672)

> Let's say I gave you a long String and I wanted you to tell me the most common word in that String. How would you do that? 

> Follow-up: how about if I gave you the entire works of Alexandre Dumas, one of the most prolific authors in history. How would your solution work? How could you change it to solve this more specific problem? 

### Solution

There are 2 solutions. Either __HashMap__ or __Trie__. It's easy to think of first, but remember that Trie is designed to do this kind of job. 

> A trie will be more useful in the second situation where you will have millions of words. You can have a counter at every node to see its frequency

__Now the follow up__. For big data problems, we can always do __divide and conquer__ by hash value. 

Alternatively, the comment by [Prince](http://www.careercup.com/question?id=5715664853532672) mentioned how to solve with __Map Reduce__: 

> Instead of loading it as a string first I would stream data so that I avoid memory spike. Further our map size might increases as new words are added to it. Also, we can use map reduce type job were we create map<word, frequency> of each play in parallel and later join/collapse them this will reduce the time it will take to get result. 

> Common phrase should be no different then above algorithm. However we need to rebuild our index with <phase, frequency>
]]></content>
  </entry>
  
</feed>
