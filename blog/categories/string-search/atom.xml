<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: String Search | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/string-search/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-20T10:57:26+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Most Frequent Word From a Book]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/most-frequent-word-from-book/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/most-frequent-word-from-book</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=5715664853532672)

> Let's say I gave you a long String and I wanted you to tell me the most common word in that String. How would you do that? 

> Follow-up: how about if I gave you the entire works of Alexandre Dumas, one of the most prolific authors in history. How would your solution work? How could you change it to solve this more specific problem? 

### Solution

There are 2 solutions. Either __HashMap__ or __Trie__. It's easy to think of first, but remember that Trie is designed to do this kind of job. 

> A trie will be more useful in the second situation where you will have millions of words. You can have a counter at every node to see its frequency

__Now the follow up__. For big data problems, we can always do __divide and conquer__ by hash value. 

Alternatively, the comment by [Prince](http://www.careercup.com/question?id=5715664853532672) mentioned how to solve with __Map Reduce__: 

> Instead of loading it as a string first I would stream data so that I avoid memory spike. Further our map size might increases as new words are added to it. Also, we can use map reduce type job were we create map<word, frequency> of each play in parallel and later join/collapse them this will reduce the time it will take to get result. 

> Common phrase should be no different then above algorithm. However we need to rebuild our index with <phase, frequency>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Match Triplet With Reverse Order]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/match-triplet-with-reverse-order/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/match-triplet-with-reverse-order</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=11655778)

> Find the substring of length 3 which is present in the reverse order from the string. 

> Ex: if the string is abcdcba (cba is the reverse of abc) so we should return cba. 

### Solution

1. __HashMap (recommended)__. Hash all substrings of length 3. O(n). Look up all reverse substrings of length 3 in this hash set. O(n) time and O(n) space. 

1. __KMP Algo__. Take every substring of length 3. Reverse it and find it in the input using KMP. O(n^2) time and O(1) space. 

1. __Build suffix tree__ of height 3. Then in reverse order, check triplets. 

The 3 solutions above all work well. Pick the one you love. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 20.8 Full Text Search (Suffix Tree)]]></title>
    <link href="http://okckd.github.io/blog/2014/09/10/full-text-search/"/>
    <updated>2014-09-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/10/full-text-search</id>
    <content type="html"><![CDATA[### Question

> Given a string s and an array of smaller strings T, design a method to search s for each small string in T. 

### Solution

__This is a very classic question of string search__, favored by Google and Facebook. 

The solution is __suffix tree__ (to be distinguished from __trie__, or prefix tree, which searched word by its prefix). Suffix tree is good for search a proportion of a long string. For example, using "bibs" to build a suffix tree like this: 

<img class="middle" src="/assets/images/suffix-tree-example-bibs.png">

The building of suffix tree and searching is not a very lengthy code. It's posted below and it's not written by me. 

### Code

Main method:

	public static void main(String[] args) {
		String testString = "mississippi";
		String[] stringList = { "is", "sip", "hi", "sis" };
		SuffixTree tree = new SuffixTree(testString);
		for (String s : stringList) {
			ArrayList<Integer> list = tree.getIndexes(s);
			if (list != null) {
				System.out.println(s + ": " + list.toString());
			} else {
				System.out.println(s + ": does not exist.");
			}
		}
	}

SuffixTree.java

	public class SuffixTree {
		SuffixTreeNode root = new SuffixTreeNode();
		
		public SuffixTree(String s) {
			// create a suffix tree with input string s
			for (int i = 0; i < s.length(); i++) {
				String suffix = s.substring(i);
				root.insertString(suffix, i);
			}
		}
		
		public ArrayList<Integer> getIndexes(String s) {
			return root.getIndexes(s);
		}
	}

SuffixTreeNode.java

	public class SuffixTreeNode {

		char value;
		HashMap<Character, SuffixTreeNode> children;
		ArrayList<Integer> indexes = new ArrayList<Integer>();

		public SuffixTreeNode() {
			children = new HashMap<Character, SuffixTreeNode>();
		}

		public void insertString(String s, int index) {
			indexes.add(index);
			if (s != null && s.length() > 0) {
				value = s.charAt(0);
				SuffixTreeNode child = null;
				if (children.containsKey(value)) {
					child = children.get(value);
				} else {
					child = new SuffixTreeNode();
					children.put(value, child);
				}
				String remainder = s.substring(1);
				child.insertString(remainder, index);
			}
		}

		public ArrayList<Integer> getIndexes(String s) {
			if (s == null || s.length() == 0) {
				return indexes;
			} else {
				char first = s.charAt(0);
				if (children.containsKey(first)) {
					String remainder = s.substring(1);
					return children.get(first).getIndexes(remainder);
				}
			}
			return null;
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Boggle Solver (Search Words From Matrix)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/29/Boggle-solver/"/>
    <updated>2014-08-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/29/Boggle-solver</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/746082/how-to-find-list-of-possible-words-from-a-letter-matrix-boggle-solver)

> Boggle Game: 

    F X I E
    A M L O
    E W B X
    A S T U

> The goal of the game is to find as many words as you can that can be formed by chaining letters together. You are given a dictionary of words are reference. 

### Variation

__Another version of questions states in [here](http://www.glassdoor.com/Interview/I-was-asked-to-write-an-algorithm-to-solve-a-crossword-like-puzzle-I-forget-the-name-but-started-with-a-B-As-opposed-QTN_435641.htm)__

> ... Boggle Game. As opposed to simply vertical, horizontal, and diagonal placement of words, they were allowed to snake around the grid in any way. 

For this version of question, no 'visited' memory needs to be stored. In other words, it's a simpler version of above question. 

### Solution

__[The best solution](http://stackoverflow.com/a/4314056) is to use Trie__, then do DFS search. However it might not be as intuitive as it seems. 

The idea is from [this answer](http://stackoverflow.com/a/746102) (However this guy admits that his solution does not handle 'visited' nodes properly, means the same char might be visited again to produce a word). 

We need to first define a class called Item: 

    class Item {
        public final int x, y;
        public final String prefix;

        public Item(int row, int column, String prefix) {
            this.x = row;
            this.y = column;
            this.prefix = prefix;
        }
    }

So when we start doing DFS, we pass in an Item object which stores 2 information: 

1. The next position that we're going to visit.
1. The prefix string that we have validated so far (before visiting this position).

For example: 

    F X I E
    A M L O
    E W B X
    A S T U

We'll have Items objects like (0, 0, ""), (0, 1, "F"), (0, 2, "FA") ... We guarantee that the prefix must be a valid prefix by searching them in the Trie. 

How to tell whether a string is a prefix of word, or it's an actual word? We have a property in TrieNode called TrieNode.isWord() to help us. 

That's about it. I spend quite some time writing the code below, by refering to the Java solution by [zouzhile](http://stackoverflow.com/a/11698898). 

### Code

BoggleSolver.java

    public class BoggleSolver {

        private static BufferedReader in = null;
        private static final String INPUT_FILE = "dictionary.txt";

        public static void beginFileReader() {
            try {
                in = new BufferedReader(new FileReader(new File(BoggleSolver.class
                        .getResource(INPUT_FILE).toURI())));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (URISyntaxException e) {
                e.printStackTrace();
            }
        }

        private Trie buildTrie() {
            Trie trie = new Trie();
            beginFileReader();
            String line = null;
            try {
                while ((line = in.readLine()) != null) {
                    String[] words = line.split(" ");
                    for (String word : words) {
                        word = word.trim().toLowerCase();
                        trie.addWord(word);
                    }
                }
                if (in != null) {
                    in.close();
                }
            } catch (IOException e1) {
                e1.printStackTrace();
            }
            return trie;
        }

        public Set<String> findWords(char[][] map, Trie dict) {
            Set<String> ans = new TreeSet<String>();
            int m = map.length;
            int n = map[0].length;
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    boolean[][] visited = new boolean[m][n];
                    findWordsDfs(ans, dict, map, visited, new Item(i, j, ""));
                    // item have 3 parameters:
                    // location x,y and the prefix string before reaching (i.j)
                }
            }
            return ans;
        }

        public void findWordsDfs(Set<String> ans, Trie dict, char[][] map,
                boolean[][] visited, Item item) {
            // item: the location that we're going to test
            // item.prefix is the word prefix before reaching (x, y)

            int m = map.length;
            int n = map[0].length;
            int x = item.x;
            int y = item.y;

            // check whether cur.(x,y) is a valid position
            if (x < 0 || x >= m || y < 0 || y >= n) {
                return;
            } else if (visited[x][y]) {
                return;
            }
            String newWord = item.prefix + map[x][y];
            // check whether cur.prefix is a valid prefix
            TrieNode findWord = dict.match(newWord);
            if (findWord == null) {
                // up to this position (x, y), the word dont' exists
                return;
            }
            // now cur is in a valid position, with a valid prefix
            if (findWord.isWord()) {
                ans.add(newWord);
            }
            // visit this position, and continue in 4 different directions
            visited[x][y] = true;
            findWordsDfs(ans, dict, map, visited, new Item(x, y - 1, newWord));
            findWordsDfs(ans, dict, map, visited, new Item(x, y + 1, newWord));
            findWordsDfs(ans, dict, map, visited, new Item(x - 1, y, newWord));
            findWordsDfs(ans, dict, map, visited, new Item(x + 1, y, newWord));
            visited[x][y] = false;
        }

        public static void main(String[] args) {
            String[] rows = "eela,elps,weut,korn".split(",");
            char[][] input = new char[4][4];
            for (int i = 0; i < 4; i++) {
                input[i] = rows[i].toCharArray();
            }

            // prepare test data
            BoggleSolver solver = new BoggleSolver();
            Trie dictionary = solver.buildTrie();
            // start finding words
            Set<String> set = solver.findWords(input, dictionary);
            // present the result
            System.out.println(set.size() + " words are found, they are: ");
            for (String str : set) {
                System.out.println(str);
            }
        }

        class Item {
            public final int x, y;
            public final String prefix;

            public Item(int row, int column, String prefix) {
                this.x = row;
                this.y = column;
                this.prefix = prefix;
            }
        }
    }

Trie.java

    public class Trie {
        private TrieNode root;

        public Trie() {
            this.root = new TrieNode();
        }

        public void addWord(String word) {
            TrieNode node = this.root;
            for (char c : word.toCharArray()) {
                node = node.addChild(c);
                if (node == null)
                    return;
            }
            node.setWord(true);
        }

        public TrieNode match(String s) {
            TrieNode node = this.root;
            for (char c : s.toCharArray()) {
                node = node.get(c);
                if (node == null)
                    return null;
            }
            return node;
        }
    }

TrieNode.java

    public class TrieNode {
        private TrieNode[] children;
        private boolean isWord = false;

        public TrieNode() {
            this.children = new TrieNode[26];
        }

        public TrieNode addChild(char child) {
            if (child < 'a' || child > 'z')
                return null;

            int offset = child - 'a';
            if (this.children[offset] == null) {
                this.children[offset] = new TrieNode();
            }
            return this.children[offset];
        }

        public boolean isWord() {
            return isWord;
        }

        public void setWord(boolean isWord) {
            this.isWord = isWord;
        }

        public TrieNode get(char c) {
            int offset = c - 'a';
            return this.children[offset];
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Facebook] Large String Find Query (HashMap, Prefix Array)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/14/Large-string-find-substring/"/>
    <updated>2014-08-14T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/14/Large-string-find-substring</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#15)

> 有一个长度为n的字符串str，有非常多的关键字query（长度不超过10），需要判断每个关键字是否是str的子串。

> 注意：query是动态的输入进行查询的，预先并不知道所有的query。

### Solution

__Basic idea of the solution is to use Prefix Tree (Trie)__ and similar alternatives. 

__Solution 1__ is [an nice idea using HashMap](http://www.itint5.com/discuss/27/%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%A2%84%E5%A4%84%E7%90%86). 

> 我是把所有长度< =10的子串，哈希一下存放到10个哈希表中。

> 至于哈希函数的选取，随便选一个应该都不会超时。

__Solution 2__ is using so-called '__prefix array__'. The most important point of this idea is to only make a substring instance __for every 10 characters__. 

> 只用=10的子串。然后二分查找

> 用=10的字串排序即可，如包含更短的串会使得预处理变成O(10nlg(10n))。 查找的复杂度可能没什么变化，使用<=10会是O(lg(10n))，而只使用=10子串初始化的话，因为可能还要进行短query跟长子串间的前缀比较，复杂度会是O(10lgn)，稍微有点提高。

Which is to say, using substring length == 10, we comsume __less time for pre-processing__, and a little __more time when querying__. 

### Code

__read it from [here](http://www.itint5.com/discuss/203/%E8%B6%85%E7%AE%80%E5%8D%95%E7%9A%84prefix-array-java-code)__, note written by me

    private List<String> prefixList;
    
    // pre-process the large string
    public void initWithString(String str) {
        Set<String> strs = new HashSet<String>();

        for(int i = 0; i < str.length(); ++i) {
            strs.add(str.substring(i, Math.min(str.length(), i + 10)));
        }
        prefixList = new ArrayList<String>(strs);
        Collections.sort(prefixList);
    }
    
    // find the query substring
    public boolean existSubString(String query) {
        int low = 0;
        int high = prefixList.size() - 1;
        while(low <= high) {
            int mid = (low + high) / 2;
            int comp = prefixList.get(mid).compareTo(query);
            if(comp == 0)  {
                return true;
            }
            if(prefixList.get(mid).startsWith(query)) {
                return true;
            }
            if(comp > 0) //mid > query
            {
                high = mid - 1;
            }else{
                low = mid + 1;
            }
        }
        return false;
    }
]]></content>
  </entry>
  
</feed>
