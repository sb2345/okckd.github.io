<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: String Search | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/string-search/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-12-23T14:57:50+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 20.8 Full Text Search (Suffix Tree)]]></title>
    <link href="http://okckd.github.io/blog/2014/09/10/full-text-search/"/>
    <updated>2014-09-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/10/full-text-search</id>
    <content type="html"><![CDATA[### Question

> Given a string s and an array of smaller strings T, design a method to search s for each small string in T. 

### Solution

__This is a very classic question of string search__, favored by Google and Facebook. 

The solution is __suffix tree__ (to be distinguished from __trie__, or prefix tree, which searched word by its prefix). Suffix tree is good for search a proportion of a long string. For example, using "bibs" to build a suffix tree like this: 

<img class="middle" src="/assets/images/suffix-tree-example-bibs.png">

The building of suffix tree and searching is not a very lengthy code. It's posted below and it's not written by me. 

### Code

Main method:

	public static void main(String[] args) {
		String testString = "mississippi";
		String[] stringList = { "is", "sip", "hi", "sis" };
		SuffixTree tree = new SuffixTree(testString);
		for (String s : stringList) {
			ArrayList<Integer> list = tree.getIndexes(s);
			if (list != null) {
				System.out.println(s + ": " + list.toString());
			} else {
				System.out.println(s + ": does not exist.");
			}
		}
	}

SuffixTree.java

	public class SuffixTree {
		SuffixTreeNode root = new SuffixTreeNode();
		
		public SuffixTree(String s) {
			// create a suffix tree with input string s
			for (int i = 0; i < s.length(); i++) {
				String suffix = s.substring(i);
				root.insertString(suffix, i);
			}
		}
		
		public ArrayList<Integer> getIndexes(String s) {
			return root.getIndexes(s);
		}
	}

SuffixTreeNode.java

	public class SuffixTreeNode {

		char value;
		HashMap<Character, SuffixTreeNode> children;
		ArrayList<Integer> indexes = new ArrayList<Integer>();

		public SuffixTreeNode() {
			children = new HashMap<Character, SuffixTreeNode>();
		}

		public void insertString(String s, int index) {
			indexes.add(index);
			if (s != null && s.length() > 0) {
				value = s.charAt(0);
				SuffixTreeNode child = null;
				if (children.containsKey(value)) {
					child = children.get(value);
				} else {
					child = new SuffixTreeNode();
					children.put(value, child);
				}
				String remainder = s.substring(1);
				child.insertString(remainder, index);
			}
		}

		public ArrayList<Integer> getIndexes(String s) {
			if (s == null || s.length() == 0) {
				return indexes;
			} else {
				char first = s.charAt(0);
				if (children.containsKey(first)) {
					String remainder = s.substring(1);
					return children.get(first).getIndexes(remainder);
				}
			}
			return null;
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Google] Boggle Solver (Search Words From Matrix)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/29/Boggle-solver/"/>
    <updated>2014-08-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/29/Boggle-solver</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/746082/how-to-find-list-of-possible-words-from-a-letter-matrix-boggle-solver)

> Boggle Game: 

    F X I E
    A M L O
    E W B X
    A S T U

> The goal of the game is to find as many words as you can that can be formed by chaining letters together. You are given a dictionary of words are reference. 

### Variation

__Another version of questions states in [here](http://www.glassdoor.com/Interview/I-was-asked-to-write-an-algorithm-to-solve-a-crossword-like-puzzle-I-forget-the-name-but-started-with-a-B-As-opposed-QTN_435641.htm)__

> ... Boggle Game. As opposed to simply vertical, horizontal, and diagonal placement of words, they were allowed to snake around the grid in any way. 

For this version of question, no 'visited' memory needs to be stored. In other words, it's a simpler version of above question. 

### Solution

__[The best solution](http://stackoverflow.com/a/4314056) is to use Trie__, then do DFS search. However it might not be as intuitive as it seems. 

The idea is from [this answer](http://stackoverflow.com/a/746102) (However this guy admits that his solution does not handle 'visited' nodes properly, means the same char might be visited again to produce a word). 

We need to first define a class called Item: 

    class Item {
        public final int x, y;
        public final String prefix;

        public Item(int row, int column, String prefix) {
            this.x = row;
            this.y = column;
            this.prefix = prefix;
        }
    }

So when we start doing DFS, we pass in an Item object which stores 2 information: 

1. The next position that we're going to visit.
1. The prefix string that we have validated so far (before visiting this position).

For example: 

    F X I E
    A M L O
    E W B X
    A S T U

We'll have Items objects like (0, 0, ""), (0, 1, "F"), (0, 2, "FA") ... We guarantee that the prefix must be a valid prefix by searching them in the Trie. 

How to tell whether a string is a prefix of word, or it's an actual word? We have a property in TrieNode called TrieNode.isWord() to help us. 

That's about it. I spend quite some time writing the code below, by refering to the Java solution by [zouzhile](http://stackoverflow.com/a/11698898). 

### Code

BoggleSolver.java

    public class BoggleSolver {

        private static BufferedReader in = null;
        private static final String INPUT_FILE = "dictionary.txt";

        public static void beginFileReader() {
            try {
                in = new BufferedReader(new FileReader(new File(BoggleSolver.class
                        .getResource(INPUT_FILE).toURI())));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (URISyntaxException e) {
                e.printStackTrace();
            }
        }

        private Trie buildTrie() {
            Trie trie = new Trie();
            beginFileReader();
            String line = null;
            try {
                while ((line = in.readLine()) != null) {
                    String[] words = line.split(" ");
                    for (String word : words) {
                        word = word.trim().toLowerCase();
                        trie.addWord(word);
                    }
                }
                if (in != null) {
                    in.close();
                }
            } catch (IOException e1) {
                e1.printStackTrace();
            }
            return trie;
        }

        public Set<String> findWords(char[][] map, Trie dict) {
            Set<String> ans = new TreeSet<String>();
            int m = map.length;
            int n = map[0].length;
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    boolean[][] visited = new boolean[m][n];
                    findWordsDfs(ans, dict, map, visited, new Item(i, j, ""));
                    // item have 3 parameters:
                    // location x,y and the prefix string before reaching (i.j)
                }
            }
            return ans;
        }

        public void findWordsDfs(Set<String> ans, Trie dict, char[][] map,
                boolean[][] visited, Item item) {
            // item: the location that we're going to test
            // item.prefix is the word prefix before reaching (x, y)

            int m = map.length;
            int n = map[0].length;
            int x = item.x;
            int y = item.y;

            // check whether cur.(x,y) is a valid position
            if (x < 0 || x >= m || y < 0 || y >= n) {
                return;
            } else if (visited[x][y]) {
                return;
            }
            String newWord = item.prefix + map[x][y];
            // check whether cur.prefix is a valid prefix
            TrieNode findWord = dict.match(newWord);
            if (findWord == null) {
                // up to this position (x, y), the word dont' exists
                return;
            }
            // now cur is in a valid position, with a valid prefix
            if (findWord.isWord()) {
                ans.add(newWord);
            }
            // visit this position, and continue in 4 different directions
            visited[x][y] = true;
            findWordsDfs(ans, dict, map, visited, new Item(x, y - 1, newWord));
            findWordsDfs(ans, dict, map, visited, new Item(x, y + 1, newWord));
            findWordsDfs(ans, dict, map, visited, new Item(x - 1, y, newWord));
            findWordsDfs(ans, dict, map, visited, new Item(x + 1, y, newWord));
            visited[x][y] = false;
        }

        public static void main(String[] args) {
            String[] rows = "eela,elps,weut,korn".split(",");
            char[][] input = new char[4][4];
            for (int i = 0; i < 4; i++) {
                input[i] = rows[i].toCharArray();
            }

            // prepare test data
            BoggleSolver solver = new BoggleSolver();
            Trie dictionary = solver.buildTrie();
            // start finding words
            Set<String> set = solver.findWords(input, dictionary);
            // present the result
            System.out.println(set.size() + " words are found, they are: ");
            for (String str : set) {
                System.out.println(str);
            }
        }

        class Item {
            public final int x, y;
            public final String prefix;

            public Item(int row, int column, String prefix) {
                this.x = row;
                this.y = column;
                this.prefix = prefix;
            }
        }
    }

Trie.java

    public class Trie {
        private TrieNode root;

        public Trie() {
            this.root = new TrieNode();
        }

        public void addWord(String word) {
            TrieNode node = this.root;
            for (char c : word.toCharArray()) {
                node = node.addChild(c);
                if (node == null)
                    return;
            }
            node.setWord(true);
        }

        public TrieNode match(String s) {
            TrieNode node = this.root;
            for (char c : s.toCharArray()) {
                node = node.get(c);
                if (node == null)
                    return null;
            }
            return node;
        }
    }

TrieNode.java

    public class TrieNode {
        private TrieNode[] children;
        private boolean isWord = false;

        public TrieNode() {
            this.children = new TrieNode[26];
        }

        public TrieNode addChild(char child) {
            if (child < 'a' || child > 'z')
                return null;

            int offset = child - 'a';
            if (this.children[offset] == null) {
                this.children[offset] = new TrieNode();
            }
            return this.children[offset];
        }

        public boolean isWord() {
            return isWord;
        }

        public void setWord(boolean isWord) {
            this.isWord = isWord;
        }

        public TrieNode get(char c) {
            int offset = c - 'a';
            return this.children[offset];
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Facebook] Large String Find Substring (Trie, Prefix Tree)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/14/Large-string-find-substring/"/>
    <updated>2014-08-14T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/14/Large-string-find-substring</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#15)

> 有一个长度为n的字符串str，有非常多的关键字query（长度不超过10），需要判断每个关键字是否是str的子串。

> 注意：query是动态的输入进行查询的，预先并不知道所有的query。

### Solution

__Basic idea of the solution is to use Prefix Tree (Trie)__ and similar alternatives. 

__Solution 1__ is [an nice idea using HashMap](http://www.itint5.com/discuss/27/%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%A2%84%E5%A4%84%E7%90%86). 

> 我是把所有长度< =10的子串，哈希一下存放到10个哈希表中。

> 至于哈希函数的选取，随便选一个应该都不会超时。

__Solution 2__ is using so-called '__prefix array__'. The most important point of this idea is to only make a substring instance __for every 10 characters__. 

> 只用=10的子串。然后二分查找

> 用=10的字串排序即可，如包含更短的串会使得预处理变成O(10nlg(10n))。 查找的复杂度可能没什么变化，使用<=10会是O(lg(10n))，而只使用=10子串初始化的话，因为可能还要进行短query跟长子串间的前缀比较，复杂度会是O(10lgn)，稍微有点提高。

Which is to say, using substring length == 10, we comsume __less time for pre-processing__, and a little __more time when querying__. 

### Code

__read it from [here](http://www.itint5.com/discuss/203/%E8%B6%85%E7%AE%80%E5%8D%95%E7%9A%84prefix-array-java-code)__, note written by me

    private List<String> prefixList;
    
    // pre-process the large string
    public void initWithString(String str) {
        Set<String> strs = new HashSet<String>();

        for(int i = 0; i < str.length(); ++i) {
            strs.add(str.substring(i, Math.min(str.length(), i + 10)));
        }
        prefixList = new ArrayList<String>(strs);
        Collections.sort(prefixList);
    }
    
    // find the query substring
    public boolean existSubString(String query) {
        int low = 0;
        int high = prefixList.size() - 1;
        while(low <= high) {
            int mid = (low + high) / 2;
            int comp = prefixList.get(mid).compareTo(query);
            if(comp == 0)  {
                return true;
            }
            if(prefixList.get(mid).startsWith(query)) {
                return true;
            }
            if(comp > 0) //mid > query
            {
                high = mid - 1;
            }else{
                low = mid + 1;
            }
        }
        return false;
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Design] Big Data - Fuzzy Search Url]]></title>
    <link href="http://okckd.github.io/blog/2014/08/10/big-data-fuzzy-search-url/"/>
    <updated>2014-08-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/10/big-data-fuzzy-search-url</id>
    <content type="html"><![CDATA[### Question 

[link](http://blog.csdn.net/v_july_v/article/details/7382693)

> 给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？

### Bloom Filter

自从Burton Bloom在70年代提出[Bloom Filter](http://blog.csdn.net/v_july_v/article/details/6685894)之后，Bloom Filter就被广泛用于__拼写检查和数据库系统中__。

#### 基本原理及要点

An empty Bloom filter is __a bit array of m bits__, all set to 0. There must also be __k different hash functions__ defined, each of which maps or hashes some set element to one of the m array positions with a uniform random distribution. 

很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。

所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。 

### Error rate

    m: length of BF array (in bits)
    n: number of input elements
    k: number of hash functions

A Bloom filter [with 1% error](http://en.wikipedia.org/wiki/Bloom_filter#Space_and_time_advantages) and an optimal value of k, in contrast, requires only about 9.6 bits per element (means m = 9.6 x n). 

#### Usage

Bloom Filter可以用来实现数据字典，进行数据的判重，或者集合求交集.

### Solution

Of course we can always use __【分治+trie树/hash+小顶堆】__ standard solution, but for __Fuzzy search, BF is the best__. 

4G = 2^32 大概是40亿 x 8大概是340亿bit，n = 50亿，如果按出错率0.01算需要的大概是480亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 79] Word Search]]></title>
    <link href="http://okckd.github.io/blog/2014/05/21/Word-Search/"/>
    <updated>2014-05-21T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/05/21/Word-Search</id>
    <content type="html"><![CDATA[### Question 
[link](https://oj.leetcode.com/problems/word-search/)

<div class="question-content">
            <p></p><p>
Given a 2D board and a word, find if the word exists in the grid.
</p>
<p>
The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
</p>

<p>
For example,<br>
Given <b>board</b> = 
</p><pre>[
  ["ABCE"],
  ["SFCS"],
  ["ADEE"]
]
</pre>

<b>word</b> = <code>"ABCCED"</code>, -&gt; returns <code>true</code>,<br>
<b>word</b> = <code>"SEE"</code>, -&gt; returns <code>true</code>,<br>
<b>word</b> = <code>"ABCB"</code>, -&gt; returns <code>false</code>.<br>
<p></p><p></p>
</div>

### Stats
<table border="2">
	<tr>
		<td>Frequency</td>
		<td bgcolor="red">4</td>
	</tr>
	<tr>
		<td>Difficulty</td>
		<td bgcolor="yellow">3</td>
	</tr>
	<tr>
		<td>Adjusted Difficulty</td>
		<td bgcolor="yellow">3</td>
	</tr>
	<tr>
		<td>Time to use</td>
		<td bgcolor="red">50 minutes</td>
	</tr>
</table>

Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)

### Analysis

__This is a very classical DFS question__. Being able to write this solution fast and precise is very very essential. 

The solution is recursive DFS search. 

### Solution

__I posted my code first, on which I spend nearly an hour's time__. 

This idea is good, but I had made a serious mistakes. That is, when the find() method returns true, I shall terminate the program immediately. I got it wrong at first, and wasted a ton of time in debugging. 

__The second code posted below comes from [this blog](http://needjobasap.blogspot.sg/2014/01/word-search-leetcode.html)__. The code is slightly shorter because it checks __visited_array__ at the beginning of search() method, instead of for each directions. Other than that, it's basically same solution. 

### Code

__First, my code__


    public boolean exist(char[][] board, String word) {
        if (word.length() == 0) return true;
        int m = board.length, n = board[0].length;
        for (int i = 0; i < m; i ++) {
            for (int j = 0; j < n; j ++) {
                if (board[i][j] == word.charAt(0)) {
                    int[][] visited = new int[m][n];
                    visited[i][j] = 1;
                    boolean ans = find(i, j, board, visited, word.substring(1));
                    if (ans) return true;
                }
            }
        }
        return false;
    }

    private boolean find(int a, int b, char[][] board, int[][] visited, 
                        String word) {
        if (word.length() == 0) return true;
        int m = board.length, n = board[0].length;
        char target = word.charAt(0);
        if (a > 0 && visited[a-1][b] == 0 && board[a-1][b] == target) {
            visited[a - 1][b] = 1;
            boolean ans = find(a - 1, b, board, visited, word.substring(1));
            if (ans) return true;
            visited[a - 1][b] = 0;
        } // top
        if (a < m - 1 && visited[a+1][b] == 0 && board[a+1][b] == target) {
            visited[a + 1][b] = 1;
            boolean ans = find(a + 1, b, board, visited, word.substring(1));
            if (ans) return true;
            visited[a + 1][b] = 0;
        } // bottom
        if (b > 0 && visited[a][b-1] == 0 && board[a][b-1] == target) {
            visited[a][b - 1] = 1;
            boolean ans = find(a, b - 1, board, visited, word.substring(1));
            if (ans) return true;
            visited[a][b - 1] = 0;
        } // left
        if (b < n - 1 && visited[a][b+1] == 0 && board[a][b+1] == target) {
            visited[a][b + 1] = 1;
            boolean ans = find(a, b + 1, board, visited, word.substring(1));
            if (ans) return true;
            visited[a][b + 1] = 0;
        } // right
        return false;
    }


__Second, code from blog__


    public boolean exist(char[][] board, String word) {
        int height = board.length;
        int width = board[0].length;
        boolean[][] visited = new boolean[height][width];
        for (int i = 0; i < height; i++) 
            for (int j = 0; j < width; j++) 
                if (search(board, visited, i, j, word, 0)) 
                    return true;
        return false;
    }

    private boolean search(char[][] board, boolean[][] visited, 
            int row, int col, String word, int index) {
        if (word.charAt(index) != board[row][col]) 
            return false;
        if (index == word.length() - 1) 
            return true;

        int height = board.length;
        int width = board[0].length;
        visited[row][col] = true;
        //up
        if (row > 0 && !visited[row - 1][col] 
                && search(board, visited, row - 1, col, word, index + 1)) 
            return true;
        //down
        if (row < height - 1 && !visited[row + 1][col] 
                && search(board, visited, row + 1, col, word, index + 1)) 
            return true;
        //left
        if (col > 0 && !visited[row][col - 1] 
                && search(board, visited, row, col - 1, word, index + 1)) 
            return true;
        //right
        if (col < width - 1 && !visited[row][col + 1] 
                && search(board, visited, row, col + 1, word, index + 1)) 
            return true;
        // if we did not find the path we need set this position as unvisited
        visited[row][col] = false;

        return false;
    }
]]></content>
  </entry>
  
</feed>
