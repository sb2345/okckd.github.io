<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java Oop | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/java-oop/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-10T19:36:19+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Java OOP] Java Runtime Exception]]></title>
    <link href="http://okckd.github.io/blog/2014/12/23/Java-runtime-exception/"/>
    <updated>2014-12-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/12/23/Java-runtime-exception</id>
    <content type="html"><![CDATA[### Exceptions in Java

In Java, there are [3 categories of exceptions](http://www.tutorialspoint.com/java/java_exceptions.htm): 

1. checked exceptions
    1. Typically a user error
    1. eg. if a file cannot be found. 
    1. These exceptions cannot simply be ignored at the time of compilation.
    
1. runtime exceptions (also called un-checked exceptions)
    1. exception that could have been avoided by the programmer
    1. eg. NullPointerException
    1. ignored at the time of compilation

1. error
    1. These are not exceptions at all
    1. eg. stack overflow occurs
    1. also ignored at the time of compilation

#### 1. checked exception

[A checked exception](http://stackoverflow.com/a/2190175) __must be handled explicitly__ by the code (by either putting a try/catch block around the code, or adding a "throws" clause to the method).

The [class Exception](http://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) and any subclasses that are not also subclasses of RuntimeException are __checked exceptions__. Example: 

1. FileNotFoundException
1. HttpRetryException
1. SocketException
1. IOException

Note: __java.lang.RuntimeException__ is a subclass of __java.lang.Exception__. 

#### 2. un-checked exceptions (RuntimeException)

A un-checked exception __does not need__ to be explicitly handled. 

[RuntimeException](http://docs.oracle.com/javase/7/docs/api/java/lang/RuntimeException.html) and its subclasses are __unchecked exceptions__. 

[Generally](http://stackoverflow.com/a/2190177) RuntimeExceptions __can be prevented__ programmatically. E.g NullPointerException, ArrayIndexOutOfBoundException. If you check for null before calling any method, NullPointerException would never occur. Similarly ArrayIndexOutOfBoundException would never occur if you check the index first. RuntimeException are not checked by the compiler, so it is clean code.

The runtime exception classes __[are exempted](http://stackoverflow.com/a/2190659) from compile-time checking__, since the compiler cannot establish that run-time exceptions cannot occur. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Java OOP] Override/overload Java Main Method]]></title>
    <link href="http://okckd.github.io/blog/2014/12/22/overload-override-java-main-method/"/>
    <updated>2014-12-22T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/12/22/overload-override-java-main-method</id>
    <content type="html"><![CDATA[### Can we overload main method in Java?

Can. But only __public static void main(String[] args)__ will be used when [your class is launched by the JVM](http://stackoverflow.com/questions/3759315/can-we-overload-the-main-method-in-java). 

You can call other __main() method__ yourself from code. 

Eg.

    class Simple{  
      public static void main(int a){  
      System.out.println(a);  
      }  

      public static void main(String args[]){  
      System.out.println("main() method invoked");  
      main(10);  
      }  
    }

output: 

    main() method invoked
    10

### Can we override main method in Java?

No.

[MAIN is a class method](http://stackoverflow.com/questions/9083876/override-main-method). Hence, it does not makes sense to "override" it (or any static method). The concept of "overriding" is only for instance methods.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Java OOP] Common Root of Java Classes]]></title>
    <link href="http://okckd.github.io/blog/2014/12/22/common-root-java-class/"/>
    <updated>2014-12-22T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/12/22/common-root-java-class</id>
    <content type="html"><![CDATA[### Common Root Class

__java.lang.Object__, [link](http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)

All Java classes are derived from this [common root class](http://www.ntu.edu.sg/home/ehchua/programming/java/J3b_OOPInheritancePolymorphism.html), that defines common behaviors.

Common behaviors include multi-threading and garbage collector etc.

#### Some methods

[ref](http://docs.oracle.com/javase/tutorial/java/IandI/objectclass.html)

protected Object clone() throws CloneNotSupportedException
> Creates and returns a copy of this object.

public boolean equals(Object obj)
> Indicates whether some other object is "equal to" this one.

protected void finalize() throws Throwable
> Called by the garbage collector on an object when garbage collection determines that there are no more references to the object

public final Class getClass()
> Returns the runtime class of an object.

public int hashCode()
> Returns a hash code value for the object.

public String toString()
> Returns a string representation of the object.

### Sync-related methods

The notify, notifyAll, and wait methods of Object all play a part in synchronizing the activities of independently running threads in a program. 

    public final void notify()
    public final void notifyAll()
    public final void wait()
    public final void wait(long timeout)
    public final void wait(long timeout, int nanos)
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Java OOP] Interface Extend Another Interface]]></title>
    <link href="http://okckd.github.io/blog/2014/12/22/can-interface-extend-interface/"/>
    <updated>2014-12-22T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/12/22/can-interface-extend-interface</id>
    <content type="html"><![CDATA[### Can an interface extend another interface in Java?

Yes. Just remember that you should implement the methods in [both interfaces](http://www.programmerinterview.com/index.php/java-questions/java-can-an-interface-extend-another-interface/). 

Example in Java source code [link1](http://docs.oracle.com/javase/7/docs/api/java/util/List.html), [link2](http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html): 

    public interface List<E> extends Collection<E> {
    
    }

    public interface Collection<E> extends Iterable<E> {
    
    }

In conclusion, [ref](http://stackoverflow.com/questions/19546357/can-an-interface-extend-multiple-interfaces-in-java)

An interface can extend multiple interfaces.

A class can implement multiple interfaces.

However, a class can only extend a single class.

#### a special case

    interface A
    {
        void test();
    }

    interface B 
    {
        void test();
    }

    class C implements A, B
    {
        @Override
        public void test() {

        }
    }

Well, a single implementation works for the both methods. This implementation works no problem. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Java OOP] Discussion of Polymorphism]]></title>
    <link href="http://okckd.github.io/blog/2014/12/22/Discussion-of-Polymorphism/"/>
    <updated>2014-12-22T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/12/22/Discussion-of-Polymorphism</id>
    <content type="html"><![CDATA[### Polymorphism

Polymorphism is to [use common interface](http://javarevisited.blogspot.sg/2011/08/what-is-polymorphism-in-java-example.html) instead of concrete implementation while coding. 

When we program for interface our code is capable of handling any new requirement or enhancement arise in near future due to new implementation of our common interface. If we don't use common interface and rely on concrete implementation, we always need to change and duplicate most of our code to support new implementation. 

The most common use of polymorphism in OOP occurs when a parent class reference is used to refer to a child class object.

### Example 

Example of Bicycle class given on [official oracle website](http://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html): 

    public class Bicycle{
        public void printDescription(){
            System.out.println("\nBike is " + "in gear " + this.gear
                + " with a cadence of " + this.cadence +
                " and travelling at a speed of " + this.speed + ". ");
        }
    }

    public class MountainBike extends Bicycle {
        private String suspension;

        public void printDescription() {
            super.printDescription();
            System.out.println("The " + "MountainBike has a" +
                getSuspension() + " suspension.");
        }
    }

    public class RoadBike extends Bicycle{
        private int tireWidth;

        public void printDescription(){
            super.printDescription();
            System.out.println("The RoadBike" + " has " + getTireWidth() +
                " MM tires.");
        }
    }

    public class TestBikes {
        public static void main(String[] args){
            Bicycle bike01, bike02, bike03;

            bike01 = new Bicycle(20, 10, 1);
            bike02 = new MountainBike(20, 10, 5, "Dual");
            bike03 = new RoadBike(40, 20, 8, 23);

            bike01.printDescription();
            bike02.printDescription();
            bike03.printDescription();
        }
    }

The output: 

    Bike is in gear 1 with a cadence of 20 and travelling at a speed of 10. 

    Bike is in gear 5 with a cadence of 20 and travelling at a speed of 10. 
    The MountainBike has a Dual suspension.

    Bike is in gear 8 with a cadence of 40 and travelling at a speed of 20. 
    The RoadBike has 23 MM tires.

Referring to the same page, __JVM calls the appropriate method for the object that is referred to in each variable__. It does not call the method that is defined by the variable's type. 

### Another example

Cylinder is a subclass of Circle. We can say that Cylinder "is-a" Circle.

We can create an instance of Cylinder, and assign it to a Circle reference: 

> Circle c1 = new Cylinder();

You can invoke all the methods defined in the Circle class, but __you cannot invoke methods defined in the Cylinder class__. c1 is a reference to the Circle class, which does not know about the methods defined in the subclass Cylinder.

__The reference c1, however, retains its internal identity__. Since Cylinder overrides getArea() method, calling c1.getArea() will invokes the overridden version defined in subclass Cylinder, instead of in Circle. This is because c1 is holding a Cylinder object internally.

The code is below: 

    public class PolymorphismSubstitutabilityDemo {

        public static void main(String[] args) {
            Circle c1 = new Cylinder(1, "white", 10);
            System.out.println(c1.getClass());
            System.out.println(c1.getRadius());
            System.out.println(c1.getColor());
            System.out.println(c1.getArea());
        }
    }

    class Circle {
        int radius;
        String color;

        public Circle(int a, String b) {
            this.radius = a;
            this.color = b;
        }

        public int getRadius() {
            return radius;
        }

        public String getColor() {
            return color;
        }

        public double getArea() {
            return 3.14159 * Math.pow(radius, 2);
        }
    }

    class Cylinder extends Circle {
        int height;

        public Cylinder(int a, String b, int c) {
            super(a, b);
            this.height = c;
        }

        public int getHeight() {
            return height;
        }

        public double getArea() {
            return super.getArea() * height;
        }
    }

The output of execution: 

    class Cylinder
    1
    white
    31.4159

### Summary: 

[ref](http://www.ntu.edu.sg/home/ehchua/programming/java/J3b_OOPInheritancePolymorphism.html)

1. A subclass instance can be assigned (substituted) to a superclass' reference.

1. Once substituted, we can invoke methods defined in the superclass; we cannot invoke methods defined in the subclass.

1. However, if the subclass overrides inherited methods from the superclass, the subclass (overridden) versions will be invoked.
]]></content>
  </entry>
  
</feed>
