<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java oop | Shuatiblog.com]]></title>
  <link href="http://www.shuatiblog.com/blog/categories/java-oop/atom.xml" rel="self"/>
  <link href="http://www.shuatiblog.com/"/>
  <updated>2015-10-23T02:52:06-05:00</updated>
  <id>http://www.shuatiblog.com/</id>
  <author>
    <name><![CDATA[CodeMonkey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Java OOP] Template method pattern (abstract class) ]]></title>
    <link href="http://www.shuatiblog.com/blog/2015/10/23/Template-method-pattern/"/>
    <updated>2015-10-23T00:00:00-05:00</updated>
    <id>http://www.shuatiblog.com/blog/2015/10/23/Template-method-pattern</id>
    <content type="html"><![CDATA[# Overview

__[Template method pattern](https://en.wikipedia.org/wiki/Template_method_pattern) is a behavioral design pattern__ that defines the program skeleton of an algorithm in a method, called template method, which __defers some steps to subclasses__. 

It lets one __redefine__ certain steps of an algorithm without changing the algorithm's structure.

## Usage 

The template method is used in frameworks, where each implements the invariant parts of a domain's architecture.

## Example in Java

Refer to [code from WIKI](https://en.wikipedia.org/wiki/Template_method_pattern#Example_in_Java): 

    /**
     * An abstract class that is common to several games in
     * which players play against the others, but only one is
     * playing at a given time.
     */

    abstract class Game {
     /* Hook methods. Concrete implementation may differ in each subclass*/
        protected int playersCount;
        abstract void initializeGame();
        abstract void makePlay(int player);
        abstract boolean endOfGame();
        abstract void printWinner();

        /* A template method : */
        public final void playOneGame(int playersCount) {
            this.playersCount = playersCount;
            initializeGame();
            int j = 0;
            while (!endOfGame()) {
                makePlay(j);
                j = (j + 1) % playersCount;
            }
            printWinner();
        }
    }

    //Now we can extend this class in order 
    //to implement actual games:

    class Monopoly extends Game {

        /* Implementation of necessary concrete methods */
        void initializeGame() {
            // Initialize players
            // Initialize money
        }
        void makePlay(int player) {
            // Process one turn of player
        }
        boolean endOfGame() {
            // Return true if game is over 
            // according to Monopoly rules
        }
        void printWinner() {
            // Display who won
        }
        /* Specific declarations for the Monopoly game. */

        // ...
    }

    class Chess extends Game {

        /* Implementation of necessary concrete methods */
        void initializeGame() {
            // Initialize players
            // Put the pieces on the board
        }
        void makePlay(int player) {
            // Process a turn for the player
        }
        boolean endOfGame() {
            // Return true if in Checkmate or 
            // Stalemate has been reached
        }
        void printWinner() {
            // Display the winning player
        }
        /* Specific declarations for the chess game. */

        // ...
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Java OOP] Why avoid using Protected? ]]></title>
    <link href="http://www.shuatiblog.com/blog/2015/10/22/avoid-protected/"/>
    <updated>2015-10-22T00:00:00-05:00</updated>
    <id>http://www.shuatiblog.com/blog/2015/10/22/avoid-protected</id>
    <content type="html"><![CDATA[# Overview

Some experienced developers don’t use __protected__ since it cannot provide clean data hiding.

Why is that?

## background

Remembering in the post __[Java OOP] Java modifier and Access Level__, we got this: 

<img class="middle" src="/assets/images/java-access-level-table.png">

__Note__: Java default access setting is 'No modifier', which is also called '__Package Private__'.

__Another note__: by saying 'subclass', it means subclass declared in __another package__. 

And in __[Design] Composition Over Inheritance__, we know that basically __inheritance breaks encapsulation__. 

## the reason

1. inheritance is seldom the best tool and is not as flexible

1. the protected members form an interface towards subclasses (which is bad)

1. interfaces are tricky to get right and document properly

So, [it's better not to make](http://stackoverflow.com/questions/4913025/reasons-to-use-private-instead-of-protected-for-fields-and-methods) the class inheritable and instead make sure it's as flexible as possible (and no more) by using other means.

## A excellent answer

A excellent answer [from Sam Brand](http://programmers.stackexchange.com/questions/162643/why-is-clean-code-suggesting-avoiding-protected-variables):

1. They tend to lead to __[YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it)__ issues. Unless you have a descendant class that actually does stuff with the protected member, make it private.

    > __"You aren't gonna need it"__ (acronym: YAGNI) is a principle of extreme programming (XP) that states a programmer should not add functionality until deemed necessary.

1. They tend to lead to __[LSP](https://en.wikipedia.org/wiki/Liskov_substitution_principle)__ issues. Protected variables generally have some intrinsic invariance associated with them (or else they'd be public). Inheritors then need to maintain those properties, which people can screw up or willfully violate.

    > __Substitutability__ is a principle in OOP. It states that if S is a subtype of T, then objects of type T may be replaced with objects of type S without altering any of the desirable properties of that program
    
    > __Liskov substitution principle (LSP)__ is a particular definition of a subtyping relation introduced by Barbara Liskov in 1987

1. They tend to violate __[OCP](https://en.wikipedia.org/wiki/Open/closed_principle)__. If the base class makes too many assumptions about the protected member, or the inheritor is too flexible with the behavior of the class, it can lead to the base class' behavior being modified by that extension.

    > __open/closed principle__ states "software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification".
    
    > That is, such an entity can allow its behaviour to be extended without modifying its source code. 
    
    > This is especially valuable in a production environment, where changes to source code may necessitate code reviews, unit tests, and other such procedures to qualify it for use in a product

1. They tend to lead to inheritance for extension rather than composition. This tends to lead to tighter coupling, more violations of __[SRP](https://en.wikipedia.org/wiki/Single_responsibility_principle)__, more difficult testing, and a slew of other things that fall within the 'favor composition over inheritance' discussion.

> __single responsibility principle__ states that every class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility 

# An example

ClassA in packageA:

    package packA;

    import packB.ClassB;

    public class ClassA {

        protected int val = 10;

        protected String getColor() {
            return "colored";
        }

        public static void main(String[] args) {
            ClassA ins = new ClassA();
            System.out.println("val is " + ins.val);
            System.out.println("color is " + ins.getColor());
            System.out.println();

            ClassB ins2 = new ClassB();
            System.out.println("val is " + ins2.val);
            System.out.println("color is " + ins2.getColor());
        }
    }

ClassB in packageB:

    package packB;

    import packA.ClassA;

    public class ClassB extends ClassA {

        public ClassB() {
            val = 5;
        }

        public String getColor() {
            return super.getColor();
        }
    }

Execution result:

    val is 10
    color is colored

    val is 5
    color is colored

The code shows how __ClassB__ is able to access 1 __protected variable__ and 1 __protected method__. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Java OOP] Three Properties of Class/Object ]]></title>
    <link href="http://www.shuatiblog.com/blog/2015/08/24/three-property-object/"/>
    <updated>2015-08-24T00:00:00-05:00</updated>
    <id>http://www.shuatiblog.com/blog/2015/08/24/three-property-object</id>
    <content type="html"><![CDATA[# Objects

Much of the power and flexibility of modern software analysis and design derives from its use of objects.

# Classes

Classes create an abstract representation of the world, letting you discard unnecessary details.

# The 3 properties

## Class

1. properties

1. __behavior__

1. relationships to other objects

## Object

1. state

1. __behavior__

1. identity

Ref: http://javadevwannabe.blogspot.sg/2012/02/state-behavior-and-identity.html?m=1
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Java OOP] Overload, Override, Compile, Runtime (Static/Dynamic Polymph) ]]></title>
    <link href="http://www.shuatiblog.com/blog/2015/05/24/overload-override-compile-runtime/"/>
    <updated>2015-05-24T00:00:00-05:00</updated>
    <id>http://www.shuatiblog.com/blog/2015/05/24/overload-override-compile-runtime</id>
    <content type="html"><![CDATA[# The master statement

Overloading is Compile Time and Overriding is Runtime. 

# Examples

## Overloading 

    public static class test
    {
        static void Main(string[] args)
        {
            Foo();
            Foo("test");
        }

        public static void Foo()
        {
            Console.WriteLine("No message supplied");
        }

        public static void Foo(string message)
        {
            Console.WriteLine(message);
        }
    }

This is called __static (compile-time) polymorphism__ because the compiler is aware of exactly which method you are calling. 

## Overriding

When the PrintMessage() function is call, it determines which version of GetMessage() to use at runtime, __based on the type of IMessage__ that is passed in.

    public static class MessagePrinter
    {
        public static void PrintMessage(IMessage message)
        {
            Console.WriteLine(message.GetMessage());
        }
    }

    public interface IMessage
    {
        public string GetMessage();
    }

    public class XMLMessage : IMessage
    {
        public string GetMessage()
        {
            return "This is an XML Message";
        }
    }

    public class SOAPMessage : IMessage
    {
        public string GetMessage()
        {
            return "This is a SOAP Message";
        }
    }

This is __dynamic (runtime) polymorphism__. This is due to the fact that the compiler doesn't necessarily know what type of object is being passed in at compile-time.  

# Conclusion

## Overloading

Compile time Polymorphism = Static Polymorphism = Early binding

## Overriding

Runtime Polymorphism = Dynamic Polymorphism = Late binding = 

Reference: [How Overloading is Compile Time and Overriding is Runtime from stackoverflow.com](http://stackoverflow.com/questions/10915828/how-overloading-is-compile-time-and-overriding-is-runtime)
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Java OOP] Can abstract class have 0 abstract method? ]]></title>
    <link href="http://www.shuatiblog.com/blog/2015/02/09/abstract-class-without-abstract-method/"/>
    <updated>2015-02-09T00:00:00-06:00</updated>
    <id>http://www.shuatiblog.com/blog/2015/02/09/abstract-class-without-abstract-method</id>
    <content type="html"><![CDATA[# Definition

[An abstract class](https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html) is a class that is declared abstract —it may or may not include abstract methods. Abstract classes cannot be instantiated, but they can be subclassed.

## with NO abstract method?

> [In JDK 1.0 it was](http://stackoverflow.com/a/2283437) indeed necessary to have __at least one abstract method__ in an abstract class. 
>
> This restriction was removed in JDK 1.1 (1997? (I'm old)) and such classes added to the Java library, such as java.awt.event.KeyAdapter.

__So, no abstract method is fine__. Doing it prevents you from instantiation - you can only inherit. 

However, different opinions are:

> [is subjective](http://stackoverflow.com/a/2283450) and a matter of style. __Personally I would say yes__. If your intent is to prevent a class (with no abstract methods) from being instantiated, the best way to handle this is with a privateprotected constructor, not by marking it abstract.

## how about abstract variable?

There is no such thing in Java.

For more on abstract class, read __[Java OOP] Template method pattern__.
]]></content>
  </entry>
  
</feed>
