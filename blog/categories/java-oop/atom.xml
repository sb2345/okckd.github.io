<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java Oop | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/java-oop/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-20T10:57:26+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Java OOP] Java BlockingQueue (2)]]></title>
    <link href="http://okckd.github.io/blog/2015/01/12/java-blocking-queue-2/"/>
    <updated>2015-01-12T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/12/java-blocking-queue-2</id>
    <content type="html"><![CDATA[### Blocking Queue Implementation

<img class="middle" src="/assets/images/blocking-queue.png">

[source](http://tutorials.jenkov.com/java-concurrency/blocking-queues.html)

1. A blocking queue is a queue, so we init a queue with a pre-defined size. 

1. BlockingQueue Class comes with Java 5, in java.util.concurrent.BlockingQueue. This example is only used to help you understand what's happening behind the scene. 

1. Both __enqueue(Object o){}__ and __dequeue(){}__ are __synchronized__ method. 

1. Both methods do __while { wait(); }__ and then __notifyAll()__. 

### Code

    public class MyBlockingQueue {

        private List<Object> queue = new LinkedList<Object>();
        private int size = 10;

        public MyBlockingQueue(int size) {
            this.size = size;
        }

        public synchronized void enqueue(Object item) throws InterruptedException {
            while (this.queue.size() == this.size) {
                wait();
            }
            if (this.queue.size() == 0) {
                notifyAll();
            }
            this.queue.add(item);
        }

        public synchronized Object dequeue() throws InterruptedException {
            while (this.queue.size() == 0) {
                wait();
            }
            if (this.queue.size() == this.size) {
                notifyAll();
            }

            return this.queue.remove(0);
        }

        public boolean isEmpty() {
            return this.queue.isEmpty();
        }
    }

### Another example

This BlockingQueue example makes use MyBlockingQueue that we defined above.  

    public class Main {

        public static void main(String[] args) throws Exception {

            MyBlockingQueue queue = new MyBlockingQueue(1024);

            Producer producer = new Producer(queue);
            Consumer consumer = new Consumer(queue);

            new Thread(producer).start();
            new Thread(consumer).start();

            Thread.sleep(4000);
        }
    }

Producer

    public class Producer implements Runnable {

        protected MyBlockingQueue queue = null;

        public Producer(MyBlockingQueue queue) {
            this.queue = queue;
        }

        public void run() {
            System.out.println("Producer starting... ");
            try {
                for (int i = 1; i <= 5; i++) {
                    queue.enqueue("" + i);
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

Consumer

    public class Consumer implements Runnable {

        protected MyBlockingQueue queue = null;

        public Consumer(MyBlockingQueue queue) {
            this.queue = queue;
        }

        public void run() {
            try {
                for (int i = 1; i <= 5; i++) {
                    System.out.println(queue.dequeue());
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Consumer finished. ");
        }
    }

Output: 

    Producer starting... 
    1
    2
    3
    4
    5
    Consumer finished. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Java OOP] Java BlockingQueue (1)]]></title>
    <link href="http://okckd.github.io/blog/2015/01/12/java-blocking-queue-1/"/>
    <updated>2015-01-12T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/12/java-blocking-queue-1</id>
    <content type="html"><![CDATA[### Overview

__[A blocking queue](http://tutorials.jenkov.com/java-concurrency/blocking-queues.html)__ is a queue that blocks when you try to __dequeue from a empty queue__, or if you try to __enqueue items into a full queue__. 

<img class="middle" src="/assets/images/blocking-queue.png">

#### Details 

1. BlockingQueue __doesn’t accept null values__. Otherwise throw NullPointerException.

1. BlockingQueue implementations are __thread-safe__. All queuing methods are atomic in nature and use internal locks or other forms of concurrency control.

1. BlockingQueue interface is part of java collections framework and it’s primarily used for implementing __producer consumer problem__. 

Two important methods: 

1. put(E e): This method is used to insert elements to the queue, if the queue is full it waits for the space to be available.

1. E take(): This method retrieves and remove the element from the head of the queue, if queue is empty it waits for the element to be available.

#### Usage

[BlockingQueue is typically used](http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html) to have one thread produce objects, with another thread consumes (producer consumer problem). Refer to __[Design] Producer Consumer Problem__. 

### Example 1

This example shows __how changing the speed of consuming and producing__ results in different sequence of outputs, using a BlockingQueue. The size of the BlockingQueue is initialized at 5. 

    public class Main {

        // original post from:
        // http://www.journaldev.com/1034/java-blockingqueue-example-implementing-producer-consumer-problem

        private static final Setting testFullQueue = new Setting(3, 10, 0);
        private static final Setting testEmptyQueue = new Setting(10, 3, 100);

        public static void main(String[] args) {

            // Creating BlockingQueue of size 5
            BlockingQueue<Message> queue = new ArrayBlockingQueue<>(5);

            Setting variableSetting = testFullQueue;
            Producer producer = new Producer(queue, variableSetting.produceSpeed);
            Consumer consumer = new Consumer(queue, variableSetting.consumeSpeed,
                    variableSetting.consumerDelay);

            // starting producer to produce messages in queue
            new Thread(producer).start();

            // starting consumer to consume messages from queue
            new Thread(consumer).start();

            System.out.println("Producer and Consumer has been started");
        }

        static class Setting {
            int produceSpeed;
            int consumeSpeed;
            int consumerDelay;

            public Setting(int a, int b, int c) {
                this.produceSpeed = a;
                this.consumeSpeed = b;
                this.consumerDelay = c;
            }
        }
    }

Producer

    public class Producer implements Runnable {

        private BlockingQueue<Message> queue;
        int produceSpeed;

        public Producer(BlockingQueue<Message> q, int a) {
            this.queue = q;
            this.produceSpeed = a;
        }

        @Override
        public void run() {
            // produce messages
            for (int i = 0; i < 13; i++) {
                Message msg = new Message("" + i);
                try {
                    Thread.sleep(produceSpeed);
                    queue.put(msg);
                    System.out.println("Produced " + msg.getMsg() + "           ("
                            + queue.size() + " items)");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            // adding exit message
            Message msg = new Message("exit");
            try {
                queue.put(msg);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }

Consumer

    public class Consumer implements Runnable {

        private BlockingQueue<Message> queue;
        int consumeSpeed;
        int consumerDelay;

        public Consumer(BlockingQueue<Message> q, int a, int b) {
            this.queue = q;
            this.consumeSpeed = a;
            this.consumerDelay = b;
        }

        @Override
        public void run() {
            try {
                // initial delay: used to wait for producer to
                // fill up the queue
                Thread.sleep(consumerDelay);
                Message msg;
                // consuming messages until exit message is received
                while ((msg = queue.take()).getMsg() != "exit") {
				System.out.println("         " + msg.getMsg() + " Consumed"+ "  ("
						+ queue.size() + " items)");
                    Thread.sleep(consumeSpeed);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Consumer finished working. Exit. ");
        }
    }

Message Class

    public class Message {
        private String msg;

        public Message(String str){
            this.msg=str;
        }

        public String getMsg() {
            return msg;
        }
    }

Output (testFullQueue): 

    Producer and Consumer has been started
    Produced 0           (0 items)
             0 Consumed  (0 items)
    Produced 1           (1 items)
    Produced 2           (2 items)
             1 Consumed  (1 items)
    Produced 3           (2 items)
    Produced 4           (3 items)
    Produced 5           (4 items)
             2 Consumed  (3 items)
    Produced 6           (4 items)
    Produced 7           (5 items)
             3 Consumed  (5 items)
    Produced 8           (5 items)
             4 Consumed  (4 items)
    Produced 9           (5 items)
             5 Consumed  (4 items)
    Produced 10           (5 items)
             6 Consumed  (4 items)
    Produced 11           (5 items)
             7 Consumed  (4 items)
    Produced 12           (5 items)
             8 Consumed  (4 items)
             9 Consumed  (4 items)
             10 Consumed  (3 items)
             11 Consumed  (2 items)
             12 Consumed  (1 items)
    Consumer finished working. Exit. 

Output (testEmptyQueue):

    Producer and Consumer has been started
    Produced 0           (1 items)
    Produced 1           (2 items)
    Produced 2           (3 items)
    Produced 3           (4 items)
    Produced 4           (5 items)
    Produced 5           (5 items)
             0 Consumed  (5 items)
             1 Consumed  (4 items)
             2 Consumed  (3 items)
    Produced 6           (4 items)
             3 Consumed  (3 items)
             4 Consumed  (2 items)
    Produced 7           (3 items)
             5 Consumed  (2 items)
             6 Consumed  (1 items)
             7 Consumed  (0 items)
    Produced 8           (1 items)
             8 Consumed  (0 items)
    Produced 9           (1 items)
             9 Consumed  (0 items)
    Produced 10           (1 items)
             10 Consumed  (0 items)
    Produced 11           (0 items)
             11 Consumed  (0 items)
    Produced 12           (1 items)
             12 Consumed  (0 items)
    Consumer finished working. Exit. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Java OOP] BlockingQueue and Thread Pool]]></title>
    <link href="http://okckd.github.io/blog/2015/01/12/blocking-queue-and-thread-pool/"/>
    <updated>2015-01-12T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/12/blocking-queue-and-thread-pool</id>
    <content type="html"><![CDATA[### Blocking Queue VS. Thread Pool

These are 2 very different things, however it might be a little bit confusing for a layman. I have very little knowledge about Java multi-threading. But after writing some example of thread pool and blockingqueue, I am able to identify some significant differences between the 2 DS: 

1. Thread pools are often used in multi threaded servers. For example, we create 10 thread only for processing 1,000 tasks. However in BlockingQueue, there're typically only 2 thread: Producer and Consumer. Of course there can be more, but the basic pattern defines only 2 (types of) threads. 

1. Threads are added into thread pool, while in BlockingQueue, it stores tasks (runnables). 

It's not a common practise to compare the 2 DS. If you read this and have got some interesting thoughts, do not hesitate to let me know by commenting below! 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Java OOP] Java Runtime Exception]]></title>
    <link href="http://okckd.github.io/blog/2014/12/23/java-runtime-exception/"/>
    <updated>2014-12-23T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/12/23/java-runtime-exception</id>
    <content type="html"><![CDATA[### Exceptions in Java

In Java, there are [3 categories of exceptions](http://www.tutorialspoint.com/java/java_exceptions.htm): 

1. checked exceptions
    1. Typically a user error
    1. eg. if a file cannot be found. 
    1. These exceptions cannot simply be ignored at the time of compilation.
    
1. runtime exceptions (also called un-checked exceptions)
    1. exception that could have been avoided by the programmer
    1. eg. NullPointerException
    1. ignored at the time of compilation

1. error
    1. These are not exceptions at all
    1. eg. stack overflow occurs
    1. also ignored at the time of compilation

#### 1. checked exception

[A checked exception](http://stackoverflow.com/a/2190175) __must be handled explicitly__ by the code (by either putting a try/catch block around the code, or adding a "throws" clause to the method).

The [class Exception](http://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) and any subclasses that are not also subclasses of RuntimeException are __checked exceptions__. Example: 

1. FileNotFoundException
1. HttpRetryException
1. SocketException
1. IOException

Note: __java.lang.RuntimeException__ is a subclass of __java.lang.Exception__. 

#### 2. un-checked exceptions (RuntimeException)

A un-checked exception __does not need__ to be explicitly handled. 

[RuntimeException](http://docs.oracle.com/javase/7/docs/api/java/lang/RuntimeException.html) and its subclasses are __unchecked exceptions__. 

[Generally](http://stackoverflow.com/a/2190177) RuntimeExceptions __can be prevented__ programmatically. E.g NullPointerException, ArrayIndexOutOfBoundException. If you check for null before calling any method, NullPointerException would never occur. Similarly ArrayIndexOutOfBoundException would never occur if you check the index first. RuntimeException are not checked by the compiler, so it is clean code.

The runtime exception classes __[are exempted](http://stackoverflow.com/a/2190659) from compile-time checking__, since the compiler cannot establish that run-time exceptions cannot occur. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Java OOP] Override/overload Java Main Method]]></title>
    <link href="http://okckd.github.io/blog/2014/12/22/overload-override-java-main-method/"/>
    <updated>2014-12-22T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/12/22/overload-override-java-main-method</id>
    <content type="html"><![CDATA[### Can we overload main method in Java?

Can. But only __public static void main(String[] args)__ will be used when [your class is launched by the JVM](http://stackoverflow.com/questions/3759315/can-we-overload-the-main-method-in-java). 

You can call other __main() method__ yourself from code. 

Eg.

    class Simple{  
      public static void main(int a){  
      System.out.println(a);  
      }  

      public static void main(String args[]){  
      System.out.println("main() method invoked");  
      main(10);  
      }  
    }

output: 

    main() method invoked
    10

### Can we override main method in Java?

No.

[MAIN is a class method](http://stackoverflow.com/questions/9083876/override-main-method). Hence, it does not makes sense to "override" it (or any static method). The concept of "overriding" is only for instance methods.
]]></content>
  </entry>
  
</feed>
