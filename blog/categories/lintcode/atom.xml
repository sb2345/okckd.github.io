<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lintcode | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/lintcode/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-24T18:46:38+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[LintCode] Trailing Zeros of Factorial]]></title>
    <link href="http://okckd.github.io/blog/2014/07/02/Trailing-Zero-of-Factorial/"/>
    <updated>2014-07-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/02/Trailing-Zero-of-Factorial</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.lintcode.com/en/problem/trailing-zeros/">link</a></p>

<blockquote><p>Write an algorithm which computes the number of trailing zeros in n factorial.</p>

<p>Example: 11! = 39916800, so the out should be 2</p></blockquote>

<h3>Solution</h3>

<p>Note that a trailing zero is produced by 2 * 5.</p>

<p>This question basically is couting the number of factor 5 (because factor 2 is always sufficient).</p>

<h3>Code</h3>

<pre><code>public long trailingZeros(long n) {
    if (n &lt;= 0) {
        return 0;
    }
    long d = 5;
    long result = 0;
    while (d &lt; n) {
        result += n / d;
        d *= 5;
    }
    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LintCode] Partition Array]]></title>
    <link href="http://okckd.github.io/blog/2014/06/28/Partition-array/"/>
    <updated>2014-06-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/28/Partition-array</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.lintcode.com/en/problem/partition-array/">link</a></p>

<blockquote><p>Given an array &ldquo;nums&rdquo; of integers and an int &ldquo;k&rdquo;, Partition the array (i.e move the elements in &ldquo;nums&rdquo;) such that,</p>

<ol>
<li>All elements &lt; k are moved to the left</li>
<li>All elements >= k are moved to the right</li>
</ol>


<p>Return the partitioning Index, i.e the first index &ldquo;i&rdquo; nums[i] >= k.</p>

<p>Example: If nums=[3,2,2,1] and k=2, a valid answer is 1.</p></blockquote>

<h3>Analysis</h3>

<p>The solution is to keep swapping elements. It confuses me for a while, until I realize the swapping mechanism is actually not difficult.</p>

<p>There&rsquo;s another question on leetcode &ldquo;Sort Color&rdquo;, which is similar to this question (just partition twice).</p>

<h3>Code</h3>

<pre><code>public int partitionArray(ArrayList&lt;Integer&gt; nums, int k) {
    //write your code here
    ArrayList&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();
    if (nums == null || nums.size() == 0) {
        return ans;
    }
    int len = nums.size();
    int left = 0;
    int right = len - 1;
    while (left &lt; right) {
        while (left &lt; len &amp;&amp; nums.get(left) &lt; k) {
            left++;
        }
        while (right &gt;= 0 &amp;&amp; nums.get(right) &gt;= k) {
            right--;
        }
        if (left &gt; right) {
            break;
        } else {
            // swap 2 elements
            int temp = nums.get(left);
            nums.set(left, nums.get(right));
            nums.set(right, temp);
            left++;
            right--;
        }
    }
    // now return the correct value
    if (left == len) {
        return len;
    } else {
        return left;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LintCode] Minimum Subarray]]></title>
    <link href="http://okckd.github.io/blog/2014/06/28/Minimum-subarray/"/>
    <updated>2014-06-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/28/Minimum-subarray</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.lintcode.com/en/problem/minimum-subarray/">link</a></p>

<blockquote><p>Given an array of integers, find the subarray with smallest sum. Return the sum of the subarray.</p>

<p>Note The subarray should contain at least one integer.</p>

<p>Example For [1, -1, -2, 1], return -3</p></blockquote>

<h3>Analysis</h3>

<p>Same as &ldquo;Max subarray&rdquo;.</p>

<h3>Code</h3>

<pre><code>public int minSubArray(ArrayList&lt;Integer&gt; nums) {
    // write your code
    if (nums == null || nums.size() == 0) {
        return 0;
    }
    int min = nums.get(0);
    int pre = Math.min(0, nums.get(0));
    for (int i = 1; i &lt; nums.size(); i++) {
        pre += nums.get(i);
        min = Math.min(min, pre);
        pre = Math.min(0, pre);
    }
    return min;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LintCode] Maximum Subarray II]]></title>
    <link href="http://okckd.github.io/blog/2014/06/28/Maximum-subarray-II/"/>
    <updated>2014-06-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/28/Maximum-subarray-II</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.lintcode.com/en/problem/maximum-subarray-ii/">link</a></p>

<blockquote><p>Given an array of integers, find two non-overlapping subarrays which have the largest sum. The number in each subarray should be contiguous. Return the largest sum.</p>

<p>Note The subarray should contain at least one number</p>

<p>Example For given [1, 3, -1, 2, -1, 2], the two subarrays are [1, 3] and [2, -1, -2] or [1, 3, -1, 2] and [2], they both have the largest sum 7.</p></blockquote>

<h3>Analysis</h3>

<p><strong>This is not an easy question</strong>. I thought I have to use DP 2 times:</p>

<ol>
<li>first time, calculate max sum ending at each point.</li>
<li>second time, calculate max sum to the left/right of a point (inclusive but not necessarily ending at current point).</li>
</ol>


<p>After a second thought, <strong>the first DP path can be denoted with a single variable</strong>. So there comes the solution below.</p>

<h3>Code</h3>

<pre><code>public int maxTwoSubArrays(ArrayList&lt;Integer&gt; nums) {
    // write your code
    int len = nums.size();
    int[] dp1 = new int[len];
    int[] dp2 = new int[len];
    // dp1[k] denotes the max sum to the left of k (inclusive)
    // dp2[k] denotes the max sum to the right of k (inclusive)
    dp1[0] = nums.get(0);
    int sumSoFar = Math.max(0, nums.get(0));
    for (int i = 1; i &lt; len; i++) {
        sumSoFar += nums.get(i);
        dp1[i] = Math.max(dp1[i - 1], sumSoFar);
        sumSoFar = Math.max(0, sumSoFar);
    }
    dp2[len - 1] = nums.get(len - 1);
    sumSoFar = Math.max(0, nums.get(len - 1));
    for (int i = len - 2; i &gt;= 0; i--) {
        sumSoFar += nums.get(i);
        dp2[i] = Math.max(dp2[i + 1], sumSoFar);
        sumSoFar = Math.max(0, sumSoFar);
    }
    // now for every node, calculate leftMaxSum + rightMaxSum
    int maxSum = Integer.MIN_VALUE;
    for (int i = 0; i &lt; len - 1; i++) {
        maxSum = Math.max(maxSum, dp1[i] + dp2[i + 1]);
    }
    return maxSum;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LintCode] Majority Number III]]></title>
    <link href="http://okckd.github.io/blog/2014/06/28/Majority-Number-III/"/>
    <updated>2014-06-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/28/Majority-Number-III</id>
    <content type="html"><![CDATA[<h3>Question</h3>

<p><a href="http://www.lintcode.com/en/problem/majority-number-iii/">link</a></p>

<blockquote><p>Given an array of integers and a number k, the majority number is the number that occurs more than 1/k of the size of the array. Find it.</p>

<p>Note: There is only one majority number in the array</p>

<p>Example: For [3,1,2,3,2,3,3,4,4,4] and k = 3, return 3</p></blockquote>

<h3>Analysis</h3>

<p>Similar to &lsquo;Majority Number II&rsquo;, but a little more difficult.</p>

<p>_Instead of keeping 2 value for checking, now keep k values__. Since values are constantly checked for existance, using a HashMap looks like a great idea.</p>

<p><strong>Another idea suggest by <a href="http://www.geeksforgeeks.org/given-an-array-of-of-size-n-finds-all-the-elements-that-appear-more-than-nk-times/">G4G</a> is a mechanism similar to the famous Tetris Game</strong>. The size of the buffer is k. The buffer is full, we remove all items by counter of 1. When counter reach 0, remove that item. In this way, the elements left in the buffer are the majority numbers.</p>

<p>This method is also used in counting highly-frequent string keywrods. For example, another post <strong>[Design] Big Data &ndash; Real Time Top K</strong> discusses about it.</p>

<h3>Code</h3>

<p>I did not write code for this question. Shouldn&rsquo;t be difficult.</p>
]]></content>
  </entry>
  
</feed>
