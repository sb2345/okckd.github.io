<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Lintcode | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/lintcode/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-11T01:23:37+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[LintCode] Trailing Zeros of Factorial]]></title>
    <link href="http://okckd.github.io/blog/2014/07/02/Trailing-Zero-of-Factorial/"/>
    <updated>2014-07-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/02/Trailing-Zero-of-Factorial</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.lintcode.com/en/problem/trailing-zeros/)

> Write an algorithm which computes the number of trailing zeros in n factorial.

> Example: 11! = 39916800, so the out should be 2

### Solution

Note that a trailing zero is produced by 2 * 5.

This question basically is couting the number of factor 5 (because factor 2 is always sufficient). 

### Code

    public long trailingZeros(long n) {
        if (n <= 0) {
            return 0;
        }
        long d = 5;
        long result = 0;
        while (d < n) {
            result += n / d;
            d *= 5;
        }
        return result;
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LintCode] Partition Array]]></title>
    <link href="http://okckd.github.io/blog/2014/06/28/Partition-array/"/>
    <updated>2014-06-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/28/Partition-array</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.lintcode.com/en/problem/partition-array/)

> Given an array "nums" of integers and an int "k", Partition the array (i.e move the elements in "nums") such that,

> 1. All elements < k are moved to the left
> 2. All elements >= k are moved to the right

> Return the partitioning Index, i.e the first index "i" nums[i] >= k.

> Example: If nums=[3,2,2,1] and k=2, a valid answer is 1.

### Analysis 

The solution is to keep swapping elements. It confuses me for a while, until I realize the swapping mechanism is actually not difficult. 

There's another question on leetcode "Sort Color", which is similar to this question (just partition twice). 

### Code

    public int partitionArray(ArrayList<Integer> nums, int k) {
	    //write your code here
		ArrayList<Integer> ans = new ArrayList<Integer>();
		if (nums == null || nums.size() == 0) {
			return ans;
		}
		int len = nums.size();
		int left = 0;
		int right = len - 1;
		while (left < right) {
			while (left < len && nums.get(left) < k) {
				left++;
			}
			while (right >= 0 && nums.get(right) >= k) {
				right--;
			}
			if (left > right) {
				break;
			} else {
				// swap 2 elements
				int temp = nums.get(left);
				nums.set(left, nums.get(right));
				nums.set(right, temp);
				left++;
				right--;
			}
		}
		// now return the correct value
		if (left == len) {
			return len;
		} else {
			return left;
		}
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LintCode] Minimum Subarray]]></title>
    <link href="http://okckd.github.io/blog/2014/06/28/Minimum-subarray/"/>
    <updated>2014-06-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/28/Minimum-subarray</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.lintcode.com/en/problem/minimum-subarray/)

> Given an array of integers, find the subarray with smallest sum. Return the sum of the subarray.

> Note The subarray should contain at least one integer.

> Example For [1, -1, -2, 1], return -3

### Analysis 

Same as "Max subarray". 

### Code

    public int minSubArray(ArrayList<Integer> nums) {
        // write your code
        if (nums == null || nums.size() == 0) {
            return 0;
        }
        int min = nums.get(0);
        int pre = Math.min(0, nums.get(0));
        for (int i = 1; i < nums.size(); i++) {
            pre += nums.get(i);
            min = Math.min(min, pre);
            pre = Math.min(0, pre);
        }
        return min;
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LintCode] Maximum Subarray II]]></title>
    <link href="http://okckd.github.io/blog/2014/06/28/Maximum-subarray-II/"/>
    <updated>2014-06-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/28/Maximum-subarray-II</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.lintcode.com/en/problem/maximum-subarray-ii/)

> Given an array of integers, find two non-overlapping subarrays which have the largest sum. The number in each subarray should be contiguous. Return the largest sum.

> Note The subarray should contain at least one number

> Example For given [1, 3, -1, 2, -1, 2], the two subarrays are [1, 3] and [2, -1, -2] or [1, 3, -1, 2] and [2], they both have the largest sum 7.

### Analysis 

__This is not an easy question__. I thought I have to use DP 2 times: 

1. first time, calculate max sum ending at each point.
1. second time, calculate max sum to the left/right of a point (inclusive but not necessarily ending at current point). 

After a second thought, __the first DP path can be denoted with a single variable__. So there comes the solution below.

### Code

    public int maxTwoSubArrays(ArrayList<Integer> nums) {
        // write your code
        int len = nums.size();
        int[] dp1 = new int[len];
        int[] dp2 = new int[len];
        // dp1[k] denotes the max sum to the left of k (inclusive)
        // dp2[k] denotes the max sum to the right of k (inclusive)
        dp1[0] = nums.get(0);
        int sumSoFar = Math.max(0, nums.get(0));
        for (int i = 1; i < len; i++) {
            sumSoFar += nums.get(i);
            dp1[i] = Math.max(dp1[i - 1], sumSoFar);
            sumSoFar = Math.max(0, sumSoFar);
        }
        dp2[len - 1] = nums.get(len - 1);
        sumSoFar = Math.max(0, nums.get(len - 1));
        for (int i = len - 2; i >= 0; i--) {
            sumSoFar += nums.get(i);
            dp2[i] = Math.max(dp2[i + 1], sumSoFar);
            sumSoFar = Math.max(0, sumSoFar);
        }
        // now for every node, calculate leftMaxSum + rightMaxSum
        int maxSum = Integer.MIN_VALUE;
        for (int i = 0; i < len - 1; i++) {
            maxSum = Math.max(maxSum, dp1[i] + dp2[i + 1]);
        }
        return maxSum;
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LintCode] Majority Number III]]></title>
    <link href="http://okckd.github.io/blog/2014/06/28/Majority-Number-III/"/>
    <updated>2014-06-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/28/Majority-Number-III</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.lintcode.com/en/problem/majority-number-iii/)

> Given an array of integers and a number k, the majority number is the number that occurs more than 1/k of the size of the array. Find it.

> Note: There is only one majority number in the array

> Example: For [3,1,2,3,2,3,3,4,4,4] and k = 3, return 3

### Analysis 

Similar to 'Majority Number II', but a little more difficult. 

_Instead of keeping 2 value for checking, now keep k values__. Since values are constantly checked for existance, using a HashMap looks like a great idea. 

The idea is this. 

### Code

I did not write code for this question, because it looks too complex. 
]]></content>
  </entry>
  
</feed>
