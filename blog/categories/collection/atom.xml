<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Collection | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/collection/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-07-29T21:57:25+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Collection] F Question List]]></title>
    <link href="http://okckd.github.io/blog/2014/07/19/F-question-list/"/>
    <updated>2014-07-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/19/F-question-list</id>
    <content type="html"><![CDATA[### Leetcode Questions

1. Inverse Integer
1. Anagrams
1. Edit distance

### Difficult Questions

1. Binary hamming code
1. 有一个长度为n的字符串str，有非常多的关键字query（长度不超过10），需要判断每个关键字是否是str的子串。
1. Given a dictionary and some words. Check whether these words exists in the dictionary. 

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Collection] Leetcode Second]]></title>
    <link href="http://okckd.github.io/blog/2014/07/08/Leetcode-second/"/>
    <updated>2014-07-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/08/Leetcode-second</id>
    <content type="html"><![CDATA[### Question List

1. Integer to Roman
1. Reverse Linked List II
1. ZigZag Conversion
1. Surrounded Regions - constant space
1. Longest Palindromic Substring
1. Candy
1. Rotate List
1. Remove Duplicates from Sorted Array 
1. Validate Binary Search Tree - use intervals
1. Gray Code 
1. Combination Sum II
1. Add Binary
1. Merge Intervals
1. Scramble String
1. Remove Duplicates from Sorted Array II
1. Generate Parentheses 
1. Permutation Sequence 
1. Substring with Concatenation of All Words 
1. String to Integer (atoi)

### Difficult

1. Gas Station
1. Reverse Words in a String
1. Word Search
1. Container With Most Water
1. First Missing Positive - note there's 1 special case
1. Sort List
1. Anagrams
1. Merge k Sorted Lists - very difficult
1. Permutations II - use different DS for flagging elements
1. Palindrome Partitioning II
1. Word Ladder
1. Largest Rectangle in Histogram
1. Minimum Window Substring - difficult
1. Longest Valid Parentheses - difficult
1. Median of Two Sorted Arrays - difficult
1. Regular Expression Matching
1. Wildcard Matching

Special 1:

water, rain and histogram etc.

Sepecial 2: 

word and string-related
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Collection] a Study of BST Node Insertion / Deletion]]></title>
    <link href="http://okckd.github.io/blog/2014/06/11/Study-BST-insert-and-delete/"/>
    <updated>2014-06-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/11/Study-BST-insert-and-delete</id>
    <content type="html"><![CDATA[## First Word

For BST it's very important to do insert and delete (balancing not required). 

Insertion is easy, but deletion is very difficult. However, it's a good idea to at least know the principles. 

### Insert a node

#### Steps:

1. check whether new value = current node value. If not, proceed.

2. if new value is less, than:
    1. if current node has no left child, set left to new value, and return
    2. otherwise, go to left child and start over

3. if new value is greater, than:
    1. if current node has no right child, set right to new value
    2. otherwise, go to right child and start over

#### Note:

The BST may not be balanced after the insertion. 

#### Code

Code snippet from [this article](http://www.algolist.net/Data_structures/Binary_search_tree/Insertion)

	public boolean add(TreeNode node, int value) {
		if (value == node.val)
			return false;
		if (value < node.val) {
			if (node.left == null) {
				node.left = new TreeNode(value);
				return true;
			} else {
				return add(node.left, value);
			}
		} else if (value > node.val) {
			if (node.right == null) {
				node.right = new TreeNode(value);
				return true;
			} else {
				return add(node.right, value);
			}
		}
		return false;
	}

### Delete a node

#### Steps:

1. Find the node
2. Find the maximum node in the left subtree
3. Replace the node with the maximum node in the left subtree.

#### Special Cases:

1. The node doest have a left child.
2. The maximum node in the left subtree has a left child.
3. The node is the root of the tree

#### Code

The source code given by [ninechap](http://answer.ninechapter.com/solutions/delete-a-node-in-binary-search-tree/)

	private void myDeleteNode(TreeNode parent, TreeNode node) {
		if (node.left == null) {
			if (parent.right == node) {
				parent.right = node.right;
			} else {
				parent.left = node.right;
			}
		} else {
			TreeNode maxNodeParent = node;
			TreeNode maxNode = node.left;

			// find the maximum node in the left sub tree
			while (maxNode.right != null) {
				maxNodeParent = maxNode;
				maxNode = maxNode.right;
			}

			if (maxNodeParent.left == maxNode) {
				maxNodeParent.left = maxNode.left;
			} else {
				maxNodeParent.right = maxNode.left;
			}

			// move replacedNode to node
			maxNode.left = node.left;
			maxNode.right = node.right;
			if (parent.left == node) {
				parent.left = maxNode;
			} else {
				parent.right = maxNode;
			}
		}
	}

	private void findAndDelete(TreeNode parent, TreeNode node, int val) {
		if (node == null) {
			return;
		}
		if (node.val == val) {
			myDeleteNode(parent, node);
		} else if (node.val < val) {
			findAndDelete(node, node.right, val);
		} else {
			findAndDelete(node, node.left, val);
		}
	}

	public TreeNode deleteNode(TreeNode root, int val) {
		TreeNode dummyNode = new TreeNode(0);
		dummyNode.left = root;
		findAndDelete(dummyNode, root, val);
		return dummyNode.left;
	}

### A little bit on balancing

There are 2 ways to balance a tree. __Most common method is tree rotation__: 

<img class="left" src="/assets/images/rotate-tree.png">

An AVL Trees means a self-balancing search trees. If balance gets out of range −1...+1, the subtree is rotated to bring into balance. 

__Second way is to convert tree into a linkedlist__, then build the tree again (we have discussed this algorithm before, pick the middle element). 

This method is slow if we insert and re-balance on each step, but we can do bulk insert/delete forgetting about the re-balancing for a while. This will make the data structure faster! [more details](http://java.dzone.com/articles/algorithm-week-balancing)
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Collection] Classic Questions That Needs to Be Memorized]]></title>
    <link href="http://okckd.github.io/blog/2014/06/10/Classic-questions-to-memorize/"/>
    <updated>2014-06-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/10/Classic-questions-to-memorize</id>
    <content type="html"><![CDATA[## Question list

__Permutation__

1. __[Subsets](/blog/2014/05/22/Subsets/)__

1. __[Subsets II](/blog/2014/05/22/Subsets-II/)__

1. __[Permutations](/blog/2014/05/14/Permutations/)__

1. __[Permutations II](/blog/2014/05/14/Permutations-II/)__ - difficult

__Binary Tree__

1. __[Binary Tree Inorder Traversal](/blog/2014/05/24/Binary-Tree-Inorder-Traversal/)__

1. __[Binary Tree Postorder Traversal](/blog/2014/06/03/Binary-Tree-Postorder-Traversal/)__ - difficult

1. __[Lowest Common Ancestor Problem Version 2](/blog/2014/06/10/Lowest-Common-Ancestor-Tree/)__

1. __[Binary Tree Maximum Path Sum](/blog/2014/05/28/Binary-Tree-Maximum-Path-Sum/)__

1. __[Convert Sorted List to Binary Search Tree](/blog/2014/05/26/Convert-Sorted-List-to-Binary-Search-Tree/)__

__Other__

1. __[Minimum Window Substring ](/blog/2014/05/21/Minimum-Window-Substring/)__ - very difficult

1. __[Regular Expression Matching](/blog/2014/04/29/Regular-Expression-Matching/)__ - very difficult

1. __[Wildcard Matching](/blog/2014/05/15/Wildcard-Matching/)__ - difficult
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Collection] a Study of Implemention of DFS Using a Stack]]></title>
    <link href="http://okckd.github.io/blog/2014/06/03/Study-implement-DFS/"/>
    <updated>2014-06-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/03/Study-implement-DFS</id>
    <content type="html"><![CDATA[### First Word

This post talks about how to implement DFS without recursion. 

__We have studied 2 kinds of DFS in the post [A Study of DFS, BFS and space efficiency](/blog/2014/05/29/Study-DFS-BFS-space/)__. We will skip "true DFS" here, and only talk about "pseudo-DFS" implementation. 

Remember, __space usage of psudo-DFS is O(depth x branching factor)__. 

### Analysis

A DFS without recursion is basically the same as BFS - but use a stack instead of a queue as the data structure. 

More details are discussed in [this thread](http://stackoverflow.com/questions/21508765/how-to-implement-depth-first-search-for-graph-with-non-recursive-aprroach). 

### Implementation

The following code come from [this post](http://stackoverflow.com/a/21508819).

    DFS(source):
      s <- new stack
      visited <- {} //empty set
      s.push(source)
      while (s.empty() == false):
        current <- s.pop()
        if (current is in visited):
            continue
        visited.add(current)
        //do something with current
        for each node v such that (source,v) is an edge:
            s.push(v)
]]></content>
  </entry>
  
</feed>
