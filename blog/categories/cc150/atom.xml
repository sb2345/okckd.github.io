<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cc150 | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/cc150/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-18T21:23:24+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[CC150] 9.7 Circus Tower Routine]]></title>
    <link href="http://okckd.github.io/blog/2014/08/12/9-7-circus-man-ordering/"/>
    <updated>2014-08-12T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/12/9-7-circus-man-ordering</id>
    <content type="html"><![CDATA[### Question 

> A circus is designing a tower routine consisting of people standing atop one another’s shoulders. For practical and aesthetic reasons, each person must be both shorter and lighter than the person below him or her. Given the heights and weights of each person in the circus, write a method to compute the largest possible number of people in such a tower.

> EXAMPLE:

>Input: (ht, wt): (65, 100) (70, 150) (56, 90) (75, 190) (60, 95) (68, 110)
>
> Output: The longest tower is length 6 and includes from top to bottom: (56, 90) (60,95) (65,100) (68,110) (70,150) (75,190)

### Solution

The solution given in the book is unclear, but it's a very simple idea which is pointed out [here](http://www.careercup.com/question?id=9339758) and [here](http://hawstein.com/posts/9.7.html). 

1. sort the input persons by 'height'. O(nlogn) 
2. find the longest increasing 'weight' sequence in the sorted list. This can be done in O(nlogn) with DP.

### Code

__written by me__

	public int longestTower(List<Man> list) {
		Collections.sort(list, new ManComparator());
		// now find the longest increasing sequence of 'weight' property
		int len = list.size();
		int maxLen = 1;
		int[] dp = new int[len];
		for (int i = 1; i < len; i++) {
			dp[i] = 1;
			for (int j = 0; j < i; j++) {
				if (list.get(i).weight > list.get(j).weight) {
					dp[i] = Math.max(dp[i], dp[j] + 1);
				}
			}
			maxLen = Math.max(maxLen, dp[i]);
		}
		return maxLen;
	}

	class ManComparator implements Comparator<Man> {
		@Override
		public int compare(Man o1, Man o2) {
			return o1.height - o2.height;
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150] 9.4 Sort Large Files]]></title>
    <link href="http://okckd.github.io/blog/2014/08/07/9-4-sort-large-files/"/>
    <updated>2014-08-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/07/9-4-sort-large-files</id>
    <content type="html"><![CDATA[### Question 

> If you have a 2 GB file with one string per line, which sorting algorithm would you use to sort the file and why?

### Solution

__External Sorting__ and N-way merge. 

1. Divide the file into K chunks, where X * K = 2 GB Bring each chunk into memory and sort the lines as usual using any O(n log n) algorithm Save the lines back to the file
1. Now bring the next chunk into memory and sort
1. Once we’re done, merge them one by one

### Details

[Wiki example](http://en.wikipedia.org/wiki/External_sorting#External_merge_sort) of sorting 900 megabytes of data using only 100 megabytes of RAM:

1. __Read 100 MB of the data in main memory and sort__ by some conventional method, like quicksort.
1. Write the sorted data to disk.
1. Repeat steps 1 and 2 until all of the data is in sorted 100 MB chunks (there are 900MB / 100MB = 9 chunks), which now need to be merged into one single output file.
1. __Read the first 10 MB (= 100MB / (9 chunks + 1)) of each sorted chunk__ into input buffers in main memory and allocate the remaining 10 MB for an output buffer. (In practice, it might provide better performance to make the output buffer larger and the input buffers slightly smaller.)
1. __Perform a 9-way merge__ and store the result in the output buffer. Whenever the output buffer fills, write it to the final sorted file and empty it. Whenever any of the 9 input buffers empties, fill it with the next 10 MB of its associated 100 MB sorted chunk until no more data from the chunk is available. __This is the key step that makes external merge sort work externally__ -- because the merge algorithm only makes one pass sequentially through each of the chunks, each chunk does not have to be loaded completely; rather, sequential parts of the chunk can be loaded as needed.

### Similar Question

[link](http://www.glassdoor.com/Interview/Sort-a-million-32-bit-integers-using-only-2MB-of-RAM-QTN_120936.htm)

> [Google] Sort a million 32 bit integers using only 2MB of RAM.

1 million integers = 4MB which is > 2MB RAM.

Solution: external sort - divide and conquer

1. read half the list into 2MB ram and sort using quicksort (quicksort uses logn space - however 0.5m integers is less than 2MB (2000kb v 2048kb) so this should be okay).
2. write sorted data to disk
3. repeat for next chunk
4. merging results: we need an output buffer. lets say this is 1MB. then we read 512KB from each of your chunks into input buffers. we then perform a 2-way merge of the data. when an input buffer becomes empty we can pull in the remainder of the chunk.
5. when the output buffer is full we write this to disk.
6. when the process completes we are left with 2x 1MB files sorted in the correct order.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150] 17.1 How Web Works]]></title>
    <link href="http://okckd.github.io/blog/2014/08/03/17-1-How-Web-Works/"/>
    <updated>2014-08-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/03/17-1-How-Web-Works</id>
    <content type="html"><![CDATA[### Question 

17.1 Explain what happens, step by step, after you type a URL into a browser Use as much detail as possible. 

### Short Answer

1. Browser contacts the DNS server to find the IP address of URL
1. DNS returns back the IP address of the site
1. Browser opens TCP connection to the web server at port 80
1. The browser sends a GET request to the server, asking for the file 
1. Browser fetches the html code 
1. Browser renders the HTML in the display window
1. Browser terminates the connection when window is closed

[ref](http://superuser.com/q/157408)

### More Details

Phase 1: 

1. browser checks cache; if requested object is in cache and is fresh, skip to Phase 3 #4
1. browser asks OS for server's IP address
1. OS makes a DNS lookup and replies the IP address to the browser
1. browser opens a TCP connection to server (this step is much more complex with HTTPS)
1. browser sends the HTTP request through TCP connection

[ref](http://stackoverflow.com/a/2092602)

Phase 2: 

1. That computer receives the HTTP request from the TCP/IP connection and passes it to the web server program.
1. Web server reads the hostname and path and finds or generates the data that you've asked for.
1. Web server generates an HTTP response containing that data.
1. Web server sends that HTTP response back down the TCP/IP connection to your machine.

[ref](http://superuser.com/a/31474)

Phase 3: 

1. browser receives HTTP response and may close the TCP connection, or reuse it for another request
1. browser checks if the response is a redirect (3xx result status codes), authorization request (401), error (4xx and 5xx), etc.; these are handled differently from normal responses (2xx)
1. if cacheable, response is stored in cache
1. browser decodes response (e.g. if it's gzipped)
1. browser determines what to do with response (e.g. is it a HTML page, is it an image, is it a sound clip?)
1. browser renders response, or offers a download dialog for unrecognized types

### Miscellaneous:

Each domain name server is divided into zones A single server may only be responsible for knowing the host names and IP addresses for a small subset of a zone, but DNS servers can work together to map all domain names to their IP addresses That means if one domain name server is unable to find the IP addresses of a requested domain then it requests the information from other domain name servers

The firewall will control connections to & from your computer. For the most part it will just be controlling who can connect to your computer and on what ports. For web browsing your firewall generally won't be doing a whole lot.

Your router essentially guides your request through the network, helping the packets get from computer to computer and potentially doing some NAT (Network Address Tranlator) to translate IP addresses along the way (so your internat LAN request can be transitioned onto the wider internet and back).

### Even more

An even more detailed article can be found [here](http://www.garshol.priv.no/download/text/http-tut.html). 
]]></content>
  </entry>
  
</feed>
