<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cc150v4 | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/cc150v4/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-08T01:36:05+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 10.4 Implement Mathematical Operators]]></title>
    <link href="http://okckd.github.io/blog/2014/09/08/implement-math-operators/"/>
    <updated>2014-09-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/08/implement-math-operators</id>
    <content type="html"><![CDATA[### Question

> Write a method to implement *, - , / operations You should use only the + operator. 

### Solution

__First it's important to write a 'negate' operator__. This is used in all other operations. 

	public static int FnNegate(int a) {
		int neg = 0;
		int d = a < 0 ? 1 : -1;
		while (a != 0) {
			neg += d;
			a += d;
		}
		return neg;
	}

Although we can only use +, the author also used > and < comparison operators. 

This is a borning question, I did not write code myself. 

### Code

__not written by me__

	/* Flip a positive sign to negative, or a negative sign to pos */
	public static int FnNegate(int a) {
		int neg = 0;
		int d = a < 0 ? 1 : -1;
		while (a != 0) {
			neg += d;
			a += d;
		}
		return neg;
	}

	/* Subtract two numbers by negating b and adding them */
	public static int FnMinus(int a, int b) {
		return a + FnNegate(b);
	}

	/* Check if a and b are different signs */
	public static boolean DifferentSigns(int a, int b) {
		return ((a < 0 && b > 0) || (a > 0 && b < 0)) ? true : false;
	}

	/* Return absolute value */
	public static int abs(int a) {
		if (a < 0)
			return FnNegate(a);
		else
			return a;
	}

	/* Multiply a by b by adding a to itself b times */
	public static int FnTimes(int a, int b) {
		if (a < b)
			return FnTimes(b, a); // algo is faster if b < a
		int sum = 0;
		for (int iter = abs(b); iter > 0; --iter)
			sum += a;
		if (b < 0)
			sum = FnNegate(sum);
		return sum;
	}

	// returns 1, if a/b >= 0.5, and 0 otherwise
	public static int DefineAndRoundFraction(int a, int b) {
		if (FnTimes(abs(a), 2) >= abs(b))
			return 1;
		else
			return 0;
	}

	/*
	 * Divide a by b by literally counting how many times does b go into a. That
	 * is, count how many times you can subtract b from a until you hit 0.
	 */
	public static int FnDivide(int a, int b)
			throws java.lang.ArithmeticException {
		if (b == 0) {
			throw new java.lang.ArithmeticException("ERROR: Divide by zero.");
		}
		int quotient = 0;
		int divisor = FnNegate(abs(b));
		int divend; /* dividend */
		for (divend = abs(a); divend >= abs(divisor); divend += divisor) {
			++quotient;
		}
		if (DifferentSigns(a, b))
			quotient = FnNegate(quotient);
		return quotient;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] Chap9 Example - Sort Persons]]></title>
    <link href="http://okckd.github.io/blog/2014/09/07/sort-persons/"/>
    <updated>2014-09-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/07/sort-persons</id>
    <content type="html"><![CDATA[### Question

> You have a very large array of ‘Person’ objects. Sort the people in increasing order of age. 

### Solution

First we look at the nature of this question: 

1. large input array
1. sort based on age (__which is between 1 and 100__, this is important)

__This exactly matches the charasteristics of Bucket Sort__. Time complexity in average case is O(n + k) where k is the number of buckets. ]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 9.5 Search Array Containing Empty String]]></title>
    <link href="http://okckd.github.io/blog/2014/09/07/search-array-containing-empty-string/"/>
    <updated>2014-09-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/07/search-array-containing-empty-string</id>
    <content type="html"><![CDATA[### Question

> Given a sorted array of strings which is interspersed with empty strings, write a method to find the location of a given string. 

> Example: find “ball” in [“at”, “”, “”, “”, “ball”, “”, “”, “car”, “”, “”, “dad”, “”, “”] will return 4

> Example: find “ballcar” in [“at”, “”, “”, “”, “”, “ball”, “car”, “”, “”, “dad”, “”, “”] will return -1 

### Solution

The solution is binary search, but when reads empty, __advance to the next non-empty string__. 

But wait, __there can be a very big problem that causes looping forever__. Eg. 

> "a", "", "", "", "c" (5 items), look for "b"

> Now 'left' points to 1st string("a") and 'right' points to 4th(""). If we read read 'mid' value and advance to the next non-empty string, it'll be "c". 

> since "c" is large than "b", 'right' is set to the 4th index. It's a endless loop!

There're various ways to solve this. The book suggests 

My approach is to use 2 instances of 'mid': 

1. calculatedMid
1. comparisonMid

### Code

	public static int search(String[] input, String target) {
		if (target == null || target.length() == 0) {
			return -1;
		}
		int len = input.length;
		int left = 0, right = len - 1;
		while (left < right) {
			int calculatedMid = left + (right - left) / 2;
			int comparisonMid = calculatedMid;
			while (comparisonMid < len && input[comparisonMid].length() == 0) {
				comparisonMid++;
			}
			if (input[comparisonMid].equals(target)) {
				return comparisonMid;
			} else if (input[comparisonMid].compareTo(target) < 0) {
				left = comparisonMid + 1;
			} else {
				right = calculatedMid - 1;
			}
		}
		if (left < len && input[left].equals(target)) {
			return left;
		} else {
			return -1;
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 8.4 Generate Permutation Recursively]]></title>
    <link href="http://okckd.github.io/blog/2014/09/07/generate-permutation-recursively/"/>
    <updated>2014-09-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/07/generate-permutation-recursively</id>
    <content type="html"><![CDATA[### Question

> Write a method to compute all permutations of a string. 

> Do it recursively. 

### Solution

1. Get first char. 

1. Permute the reminder of the string.

1. Insert that char into all possible positions. 

The code is more concise that doing it iteratively, __and no visited array needed__! 

### Code

	public static ArrayList<String> getPerms(String s) {
		ArrayList<String> ans = new ArrayList<String>();
		if (s.length() == 1) {
			ans.add(s);
			return ans;
		}
		char single = s.charAt(0);
		ArrayList<String> partialPerms = getPerms(s.substring(1));
		for (String part : partialPerms) {
			for (int i = 0; i <= part.length(); i++) {
				ans.add(part.substring(0, i) + single + part.substring(i));
			}
		}
		return ans;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 5.7 Find Missing Number]]></title>
    <link href="http://okckd.github.io/blog/2014/09/07/find-missing-number/"/>
    <updated>2014-09-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/07/find-missing-number</id>
    <content type="html"><![CDATA[### Question

> An array A[1...n] contains all the integers from 0 to n except for one number which is missing. In this problem, we cannot access an entire integer in A with a single operation.

> The elements of A are represented in binary, and the only operation we can use to access them is “fetch the jth bit of A[i]”, which takes constant time. Write code to find the missing integer. Can you do it in O(n) time?

### Solution

__This is a difficult bit operation question__. 

The main thing to understand is, for a particular bit: 

> if the bit value of the removed number is 0, then count(0) <= count(1)

> if the bit value of the removed number is 1, then count(0) > count(1)

By using this principle, we can easily find the missing value for each bit. 

__However, we must know when to stop checking__. For example: 

> input: 000, 001, 011

We know that the last bit is 0, second last is 1. We shall stop here and return the result "010". If we did not stop, the result value would be "110", which is wrong. How this is handled is by __passing only half of the input list each time__, and we also add one condition at the beginning:

	if (list.size() == 0)
		return 0;

By doing this, we always limit the input list to a smaller range, until we finish finding all bits. 

### Code

__hard to write__

	public static int findMissing(List<BitInteger> list) {
		return helper(list, BitInteger.INTEGER_SIZE - 1);
	}

	private static int helper(List<BitInteger> list, int col) {
		if (list.size() == 0)
			return 0;
		List<BitInteger> zeroList = new ArrayList<BitInteger>();
		List<BitInteger> oneList = new ArrayList<BitInteger>();
		for (BitInteger bit : list) {
			if (bit.fetch(col) == 0) {
				zeroList.add(bit);
			} else {
				oneList.add(bit);
			}
		}
		if (zeroList.size() <= oneList.size()) {
			// this means the missing value contains a 0
			return helper(zeroList, col - 1) << 1;
		} else {
			// the missing value contains 1
			return helper(oneList, col - 1) << 1 | 1;
		}
	}
]]></content>
  </entry>
  
</feed>
