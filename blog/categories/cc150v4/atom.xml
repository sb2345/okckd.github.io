<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cc150v4 | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/cc150v4/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-07T23:36:23+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[CC150v4] Chap9 Example - Sort Persons]]></title>
    <link href="http://okckd.github.io/blog/2014/09/07/sort-persons/"/>
    <updated>2014-09-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/07/sort-persons</id>
    <content type="html"><![CDATA[### Question

> You have a very large array of ‘Person’ objects. Sort the people in increasing order of age. 

### Solution

First we look at the nature of this question: 

1. large input array
1. sort based on age (__which is between 1 and 100__, this is important)

__This exactly matches the charasteristics of Bucket Sort__. Time complexity in average case is O(n + k) where k is the number of buckets. ]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 9.5 Search Array Containing Empty String]]></title>
    <link href="http://okckd.github.io/blog/2014/09/07/search-array-containing-empty-string/"/>
    <updated>2014-09-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/07/search-array-containing-empty-string</id>
    <content type="html"><![CDATA[### Question

> Given a sorted array of strings which is interspersed with empty strings, write a method to find the location of a given string. 

> Example: find “ball” in [“at”, “”, “”, “”, “ball”, “”, “”, “car”, “”, “”, “dad”, “”, “”] will return 4

> Example: find “ballcar” in [“at”, “”, “”, “”, “”, “ball”, “car”, “”, “”, “dad”, “”, “”] will return -1 

### Solution



### Code


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 8.4 Generate Permutation Recursively]]></title>
    <link href="http://okckd.github.io/blog/2014/09/07/generate-permutation-recursively/"/>
    <updated>2014-09-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/07/generate-permutation-recursively</id>
    <content type="html"><![CDATA[### Question

> Write a method to compute all permutations of a string. 

> Do it recursively. 

### Solution

1. Get first char. 

1. Permute the reminder of the string.

1. Insert that char into all possible positions. 

The code is more concise that doing it iteratively, __and no visited array needed__! 

### Code

	public static ArrayList<String> getPerms(String s) {
		ArrayList<String> ans = new ArrayList<String>();
		if (s.length() == 1) {
			ans.add(s);
			return ans;
		}
		char single = s.charAt(0);
		ArrayList<String> partialPerms = getPerms(s.substring(1));
		for (String part : partialPerms) {
			for (int i = 0; i <= part.length(); i++) {
				ans.add(part.substring(0, i) + single + part.substring(i));
			}
		}
		return ans;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 5.7 Find Missing Number]]></title>
    <link href="http://okckd.github.io/blog/2014/09/07/find-missing-number/"/>
    <updated>2014-09-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/07/find-missing-number</id>
    <content type="html"><![CDATA[### Question

> An array A[1...n] contains all the integers from 0 to n except for one number which is missing. In this problem, we cannot access an entire integer in A with a single operation.

> The elements of A are represented in binary, and the only operation we can use to access them is “fetch the jth bit of A[i]”, which takes constant time. Write code to find the missing integer. Can you do it in O(n) time?

### Solution

__This is a difficult bit operation question__. 

The main thing to understand is, for a particular bit: 

> if the bit value of the removed number is 0, then count(0) <= count(1)

> if the bit value of the removed number is 1, then count(0) > count(1)

By using this principle, we can easily find the missing value for each bit. 

__However, we must know when to stop checking__. For example: 

> input: 000, 001, 011

We know that the last bit is 0, second last is 1. We shall stop here and return the result "010". If we did not stop, the result value would be "110", which is wrong. How this is handled is by __passing only half of the input list each time__, and we also add one condition at the beginning:

	if (list.size() == 0)
		return 0;

By doing this, we always limit the input list to a smaller range, until we finish finding all bits. 

### Code

__hard to write__

	public static int findMissing(List<BitInteger> list) {
		return helper(list, BitInteger.INTEGER_SIZE - 1);
	}

	private static int helper(List<BitInteger> list, int col) {
		if (list.size() == 0)
			return 0;
		List<BitInteger> zeroList = new ArrayList<BitInteger>();
		List<BitInteger> oneList = new ArrayList<BitInteger>();
		for (BitInteger bit : list) {
			if (bit.fetch(col) == 0) {
				zeroList.add(bit);
			} else {
				oneList.add(bit);
			}
		}
		if (zeroList.size() <= oneList.size()) {
			// this means the missing value contains a 0
			return helper(zeroList, col - 1) << 1;
		} else {
			// the missing value contains 1
			return helper(oneList, col - 1) << 1 | 1;
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CC150v4] 6.2 Cover the Chess Board]]></title>
    <link href="http://okckd.github.io/blog/2014/09/07/cover-the-chess-board/"/>
    <updated>2014-09-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/07/cover-the-chess-board</id>
    <content type="html"><![CDATA[### Question

> There is an 8x8 chess board in which two diagonally opposite squares have been cut off. You are given 31 dominos, and a single domino can cover exactly two squares. 

> Can you use the 31 dominos to cover the entire board? Prove your answer (by providing an example, or showing why it’s impossible). 

### Solution

The chess board initially has 32 black and 32 white squares. By removing opposite corners, we're left with 30 of one color and 32 of the other color. 

31 dominos must cover 31 of one color and 31 of the other color. 

So, impossible. 
]]></content>
  </entry>
  
</feed>
