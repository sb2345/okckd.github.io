<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | Shuatiblog.com]]></title>
  <link href="www.shuatiblog.com/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="www.shuatiblog.com/"/>
  <updated>2015-04-15T16:54:07+08:00</updated>
  <id>www.shuatiblog.com/</id>
  <author>
    <name><![CDATA[CodeMonkey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[LeetCode 173] Binary Search Tree Iterator ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/15/Binary-Search-Tree-Iterator/"/>
    <updated>2015-04-15T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/15/Binary-Search-Tree-Iterator</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/binary-search-tree-iterator/)

<div class="question-content">
              <p></p><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>

<p>Calling <code>next()</code> will return the next smallest number in the BST.</p>

<p><b>Note: </b><code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<i>h</i>) memory, where <i>h</i> is the height of the tree. </p>

<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/tree/">Tree</a>
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/stack/">Stack</a>
                  
                </span>
              
            </div>

### Analysis

This is an extremely important question, if you are going for an interview. I repeat: __this is an extremely important question, if you are going for an interview__. If you do not remember it by heart, I will repeat again. 

The solution of the iterator applies to a lot of related questions. So make sure you practise this question until you are perfect. You WILL BE ASKED this question at times. 

You could read my other post [[Question] Iterator of Binary Search Tree](/blog/2014/06/14/Iterator-of-Tree/). 

### Solution

We only need to keep 1 variable in RAM, that is a stack. 

### Code

    public class BSTIterator {

        Stack<TreeNode> stack = new Stack<TreeNode>();

        public BSTIterator(TreeNode root) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
        }

        /** @return whether we have a next smallest number */
        public boolean hasNext() {
            return !stack.isEmpty();
        }

        /** @return the next smallest number */
        public int next() {
            if (!hasNext()) {
                return 0;
            }
            TreeNode next = stack.pop();
            TreeNode node = next.right;
            while (node != null) {
                stack.push(node);
                node = node.left;
            }
            return next.val;
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 169] Majority Element ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/14/Majority-Element/"/>
    <updated>2015-04-14T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/14/Majority-Element</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/majority-element/)

### Solution

<div class="question-content">
              <p></p><p>Given an array of size <i>n</i>, find the majority element. The majority element is the element that appears more than <code>? n/2 ?</code> times.</p>

<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>

<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/divide-and-conquer/">Divide and Conquer</a>
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/array/">Array</a>
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/bit-manipulation/">Bit Manipulation</a>
                  
                </span>
              
            </div>

### Analysis

I have already covered this question in [[LintCode] Majority Number](/blog/2014/06/28/Majority-Number/). However, I have also discovered __a few other very interesting solution__. Check below. 

### Solution

The best solution is of course the voting algorithm. Read code below. 

Second solution presented by offical answer, is to do sorting: 

    public int majorityElement(int[] num) {
        if (num.length == 1) {
            return num[0];
        }

        Arrays.sort(num);
        return num[num.length / 2];
    }

Third interesting solution is doing bit manipulation. Read [Yanyulin's blog](http://www.yanyulin.info/pages/2014/12/851338983752.html) for more. 

### Code

    public class Solution {
        public int majorityElement(int[] num) {
            if (num == null || num.length == 0) {
                return 0;
            }
            int major = num[0];
            long count = 1;

            for (int i = 1; i < num.length; i++) {
                if (major == num[i]) {
                    count++;
                } else if (count == 0) {
                    major = num[i];
                    count = 1;
                } else {
                    count--;
                }
            }

            return major;
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 168] Excel Sheet Column Title ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/14/Excel-Sheet-Column-Title/"/>
    <updated>2015-04-14T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/14/Excel-Sheet-Column-Title</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/excel-sheet-column-title/)

<div class="question-content">
              <pExcel Sheet Column Number></p><p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>

<p>For example:</p>
<pre>    1 -&gt; A
    2 -&gt; B
    3 -&gt; C
    ...
    26 -&gt; Z
    27 -&gt; AA
    28 -&gt; AB </pre>

<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ifanchu">@ifanchu</a> for adding this problem and creating all test cases.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/math/">Math</a>
                  
                </span>
              
            </div>

### Analysis

This is pretty much a similar question. It's pretty easy. 

### Code

    public class Solution {
        public int titleToNumber(String s) {
            if (s == null || s.length() == 0) {
                return 0;
            }
            int sum = 0;
            for (char ch: s.toCharArray()) {
                sum *= 26;
                sum += (int) (ch - 'A' + 1);
            }
            return sum;
        }
    }

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 164] Maximum Gap ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/13/Maximum-Gap/"/>
    <updated>2015-04-13T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/13/Maximum-Gap</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/maximum-gap/)

<div class="question-content">
              <p></p><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>

<p>Try to solve it in linear time/space.</p>

<p>Return 0 if the array contains less than 2 elements.</p>

<p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p>

<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/porker2008">@porker2008</a> for adding this problem and creating all test cases.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/sort/">Sort</a>
                  
                </span>
              
            </div>

### Analysis

__This is an extremely difficult question__ of bucket sort. I refered to [programcreek](http://www.programcreek.com/2014/03/leetcode-maximum-gap-java/) and [tgic's blog](http://leetcode.tgic.me/maximum-gap/index.html) for reference. 

### Solution

__Basic idea is to put elements into buckets__. The number of bucket is (almost) same as the number of elements in the input. In this way, each bucket __ideally__ will contain 1 element. 

We then know that __the max gap must be cross-bucket instead of within bucket__. So we simply keep track of max and min value within each bucket for the purpose of calculating gap. 

__Why did I say "number of bucket is (almost) same as the number of elements in the input"__? Well, consider this case: 3 values and (maxVal - minVal) == 100. We can make 3 bucket with size = 34. How about 5 values and (maxVal - minVal) == 6? Bucket size shall be either 1 or 2. So we'll have either 3 or 6 bucket. 

So, in the code below, you can see I make bucket size "larger by 1": 

    // bSize is size of bucket (should be larger by 1)
    int bSize = (maxVal - minVal + 1) / num.length + 1;

    // calcualte number of buckets needed
    int bCount = (maxVal - minVal) / bSize + 1;
    Bucket[] buckets = new Bucket[bCount];


Note that simply use __input.length__ as bucket count is wrong. 

### Code

My code written in Java:

    public class Solution {
        public int maximumGap(int[] num) {
            if (num == null || num.length < 2) {
                return 0;
            }

            // find out max and min values of input
            int minVal = num[0];
            int maxVal = num[0];
            for (int n: num) {
                minVal = Math.min(minVal, n);
                maxVal = Math.max(maxVal, n);
            }
            // bSize is size of bucket (should be larger by 1)
            int bSize = (maxVal - minVal + 1) / num.length + 1;

            // calcualte number of buckets needed
            int bCount = (maxVal - minVal) / bSize + 1;
            Bucket[] buckets = new Bucket[bCount];

            // match every value into a bucket
            // bucket maintains the max/min within the bucket
            for (int n: num) {
                int bIndex = (n - minVal) / bSize;
                if (buckets[bIndex] == null) {
                    buckets[bIndex] = new Bucket(n, n);
                } else {
                    buckets[bIndex].updateVal(n);
                }
            }

            // for every bucket, check in sequence and get max gap
            int gap = 0;
            int pre = 0;
            int cur = 1;
            while (cur < bCount) {
                // skip all empty buckets
                while (cur < bCount && buckets[cur] == null) {
                    cur++;
                }
                if (cur == bCount) break;
                // update gap, pre and cur
                gap = Math.max(gap, buckets[cur].min - buckets[pre].max);
                pre = cur;
                cur++;
            }

            return gap;
        }

        class Bucket {
            int min;
            int max;

            public Bucket(int a, int b) {
                min = a;
                max = b;
            }

            public void updateVal(int val) {
                min = Math.min(min, val);
                max = Math.max(max, val);
            }
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 172] Factorial Trailing Zeroes ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/13/Factorial-Trailing-Zeroes/"/>
    <updated>2015-04-13T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/13/Factorial-Trailing-Zeroes</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/factorial-trailing-zeroes/)

<div class="question-content">
              <p></p><p>Given an integer <i>n</i>, return the number of trailing zeroes in <i>n</i>!.</p>

<p><b>Note: </b>Your solution should be in logarithmic time complexity.</p>

<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/math/">Math</a>
                  
                </span>
              
            </div>

### Analysis

This question I've seen it quite a few time, also. We're basically count the number of factor 5s. 

Eg. 

> n = 5, count = 1

> n = 6, count = 1

> n = 10, count = 2

> n = 24, count = 4

> n = 25, count = 6

> n = 26, count = 6

### Solution

Please read this post __[[LintCode] Trailing Zeros of Factorial(/blog/2014/07/02/Trailing-Zero-of-Factorial/)__. 

### Code

    public class Solution {
        public int trailingZeroes(int n) {
            if (n < 5) {
                return 0;
            }
            int res = 0;
            long base = 5;
            while (n >= base) {
                res += n / base;
                base *= 5;
            }
            return res;
        }
    }
]]></content>
  </entry>
  
</feed>
