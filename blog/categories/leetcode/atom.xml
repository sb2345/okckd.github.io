<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | Shuatiblog.com]]></title>
  <link href="http://okckd.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-04-09T20:52:28+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[codemonkey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[LeetCode 160] Intersection of Two Linked Lists ]]></title>
    <link href="http://okckd.github.io/blog/2015/04/08/Intersection-of-Two-Linked-Lists/"/>
    <updated>2015-04-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/04/08/Intersection-of-Two-Linked-Lists</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/intersection-of-two-linked-lists/)

<div class="question-content">
              <p></p><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<br>
<p>For example, the following two linked lists: </p>
<pre>A:          a1 ? a2
                   ?
                     c1 ? c2 ? c3
                   ?            
B:     b1 ? b2 ? b3
</pre>
<p>begin to intersect at node c1.</p>
<br>
<p><b>Notes:</b>
</p><ul>
<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>
<li>The linked lists must retain their original structure after the function returns. </li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
<p></p>

<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/stellari">@stellari</a> for adding this problem and creating all test cases.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/linked-list/">Linked List</a>
                  
                </span>
              
            </div>

### Analysis

This question is very similar to __[LeetCode Plus] Lowest Common Ancestor of Binary Tree (II)__. 

### Solution

[This](http://stackoverflow.com/a/2216683/909524) is a pretty nice answer. The following explanation is quoted from [g4g](http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/):

>1. Get count of the nodes in first list, let count be c1.
>
>2. Get count of the nodes in second list, let count be c2.
>
>3. Get the difference of counts d = abs(c1 – c2)
>
>4. Now traverse the bigger list from the first node till d nodes so that from here onwards both the lists have equal no of nodes.
>
>5. Then we can traverse both the lists in parallel till we come across a common node. 

### Code

    /**
     * Definition for singly-linked list.
     * public class ListNode {
     *     int val;
     *     ListNode next;
     *     ListNode(int x) {
     *         val = x;
     *         next = null;
     *     }
     * }
     */
    public class Solution {
        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
            return helper(headA, headB, length(headA) - length(headB));
        }

        public ListNode helper(ListNode n1, ListNode n2, int offset) {
            if (offset < 0) {
                return helper(n2, n1, 0 - offset);
            }
            // move n1 to the distance of offset
            while (offset != 0) {
                n1 = n1.next;
                offset--;
            }
            while (n1 != null && n1 != n2) {
                n1 = n1.next;
                n2 = n2.next;
            }
            return n1;
        }

        int length(ListNode node) {
            int len = 0;
            while (node != null) {
                node = node.next;
                len++;
            }
            return len;
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 155] Min Stack ]]></title>
    <link href="http://okckd.github.io/blog/2015/04/07/Min-Stack/"/>
    <updated>2015-04-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/04/07/Min-Stack</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/min-stack/)

<div class="question-content">
              <p></p><p>
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
</p><ul>
<li>
push(x) -- Push element x onto stack.
</li>
<li>
pop() -- Removes the element on top of the stack.
</li>
<li>
top() -- Get the top element.
</li>
<li>
getMin() -- Retrieve the minimum element in the stack.
</li>
</ul>
<p></p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/stack/">Stack</a>
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/data-structure/">Data Structure</a>
                  
               sn’t look possible to go to left half or right half by doing constant number of comparisons at the mSolution </span>
</div>

### Analysis

I've already cover this question in another post __[Question] Min Stack__. 

### My Code

    class MinStack {

        Stack<Integer> stack = new Stack<Integer>();
        Stack<Integer> min = new Stack<Integer>();

        public void push(int x) {
            stack.push(x);
            if (min.isEmpty() || min.peek() >= x) {
                min.push(x);
            }
        }

        public void pop() {
            if (stack.isEmpty()) {
                return;
            }
            int topNum = stack.pop();
            if (topNum == min.peek()) {
                min.pop();
            }
        }

        public int top() {
            if (stack.isEmpty()) {
                return 0;
            }
            return stack.peek();
        }

        public int getMin() {
            if (min.isEmpty()) {
                return 0;
            }
            return min.peek();
        }
    }

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 152] Maximum Product Subarray ]]></title>
    <link href="http://okckd.github.io/blog/2015/04/07/Maximum-Product-Subarray/"/>
    <updated>2015-04-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/04/07/Maximum-Product-Subarray</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/maximum-product-subarray/)

<div class="question-content">
              <p></p><p>
Find the contiguous subarray within an array (containing at least one number) which has the largest product.
</p>

<p>
For example, given the array <code>[2,3,-2,4]</code>,<br>
the contiguous subarray <code>[2,3]</code> has the largest product = <code>6</code>.
</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/array/">Array</a>
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/dynamic-programming/">Dynamic Programming</a>
                  
                </span>
              
            </div>

### Analysis

__This is a pretty difficult question__. It's hard to write bug-free solution if you have never practised before. 

So the first idea that comes to me is the case of array element = 0. Why this case? cuz the maximum subarray MUST NOT CONTAIN 0 unless the input is like {-1, 0, -1}. So we could divide array from 0s and calculate max sum seperately. This idea is good, though a little difficult in coding. Read it [here](http://www.geeksforgeeks.org/maximum-product-subarray/) or [here](https://shepherdyuan.wordpress.com/2014/07/23/linkedin-maximum-sumproduct-subarray/). 

### Solution

After a bit exploration, I found a must easier apporach, thanks to [code ganker](http://blog.csdn.net/linhuanmars/article/details/39537283) and [Yu](http://yucoding.blogspot.sg/2014/10/leetcode-quesion-maximum-product.html). The idea is to simply ALWAYS CALCULATE preMax and preMin by using MAX/MIN(Val1, Val2, Val3) method.  

### My Code

    public class Solution {
        public int maxProduct(int[] A) {
            if (A == null || A.length == 0) {
                return 0;
            } else if (A.length == 1) {
                return A[0];
            }

            int preMax = A[0];
            int preMin = A[0];
            int max = A[0];

            for (int i = 1; i < A.length; i++) {
                int temp = preMin;
                preMin = Math.min(Math.min(preMin * A[i], preMax * A[i]), A[i]);
                preMax = Math.max(Math.max(temp * A[i], preMax * A[i]), A[i]);
                max = Math.max(max, preMax);
            }

            return max;
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 154] Find Minimum in Rotated Sorted Array II ]]></title>
    <link href="http://okckd.github.io/blog/2015/04/07/Find-Minimum-in-Rotated-Sorted-Array-II/"/>
    <updated>2015-04-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/04/07/Find-Minimum-in-Rotated-Sorted-Array-II</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/)

<div class="question-content">
              <p></p><blockquote>
<p><i>Follow up</i> for "Find Minimum in Rotated Sorted Array":<br>
What if <i>duplicates</i> are allowed?</p>

<p>Would this affect the run-time complexity? How and why?</p>
</blockquote>

<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>

<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>

<p>Find the minimum element.</p>

<p>The array may contain duplicates.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/array/">Array</a>
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/binary-search/">Binary Search</a>
      about/            
                </span>
              
            </div>

### Solution

This question is simply a modified version of previous question. The special cases of the input makes it O(n) worst case complexity. 

### My Code

    public class Solution {
        public int findMin(int[] num) {
            if (num == null || num.length == 0) {
                return 0;
            }
            return helper(num, 0, num.length - 1);
        }

        private int helper(int[] num, int left, int right) {
            if (num[left] < num[right] || left == right) {
                return num[left];
            } else if (num[left] == num[right]) {
                return helper(num, left + 1, right);
            } else if (left + 1 == right) {
                return num[right];
            }
            int mid = left + (right - left) / 2;
            if (num[mid] >= num[left]) {
                return helper(num, mid, right);
            } else {
                return helper(num, left, mid);
            }
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 153] Find Minimum in Rotated Sorted Array ]]></title>
    <link href="http://okckd.github.io/blog/2015/04/07/Find-Minimum-in-Rotated-Sorted-Array/"/>
    <updated>2015-04-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/04/07/Find-Minimum-in-Rotated-Sorted-Array</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

<div class="question-content">
              <p></p><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>

<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>

<p>Find the minimum element.</p>

<p>You may assume no duplicate exists in the array.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/array/">Array</a>
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/binary-search/">Binary Search</a>
                  
                </span>
              
            </div>

### Analysis

This question is very similar to __[LeetCode 33] Search in Rotated Sorted Array__. Note a few special cases. 

### Solution

Very good code can be found [here](http://www.programcreek.com/2014/02/leetcode-find-minimum-in-rotated-sorted-array/) and [here](http://www.sanfoundry.com/java-program-find-minimum-element-rotated-sorted-array-using-binary-search-approach/). 

### My Code

    public class Solution {
        public int findMin(int[] num) {
            if (num == null || num.length == 0) {
                return 0;
            }
            return helper(num, 0, num.length - 1);
        }

        private int helper(int[] num, int left, int right) {
            if (num[left] <= num[right]) {
                return num[left];
            } else if (left + 1 == right) {
                return num[right];
            }
            int mid = left + (right - left) / 2;
            if (num[mid] > num[left]) {
                return helper(num, mid, right);
            } else {
                return helper(num, left, mid);
            }
        }
    }
]]></content>
  </entry>
  
</feed>
