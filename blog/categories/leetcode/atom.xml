<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | Shuatiblog.com]]></title>
  <link href="www.shuatiblog.com/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="www.shuatiblog.com/"/>
  <updated>2015-04-12T23:18:08+08:00</updated>
  <id>www.shuatiblog.com/</id>
  <author>
    <name><![CDATA[CodeMonkey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[LeetCode 162] Find Peak Element ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/12/Find-Peak-Element/"/>
    <updated>2015-04-12T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/12/Find-Peak-Element</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/find-peak-element/)

<div class="question-content">
              <p></p><p>A peak element is an element that is greater than its neighbors.</p>

<p>Given an input array where <code>num[i] ? num[i+1]</code>, find a peak element and return its index.</p>

<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>

<p>You may imagine that <code>num[-1] = num[n] = -8</code>.</p>

<p>For example, in array <code>[1, 2, 3, 1]</code>, 3 is a peak element and your function should return the index number 2.</p>

<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show spoilers.</a></p>

<div class="spoilers" style="display: none;"><b>Note:</b>
<p>Your solution should be in logarithmic complexity.</p>
</div>

<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/array/">Array</a>
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/binary-search/">Binary Search</a>
                  
                </span>
              
            </div>

### Analysis

This basically is a binary search question. Instead of checking the values, we check the slope (upgoing or downslope). 

__The important point__ is the special cases like [1, 2, 3] or [3, 2, 1], we need to return the corner values. Well there're 2 ways to handle these corner cases. 

### Solution

First, referring to [G4G](http://www.geeksforgeeks.org/find-a-peak-in-a-given-array/), the corner case is handled in this way: 

    if ((mid == 0 || arr[mid-1] <= arr[mid]) &&
            (mid == n-1 || arr[mid+1] <= arr[mid]))
        return mid;

The code 1 below is doing similar things. That code is readable and easy to come up with. I recommend this solution during a interview. 

For those who are interested, there is a extremely concise solution thanks to [Duplan](http://blog.csdn.net/u010367506/article/details/41943309). I have the Java version posted below as code 2. 

### Code

Code 1

    public class Solution {
        public int findPeakElement(int[] num) {
            if (num == null || num.length == 0) {
                return 0;
            } else if (num.length == 1) {
                return 0;
            } else if (num[0] > num[1]) {
                return 0;
            } else if (num[num.length - 2] < num[num.length - 1]) {
                return num.length - 1;
            }
            // now the leftmost edge is increasing
            // and the rightmost edge is also increasing backwards
            return helper(num, 0, num.length - 1);
        }

        public int helper(int[] num, int left, int right) {
            int mid = left + (right - left) / 2;
            if (left + 2 == right) {
                return mid;
            } else if (num[mid] > num[mid + 1]) {
                // middle is decreasing, so peak on the left side
                return helper(num, left, mid + 1);
            } else {
                return helper(num, mid, right);
            }
        }
    }

Code 2

    public class Solution {
        public int findPeakElement(int[] num) {
            if (num == null || num.length == 0) {
                return 0;
            }
            return helper(num, 0, num.length - 1);
        }

        public int helper(int[] num, int left, int right) {
            int mid = left + (right - left) / 2;
            if (left == right) {
                return left;
            } else if (num[mid] > num[mid + 1]) {
                // middle is decreasing, so peak on the left side
                return helper(num, left, mid);
            } else {
                return helper(num, mid + 1, right);
            }
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 165] Compare Version Numbers ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/12/Compare-Version-Numbers/"/>
    <updated>2015-04-12T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/12/Compare-Version-Numbers</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/compare-version-numbers/)

<div class="question-content">
              <p></p><p>Compare two version numbers <i>version1</i> and <i>version2</i>.<br>
If <i>version1</i> &gt; <i>version2</i> return 1, if <i>version1</i> &lt; <i>version2</i> return -1, otherwise return 0.</p>

<p>You may assume that the version strings are non-empty and contain only digits and the <code>.</code> character.<br>
The <code>.</code> character does not represent a decimal point and is used to separate number sequences.<br>
For instance, <code>2.5</code> is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.</p>

<p>Here is an example of version numbers ordering:</p>
<pre>0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37</pre>

<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/string/">String</a>
                  
                </span>
              
            </div>

### Analysis

I've seen a couple of interesting ideas on other people's blogs, including [one](http://www.programcreek.com/2014/03/leetcode-compare-version-numbers-java/) that uses String.split() to convert input to an array, and [this one](http://www.meetqun.com/thread-3331-1-1.html) which uses 2 pointers to compare. 

My solution might seem more intuitive for some. See below for my solution. 

### Solution

The idea is to identify what the current number is (before end of string, or before the next '.'). If there's no more string, value = 0, so the case of (1.0, 1) essentially equals. Without further ado, let's look at the code. 

### Code

    public class Solution {
        public int compareVersion(String version1, String version2) {
            if (version1 == null || version2 == null) {
                return 0;
            }
            return helper(version1, version2);
        }

        private int helper(String v1, String v2) {
            if (v1.length() == 0 && v2.length() == 0) {
                return 0;
            }

            int num1 = 0;
            int num2 = 0;

            if (v1.length() != 0) {
                int p1 = 0;
                while (p1 < v1.length() && v1.charAt(p1) != '.') {
                    p1++;
                }
                num1 = Integer.parseInt(v1.substring(0, p1));
                if (p1 < v1.length()) p1++;
                v1 = v1.substring(p1);
            }

            if (v2.length() != 0) {
                int p2 = 0;
                while (p2 < v2.length() && v2.charAt(p2) != '.') {
                    p2++;
                }
                num2 = Integer.parseInt(v2.substring(0, p2));
                if (p2 < v2.length()) p2++;
                v2 = v2.substring(p2);
            }

            if (num1 != num2) {
                return (num1 - num2) / Math.abs(num1 - num2);
            } else {
                return helper(v1, v2);
            }
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 166] Fraction to Recurring Decimal ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/11/Fraction-to-Recurring-Decimal/"/>
    <updated>2015-04-11T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/11/Fraction-to-Recurring-Decimal</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/fraction-to-recurring-decimal/)

<div class="question-content">
              <p></p><p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>

<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>
<p>
For example,
</p><ul>
<li>Given numerator = 1, denominator = 2, return "0.5".</li>
<li>Given numerator = 2, denominator = 1, return "2".</li>
<li>Given numerator = 2, denominator = 3, return "0.(6)".</li>
</ul>
<p></p>

<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Shangrila">@Shangrila</a> for adding this problem and creating all test cases.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/hash-table/">Hash Table</a>
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/math/">Math</a>
                  
                </span>
</div>

### Analysis

Wow, this is just another incredible question on Leetcode. Quite a few difficult corner cases in the OJ. 

Current AC rate is first lowest at 12.4%. 

### Solution

There're 3 things that we must take note: 

1. Handle positive/nagetive cases well. Note that both numerator and denominator can be negative number. And there're also case like: 

> 1 / -3 = -0.(3)

2. Note that we have to match the repetation of the actual numerator. Not the quotient. What do I mean by that? 

>1 / 6 = 0.1(6)
>
>1 / 333 = 0.(003)
    
3. Note below is __how to override the equals() method__ (first one is wrong and second is right): 

    public boolean equals(Pair p) {
        
    }

    public boolean equals(Object obj) {
        
    }

__One more thing__: Most other guys' solutions like [this](http://www.programcreek.com/2014/03/leetcode-fraction-to-recurring-decimal-java/), [this](http://blog.csdn.net/ljiabin/article/details/42025037) and [this](http://yuanhsh.iteye.com/blog/2176178) are using Hashing. It's fine and definitely good. I used linearly search though, which is a small time compromise. I am presenting my code below and please just consider it as something different. Keep in mind it's not the optimized solution. 

### Code

    public class Solution {
        public String fractionToDecimal(int numerator, int denominator) {
            long quotient = (long) numerator / denominator;
            long reminder = (long) numerator % denominator;
            if (reminder == 0) {
                return String.valueOf(quotient);
            }

            // The result has 3 parts: sign, integer part, and fraction part
            // eg. -4 / 3 = -1 and the result of (1/3) = (3)
            String sign = ((long) numerator * denominator >= 0) ? "" : "-";
            long integer = Math.abs(quotient);
            String fraction = fraction(Math.abs((long)reminder), Math.abs((long)denominator));

            // why do we have to seperate sign from integer?
            // cuz 1 / -3 = -0.(3), while quotient is 0. 
            // So, we can't simply concatenate quotient with fraction
            return sign + integer + "." + fraction;
        }

        String fraction(long num, long denum) {
            // eg. num = 1, denum = 4, should return "25"

            List<Pair> list = new ArrayList<Pair>();
            String result = "";
            while (num != 0) {
                num *= 10;
                long digit = num / denum;

                // eg. 1 / 333 = (003), so the pairs would be like this:
                // {10, 0}, {100, 0}, {1000, 3}, {10, 0}...
                Pair cur = new Pair(num, digit);
                num %= denum;

                // now add cur Pair to the list
                if (list.indexOf(cur) == -1) {
                    list.add(cur);
                } else {
                    // found a recurring dicimal in the previous output stream
                    int pos = list.indexOf(cur);
                    for (int i = 0; i < pos; i++) {
                        result += list.get(i).digit;
                    }
                    result += "(";
                    for (int i = pos; i < list.size(); i++) {
                        result += list.get(i).digit;
                    }
                    result += ")";
                    break;
                }
            }

            // if there is recurring digit, the result should have already been generated
            if (result.length() == 0) {
                for (Pair p: list) {
                    result += p.digit;
                }
            }
            return result;
        }

        class Pair {
            long num;
            long digit;

            public Pair(long a, long b) {
                num = a;
                digit = b;
            }

            public boolean equals(Object obj) {
                // note the equals interface passes in (Object obj)
                // instead of a Pair object
                Pair p = (Pair) obj;
                return this.num == p.num && this.digit == p.digit;
            }
        }
    }

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 160] Intersection of Two Linked Lists ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/08/Intersection-of-Two-Linked-Lists/"/>
    <updated>2015-04-08T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/08/Intersection-of-Two-Linked-Lists</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/intersection-of-two-linked-lists/)

<div class="question-content">
              <p></p><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<br>
<p>For example, the following two linked lists: </p>
<pre>A:          a1 ? a2
                   ?
                     c1 ? c2 ? c3
                   ?            
B:     b1 ? b2 ? b3
</pre>
<p>begin to intersect at node c1.</p>
<br>
<p><b>Notes:</b>
</p><ul>
<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>
<li>The linked lists must retain their original structure after the function returns. </li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
<p></p>

<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/stellari">@stellari</a> for adding this problem and creating all test cases.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/linked-list/">Linked List</a>
                  
                </span>
              
            </div>

### Analysis

This question is very similar to __[LeetCode Plus] Lowest Common Ancestor of Binary Tree (II)__. 

### Solution

[This](http://stackoverflow.com/a/2216683/909524) is a pretty nice answer. The following explanation is quoted from [g4g](http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/):

>1. Get count of the nodes in first list, let count be c1.
>
>2. Get count of the nodes in second list, let count be c2.
>
>3. Get the difference of counts d = abs(c1 – c2)
>
>4. Now traverse the bigger list from the first node till d nodes so that from here onwards both the lists have equal no of nodes.
>
>5. Then we can traverse both the lists in parallel till we come across a common node. 

### Code

    /**
     * Definition for singly-linked list.
     * public class ListNode {
     *     int val;
     *     ListNode next;
     *     ListNode(int x) {
     *         val = x;
     *         next = null;
     *     }
     * }
     */
    public class Solution {
        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
            return helper(headA, headB, length(headA) - length(headB));
        }

        public ListNode helper(ListNode n1, ListNode n2, int offset) {
            if (offset < 0) {
                return helper(n2, n1, 0 - offset);
            }
            // move n1 to the distance of offset
            while (offset != 0) {
                n1 = n1.next;
                offset--;
            }
            while (n1 != null && n1 != n2) {
                n1 = n1.next;
                n2 = n2.next;
            }
            return n1;
        }

        int length(ListNode node) {
            int len = 0;
            while (node != null) {
                node = node.next;
                len++;
            }
            return len;
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 155] Min Stack ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/07/Min-Stack/"/>
    <updated>2015-04-07T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/07/Min-Stack</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/min-stack/)

<div class="question-content">
              <p></p><p>
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
</p><ul>
<li>
push(x) -- Push element x onto stack.
</li>
<li>
pop() -- Removes the element on top of the stack.
</li>
<li>
top() -- Get the top element.
</li>
<li>
getMin() -- Retrieve the minimum element in the stack.
</li>
</ul>
<p></p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/stack/">Stack</a>
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/data-structure/">Data Structure</a>
                  
               sn’t look possible to go to left half or right half by doing constant number of comparisons at the mSolution </span>
</div>

### Analysis

I've already cover this question in another post __[Question] Min Stack__. 

### My Code

    class MinStack {

        Stack<Integer> stack = new Stack<Integer>();
        Stack<Integer> min = new Stack<Integer>();

        public void push(int x) {
            stack.push(x);
            if (min.isEmpty() || min.peek() >= x) {
                min.push(x);
            }
        }

        public void pop() {
            if (stack.isEmpty()) {
                return;
            }
            int topNum = stack.pop();
            if (topNum == min.peek()) {
                min.pop();
            }
        }

        public int top() {
            if (stack.isEmpty()) {
                return 0;
            }
            return stack.peek();
        }

        public int getMin() {
            if (min.isEmpty()) {
                return 0;
            }
            return min.peek();
        }
    }

]]></content>
  </entry>
  
</feed>
