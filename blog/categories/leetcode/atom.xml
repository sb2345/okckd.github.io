<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Leetcode | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-07-29T13:04:23+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[LeetCode 151] Reverse Words in a String]]></title>
    <link href="http://okckd.github.io/blog/2014/06/03/Reverse-Words-in-a-String/"/>
    <updated>2014-06-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/03/Reverse-Words-in-a-String</id>
    <content type="html"><![CDATA[### Question 
[link](https://oj.leetcode.com/problems/reverse-words-in-a-string/)

<div class="question-content bg-color bg-img font-color">
<p class="font-color"></p><p class="font-color">
Given an input string, reverse the string word by word.
</p>

<p class="font-color">
For example,<br>
Given s = "<code>the sky is blue</code>",<br>
return "<code>blue is sky the</code>".
</p>

<div>
<b>Clarification:</b>

<p class="font-color">
</p><ul class="bg-color bg-img font-color">
<li>What constitutes a word?<br>
A sequence of non-space characters constitutes a word.</li>
<li>Could the input string contain leading or trailing spaces?<br>
Yes. However, your reversed string should not contain leading or trailing spaces.</li>
<li>How about multiple spaces between two words?<br>
Reduce them to a single space in the reversed string.</li>
</ul>
<p class="font-color"></p>
</div><p class="font-color"></p>
          </div>

### Stats
<table border="2">
	<tr>
		<td>Adjusted Difficulty</td>
		<td bgcolor="yellow">3</td>
	</tr>
	<tr>
		<td>Time to use</td>
		<td bgcolor="yellow">--------</td>
	</tr>
</table>

Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)

### Analysis

__This is an very classic question__, and there is a very nice solution. 

### Solution

__First solution is read each character from the back, and insert each word into answer String__. I used this method, and passed in 2 attempts. I have always been afriad of string question, and this time it gave me an easy time. 

I post my code below. Altough it can be better if I use StringBuilder. Most blog/forum would give this solution including [this one](https://oj.leetcode.com/discuss/3378/is-my-solution-good-enough). 

However, previous solution uses extra space. __We can do it in-place suggested by [this post](http://stackoverflow.com/a/1009174)__. 

<blockquote cite="http://stackoverflow.com/a/1009174">
    <p class="font-color">Reverse the entire string, then reverse the letters of each individual word.</p>

    <p class="font-color">After the first pass the string will be</p>

    <pre><code>s1 = "Z Y X si eman yM"
    </code></pre>

    <p class="font-color">and after the second pass it will be</p>

    <pre><code>s1 = "Z Y X is name My"
    </code></pre>
</blockquote>

There are 2 things to note. 

__One, the edge cases__ are easily omitted, like all-space input, double-space in between, and a lot more. 

__Two, The Clarification part is extremely helpful__ for writing a bug-free solution. It's always better to clarify further about what the question is ask. For example, can we use __String.split()__ and __String.substring()__? (normally we would better not to) Can we use any extra space? That decides weather we copy by substring or by character. 

In conclusion, __this is an easy question that's not easy to get correct answer__. Practise more! And since this is the last post of Leetcode questions, my focus from tomorrow onwards will be shifted to "CC150". Thanks for reading! 

### Code

__My code__. pointer solution. 

    public String reverseWords(String s) {
		if (s.length() == 0) return "";
		int p = s.length() - 1;
		// p points to the last non-space character
		String ans = "";
		while (p >= 0) {
			int j = p;
			while (j >= 0 && s.charAt(j) != ' ') {
				j --;
			}
			ans += s.substring(j + 1, p + 1) + " ";
			p = j;
			while (p >= 0 && s.charAt(p) == ' ') {
				p--;
			}
		}
		return ans.trim();
    }

__Updated on June 9th, the in-place solution__

Note that String.split() behaves strangely when there is space char. So it's necessary to check (str==""). Eg: 

> " a  b c " -> after String.split(" ") -> [, a, , b, c]

    public String reverseWords(String s) {
		if (s == null || s.length() == 0) {
			return s;
		}
		String[] words = s.split(" ");
		String firstReversed = "";
		for (int i = 0; i < words.length; i ++) {
		    if (words[i].equals("")) continue;
			firstReversed += inPlaceReverse(words[i]) + " ";
		}
		return inPlaceReverse(firstReversed);
    }
	
	private String inPlaceReverse(String str) {
		if (str == null || str.length() == 0) return str;
		char[] chars = str.trim().toCharArray();
		int left = 0;
		int right = chars.length - 1;
		while (left < right) {
			char temp = chars[left];
			chars[left] = chars[right];
			chars[right] = temp;
			left ++;
			right --;
		}
		return String.valueOf(chars);
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 143] Reorder List]]></title>
    <link href="http://okckd.github.io/blog/2014/06/03/Reorder-List/"/>
    <updated>2014-06-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/03/Reorder-List</id>
    <content type="html"><![CDATA[### Question 
[link](https://oj.leetcode.com/problems/reorder-list/)

<div class="question-content bg-color bg-img font-color">
            <p class="font-color"></p><p class="font-color">
Given a singly linked list <i>L</i>: <i>L</i><sub>0</sub>→<i>L</i><sub>1</sub>→…→<i>L</i><sub><i>n</i>-1</sub>→<i>L</i><sub>n</sub>,<br>
reorder it to: <i>L</i><sub>0</sub>→<i>L</i><sub><i>n</i></sub>→<i>L</i><sub>1</sub>→<i>L</i><sub><i>n</i>-1</sub>→<i>L</i><sub>2</sub>→<i>L</i><sub><i>n</i>-2</sub>→…
</p>

<p class="font-color">You must do this in-place without altering the nodes' values.</p>

<p class="font-color">
For example,<br>
Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.
</p><p class="font-color"></p>
          </div>

### Stats
<table border="2">
	<tr>
		<td>Adjusted Difficulty</td>
		<td bgcolor="red">4</td>
	</tr>
	<tr>
		<td>Time to use</td>
		<td bgcolor="red">--------</td>
	</tr>
</table>

Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)

### Analysis

__This is a difficult question to think__. 

I first solved it with an stack which stores the second half nodes. It works. However, IT IS NOT A IN-PLACE SOLUTION, thus it's wrong. 

Eventually I did not solve it. 

__There is only one standard solution from the Internet__. [This blog](http://www.programcreek.com/2013/12/in-place-reorder-a-singly-linked-list-in-java/) explains it. 

> 1. Break list in the middle to two lists (use fast & slow pointers)
> 2. Reverse the order of the second list
> 3. Merge two list back together

Simple, right? __Because of the nature of linked list, a lot of things can be done in-place__, so we need not use any other data strucutres. 

### Solution

The code is a bit lengthy and difficult to write. It took me a while, but passed in 1 go. 

### Code

__First, code written by me__

    public void reorderList(ListNode head) {
        if (head == null || head.next == null) {
			return;
		}
		ListNode slow = head, fast = head;
		while (fast != null) {
			if (fast.next != null && fast.next.next != null) {
				fast = fast.next.next;
				slow = slow.next;
			}
			else {
				fast = null;
			}
		}
		// if length = 2, slow point to 1st
		// if length = 3, slow point to 2nd
		// if length = 4, slow point to 2nd
		ListNode secondHalf = slow.next;
		slow.next = null;
		// now reverse secondHalf
		ListNode p = secondHalf;
		while (p.next != null) {
			ListNode tail = p.next.next;
			p.next.next = secondHalf;
			secondHalf = p.next;
			p.next = tail;
		}
		// now merge 2 list: head and secondHalf
		ListNode a = head, b = secondHalf;
		while (a != null && b != null) {
			ListNode temp1 = a.next;
			ListNode temp2 = b.next;
			a.next = b;
			b.next = temp1;
			a = temp1;
			b = temp2;
		}
    }

__Second, code written by [someone](https://oj.leetcode.com/discuss/236/does-this-problem-solution-time-complexity-space-comlexity)__

    public void reorderList(ListNode head) {
        // IMPORTANT: Please reset any member data you declared, as
        // the same Solution instance will be reused for each test case.
        if (head == null || head.next == null) return;
        ListNode fast = head;
        ListNode slow = head;
        while(fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        ListNode reverseHead = slow.next;           // find the second half of list
        slow.next = null;                           // make first half end point to null
        reverseHead = reverse(reverseHead);         // reverse second half     
        ListNode cur = head;        
        while(reverseHead != null) {                // link together
            ListNode tmp = reverseHead.next;
            reverseHead.next = cur.next;
            cur.next = reverseHead;
            cur = cur.next.next;
            reverseHead = tmp;
        }
    }
    private ListNode reverse(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode prev = new ListNode(0);
        prev.next = head;
        head = prev;
        ListNode cur = prev.next;
        while(cur.next != null) {
            ListNode tmp = cur.next;
            cur.next = tmp.next;
            tmp.next = prev.next;
            prev.next = tmp;
        }
        return prev.next;
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 149] Max Points on a Line]]></title>
    <link href="http://okckd.github.io/blog/2014/06/03/Max-Points-on-a-Line/"/>
    <updated>2014-06-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/03/Max-Points-on-a-Line</id>
    <content type="html"><![CDATA[### Question 
[link](https://oj.leetcode.com/problems/max-points-on-a-line/)

<div class="question-content bg-color bg-img font-color">
            <p class="font-color"></p><p class="font-color">Given <i>n</i> points on a 2D plane, find the maximum number of points that lie on the same straight line.</p><p class="font-color"></p>
          </div>

### Stats
<table border="2">
	<tr>
		<td>Adjusted Difficulty</td>
		<td bgcolor="red">5</td>
	</tr>
	<tr>
		<td>Time to use</td>
		<td bgcolor="red">--------</td>
	</tr>
</table>

Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)

### Analysis

__This is a difficult coding question__.

The idea is simple. For n points, there are n * (n-1) lines. Check slopes and then count total, we would get the answer. 

However, coding of this idea is very difficult. 

### Solution

__Firstly, there are 2 special cases when calculating the slope__. The 2 points may locate in same position. And when point1.x = point2.x, slope = infinity. It's easy to omit these 2 cases and result in mistake. 

Secondly, when we count, we declare 2 variables: samePointNumber and maxPointCountWithSameSlope. __It's very important to initialize both values to 1 instead of 0__! Why? Because these values just can't be 0. I failed my 2nd version code when input = {(0,0), (0,0)}, the program shows result of 0, instead of 2. 

__Thirdly, about what data structure to use for counting__. There is a discussion about this at [here](https://oj.leetcode.com/discuss/2573/better-way-to-use-hashmap-for-this-question)

> 1. storing the vertical slopes as Double.NaN. That allows Double to represent every slope uniquely as (y/x). 
> 2. It is unsafe using floating points to make a hash, and -0.0 != 0.0

It's great that using __Double.NaN__, it saves us time and effort to count vertical points. Second point is very valid, but it turns out that using HashMap<Double, Integer> can AC. 

P.S. It is always not a good practise to use Double as hash key. See [here](http://stackoverflow.com/questions/1074781/double-in-hashmap). 

__Fourthly, I made a mistake here__: 

> double slope = (p.y - q.y) / (p.x - q.x);

And it's wrong. Why? Note that __Point.x and Point.y are both integers__. Integer division will return integer. We must cast it. 

> double slope = (double) (p.y - q.y) / (p.x - q.x);

__Last, OMG I wish this is last, but not least, we can reduce execution time to half__ by checking only the points with larger index than the anchor point (that's the name for 'current point'). Good idea, right? 

One more thing, __how to iterate thru the HashMap__ (value only)? There is an easy way: 

    for (Integer a : map.values()) {
        a;
    }

That's all I've found for now. 

### Code

__written by me, version 3 using HashMap__

	public int maxPoints(Point[] points) {
		if (points.length <= 1)
			return points.length;
		HashMap<Double, Integer> map = null;
		int totalMax = 0;
		for (Point p : points) {
			int samePoint = 1;
			map = new HashMap<Double, Integer>();
			for (Point q : points) {
				if (q == p || p.x > q.x) {
				} else if (p.x == q.x && p.y == q.y) {
					samePoint++;
				} else {
					double slope = Double.NaN;
					if (p.x != q.x) {
						slope = (double) (p.y - q.y) / (p.x - q.x);
					}
					if (!map.containsKey(slope)) {
						map.put(slope, 1);
					}
					map.put(slope, map.get(slope) + 1);
				}
			}
			int pointMax = 1;
			for (Integer a : map.values()) {
				pointMax = Math.max(pointMax, a);
			}
			totalMax = Math.max(totalMax, pointMax + samePoint - 1);
		}
		return totalMax;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 146] LRU Cache]]></title>
    <link href="http://okckd.github.io/blog/2014/06/03/LRU-Cache/"/>
    <updated>2014-06-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/03/LRU-Cache</id>
    <content type="html"><![CDATA[### Question 
[link](https://oj.leetcode.com/problems/lru-cache/)

<div class="question-content bg-color bg-img font-color">
            <p class="font-color"></p><p class="font-color">
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <code>get</code> and <code>set</code>.
</p>

<p class="font-color">
<code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>
<code>set(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.
</p><p class="font-color"></p>
          </div>

### Stats
<table border="2">
	<tr>
		<td>Adjusted Difficulty</td>
		<td bgcolor="red">4</td>
	</tr>
	<tr>
		<td>Time to use</td>
		<td bgcolor="red">Very difficult</td>
	</tr>
</table>

Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)

### Analysis

__This is a difficult question__, I can't write the solution easily even after a month.

### Solution

The solution is to use a Doubly-linked-list and a HashMap. Doing this allows O(1) search, remove and insert. A very nice and sophisticated data structure example, and very high frequency in interviews. 

__2 important things to note while coding__:

1. We need 2 helper methods: removeNode() and setNodeAsHead(). 

    Because we reuse both methods for get() and set() methods. 

1. Initialization of LRU 

    We need 5 variables: capacity, current size(optional but good to have), hashmap, head, tail. 

1. Initialization of DoubleLinkedListNode

    This is easy, but __do not forget about both key and value variable__. We must use DoubleLinkedListNode.key when we want to delete tail. 

### Code

__Updated on July 1st, 2014__.

This question tests your ability to write some DS by yourself, eg. DoubleLinkedList. 

    public class LRUCache {

        int size;
        int capacity;

        DoubleLinkedList head;
        DoubleLinkedList tail;
        HashMap<Integer, DoubleLinkedList> map;

        public LRUCache(int capacity) {
            this.size = 0;
            this.capacity = capacity;
            head = null;
            tail = null;
            map = new HashMap<Integer, DoubleLinkedList>();
        }

        public void remove(DoubleLinkedList node) {
            if (node == head && node == tail) {
                head = null;
                tail = null;
            } else if (node == head) {
                head.next.prev = null;
                head = head.next;
            } else if (node == tail) {
                tail.prev.next = null;
                tail = tail.prev;
            } else {
                node.prev.next = node.next;
                node.next.prev = node.prev;
            }
            node.prev = null;
            node.next = null;
        }

        public void setHead(DoubleLinkedList node) {
            node.next = head;
            node.prev = null;
            if (head != null) {
                head.prev = node;
            }

            head = node;
            if (tail == null) {
                tail = node;
            }
        }

        public int get(int key) {
            if (!map.containsKey(key)) {
                // if key is not found
                return -1;
            } else {
                // if key is found
                DoubleLinkedList target = map.get(key);
                remove(target);
                setHead(target);
                return head.val;
            }
        }

        public void set(int key, int value) {
            if (this.get(key) != -1) {
                // key exist before, just replace the old value
                DoubleLinkedList old = map.get(key);
                old.val = value;
            } else {
                // this is a new key-value pair, insert it
                DoubleLinkedList newHead = new DoubleLinkedList(key, value);
                map.put(key, newHead);
                setHead(newHead);
                if (size == capacity) {
                    // delete tail
                    map.remove(tail.key);
                    remove(tail);
                } else {
                    size++;
                }
            }
        }

        class DoubleLinkedList {
            int key;
            int val;
            DoubleLinkedList prev;
            DoubleLinkedList next;
            public DoubleLinkedList(int k, int v) {
                this.key = k;
                this.val = v;
            }
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 150] Evaluate Reverse Polish Notation]]></title>
    <link href="http://okckd.github.io/blog/2014/06/03/Evaluate-Reverse-Polish-Notation/"/>
    <updated>2014-06-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/03/Evaluate-Reverse-Polish-Notation</id>
    <content type="html"><![CDATA[### Question 
[link](https://oj.leetcode.com/problems/evaluate-reverse-polish-notation/)

<div class="question-content bg-color bg-img font-color">
            <p class="font-color"></p><p class="font-color">
Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" class="font-color">Reverse Polish Notation</a>.
</p>

<p class="font-color">
Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.
</p>

<p class="font-color">
Some examples:<br>
</p><pre>  ["2", "1", "+", "3", "*"] -&gt; ((2 + 1) * 3) -&gt; 9
  ["4", "13", "5", "/", "+"] -&gt; (4 + (13 / 5)) -&gt; 6
</pre>
<p class="font-color"></p><p class="font-color"></p>
          </div>

### Stats
<table border="2">
	<tr>
		<td>Adjusted Difficulty</td>
		<td bgcolor="lime">2</td>
	</tr>
	<tr>
		<td>Time to use</td>
		<td bgcolor="lime">--------</td>
	</tr>
</table>

Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)

### Analysis

__This is a classic question__. It's easy.

### Code

__my code__

    public int evalRPN(String[] tokens) {
        if (tokens == null || tokens.length == 0)
        	return 0;
        Stack<Integer> stack = new Stack<Integer>();
        for (int p = 0; p < tokens.length; p ++) {
        	char cur = tokens[p].charAt(0);
        	if (cur >= '0' && cur <= '9' 
        			|| tokens[p].length() > 1)
        		stack.push(Integer.parseInt(tokens[p]));
        	else if (cur == '+') {
        		int num1 = stack.pop();
        		int num2 = stack.pop();
        		stack.push(num1 + num2);
        	}
        	else if (cur == '-') {
        		int num1 = stack.pop();
        		int num2 = stack.pop();
        		stack.push(num2 - num1);
        	}
        	else if (cur == '*') {
        		int num1 = stack.pop();
        		int num2 = stack.pop();
        		stack.push(num1 * num2);
        	}
        	else if (cur == '/') {
        		int num1 = stack.pop();
        		int num2 = stack.pop();
        		stack.push(num2 / num1);
        	}
        }
        return stack.pop();
    }
]]></content>
  </entry>
  
</feed>
