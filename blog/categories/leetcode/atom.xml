<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | Shuatiblog.com]]></title>
  <link href="www.shuatiblog.com/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="www.shuatiblog.com/"/>
  <updated>2015-04-13T23:58:26+08:00</updated>
  <id>www.shuatiblog.com/</id>
  <author>
    <name><![CDATA[CodeMonkey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[LeetCode 164] Maximum Gap ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/13/Maximum-Gap/"/>
    <updated>2015-04-13T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/13/Maximum-Gap</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/maximum-gap/)

<div class="question-content">
              <p></p><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>

<p>Try to solve it in linear time/space.</p>

<p>Return 0 if the array contains less than 2 elements.</p>

<p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p>

<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/porker2008">@porker2008</a> for adding this problem and creating all test cases.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/sort/">Sort</a>
                  
                </span>
              
            </div>

### Analysis

__This is an extremely difficult question__ of bucket sort. I refered to [programcreek](http://www.programcreek.com/2014/03/leetcode-maximum-gap-java/) and [tgic's blog](http://leetcode.tgic.me/maximum-gap/index.html) for reference. 

### Solution

__Basic idea is to put elements into buckets__. The number of bucket is (almost) same as the number of elements in the input. In this way, each bucket __ideally__ will contain 1 element. 

We then know that __the max gap must be cross-bucket instead of within bucket__. So we simply keep track of max and min value within each bucket for the purpose of calculating gap. 

__Why did I say "number of bucket is (almost) same as the number of elements in the input"__? Well, consider this case: 3 values and (maxVal - minVal) == 100. We can make 3 bucket with size = 34. How about 5 values and (maxVal - minVal) == 6? Bucket size shall be either 1 or 2. So we'll have either 3 or 6 bucket. 

So, in the code below, you can see I make bucket size "larger by 1": 

    // bSize is size of bucket (should be larger by 1)
    int bSize = (maxVal - minVal + 1) / num.length + 1;

    // calcualte number of buckets needed
    int bCount = (maxVal - minVal) / bSize + 1;
    Bucket[] buckets = new Bucket[bCount];


Note that simply use __input.length__ as bucket count is wrong. 

### Code

My code written in Java:

    public class Solution {
        public int maximumGap(int[] num) {
            if (num == null || num.length < 2) {
                return 0;
            }

            // find out max and min values of input
            int minVal = num[0];
            int maxVal = num[0];
            for (int n: num) {
                minVal = Math.min(minVal, n);
                maxVal = Math.max(maxVal, n);
            }
            // bSize is size of bucket (should be larger by 1)
            int bSize = (maxVal - minVal + 1) / num.length + 1;

            // calcualte number of buckets needed
            int bCount = (maxVal - minVal) / bSize + 1;
            Bucket[] buckets = new Bucket[bCount];

            // match every value into a bucket
            // bucket maintains the max/min within the bucket
            for (int n: num) {
                int bIndex = (n - minVal) / bSize;
                if (buckets[bIndex] == null) {
                    buckets[bIndex] = new Bucket(n, n);
                } else {
                    buckets[bIndex].updateVal(n);
                }
            }

            // for every bucket, check in sequence and get max gap
            int gap = 0;
            int pre = 0;
            int cur = 1;
            while (cur < bCount) {
                // skip all empty buckets
                while (cur < bCount && buckets[cur] == null) {
                    cur++;
                }
                if (cur == bCount) break;
                // update gap, pre and cur
                gap = Math.max(gap, buckets[cur].min - buckets[pre].max);
                pre = cur;
                cur++;
            }

            return gap;
        }

        class Bucket {
            int min;
            int max;

            public Bucket(int a, int b) {
                min = a;
                max = b;
            }

            public void updateVal(int val) {
                min = Math.min(min, val);
                max = Math.max(max, val);
            }
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 172] Factorial Trailing Zeroes ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/13/Factorial-Trailing-Zeroes/"/>
    <updated>2015-04-13T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/13/Factorial-Trailing-Zeroes</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/factorial-trailing-zeroes/)

<div class="question-content">
              <p></p><p>Given an integer <i>n</i>, return the number of trailing zeroes in <i>n</i>!.</p>

<p><b>Note: </b>Your solution should be in logarithmic time complexity.</p>

<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/math/">Math</a>
                  
                </span>
              
            </div>

### Analysis

This question I've seen it quite a few time, also. We're basically count the number of factor 5s. 

Eg. 

> n = 5, count = 1

> n = 6, count = 1

> n = 10, count = 2

> n = 24, count = 4

> n = 25, count = 6

> n = 26, count = 6

### Solution

Please read this post __[[LintCode] Trailing Zeros of Factorial({% post_url /question/2014-07-02-Trailing-Zero-of-Factorial %})__. 

### Code

    public class Solution {
        public int trailingZeroes(int n) {
            if (n < 5) {
                return 0;
            }
            int res = 0;
            long base = 5;
            while (n >= base) {
                res += n / base;
                base *= 5;
            }
            return res;
        }
    }

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 168] Excel Sheet Column Number ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/13/Excel-Sheet-Column-Title/"/>
    <updated>2015-04-13T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/13/Excel-Sheet-Column-Title</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/excel-sheet-column-number/)

<div class="question-content">
              <p></p><p>Related to question <a href="https://oj.leetcode.com/problems/excel-sheet-column-title/">Excel Sheet Column Title</a></p>
<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>

<p>For example:</p>
<pre>    A -&gt; 1
    B -&gt; 2
    C -&gt; 3
    ...
    Z -&gt; 26
    AA -&gt; 27
    AB -&gt; 28 </pre>

<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/math/">Math</a>
                  
                </span>
              
            </div>

### Analysis

This question I've seen it quite a few time. It's very standard integer conversion question. 

### Solution

Please read this post __[[ItInt5] Excel Decimal Conversion({% post_url /question/2014-08-16-Excel-decimal-conversion %})__. 

### Code

recursively:

    public class Solution {
        public String convertToTitle(int n) {
            if (n < 1) {
                return "";
            }
            n--;
            char ch = (char) ((n % 26) + 'A');
            return convertToTitle(n / 26) + ch;
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 162] Find Peak Element ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/12/Find-Peak-Element/"/>
    <updated>2015-04-12T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/12/Find-Peak-Element</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/find-peak-element/)

<div class="question-content">
              <p></p><p>A peak element is an element that is greater than its neighbors.</p>

<p>Given an input array where <code>num[i] ? num[i+1]</code>, find a peak element and return its index.</p>

<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>

<p>You may imagine that <code>num[-1] = num[n] = -8</code>.</p>

<p>For example, in array <code>[1, 2, 3, 1]</code>, 3 is a peak element and your function should return the index number 2.</p>

<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show spoilers.</a></p>

<div class="spoilers" style="display: none;"><b>Note:</b>
<p>Your solution should be in logarithmic complexity.</p>
</div>

<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/array/">Array</a>
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/binary-search/">Binary Search</a>
                  
                </span>
              
            </div>

### Analysis

This basically is a binary search question. Instead of checking the values, we check the slope (upgoing or downslope). 

__The important point__ is the special cases like [1, 2, 3] or [3, 2, 1], we need to return the corner values. Well there're 2 ways to handle these corner cases. 

### Solution

First, referring to [G4G](http://www.geeksforgeeks.org/find-a-peak-in-a-given-array/), the corner case is handled in this way: 

    if ((mid == 0 || arr[mid-1] <= arr[mid]) &&
            (mid == n-1 || arr[mid+1] <= arr[mid]))
        return mid;

The code 1 below is doing similar things. That code is readable and easy to come up with. I recommend this solution during a interview. 

For those who are interested, there is a extremely concise solution thanks to [Duplan](http://blog.csdn.net/u010367506/article/details/41943309). I have the Java version posted below as code 2. 

### Code

Code 1

    public class Solution {
        public int findPeakElement(int[] num) {
            if (num == null || num.length == 0) {
                return 0;
            } else if (num.length == 1) {
                return 0;
            } else if (num[0] > num[1]) {
                return 0;
            } else if (num[num.length - 2] < num[num.length - 1]) {
                return num.length - 1;
            }
            // now the leftmost edge is increasing
            // and the rightmost edge is also increasing backwards
            return helper(num, 0, num.length - 1);
        }

        public int helper(int[] num, int left, int right) {
            int mid = left + (right - left) / 2;
            if (left + 2 == right) {
                return mid;
            } else if (num[mid] > num[mid + 1]) {
                // middle is decreasing, so peak on the left side
                return helper(num, left, mid + 1);
            } else {
                return helper(num, mid, right);
            }
        }
    }

Code 2

    public class Solution {
        public int findPeakElement(int[] num) {
            if (num == null || num.length == 0) {
                return 0;
            }
            return helper(num, 0, num.length - 1);
        }

        public int helper(int[] num, int left, int right) {
            int mid = left + (right - left) / 2;
            if (left == right) {
                return left;
            } else if (num[mid] > num[mid + 1]) {
                // middle is decreasing, so peak on the left side
                return helper(num, left, mid);
            } else {
                return helper(num, mid + 1, right);
            }
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 165] Compare Version Numbers ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/12/Compare-Version-Numbers/"/>
    <updated>2015-04-12T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/12/Compare-Version-Numbers</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/compare-version-numbers/)

<div class="question-content">
              <p></p><p>Compare two version numbers <i>version1</i> and <i>version2</i>.<br>
If <i>version1</i> &gt; <i>version2</i> return 1, if <i>version1</i> &lt; <i>version2</i> return -1, otherwise return 0.</p>

<p>You may assume that the version strings are non-empty and contain only digits and the <code>.</code> character.<br>
The <code>.</code> character does not represent a decimal point and is used to separate number sequences.<br>
For instance, <code>2.5</code> is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.</p>

<p>Here is an example of version numbers ordering:</p>
<pre>0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37</pre>

<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="www.shuatiblog.com/tag/string/">String</a>
                  
                </span>
              
            </div>

### Analysis

I've seen a couple of interesting ideas on other people's blogs, including [one](http://www.programcreek.com/2014/03/leetcode-compare-version-numbers-java/) that uses String.split() to convert input to an array, and [this one](http://www.meetqun.com/thread-3331-1-1.html) which uses 2 pointers to compare. 

My solution might seem more intuitive for some. See below for my solution. 

### Solution

The idea is to identify what the current number is (before end of string, or before the next '.'). If there's no more string, value = 0, so the case of (1.0, 1) essentially equals. Without further ado, let's look at the code. 

### Code

    public class Solution {
        public int compareVersion(String version1, String version2) {
            if (version1 == null || version2 == null) {
                return 0;
            }
            return helper(version1, version2);
        }

        private int helper(String v1, String v2) {
            if (v1.length() == 0 && v2.length() == 0) {
                return 0;
            }

            int num1 = 0;
            int num2 = 0;

            if (v1.length() != 0) {
                int p1 = 0;
                while (p1 < v1.length() && v1.charAt(p1) != '.') {
                    p1++;
                }
                num1 = Integer.parseInt(v1.substring(0, p1));
                if (p1 < v1.length()) p1++;
                v1 = v1.substring(p1);
            }

            if (v2.length() != 0) {
                int p2 = 0;
                while (p2 < v2.length() && v2.charAt(p2) != '.') {
                    p2++;
                }
                num2 = Integer.parseInt(v2.substring(0, p2));
                if (p2 < v2.length()) p2++;
                v2 = v2.substring(p2);
            }

            if (num1 != num2) {
                return (num1 - num2) / Math.abs(num1 - num2);
            } else {
                return helper(v1, v2);
            }
        }
    }
]]></content>
  </entry>
  
</feed>
