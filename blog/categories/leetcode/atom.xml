<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | Shuatiblog.com]]></title>
  <link href="http://okckd.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-04-07T21:24:55+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[shuati]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[LeetCode 155] Min Stack ]]></title>
    <link href="http://okckd.github.io/blog/2015/04/07/Min-Stack/"/>
    <updated>2015-04-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/04/07/Min-Stack</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/min-stack/)

<div class="question-content">
              <p></p><p>
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
</p><ul>
<li>
push(x) -- Push element x onto stack.
</li>
<li>
pop() -- Removes the element on top of the stack.
</li>
<li>
top() -- Get the top element.
</li>
<li>
getMin() -- Retrieve the minimum element in the stack.
</li>
</ul>
<p></p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/stack/">Stack</a>
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/data-structure/">Data Structure</a>
                  
               snâ€™t look possible to go to left half or right half by doing constant number of comparisons at the mSolution </span>
</div>

### Analysis

I've already cover this question in another post __[Question] Min Stack__. 

### My Code

    class MinStack {

        Stack<Integer> stack = new Stack<Integer>();
        Stack<Integer> min = new Stack<Integer>();

        public void push(int x) {
            stack.push(x);
            if (min.isEmpty() || min.peek() >= x) {
                min.push(x);
            }
        }

        public void pop() {
            if (stack.isEmpty()) {
                return;
            }
            int topNum = stack.pop();
            if (topNum == min.peek()) {
                min.pop();
            }
        }

        public int top() {
            if (stack.isEmpty()) {
                return 0;
            }
            return stack.peek();
        }

        public int getMin() {
            if (min.isEmpty()) {
                return 0;
            }
            return min.peek();
        }
    }

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 152] Maximum Product Subarray ]]></title>
    <link href="http://okckd.github.io/blog/2015/04/07/Maximum-Product-Subarray/"/>
    <updated>2015-04-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/04/07/Maximum-Product-Subarray</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/maximum-product-subarray/)

<div class="question-content">
              <p></p><p>
Find the contiguous subarray within an array (containing at least one number) which has the largest product.
</p>

<p>
For example, given the array <code>[2,3,-2,4]</code>,<br>
the contiguous subarray <code>[2,3]</code> has the largest product = <code>6</code>.
</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/array/">Array</a>
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/dynamic-programming/">Dynamic Programming</a>
                  
                </span>
              
            </div>

### Analysis

__This is a pretty difficult question__. It's hard to write bug-free solution if you have never practised before. 

So the first idea that comes to me is the case of array element = 0. Why this case? cuz the maximum subarray MUST NOT CONTAIN 0 unless the input is like {-1, 0, -1}. So we could divide array from 0s and calculate max sum seperately. This idea is good, though a little difficult in coding. Read it [here](http://www.geeksforgeeks.org/maximum-product-subarray/) or [here](https://shepherdyuan.wordpress.com/2014/07/23/linkedin-maximum-sumproduct-subarray/). 

### Solution

After a bit exploration, I found a must easier apporach, thanks to [code ganker](http://blog.csdn.net/linhuanmars/article/details/39537283) and [Yu](http://yucoding.blogspot.sg/2014/10/leetcode-quesion-maximum-product.html). The idea is to simply ALWAYS CALCULATE preMax and preMin by using MAX/MIN(Val1, Val2, Val3) method.  

### My Code

    public class Solution {
        public int maxProduct(int[] A) {
            if (A == null || A.length == 0) {
                return 0;
            } else if (A.length == 1) {
                return A[0];
            }

            int preMax = A[0];
            int preMin = A[0];
            int max = A[0];

            for (int i = 1; i < A.length; i++) {
                int temp = preMin;
                preMin = Math.min(Math.min(preMin * A[i], preMax * A[i]), A[i]);
                preMax = Math.max(Math.max(temp * A[i], preMax * A[i]), A[i]);
                max = Math.max(max, preMax);
            }

            return max;
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 154] Find Minimum in Rotated Sorted Array II ]]></title>
    <link href="http://okckd.github.io/blog/2015/04/07/Find-Minimum-in-Rotated-Sorted-Array-II/"/>
    <updated>2015-04-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/04/07/Find-Minimum-in-Rotated-Sorted-Array-II</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/)

<div class="question-content">
              <p></p><blockquote>
<p><i>Follow up</i> for "Find Minimum in Rotated Sorted Array":<br>
What if <i>duplicates</i> are allowed?</p>

<p>Would this affect the run-time complexity? How and why?</p>
</blockquote>

<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>

<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>

<p>Find the minimum element.</p>

<p>The array may contain duplicates.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/array/">Array</a>
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/binary-search/">Binary Search</a>
      about/            
                </span>
              
            </div>

### Solution

This question is simply a modified version of previous question. The special cases of the input makes it O(n) worst case complexity. 

### My Code

    public class Solution {
        public int findMin(int[] num) {
            if (num == null || num.length == 0) {
                return 0;
            }
            return helper(num, 0, num.length - 1);
        }

        private int helper(int[] num, int left, int right) {
            if (num[left] < num[right] || left == right) {
                return num[left];
            } else if (num[left] == num[right]) {
                return helper(num, left + 1, right);
            } else if (left + 1 == right) {
                return num[right];
            }
            int mid = left + (right - left) / 2;
            if (num[mid] >= num[left]) {
                return helper(num, mid, right);
            } else {
                return helper(num, left, mid);
            }
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 153] Find Minimum in Rotated Sorted Array ]]></title>
    <link href="http://okckd.github.io/blog/2015/04/07/Find-Minimum-in-Rotated-Sorted-Array/"/>
    <updated>2015-04-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/04/07/Find-Minimum-in-Rotated-Sorted-Array</id>
    <content type="html"><![CDATA[### Question 

[link](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

<div class="question-content">
              <p></p><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>

<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>

<p>Find the minimum element.</p>

<p>You may assume no duplicate exists in the array.</p><p></p>
              
                <div id="tags" class="btn btn-xs btn-warning">Show Tags</div>
                <span class="hide">
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/array/">Array</a>
                  
                  <a class="btn btn-xs btn-primary" href="http://okckd.github.io/tag/binary-search/">Binary Search</a>
                  
                </span>
              
            </div>

### Analysis

This question is very similar to __[LeetCode 33] Search in Rotated Sorted Array__. Note a few special cases. 

### Solution

Very good code can be found [here](http://www.programcreek.com/2014/02/leetcode-find-minimum-in-rotated-sorted-array/) and [here](http://www.sanfoundry.com/java-program-find-minimum-element-rotated-sorted-array-using-binary-search-approach/). 

### My Code

    public class Solution {
        public int findMin(int[] num) {
            if (num == null || num.length == 0) {
                return 0;
            }
            return helper(num, 0, num.length - 1);
        }

        private int helper(int[] num, int left, int right) {
            if (num[left] <= num[right]) {
                return num[left];
            } else if (left + 1 == right) {
                return num[right];
            }
            int mid = left + (right - left) / 2;
            if (num[mid] > num[left]) {
                return helper(num, mid, right);
            } else {
                return helper(num, left, mid);
            }
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 151] Reverse Words in a String]]></title>
    <link href="http://okckd.github.io/blog/2014/06/03/Reverse-Words-in-a-String/"/>
    <updated>2014-06-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/03/Reverse-Words-in-a-String</id>
    <content type="html"><![CDATA[### Question 
[link](https://oj.leetcode.com/problems/reverse-words-in-a-string/)

<div class="question-content bg-color bg-img font-color">
<p class="font-color"></p><p class="font-color">
Given an input string, reverse the string word by word.
</p>

<p class="font-color">
For example,<br>
Given s = "<code>the sky is blue</code>",<br>
return "<code>blue is sky the</code>".
</p>

<div>
<b>Clarification:</b>

<p class="font-color">
</p><ul class="bg-color bg-img font-color">
<li>What constitutes a word?<br>
A sequence of non-space characters constitutes a word.</li>
<li>Could the input string contain leading or trailing spaces?<br>
Yes. However, your reversed string should not contain leading or trailing spaces.</li>
<li>How about multiple spaces between two words?<br>
Reduce them to a single space in the reversed string.</li>
</ul>
<p class="font-color"></p>
</div><p class="font-color"></p>
          </div>

### Stats
<table border="2">
	<tr>
		<td>Adjusted Difficulty</td>
		<td bgcolor="yellow">3</td>
	</tr>
	<tr>
		<td>Time to use</td>
		<td bgcolor="yellow">--------</td>
	</tr>
</table>

Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)

### Analysis

__This is an very classic question__, and there is a very nice solution. 

### Solution

__First solution is read each character from the back, and insert each word into answer String__. I used this method, and passed in 2 attempts. I have always been afriad of string question, and this time it gave me an easy time. 

I post my code below. Altough it can be better if I use StringBuilder. Most blog/forum would give this solution including [this one](https://oj.leetcode.com/discuss/3378/is-my-solution-good-enough). 

However, previous solution uses extra space. __We can do it in-place suggested by [this post](http://stackoverflow.com/a/1009174)__. 

<blockquote cite="http://stackoverflow.com/a/1009174">
    <p class="font-color">Reverse the entire string, then reverse the letters of each individual word.</p>

    <p class="font-color">After the first pass the string will be</p>

    <pre><code>s1 = "Z Y X si eman yM"
    </code></pre>

    <p class="font-color">and after the second pass it will be</p>

    <pre><code>s1 = "Z Y X is name My"
    </code></pre>
</blockquote>

There are 2 things to note. 

__One, the edge cases__ are easily omitted, like all-space input, double-space in between, and a lot more. 

__Two, The Clarification part is extremely helpful__ for writing a bug-free solution. It's always better to clarify further about what the question is ask. For example, can we use __String.split()__ and __String.substring()__? (normally we would better not to) Can we use any extra space? That decides weather we copy by substring or by character. 

In conclusion, __this is an easy question that's not easy to get correct answer__. Practise more! And since this is the last post of Leetcode questions, my focus from tomorrow onwards will be shifted to "CC150". Thanks for reading! 

### Code

__My code__. pointer solution. 

    public String reverseWords(String s) {
		if (s.length() == 0) return "";
		int p = s.length() - 1;
		// p points to the last non-space character
		String ans = "";
		while (p >= 0) {
			int j = p;
			while (j >= 0 && s.charAt(j) != ' ') {
				j --;
			}
			ans += s.substring(j + 1, p + 1) + " ";
			p = j;
			while (p >= 0 && s.charAt(p) == ' ') {
				p--;
			}
		}
		return ans.trim();
    }

__Updated on Sep 12th__: updated with 3-step-reverse method.

    public String reverseWords(String s) {
        if (s == null || s.length() == 0) {
            return s;
        }
        StringBuilder ans = new StringBuilder();
        int len = s.length();
        int p = len - 1;
        while (p >= 0) {
            while (p >= 0 && s.charAt(p) == ' ') {
                p--;
            }
            if (p == -1) {
                break;
            }
            StringBuilder word = new StringBuilder();
            while (p >= 0 && s.charAt(p) != ' ') {
                word.append(s.charAt(p));
                p--;
            }
            if (ans.length() == 0) {
                ans.append(word.reverse().toString());
            } else {
                ans.append(" " + word.reverse().toString());
            }
        }
        return ans.toString();
    }
]]></content>
  </entry>
  
</feed>
