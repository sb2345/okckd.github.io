<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Leetcode | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-17T01:49:43+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Leetcode] Leetcode Second Round (2)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/06/Leetcode-second-two/"/>
    <updated>2014-08-06T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/06/Leetcode-second-two</id>
    <content type="html"><![CDATA[### 2.2 question list

1. Integer to Roman
1. Surrounded Regions - Must minimize stack usage
1. Jump Game II
1. Gas Station
1. Remove Duplicates from Sorted Array
1. Remove Duplicates from Sorted Array II
1. Gray Code 
1. Combination Sum II
1. Merge Intervals - Comparator\<T\> API
1. Scramble String
1. Permutation Sequence - Avoid indexing errors
1. Distinct Subsequences
1. Word Search
1. First Missing Positive - consider all special cases
1. Merge k Sorted Lists
1. Permutations II - duplication removal
1. Palindrome Partitioning II
1. Longest Valid Parentheses
1. Word Ladder
1. Minimum Window Substring - only check left bound when count = length
1. Median of Two Sorted Arrays - note the main logic conditions
1. Largest Rectangle in Histogram - be careful when coding

### Difficult

1. Regular Expression Matching
1. Wildcard Matching
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Leetcode] Leetcode Second Round]]></title>
    <link href="http://okckd.github.io/blog/2014/07/08/Leetcode-second-round/"/>
    <updated>2014-07-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/08/Leetcode-second-round</id>
    <content type="html"><![CDATA[### Question List

1. Integer to Roman
1. Reverse Linked List II
1. ZigZag Conversion
1. Surrounded Regions - constant space
1. Longest Palindromic Substring
1. Candy
1. Rotate List
1. Remove Duplicates from Sorted Array
1. Remove Duplicates from Sorted Array II
1. Validate Binary Search Tree - use intervals
1. Gray Code 
1. Combination Sum II
1. Add Binary
1. Merge Intervals
1. Scramble String
1. Generate Parentheses 
1. Permutation Sequence 
1. Substring with Concatenation of All Words 
1. String to Integer (atoi)

### Difficult

1. Gas Station
1. Reverse Words in a String
1. Word Search
1. Container With Most Water
1. First Missing Positive - note there's 1 special case
1. Sort List
1. Anagrams
1. Merge k Sorted Lists - very difficult
1. Permutations II - use different DS for flagging elements
1. Palindrome Partitioning II
1. Word Ladder
1. Largest Rectangle in Histogram
1. Minimum Window Substring - difficult
1. Longest Valid Parentheses - difficult
1. Median of Two Sorted Arrays - difficult
1. Regular Expression Matching
1. Wildcard Matching

### Special

1. water, rain and histogram etc.

1. word and string-related
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 151] Reverse Words in a String]]></title>
    <link href="http://okckd.github.io/blog/2014/06/03/Reverse-Words-in-a-String/"/>
    <updated>2014-06-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/03/Reverse-Words-in-a-String</id>
    <content type="html"><![CDATA[### Question 
[link](https://oj.leetcode.com/problems/reverse-words-in-a-string/)

<div class="question-content bg-color bg-img font-color">
<p class="font-color"></p><p class="font-color">
Given an input string, reverse the string word by word.
</p>

<p class="font-color">
For example,<br>
Given s = "<code>the sky is blue</code>",<br>
return "<code>blue is sky the</code>".
</p>

<div>
<b>Clarification:</b>

<p class="font-color">
</p><ul class="bg-color bg-img font-color">
<li>What constitutes a word?<br>
A sequence of non-space characters constitutes a word.</li>
<li>Could the input string contain leading or trailing spaces?<br>
Yes. However, your reversed string should not contain leading or trailing spaces.</li>
<li>How about multiple spaces between two words?<br>
Reduce them to a single space in the reversed string.</li>
</ul>
<p class="font-color"></p>
</div><p class="font-color"></p>
          </div>

### Stats
<table border="2">
	<tr>
		<td>Adjusted Difficulty</td>
		<td bgcolor="yellow">3</td>
	</tr>
	<tr>
		<td>Time to use</td>
		<td bgcolor="yellow">--------</td>
	</tr>
</table>

Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)

### Analysis

__This is an very classic question__, and there is a very nice solution. 

### Solution

__First solution is read each character from the back, and insert each word into answer String__. I used this method, and passed in 2 attempts. I have always been afriad of string question, and this time it gave me an easy time. 

I post my code below. Altough it can be better if I use StringBuilder. Most blog/forum would give this solution including [this one](https://oj.leetcode.com/discuss/3378/is-my-solution-good-enough). 

However, previous solution uses extra space. __We can do it in-place suggested by [this post](http://stackoverflow.com/a/1009174)__. 

<blockquote cite="http://stackoverflow.com/a/1009174">
    <p class="font-color">Reverse the entire string, then reverse the letters of each individual word.</p>

    <p class="font-color">After the first pass the string will be</p>

    <pre><code>s1 = "Z Y X si eman yM"
    </code></pre>

    <p class="font-color">and after the second pass it will be</p>

    <pre><code>s1 = "Z Y X is name My"
    </code></pre>
</blockquote>

There are 2 things to note. 

__One, the edge cases__ are easily omitted, like all-space input, double-space in between, and a lot more. 

__Two, The Clarification part is extremely helpful__ for writing a bug-free solution. It's always better to clarify further about what the question is ask. For example, can we use __String.split()__ and __String.substring()__? (normally we would better not to) Can we use any extra space? That decides weather we copy by substring or by character. 

In conclusion, __this is an easy question that's not easy to get correct answer__. Practise more! And since this is the last post of Leetcode questions, my focus from tomorrow onwards will be shifted to "CC150". Thanks for reading! 

### Code

__My code__. pointer solution. 

    public String reverseWords(String s) {
		if (s.length() == 0) return "";
		int p = s.length() - 1;
		// p points to the last non-space character
		String ans = "";
		while (p >= 0) {
			int j = p;
			while (j >= 0 && s.charAt(j) != ' ') {
				j --;
			}
			ans += s.substring(j + 1, p + 1) + " ";
			p = j;
			while (p >= 0 && s.charAt(p) == ' ') {
				p--;
			}
		}
		return ans.trim();
    }

__Updated on June 9th, the in-place solution__

Note that String.split() behaves strangely when there is space char. So it's necessary to check (str==""). Eg: 

> " a  b c " -> after String.split(" ") -> [, a, , b, c]

    public String reverseWords(String s) {
		if (s == null || s.length() == 0) {
			return s;
		}
		String[] words = s.split(" ");
		String firstReversed = "";
		for (int i = 0; i < words.length; i ++) {
		    if (words[i].equals("")) continue;
			firstReversed += inPlaceReverse(words[i]) + " ";
		}
		return inPlaceReverse(firstReversed);
    }
	
	private String inPlaceReverse(String str) {
		if (str == null || str.length() == 0) return str;
		char[] chars = str.trim().toCharArray();
		int left = 0;
		int right = chars.length - 1;
		while (left < right) {
			char temp = chars[left];
			chars[left] = chars[right];
			chars[right] = temp;
			left ++;
			right --;
		}
		return String.valueOf(chars);
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 143] Reorder List]]></title>
    <link href="http://okckd.github.io/blog/2014/06/03/Reorder-List/"/>
    <updated>2014-06-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/03/Reorder-List</id>
    <content type="html"><![CDATA[### Question 
[link](https://oj.leetcode.com/problems/reorder-list/)

<div class="question-content bg-color bg-img font-color">
            <p class="font-color"></p><p class="font-color">
Given a singly linked list <i>L</i>: <i>L</i><sub>0</sub>→<i>L</i><sub>1</sub>→…→<i>L</i><sub><i>n</i>-1</sub>→<i>L</i><sub>n</sub>,<br>
reorder it to: <i>L</i><sub>0</sub>→<i>L</i><sub><i>n</i></sub>→<i>L</i><sub>1</sub>→<i>L</i><sub><i>n</i>-1</sub>→<i>L</i><sub>2</sub>→<i>L</i><sub><i>n</i>-2</sub>→…
</p>

<p class="font-color">You must do this in-place without altering the nodes' values.</p>

<p class="font-color">
For example,<br>
Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.
</p><p class="font-color"></p>
          </div>

### Stats
<table border="2">
	<tr>
		<td>Adjusted Difficulty</td>
		<td bgcolor="red">4</td>
	</tr>
	<tr>
		<td>Time to use</td>
		<td bgcolor="red">--------</td>
	</tr>
</table>

Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)

### Analysis

__This is a difficult question to think__. 

I first solved it with an stack which stores the second half nodes. It works. However, IT IS NOT A IN-PLACE SOLUTION, thus it's wrong. 

Eventually I did not solve it. 

__There is only one standard solution from the Internet__. [This blog](http://www.programcreek.com/2013/12/in-place-reorder-a-singly-linked-list-in-java/) explains it. 

> 1. Break list in the middle to two lists (use fast & slow pointers)
> 2. Reverse the order of the second list
> 3. Merge two list back together

Simple, right? __Because of the nature of linked list, a lot of things can be done in-place__, so we need not use any other data strucutres. 

### Solution

The code is a bit lengthy and difficult to write. It took me a while, but passed in 1 go. 

### Code

__First, code written by me__

    public void reorderList(ListNode head) {
        if (head == null || head.next == null) {
			return;
		}
		ListNode slow = head, fast = head;
		while (fast != null) {
			if (fast.next != null && fast.next.next != null) {
				fast = fast.next.next;
				slow = slow.next;
			}
			else {
				fast = null;
			}
		}
		// if length = 2, slow point to 1st
		// if length = 3, slow point to 2nd
		// if length = 4, slow point to 2nd
		ListNode secondHalf = slow.next;
		slow.next = null;
		// now reverse secondHalf
		ListNode p = secondHalf;
		while (p.next != null) {
			ListNode tail = p.next.next;
			p.next.next = secondHalf;
			secondHalf = p.next;
			p.next = tail;
		}
		// now merge 2 list: head and secondHalf
		ListNode a = head, b = secondHalf;
		while (a != null && b != null) {
			ListNode temp1 = a.next;
			ListNode temp2 = b.next;
			a.next = b;
			b.next = temp1;
			a = temp1;
			b = temp2;
		}
    }

__Second, code written by [someone](https://oj.leetcode.com/discuss/236/does-this-problem-solution-time-complexity-space-comlexity)__

    public void reorderList(ListNode head) {
        // IMPORTANT: Please reset any member data you declared, as
        // the same Solution instance will be reused for each test case.
        if (head == null || head.next == null) return;
        ListNode fast = head;
        ListNode slow = head;
        while(fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        ListNode reverseHead = slow.next;           // find the second half of list
        slow.next = null;                           // make first half end point to null
        reverseHead = reverse(reverseHead);         // reverse second half     
        ListNode cur = head;        
        while(reverseHead != null) {                // link together
            ListNode tmp = reverseHead.next;
            reverseHead.next = cur.next;
            cur.next = reverseHead;
            cur = cur.next.next;
            reverseHead = tmp;
        }
    }
    private ListNode reverse(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode prev = new ListNode(0);
        prev.next = head;
        head = prev;
        ListNode cur = prev.next;
        while(cur.next != null) {
            ListNode tmp = cur.next;
            cur.next = tmp.next;
            tmp.next = prev.next;
            prev.next = tmp;
        }
        return prev.next;
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 149] Max Points on a Line]]></title>
    <link href="http://okckd.github.io/blog/2014/06/03/Max-Points-on-a-Line/"/>
    <updated>2014-06-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/03/Max-Points-on-a-Line</id>
    <content type="html"><![CDATA[### Question 
[link](https://oj.leetcode.com/problems/max-points-on-a-line/)

<div class="question-content bg-color bg-img font-color">
            <p class="font-color"></p><p class="font-color">Given <i>n</i> points on a 2D plane, find the maximum number of points that lie on the same straight line.</p><p class="font-color"></p>
          </div>

### Stats
<table border="2">
	<tr>
		<td>Adjusted Difficulty</td>
		<td bgcolor="red">5</td>
	</tr>
	<tr>
		<td>Time to use</td>
		<td bgcolor="red">--------</td>
	</tr>
</table>

Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)

### Analysis

__This is a difficult coding question__.

The idea is simple. For n points, there are n * (n-1) lines. Check slopes and then count total, we would get the answer. 

However, coding of this idea is very difficult. 

### Solution

__Firstly, there are 2 special cases when calculating the slope__. The 2 points may locate in same position. And when point1.x = point2.x, slope = infinity. It's easy to omit these 2 cases and result in mistake. 

Secondly, when we count, we declare 2 variables: samePointNumber and maxPointCountWithSameSlope. __It's very important to initialize both values to 1 instead of 0__! Why? Because these values just can't be 0. I failed my 2nd version code when input = {(0,0), (0,0)}, the program shows result of 0, instead of 2. 

__Thirdly, about what data structure to use for counting__. There is a discussion about this at [here](https://oj.leetcode.com/discuss/2573/better-way-to-use-hashmap-for-this-question)

> 1. storing the vertical slopes as Double.NaN. That allows Double to represent every slope uniquely as (y/x). 
> 2. It is unsafe using floating points to make a hash, and -0.0 != 0.0

It's great that using __Double.NaN__, it saves us time and effort to count vertical points. Second point is very valid, but it turns out that using HashMap<Double, Integer> can AC. 

P.S. It is always not a good practise to use Double as hash key. See [here](http://stackoverflow.com/questions/1074781/double-in-hashmap). 

__Fourthly, I made a mistake here__: 

> double slope = (p.y - q.y) / (p.x - q.x);

And it's wrong. Why? Note that __Point.x and Point.y are both integers__. Integer division will return integer. We must cast it. 

> double slope = (double) (p.y - q.y) / (p.x - q.x);

__Last, OMG I wish this is last, but not least, we can reduce execution time to half__ by checking only the points with larger index than the anchor point (that's the name for 'current point'). Good idea, right? 

One more thing, __how to iterate thru the HashMap__ (value only)? There is an easy way: 

    for (Integer a : map.values()) {
        a;
    }

That's all I've found for now. 

__Updated on Aug 12th, 2014__ 

Based on the solution given in CC150 v4 Q10.6 on Page 199, it's a __proper way to solve with HashMap<Line, Integer>__ instead of using HashMap<Double, Integer>. 

The reason is mentioned, it's '__unsafe using floating points to make a hash__'. 

Note that if we were to write our own 'Line' class, __we must override the 2 methods__:

1. public int hashCode() {}
1. public boolean equals(Object o) {}

### Code

__written by me, version 3 using HashMap__

	public int maxPoints(Point[] points) {
		if (points.length <= 1)
			return points.length;
		HashMap<Double, Integer> map = null;
		int totalMax = 0;
		for (Point p : points) {
			int samePoint = 1;
			map = new HashMap<Double, Integer>();
			for (Point q : points) {
				if (q == p || p.x > q.x) {
				} else if (p.x == q.x && p.y == q.y) {
					samePoint++;
				} else {
					double slope = Double.NaN;
					if (p.x != q.x) {
						slope = (double) (p.y - q.y) / (p.x - q.x);
					}
					if (!map.containsKey(slope)) {
						map.put(slope, 1);
					}
					map.put(slope, map.get(slope) + 1);
				}
			}
			int pointMax = 1;
			for (Integer a : map.values()) {
				pointMax = Math.max(pointMax, a);
			}
			totalMax = Math.max(totalMax, pointMax + samePoint - 1);
		}
		return totalMax;
	}
]]></content>
  </entry>
  
</feed>
