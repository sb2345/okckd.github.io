<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Leetcode | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-10-24T14:53:50+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Leetcode] Leetcode Third Round (1)]]></title>
    <link href="http://okckd.github.io/blog/2014/10/03/Leetcode-third-1/"/>
    <updated>2014-10-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/10/03/Leetcode-third-1</id>
    <content type="html"><![CDATA[    Days:        02/10/2014 - start
    Submission:  
    Pass:        
    
    Submit/day:  
    Pass/day:    
    
    Pass/submit: 

### Question List

1. Substring with Concatenation of All Words
1. Palindrome Partitioning II
1. Reverse Words in a String 
1. LRU Cache
1. Binary Tree Postorder Traversal
1. Word Ladder
1. Clone Graph
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Leetcode] Leetcode Second Round (3)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/18/Leetcode-second-3/"/>
    <updated>2014-08-18T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/18/Leetcode-second-3</id>
    <content type="html"><![CDATA[1. Gas Station
1. Trapping Rain Water
1. Remove Duplicates from Sorted Array II
1. Word Search
1. First Missing Positive
1. Permutations II
1. Palindrome Partitioning II
1. Word Ladder
1. Minimum Window Substring
1. Largest Rectangle in Histogram
1. LRU Cache

additional

1. Clone Graph
1. Regular Expression Matching - difficult
1. Wildcard Matching - very difficult, still
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Leetcode] Leetcode Second Round (2)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/06/Leetcode-second-2/"/>
    <updated>2014-08-06T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/06/Leetcode-second-2</id>
    <content type="html"><![CDATA[### 2.2 question list

1. Integer to Roman
1. Surrounded Regions - Must minimize stack usage
1. Jump Game II
1. Gas Station
1. Remove Duplicates from Sorted Array
1. Remove Duplicates from Sorted Array II
1. Gray Code 
1. Combination Sum II
1. Merge Intervals - Comparator\<T\> API
1. Scramble String
1. Permutation Sequence - Avoid indexing errors
1. Distinct Subsequences
1. Word Search
1. First Missing Positive - consider all special cases
1. Merge k Sorted Lists
1. Permutations II - duplication removal
1. Palindrome Partitioning II
1. Longest Valid Parentheses
1. Word Ladder
1. Minimum Window Substring - only check left bound when count = length
1. Median of Two Sorted Arrays - note the main logic conditions
1. Largest Rectangle in Histogram - be careful when coding

### Difficult

1. Regular Expression Matching
1. Wildcard Matching
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Leetcode] Leetcode Second Round (1)]]></title>
    <link href="http://okckd.github.io/blog/2014/07/08/Leetcode-second-1/"/>
    <updated>2014-07-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/08/Leetcode-second-1</id>
    <content type="html"><![CDATA[    Days:        12
    Submission:  427
    Pass:        144
    
    Submit/day:  35.6
    Pass/day:    12
    
    Pass/submit: 0.34

### Question List

1. Integer to Roman
1. Reverse Linked List II
1. ZigZag Conversion
1. Surrounded Regions - constant space
1. Longest Palindromic Substring
1. Candy
1. Rotate List
1. Remove Duplicates from Sorted Array
1. Remove Duplicates from Sorted Array II
1. Validate Binary Search Tree - use intervals
1. Gray Code 
1. Combination Sum II
1. Add Binary
1. Merge Intervals
1. Scramble String
1. Generate Parentheses 
1. Permutation Sequence 
1. Substring with Concatenation of All Words 
1. String to Integer (atoi)

### Difficult

1. Gas Station
1. Reverse Words in a String
1. Word Search
1. Container With Most Water
1. First Missing Positive - note there's 1 special case
1. Sort List
1. Anagrams
1. Merge k Sorted Lists - very difficult
1. Permutations II - use different DS for flagging elements
1. Palindrome Partitioning II
1. Word Ladder
1. Largest Rectangle in Histogram
1. Minimum Window Substring - difficult
1. Longest Valid Parentheses - difficult
1. Median of Two Sorted Arrays - difficult
1. Regular Expression Matching
1. Wildcard Matching

### Special

1. water, rain and histogram etc.

1. word and string-related
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode 151] Reverse Words in a String]]></title>
    <link href="http://okckd.github.io/blog/2014/06/03/Reverse-Words-in-a-String/"/>
    <updated>2014-06-03T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/03/Reverse-Words-in-a-String</id>
    <content type="html"><![CDATA[### Question 
[link](https://oj.leetcode.com/problems/reverse-words-in-a-string/)

<div class="question-content bg-color bg-img font-color">
<p class="font-color"></p><p class="font-color">
Given an input string, reverse the string word by word.
</p>

<p class="font-color">
For example,<br>
Given s = "<code>the sky is blue</code>",<br>
return "<code>blue is sky the</code>".
</p>

<div>
<b>Clarification:</b>

<p class="font-color">
</p><ul class="bg-color bg-img font-color">
<li>What constitutes a word?<br>
A sequence of non-space characters constitutes a word.</li>
<li>Could the input string contain leading or trailing spaces?<br>
Yes. However, your reversed string should not contain leading or trailing spaces.</li>
<li>How about multiple spaces between two words?<br>
Reduce them to a single space in the reversed string.</li>
</ul>
<p class="font-color"></p>
</div><p class="font-color"></p>
          </div>

### Stats
<table border="2">
	<tr>
		<td>Adjusted Difficulty</td>
		<td bgcolor="yellow">3</td>
	</tr>
	<tr>
		<td>Time to use</td>
		<td bgcolor="yellow">--------</td>
	</tr>
</table>

Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)

### Analysis

__This is an very classic question__, and there is a very nice solution. 

### Solution

__First solution is read each character from the back, and insert each word into answer String__. I used this method, and passed in 2 attempts. I have always been afriad of string question, and this time it gave me an easy time. 

I post my code below. Altough it can be better if I use StringBuilder. Most blog/forum would give this solution including [this one](https://oj.leetcode.com/discuss/3378/is-my-solution-good-enough). 

However, previous solution uses extra space. __We can do it in-place suggested by [this post](http://stackoverflow.com/a/1009174)__. 

<blockquote cite="http://stackoverflow.com/a/1009174">
    <p class="font-color">Reverse the entire string, then reverse the letters of each individual word.</p>

    <p class="font-color">After the first pass the string will be</p>

    <pre><code>s1 = "Z Y X si eman yM"
    </code></pre>

    <p class="font-color">and after the second pass it will be</p>

    <pre><code>s1 = "Z Y X is name My"
    </code></pre>
</blockquote>

There are 2 things to note. 

__One, the edge cases__ are easily omitted, like all-space input, double-space in between, and a lot more. 

__Two, The Clarification part is extremely helpful__ for writing a bug-free solution. It's always better to clarify further about what the question is ask. For example, can we use __String.split()__ and __String.substring()__? (normally we would better not to) Can we use any extra space? That decides weather we copy by substring or by character. 

In conclusion, __this is an easy question that's not easy to get correct answer__. Practise more! And since this is the last post of Leetcode questions, my focus from tomorrow onwards will be shifted to "CC150". Thanks for reading! 

### Code

__My code__. pointer solution. 

    public String reverseWords(String s) {
		if (s.length() == 0) return "";
		int p = s.length() - 1;
		// p points to the last non-space character
		String ans = "";
		while (p >= 0) {
			int j = p;
			while (j >= 0 && s.charAt(j) != ' ') {
				j --;
			}
			ans += s.substring(j + 1, p + 1) + " ";
			p = j;
			while (p >= 0 && s.charAt(p) == ' ') {
				p--;
			}
		}
		return ans.trim();
    }

__Updated on Sep 12th__: updated with 3-step-reverse method.

    public String reverseWords(String s) {
        if (s == null || s.length() == 0) {
            return s;
        }
        StringBuilder ans = new StringBuilder();
        int len = s.length();
        int p = len - 1;
        while (p >= 0) {
            while (p >= 0 && s.charAt(p) == ' ') {
                p--;
            }
            if (p == -1) {
                break;
            }
            StringBuilder word = new StringBuilder();
            while (p >= 0 && s.charAt(p) != ' ') {
                word.append(s.charAt(p));
                p--;
            }
            if (ans.length() == 0) {
                ans.append(word.reverse().toString());
            } else {
                ans.append(" " + word.reverse().toString());
            }
        }
        return ans.toString();
    }
]]></content>
  </entry>
  
</feed>
