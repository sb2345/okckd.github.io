<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-02T21:30:27+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Axis Aligned Rectangles]]></title>
    <link href="http://okckd.github.io/blog/2014/09/02/Axis-aligned-rectangle/"/>
    <updated>2014-09-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/02/Axis-aligned-rectangle</id>
    <content type="html"><![CDATA[### Question

[link](http://ankitsambyal.blogspot.sg/2013/10/finding-overlapping-rectangles-in-given.html), MIT handouts Person_A

> Describe an algorithm that takes an unsorted array of axis-aligned rectangles and returns __any pair of__ rectangles that overlaps, if there is such a pair. 

> Axis-aligned means that all the rectangle sides are either parallel or perpendicular to the x- and y-axis. 

> Each rectangle object has two variables: the x-y coordinates of the upper-left corner and the bottom-right corner.

### Analysis

A lot of different solutions on the internet, [eg](http://www.quora.com/Algorithms/Given-a-set-of-n-axis-aligned-rectangles-in-the-plane-find-how-big-is-the-largest-subset-of-these-rectangles-that-contain-a-common-point-in-O-n-3-and-then-in-order-O-nlogn) [eg](http://ankitsambyal.blogspot.sg/2013/10/finding-overlapping-rectangles-in-given.html), and some questions asks you to return all overlapping pairs. For now, we just return __any pair__ that overlaps.

### Solution 

I concluded some solution and come up with this solution (the idea of BST comes from [this pdf](http://www.cs.princeton.edu/~rs/AlgsDS07/17GeometricSearch.pdf)). 

1. sort the input. ]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Find Row With Most 1s]]></title>
    <link href="http://okckd.github.io/blog/2014/09/01/Find-row-with-most-1s/"/>
    <updated>2014-09-01T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/01/Find-row-with-most-1s</id>
    <content type="html"><![CDATA[### Question

[link](http://www.geeksforgeeks.org/find-the-row-with-maximum-number-1s/)

> Given a 2D array with only 1s and 0s, where each row is sorted. 

> Find the row with the maximum number of 1s. Input matrix: 

    0 1 1 1
    0 0 1 1
    1 1 1 1  // this row has maximum 1s
    0 0 0 0

> Output: 2

### Analysis

By using a modified version of binary search, we can achieve __[a O(mLogn) solution](http://www.geeksforgeeks.org/find-the-row-with-maximum-number-1s/)__ where m is number of rows and n is number of columns in matrix. 

__However, there's better solution that works in linear time__! 

### Solution 

1. Get the index of first (or leftmost) 1 in the first row. 

2. Do following for every row after the first row: 

    1. IF the element on left of previous leftmost 1 is 0, ignore this row. 
    
    1. ELSE Move left until a 0 is found. Update the leftmost index to this index and max_row_index to be the current row. 

The time complexity is O(m+n). 

### Code 

__written by me__

	public int solution(int[][] matrix) {
		int m = matrix.length;
		int n = matrix[0].length;
		int p = n;
		int row = -1;
		for (int i = 0; i < m; i++) {
			// now p is larger than 0, otherwise it's already terminated
			if (matrix[i][p - 1] == 0) {
				continue;
			}
			// p points to a 1, now search to the left direction
			for (int j = p - 1; j >= 0; j--) {
				if (matrix[i][j] == 1) {
					p = j;
				} else {
					break;
				}
			}
			// p have a new value now
			if (p == 0) {
				return i;
			} else {
				row = i;
			}
		}
		return row;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Multiples of 3 and 5]]></title>
    <link href="http://okckd.github.io/blog/2014/08/30/multiples-of-3-and-5/"/>
    <updated>2014-08-30T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/30/multiples-of-3-and-5</id>
    <content type="html"><![CDATA[### Question

[link](http://projecteuler.net/problem=1)

> If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

> Find the sum of all the multiples of 3 or 5 below 1000.

### Solution

> The multiples of 3 are 3,6,9,12,15,18,21,24,27,30,....

> The multiples of 5 are 5,10,15,20,25,30,35,40,45,....

> The intersection of these two sequences is 15,30,45,...

<img class="middle" src="/assets/images/multiples-of-3-5.png">

[source](http://math.stackexchange.com/a/9260)
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Equilibrium Points in 2D Array]]></title>
    <link href="http://okckd.github.io/blog/2014/08/27/equilibrium-points-in-2d-array/"/>
    <updated>2014-08-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/27/equilibrium-points-in-2d-array</id>
    <content type="html"><![CDATA[### Question

[link](http://get-that-job-at-google.blogspot.sg/2013/01/twitter-programming-test.html)

> In a 2D matrix of dimensions M*N, find number of "equilibrium" points.  A point (i, j) is said to be an "equilibrium" point only if all following conditions hold:

> a) sum of rows 1...(i-1) =  sum of rows (i+1)...M

> b) sum of columns 1...(j-1)  = sum of columns (j+1)...N

### Solution

This is __a generalize question of __Equilibrium index__. For now, I got no better idea then checking Equilibrium index for every single node in the matrix. 

So this question literally becomes [this](http://www.geeksforgeeks.org/equilibrium-index-of-an-array/): 

> Equilibrium index of an array is an index such that the sum of elements at lower indexes is equal to the sum of elements at higher indexes. For example, in an arrya A:

> A[0] = -7, A[1] = 1, A[2] = 5, A[3] = 2, A[4] = -4, A[5] = 3, A[6]=0

> 3 is an equilibrium index, because:
A[0] + A[1] + A[2] = A[4] + A[5] + A[6]

> 6 is also an equilibrium index, because sum of zero elements is zero, i.e., A[0] + A[1] + A[2] + A[3] + A[4] + A[5]=0

__The idea__ is to get total sum of array first. Then Iterate through the array and keep updating the left sum. 

### Code

__code for [findning EI in 1-D array](http://rosettacode.org/wiki/Equilibrium_index#Java)__

	public List<Integer> findEI(int[] array) {
		List<Integer> ans = new ArrayList<Integer>();
		int sum = 0;
		for (int i = 0; i < array.length; i++) {
			sum += array[i];
		}
		int runningSum = 0;
		for (int i = 0; i < array.length; i++) {
			if (2 * runningSum + array[i] == sum) {
				ans.add(i);
			}
			runningSum += array[i];
		}
		return ans;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Find Word That Has the Most Letters Given]]></title>
    <link href="http://okckd.github.io/blog/2014/08/27/Word-that-has-most-letters-given/"/>
    <updated>2014-08-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/27/Word-that-has-most-letters-given</id>
    <content type="html"><![CDATA[### Question

[link](http://programmers.stackexchange.com/questions/188687/try-to-find-a-word-in-the-dictionary-that-has-most-letters-given)

> Given some random letters, for example "a,e,o,g,z,k,l,j,w,n" and a dictionary. 

> Try to find a word in the dictionary that has most letters given. 

> Example: "abbee" -> 3 occurance. 

### Solution

1. Make an array that marks all given chars. Like this:

    index={a:1, b:0, c:0, d:0, e:1, f:0, g:1...}

1. Iterate over each word of dictionary. 

    The array gives an easy way to search a char's existance. I did not write code for this question. 

### Code

    max=0;
    max_index=0;
    
    foreach(dictionary as position=>word) {
        sum=0;
        foreach(word as letter)
        {
          sum += index[letter];
        }
        if(sum > max)
        {
            max = sum;
            max_index = position;
        }
    }
]]></content>
  </entry>
  
</feed>
