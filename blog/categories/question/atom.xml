<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-24T23:36:25+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Square Count of Matchstick Graph]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Square-count-in-matchstick-graph/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Square-count-in-matchstick-graph</id>
    <content type="html"><![CDATA[### Question 

> 给出下面这个图 设计数据结构和算法求出图中__所有的正方形数量__ (count the number of squares). 

{% img middle /assets/images/matchstick-square-count.jpg %}

### Solution

1. __Pre-processing__: 从每一个点开始存储上下左右四个方向最多延伸到的位置

1. __Main algorithm__: 枚举右下角位置 然后枚举正方形边长 

1. 根据预处理的延伸情况判断是否能够有一个正方形被构造出来 

Total time complexity is O(n^3). 

> 预处理可以O(n^2) 预处理是有递推关系的 
>
> 但是后面枚举的部分，只能O(n^3)
>
> __不能动态规划的原因是__：他给定了一个可以变化的图，这个图上规模为n的图和规模为n-1的图中正方形个数之间不存在递推关系。 

And 一般来说处理矩阵的问题，大部分都是O(n^3)

### Code

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Ways of Dice Throw]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Dice-roll-DP-question/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Dice-roll-DP-question</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/dice-throw-problem/)

> Given n dice each with m faces, numbered from 1 to m, find the number of ways to get sum X. X is the summation of values on each face when all the dice are thrown. 

### Solution

__DP__

> Sum(m, n, X) = Sum(m, n - 1, X - 1) + 
>
>                Sum(m, n - 1, X - 2) +
>
>                .................... + 
>
>                Sum(m, n - 1, X - m)

So we can have dp(n)(X) and for each, iterate m time. Total time is O(m * n * X). 

### Code

__not written by me__.

	int findWays(int m, int n, int x)
	{
	    // Create a table to store results of subproblems.  One extra 
	    // row and column are used for simpilicity (Number of dice
	    // is directly used as row index and sum is directly used
	    // as column index).  The entries in 0th row and 0th column
	    // are never used.
	    int table[n + 1][x + 1];
	    memset(table, 0, sizeof(table)); // Initialize all entries as 0
	 
	    // Table entries for only one dice
	    for (int j = 1; j <= m && j <= x; j++)
	        table[1][j] = 1;
	 
	    // Fill rest of the entries in table using recursive relation
	    // i: number of dice, j: sum
	    for (int i = 2; i <= n; i++)
	        for (int j = 1; j <= x; j++)
	            for (int k = 1; k <= m && k < j; k++)
	                table[i][j] += table[i-1][j-k];
	 
	    /* Uncomment these lines to see content of table
	    for (int i = 0; i <= n; i++)
	    {
	      for (int j = 0; j <= x; j++)
	        cout << table[i][j] << " ";
	      cout << endl;
	    } */
	    return table[n][x];
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Count Set Bit in Binary Number]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Count-set-bit-in-binary-number/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Count-set-bit-in-binary-number</id>
    <content type="html"><![CDATA[### Question 

> Count Set Bit in Binary Number.

> 3 = 00000011 => 2

> 128 = 10000000 => 1

### Solution

__Bits counting algorithm__ (Brian Kernighan). Basic idea is __clear 1 bit at a time__. 

This algorithm goes through as many iterations as there are set bits. In the worst case, it will pass once per bit. An integer n has log(n) bits, hence [the worst case](http://stackoverflow.com/a/12381102) is O(log(n)).

### Code

	public int countSetBit(String binary) {
		int num = Integer.parseInt(binary, 2);
		int count = 0;
		while (num != 0) {
			num &= num - 1;
			count++;
		}
		return count;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Count Level in Perfect Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/08/19/Count-level-in-perfect-BT/"/>
    <updated>2014-08-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/19/Count-level-in-perfect-BT</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/10721583/how-can-i-calculate-the-level-of-a-node-in-a-perfect-binary-tree-from-its-depth)

> A perfect binary tree, i.e. each node in the tree is either a leaf node, or has two children, and all leaf nodes are on the same level. Each node has an index in depth-first order. 

		  0
		/   \
	  1      4
	 / \    / \
	2   3  5   6

> Given the index (k) of a particular node, calculate its level. 

### Solution

__This is a [magical solution](http://stackoverflow.com/a/10721897)__.  It divides the tree in the middle with number k decrease by 1 each time. 

Beautiful, and hard to understand. 

### Code

__not written by me__.

	public int countLevel(TreeNode root, int k, int n) {
		int level = 0;
		while (k != 0) {
			k--;
			n = (n - 1) / 2;
			k = k % n;
			level++;
		}
		return level + 1;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Numbers Concatenation to Get Max Value]]></title>
    <link href="http://okckd.github.io/blog/2014/08/17/Numbers-Concatenation-Max/"/>
    <updated>2014-08-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/17/Numbers-Concatenation-Max</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#45)

> 数组nums中有n个非负整数（整数用字符串表示），将它们以一定的顺序拼接，得到最大的整数。

> 样例：

> nums: ["54", "546", "548", "60"]

> 可以拼接得到的最大整数为"6054854654"，因此函数应该返回"6054854654"。

### Solution

__I will first list out 2 special cases__: 

> {40, 20, 201} => 4020201
>
> {40, 20, 203} => 4020320

Knowing about this 2 cases helps us to come up with a sorting-based algorithm. We only need to achieve this: 

> 201 < 20
>
> 20 < 203

By reading [this post](http://www.itint5.com/discuss/183/%E8%B0%81%E8%83%BD%E5%B8%AE%E6%88%91%E7%9C%8B%E4%B8%80%E4%B8%8B%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8Cn-200%E6%97%B6%E6%8F%90%E7%A4%BAsegmentation), I found the best comparator solution, defined as below: 

    String firstNum = s1 + s2;
    String secondNum = s2 + s1;
    return firstNum.compareTo(secondNum);

### Code

__written by me__.

	public String biggestNum(String[] nums) {
		Arrays.sort(nums, new SpecialComparator());
		StringBuilder sb = new StringBuilder();
		for (int i = nums.length - 1; i >= 0; i--) {
			sb.append(nums[i]);
		}
		return sb.toString();
	}

	class SpecialComparator implements Comparator<String> {
		public int compare(String s1, String s2) {
			// eg.
			// 40 > 20
			// 20 > 201
			// 203 > 20
			String firstNum = s1 + s2;
			String secondNum = s2 + s1;
			return firstNum.compareTo(secondNum);
		}
	}
]]></content>
  </entry>
  
</feed>
