<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-19T05:21:01+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Maximum Square Sub-matrix With All 1s]]></title>
    <link href="http://okckd.github.io/blog/2015/01/18/max-squre-with-all-1/"/>
    <updated>2015-01-18T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/18/max-squre-with-all-1</id>
    <content type="html"><![CDATA[### Question

[link](http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/)

> Given a binary matrix, find out the maximum size square sub-matrix with all 1s. For example, consider the below binary matrix.

       0  1  1  0  1 
       1  1  0  1  0 
       0  1  1  1  0
       1  1  1  1  0
       1  1  1  1  1
       0  0  0  0  0

> The maximum square sub-matrix with all set bits is size 9. Note we only find __square__, not rectangles! (this makes it much easier)

### Solution

Since __square only__, we can use DP. [Quoted answer](http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/) below: 

> Let the given binary matrix be M[R][C]. The idea of the algorithm is to construct an auxiliary size matrix S[][] in which each entry S[i][j] represents size of the square sub-matrix with all 1s including M[i][j] where M[i][j] is the rightmost and bottommost entry in sub-matrix.

> 1. Construct a sum matrix S[R][C] for the given M[R][C].
>
>   1. Copy first row and first columns as it is from M[][] to S[][]
>
>   1. For other entries, use following expressions to construct S[][]

             If M[i][j] is 1 then
                S[i][j] = min(S[i][j-1], S[i-1][j], S[i-1][j-1]) + 1
             Else /*If M[i][j] is 0*/
                S[i][j] = 0
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Amazon] Lexicographic Rank of a String]]></title>
    <link href="http://okckd.github.io/blog/2015/01/18/Lexicographic-rank-of-string/"/>
    <updated>2015-01-18T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/18/Lexicographic-rank-of-string</id>
    <content type="html"><![CDATA[### Question

[link](http://www.geeksforgeeks.org/lexicographic-rank-of-a-string/)

> Given a string, find its rank among all its permutations sorted lexicographically. 

> For example, rank of “abc” is 1, rank of “acb” is 2, and rank of “cba” is 6.

### Solution

Let the given string be “__STRING__”. In the input string, ‘S’ is the first character. There are total 6 characters and __4 of them are smaller than ‘S’__. So there can be __4 * 5!__ smaller strings where first character is smaller than ‘S’, like following: 

    R X X X X X
    I X X X X X
    N X X X X X
    G X X X X X

Repeat the same process for T, and we get: 

    Rank = 4*5! + 4*4! + 3*3! + 1*2! + 1*1! + 0*0! = 597

### Code 

	public int getRank(String input) {
		if (input == null || input.length() == 0) {
			return 0;
		}
		input = input.toUpperCase();
		return helper(input) + 1;
	}

	public int helper(String input) {
		if (input == null || input.length() == 0) {
			return 0;
		}
		char headChar = input.charAt(0);
		int countSmallerThanHead = 0;
		for (char ch : input.toCharArray()) {
			if (ch < headChar) {
				countSmallerThanHead++;
			}
		}
		return countSmallerThanHead * Common.factorial(input.length() - 1)
				+ helper(input.substring(1));
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Amazon] Find Nodes of Distance K From Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2015/01/17/find-nodes-distance-k-binary-tree/"/>
    <updated>2015-01-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/17/find-nodes-distance-k-binary-tree</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=15069740)

> Find the nodes at d distance from a certain node in a Binary Tree

### Solution

[There are two types](http://www.geeksforgeeks.org/print-nodes-distance-k-given-node-binary-tree/) of nodes to be considered: 

1. Nodes in the subtree rooted of the target node. 
1. Other nodes, may be an ancestor of target, or a node in some other subtree. 

The details of find these nodes: 

1. Find the nodes which can be reached in k hops from the given node.

2. Second part we look at those nodes __on the upper part of the tree__. The parent of the given node is 1 hop away. Hence in the __other child subtree__ of the parent, we find nodes with k-1 hops. 
    
    Similarly the grand parent of B, we find nodes with k - 2 distance. 

Implementation: 

1. Start from root, store all nodes in a queue of maximum size k till you reach the given node. 

1. Call FindNodesAtDistance() on the nodes from the queue to get all the nodes distance k -i from the node. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Number of Occurence of Given Sub-sequence]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/numer-of-occurrence-given-subsequence/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/numer-of-occurrence-given-subsequence</id>
    <content type="html"><![CDATA[### Question

[link](http://stackoverflow.com/questions/6877249/find-the-number-of-occurrences-of-a-subsequence-in-a-string)

> Given a digit '3141592653', find number of occurence of subsequence "123". Note that the sequence occurs twice:

    3141592653
     1    2  3
       1  2  3

> Output 2.

### Solution

Refer to __[LeetCode 115] Distinct Subsequences__. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Number of Distinct Sub-sequence]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/numer-of-distinct-subsequence/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/numer-of-distinct-subsequence</id>
    <content type="html"><![CDATA[### Question

[link](http://stackoverflow.com/questions/5151483/how-to-find-the-number-of-distinct-subsequences-of-a-string)

> Find the number of distinct subsequences of a string (include "" as a subsequence). 

> For example, Input 

    AAA 
    ABCDEFG 
    CODECRAFT 

> Output 

    4 
    128 
    496 

### Solution

In __[LeetCode 115] Distinct Subsequences__, we discuss finding occurence of a given subsequence. 

Now if we do not specify a subsequence, __we want the total number of distinct subsequence__. 

The solution is DP, with the following equation: 

    Let, 

    dp[i] = number of distinct subsequences ending with a[i]

    last[i] = last position of character i in the given string.

__Equation__: 

    dp[i] = dp[last[i] - 1] + ... + dp[i - 1]

The final result is: 

    Distinct Subsequences = dp[1] + ... dp[len - 1]

Example 1: 

    Input   : - A B C
    dp array: 1 1 2 4
    Total = 8

Example 2: 

    Input   : - A A C
    dp array: 1 1 1 3
    Total = 6

The code is posted below. 

### Optimize Solution

There is a good optimization of this DP solution, which is to __keep another dp array 'sum'__, which sum[i] = dp[1] + dp[2] + ... + dp[i]. The final answer would be sum[len - 1]. 

This nice idea is from [this post](http://stackoverflow.com/a/5152203). Credit goes to __IVlad__. 

### Code

un-optimized code. calculate dp[0] ... dp[n], then sum to final result. 

	public int countDistinctSubseq(String input) {
		int len = input.length();
		int[] dp = new int[len + 1];
		// dp[i] denotes the number of distinct subseq within first 'i' chars
		dp[0] = 1;
		// the first 0 chars is "" - we consider it as 1 subseq

		for (int i = 1; i <= len; i++) {
			// set dp[i]
			// dp[i] = dp[i-1] + ... + dp[k] where input{k} == input{i}
			int p = i - 1;
			while (p >= 0) {
				dp[i] += dp[p];
				if (p > 0 && input.charAt(p - 1) == input.charAt(i - 1)) {
					// when meeting a same char ahead of position i, stop
					// adding to dp[i]
					break;
				}
				p--;
			}
		}
		int sum = 0;
		for (int i : dp) {
			sum += i;
		}
		return sum;
	}
]]></content>
  </entry>
  
</feed>
