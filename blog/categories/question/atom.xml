<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-31T01:30:07+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] a Product Array Puzzle]]></title>
    <link href="http://okckd.github.io/blog/2015/01/29/product-array-puzzle/"/>
    <updated>2015-01-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/29/product-array-puzzle</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/amazon-interview-set-78-fresher-internship/)

> Given an array of integers , replace each element with the product of the remaining elements.

  Eg : Input - 1 2 3 4     
       Output : 24 12 8 6 

> Do not use division.

### Solution

Store the product of the left side elements for each integer, and also the right side. 

For eg : L[]= {1 , 1 , 2 , 6 }

and R[] = { 24 , 12 , 4 , 1} 

The multiply R[i] and L[i] to get the resultant array.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Apple] Calculate Area]]></title>
    <link href="http://okckd.github.io/blog/2015/01/29/calculate-area/"/>
    <updated>2015-01-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/29/calculate-area</id>
    <content type="html"><![CDATA[### Question 

> Calculate area: 

<img class="middle" src="/assets/images/calculate-area.jpg">

### Analysis

We are only able to come up with 2 equations using the obvious relationship between semicircle and square. But we have x, y and z variables. 

<img class="middle" src="/assets/images/calculate-area-xyz.jpg">

How do we proceed? 

### Solution

Thanks to my girlfriend, who came up with the solution: 

<img class="middle" src="/assets/images/calculate-area-solution.jpg">

The tiny small shaded area can be calculated by substracting the __isosceles triangle (等腰三角形)__ from a 1/12 circle. 

And the tiny small shaded area is simply a part of the larger shaded area. 

Do you own math. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Packing Rectangles]]></title>
    <link href="http://okckd.github.io/blog/2015/01/29/Packing-Rectangles/"/>
    <updated>2015-01-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/29/Packing-Rectangles</id>
    <content type="html"><![CDATA[### Question 

[link](http://olympiads.win.tue.nl/ioi95/task/pack.html)

> Four rectangles are given. Find the smallest enclosing (new) rectangle into which these four may be fitted without overlapping. By smallest rectangle we mean the one with the smallest area.

<img class="middle" src="/assets/images/packing-rect.gif">

### Greedy 

[Greedy](http://stackoverflow.com/a/1213571) placement from __large (area) to small__.

1. Put the largest rectangle remaining into your packed area. 
1. If it can't fit anywhere, place it in a place that extends the pack region as little as possible. 
1. Repeat until you finish with the smallest rectangle.

### Optimal Solution

[There is a trade-off](http://stackoverflow.com/a/4264497) between implementation complexity/time and optimality, but there is a wide range of algorithms to choose from.

Below is quoted: 

<blockquote>
    <div class="post-text" itemprop="text">
<ol>
<li><p>First-Fit Decreasing Height (FFDH) algorithm<br>
FFDH packs the next item R (in non-increasing height) on the first level where R fits. If no level can accommodate R, a new level is created.<br>
Time complexity of FFDH: O(n·log n).<br>
Approximation ratio: FFDH(I)&lt;=(17/10)·OPT(I)+1; the asymptotic bound of 17/10 is tight.</p></li>
<li><p>Next-Fit Decreasing Height (NFDH) algorithm<br>
NFDH packs the next item R (in non-increasing height) on the current level if R fits. Otherwise, the current level is "closed" and a new level is created.<br>
Time complexity: O(n·log n).<br>
Approximation ratio: NFDH(I) &lt;= 2·OPT(I)+1; the asymptotic bound of 2 is tight.</p></li>
<li><p>Best-Fit Decreasing Height (BFDH) algorithm<br>
BFDH packs the next item R (in non-increasing height) on the level, among those that can accommodate R, for which the residual horizontal space is the minimum. If no level can accommodate R, a new level is created. </p></li>
<li><p>Bottom-Left (BL) Algorithm<br>
BL first order items by non-increasing width. BL packs the next item as near to the bottom as it will fit and then as close to the left as it can go without overlapping with any packed item. Note that BL is not a level-oriented packing algorithm.<br>
Time complexity: O(n^2).<br>
Approximation ratio: BL(I) &lt;= 3·OPT(I).  </p></li>
<li><p>Baker's Up-Down (UD) algorithm<br>
UD uses a combination of BL and a generalization of NFDH. The width of the strip and the items are normalized so that the strip is of unit width. UD orders the items in non-increasing width and then divides the items into five groups, each with width in the range (1/2, 1], (1/3,1/2], (1/4,1/3], (1/5,1/4], (0,1/5]. The strip is also divided into five regions R1, ··· , R5. Basically, some items of width in the range (1/i+1, 1/i], for 1 &lt;= i &lt;= 4, are packed to region Ri by BL. Since BL leaves a space of increasing width from top to bottom at the right side of the strip, UD takes this advantage by first packing the item to Rj for j = 1, ··· , 4 (in order) from top to bottom. If there is no such space, the item is packed to Ri by BL. Finally, items of size at most 1/5 are packed to the spaces in R1, ··· , R4 by the (generalized) NFDH algorithm. Again if there is no space in these regions, the item is packed to R5 using NFDH.<br>
Approximation ratio: UD(I) &lt;= (5/4) · OPT(I)+(53/8)H, where H is the maximum height of the items; the asymptotic bound of 5/4 is tight.</p></li>
<li><p>Reverse-fit (RF) algorithm<br>
RF also normalizes the width of the strip and the items so that the strip is of unit width. RF first stacks all items of width greater than 1/2. Remaining items are sorted in non-increasing height and will be packed above the height H0 reached by those greater than 1/2. Then RF repeats the following process. Roughly speaking, RF packs items from left to right with their bottom along the line of height H0 until there is no more room. Then packs items from right to left and from top to bottom (called reverse-level) until the total width is at least 1/2. Then the reverse-level is dropped down until (at least) one of them touches some item below. The drop down is somehow repeated.<br>
Approximation ratio: RF(I) &lt;= 2·OPT(I).</p></li>
<li><p>Steinberg's algorithm<br>
Steinberg's algorithm, denoted as M in the paper, estimates an upper bound of the height H required to pack all the items such that it is proved that the input items can be packed into a rectangle of width W and height H. They then define seven procedures (with seven conditions), each to divide a problem into two smaller ones and solve them recursively. It has been showed that any tractable problem satisfies one of the seven conditions.<br>
Approximation ratio: M(I) &lt;= 2·OPT(I).</p></li>
<li><p>Split-Fit algorithm (SF)
SF divides items into two groups, L1 with width greater than 1/2 and L2 at most 1/2. All items of L1 are first packed by FFDH. Then they are arranged so that all items with width more than 2/3 are below those with width at most 2/3. This creates a rectangle R of space with width 1/3. Remaining items in L2 are then packed to R and the space above those packed with L1 using FFDH. The levels created in R are considered to be below those created above the packing of L1.<br>
Approximation ratio: SF(I) &lt;= (3/2) ·OPT(I) + 2; the asymptotic bound of 3/2 is tight.</p></li>
<li><p>Sleator's algorithm<br>
Sleater's algorithm consists of four steps:</p>

<ol>
<li><p>All items of width greater than 1/2 are packed on top of one another in the bottom of the strip. Suppose h0 is the height of the resulting packing All subsequent packing will occur above h0.</p></li>
<li><p>Remaining items are ordered by non-increasing height. A level of items are packed (in non-increasing height order) from left to right along the line of height h0. </p></li>
<li><p>A vertical line is then drawn in the middle to cut the strip into two equal halves (note this line may cut an item that is packed partially in the right half). Draw two horizontal line segments of length one half, one across the left half (called the left baseline) and one across the right half (called the right baseline) as low as possible such that the two lines do not cross any item.</p></li>
<li><p>Choose the left or right baseline which is of a lower height and pack a level of items into the corresponding half of the strip until the next item is too wide.</p></li>
</ol>

<p>A new baseline is formed and Step (4) is repeated on the lower baseline until all items are packed.<br>
Time complexity: O(n ·log n).<br>
The approximation ratio of Sleator's algorithm is 2.5 which is tight.</p></li>
</ol>
    </div>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Two Dimensional Knapsack Problem]]></title>
    <link href="http://okckd.github.io/blog/2015/01/28/two-dimensional-knapsack-problem/"/>
    <updated>2015-01-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/28/two-dimensional-knapsack-problem</id>
    <content type="html"><![CDATA[### Question 

[link](http://blog.sina.com.cn/s/blog_8a24b3a3010190ak.html)

> 给定n种物品和一背包。物品i的重量是wi，体积是bi，其价值为vi，背包的容量为C，容积为D。问应如何选择装入背包中的物品，使得装入背包中物品的总价值最大？

> 在选择装入背包的物品时，对每种物品i只有两种选择，即装入背包或者不装入背包。不能将物品i装入背包多次，也不能只装入部分的物品i。试设计一个解此问题的动态规划算法，并分析算法的计算复杂性。

### Analysis

This is a extended question from __[Question] 0-1 Knapsack Problem__. 

Same solution, just use 3D-array for DP. 

### Solution

First of all, define a 2D array, Knapsack(n,W) denotes getting 'n'th item, with weight 'W'. When n == 0 or W = 0, dp value is 0. 

> int[][][] dp = new int[n + 1][W + 1][B + 1];

Now if item 'n' is able to fit in:

> dp[i][j][k] = max(dp[i-1][j][k] , dp[i-1][j-w[i]][k-b[i]] + v[i]);

If not able to fit in: 

> dp[i][j][k] = dp[i-1][j][k];

### Code

Code from [绝对快乐一生](http://blog.sina.com.cn/s/blog_8a24b3a3010190ak.html): 

    int main()
    {
       int i,j,k;
       int n,c,d;
       int w[MAX] = {0};   //重量
       int b[MAX] = {0};   //体积
       int v[MAX] = {0};   //价值
       cout<<"请输入物品个数:";
       cin>>n;
       cout<<"请输入背包的容量及容积:";
       cin>>c>>d;
       cout<<"请依次输入各个物品的重量,体积,价值:(共"<<n<<"个)"<<endl;
       for(i =1;i<n+1;i++)
       {
           cin>>w[i]>>b[i]>>v[i];
       }

       int dp[50][50][50]={0}; 
       //dp[i][j][k] i代表着第1到第i个物品，j代表的是重量，k代表的是容积，dp为最优价值

       for(i=1;i<n+1;i++)
           for(j =1;j <=c;j++)
               for(k = 1 ;k <= d ; k++)
               {
                   if(w[i]<=j&&b[i]<=k)  
                   //当前物品重量小于当前容量，且体积小于容积时 ，才可以考虑装入物品的问题
                       dp[i][j][k] = max(dp[i-1][j][k] , dp[i-1][j-w[i]][k-b[i]] + v[i]);
                   else dp[i][j][k] = dp[i-1][j][k];
               }
       cout<<"背包能放物品的最大价值为:"<<dp[n][c][d]<<endl;
      int x[MAX] ={0};   //记录是否被选中
      for(i =n;i>1;i--)
           if(dp[i][c][d]==dp[i-1][c][d])x[i] =0;
          else {x[i]=1;c -= w[i];d -= b[i];}
       x[1]=(dp[1][c][d])?1:0;
       cout<<"被选入背包的物品的编号,质量和体积,价值分别是:"<<endl;
       for(i=1;i<</span>n+1;i++)
           if(x[i]==1)
               cout<<"第"<<i<<"个物品: "<<w[i]<<"  "<<b[i]<<"  "<<v[i]<<endl;

    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Push and Pop Sequences of Stacks]]></title>
    <link href="http://okckd.github.io/blog/2015/01/26/Push-and-Pop-Sequences-Stacks/"/>
    <updated>2015-01-26T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/26/Push-and-Pop-Sequences-Stacks</id>
    <content type="html"><![CDATA[### Question 

[link](http://codercareer.blogspot.sg/2011/11/no-21-push-and-pop-sequences-of-stacks.html)

> Given two integer sequences, one of which is the push sequence of a stack, please check whether the other sequence is a corresponding pop sequence or not. 

> For example, if 1, 2, 3, 4, 5 is a push sequence, 4, 5, 3, 2, 1 is a corresponding pop sequence, but the sequence 4, 3, 5, 1, 2 is not.

### Solution

Refer to [this answer](http://stackoverflow.com/a/17828345): 

> Construct the stack: 
>
> For each number X in the pop order:

    If this number is not the same as the top of the stack (or the stack is empty), 
    push numbers from the push order until you pushed X. 
    
    If you pushed all numbers and didn't find X, there's no way to get the pop order.
    
    Pop X

### Code

	public boolean validSequence(int[] input, int[] sequenc) {
		// keep a pointer p in the input[] array
		int len = input.length;
		int p = 0;
		Stack<Integer> stack = new Stack<Integer>();

		int i = 0;
		while (i < len) {
			if (stack.isEmpty()) {
				// just push an element to stack
				stack.push(input[p++]);
			} else {
				// stack got elements, then check top one
				if (stack.peek() == sequenc[i]) {
					// seq found, proceed to next number in seq
					stack.pop();
					i++;
				} else {
					// did not find seq, keep pushing to stack until done
					if (p == len) {
						return false;
					} else {
						stack.push(input[p++]);
					}
				}
			}
		}
		return i == len; // or just return true;
	}
]]></content>
  </entry>
  
</feed>
