<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-09-28T22:31:34+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Celebrity Problem]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/celebrity-problem/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/celebrity-problem</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=13167666)

> You have a room with n people. A celebrity walks in. Everyone knows the celebrity, the celebrity knows no one. 

> Non-celebrities may/may not know anyone in the room. 

> Give an algorithm to find the celebrity. Discuss the complexity. 

### Solution

[Classic brute-force solution](http://www.geeksforgeeks.org/the-celebrity-problem/) would take O(n^2) time to build a map. That's not good, and we have a very simple solution that works in O(n) time: 

> Make all of them stand in a row. Let's say the people are a,b,c,d,e,f,g,h,i,j,.......n 

> Compare a and b. __If a knows b__, a is not celebrity. __If a doesn't know b__, b is not celebrity. 

> At the end, the probable celebrity who survives is the certain celebrity. (better do a check)

Total number of comparison is [3(N-1) times](http://www.geeksforgeeks.org/the-celebrity-problem/). 

### Code

__not written__

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Print Numbers Containing 5]]></title>
    <link href="http://okckd.github.io/blog/2014/09/04/print-numbers-containing-5/"/>
    <updated>2014-09-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/04/print-numbers-containing-5</id>
    <content type="html"><![CDATA[### Question

[link](http://www.mitbbs.com/article_t/JobHunting/32651839.html)

> 写一个function，对于参数n，输出从0到n之间所有含5的数字。eg. func(30) 应该输出5，15，25

> this is Groupon interview question

### Solution

Suggested by level 10 of [this forum](http://www.mitbbs.com/article_t/JobHunting/32651839.html). It's (surprisingly) a DFS question. 

### Code

__written by me__

	public void mySolution(int num) {
		if (num >= 5) {
			String str = String.valueOf(num);
			helper(num, "", 0, str.length(), false);
		}
	}

	private void helper(int max, String prefix, int pos, int len, boolean have5) {
		if (pos == len) {
			int cur = Integer.parseInt(prefix);
			if (cur <= max) {
				System.out.print(cur + ", ");
			}
			return;
		}
		for (int i = 0; i < 10; i++) {
			if (pos == len - 1 && !have5 && i != 5) {
				continue;
			}
			helper(max, prefix + i, pos + 1, len, have5 || i == 5);
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Split an Integer or Coin]]></title>
    <link href="http://okckd.github.io/blog/2014/09/02/Split-an-integer-or-coin/"/>
    <updated>2014-09-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/02/Split-an-integer-or-coin</id>
    <content type="html"><![CDATA[### Question

[link](http://blog.csdn.net/hackbuteer1/article/details/8035261)

> 整数的拆分问题

> 如，对于正整数n=6，可以拆分为：

    6
    5+1
    4+2, 4+1+1
    3+3, 3+2+1, 3+1+1+1
    2+2+2, 2+2+1+1, 2+1+1+1+1
    1+1+1+1+1+1+1

> 现在的问题是，对于给定的正整数n，程序输出该整数的拆分种类数(HDOJ  1028)。

### Solution 

This is very similar to another question I posted before: __Coin Change Problem__. 

__The DP equation is__: 

> q(n,k) = q(n,k-1) + q(n-k,k)

### Code

__not written by me__

    int main(void) {  
        int n,i,j,dp[121][121];  
        for(i = 1 ; i < 121 ; ++i)  
        {  
            for(j = 1 ; j < 121 ; ++j)  
            {  
                if(i == 1 ||  j == 1)  
                    dp[i][j] = 1;  
                else if(i > j)  
                    dp[i][j] = dp[i][j-1] + dp[i-j][j];  
                else if(i == j)  
                    dp[i][j] = dp[i][j-1] + 1;  
                else  
                    dp[i][j] = dp[i][i];  
            }  
        }  

        while(scanf("%d",&n)!=EOF)  
        {  
            cout<<dp[n][n]<<endl;  
        }  
        return 0;  
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Axis Aligned Rectangles]]></title>
    <link href="http://okckd.github.io/blog/2014/09/02/Axis-aligned-rectangle/"/>
    <updated>2014-09-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/02/Axis-aligned-rectangle</id>
    <content type="html"><![CDATA[### Question

[link](http://ankitsambyal.blogspot.sg/2013/10/finding-overlapping-rectangles-in-given.html), MIT handouts Person_A

> Describe an algorithm that takes an unsorted array of axis-aligned rectangles and returns __any pair of__ rectangles that overlaps, if there is such a pair. 

> Axis-aligned means that all the rectangle sides are either parallel or perpendicular to the x- and y-axis. 

> Each rectangle object has two variables: the x-y coordinates of the upper-left corner and the bottom-right corner.

### Analysis

A lot of different solutions on the internet, [eg](http://www.quora.com/Algorithms/Given-a-set-of-n-axis-aligned-rectangles-in-the-plane-find-how-big-is-the-largest-subset-of-these-rectangles-that-contain-a-common-point-in-O-n-3-and-then-in-order-O-nlogn) and [eg](http://ankitsambyal.blogspot.sg/2013/10/finding-overlapping-rectangles-in-given.html), and some questions asks you to return all overlapping pairs. For now, we just return __any pair__ that overlaps.

### Solution 

I concluded some solution and come up with this (the idea of BST is covered in the end of [this pdf](http://www.cs.princeton.edu/~rs/AlgsDS07/17GeometricSearch.pdf)): 

1. Sort the input by left edge. 
1. One by one, get one rectangle from the sorted input, and make a pair (rect.top, rect.bottom). 
1. Insert this pair into a __Interval Search Tree__. 
1. This tree is a BST, and use first value of the pair as BST key. 
1. Insert pair at the correct BST location. If conflicts, we've found 1 overlapping pair. 

The code for searching a intersect, and insert a pair looks like this: 

    Node x = root;
    while (x != null) {
        if (x.interval.intersects(lo, hi)) 
            return x.interval;
        else if (x.left == null)  x = x.right;
        else if (x.left.max < lo) x = x.right;
        else                      x = x.left;
    }
    return null;
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Find Row With Most 1s]]></title>
    <link href="http://okckd.github.io/blog/2014/09/01/Find-row-with-most-1s/"/>
    <updated>2014-09-01T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/01/Find-row-with-most-1s</id>
    <content type="html"><![CDATA[### Question

[link](http://www.geeksforgeeks.org/find-the-row-with-maximum-number-1s/)

> Given a 2D array with only 1s and 0s, where each row is sorted. 

> Find the row with the maximum number of 1s. Input matrix: 

    0 1 1 1
    0 0 1 1
    1 1 1 1  // this row has maximum 1s
    0 0 0 0

> Output: 2

### Analysis

By using a modified version of binary search, we can achieve __[a O(mLogn) solution](http://www.geeksforgeeks.org/find-the-row-with-maximum-number-1s/)__ where m is number of rows and n is number of columns in matrix. 

__However, there's better solution that works in linear time__! 

### Solution 

1. Get the index of first (or leftmost) 1 in the first row. 

2. Do following for every row after the first row: 

    1. IF the element on left of previous leftmost 1 is 0, ignore this row. 
    
    1. ELSE Move left until a 0 is found. Update the leftmost index to this index and max_row_index to be the current row. 

The time complexity is O(m+n). 

### Code 

__written by me__

	public int solution(int[][] matrix) {
		int m = matrix.length;
		int n = matrix[0].length;
		int p = n;
		int row = -1;
		for (int i = 0; i < m; i++) {
			// now p is larger than 0, otherwise it's already terminated
			if (matrix[i][p - 1] == 0) {
				continue;
			}
			// p points to a 1, now search to the left direction
			for (int j = p - 1; j >= 0; j--) {
				if (matrix[i][j] == 1) {
					p = j;
				} else {
					break;
				}
			}
			// p have a new value now
			if (p == 0) {
				return i;
			} else {
				row = i;
			}
		}
		return row;
	}
]]></content>
  </entry>
  
</feed>
