<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-17T10:50:51+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Number of Valid Trees Given Preorder and Postorder]]></title>
    <link href="http://okckd.github.io/blog/2014/08/17/Number-of-tree-given-preorder-postorder/"/>
    <updated>2014-08-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/17/Number-of-tree-given-preorder-postorder</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#28)

> 对于包含n个结点的二叉树（树中结点编号从1到n），已知前序和后序遍历序列，我们知道不一定能唯一的恢复这棵树。请计算出满足条件的二叉树的总数。

> Example

    前序遍历序列preorder：1 2
    后序遍历序列postorder：2 1

    一共有2棵满足条件的二叉树：
        1       1
       /         \
      2           2

### Solution

> 先看两种遍历的性质:

> pre-order: root, left *************, right #########
>
> post-order: **************left, ########right, root

> 所以 pre-order 的第一个元素一定等于 post-order 的最后一个元素. 然后在post-order中由前往后找, 找出等于pre-oder中第二个元素的位置, 也就是 left 的位置. 

> 1. 如果post-order中的这个位置不是倒数第二个, 说明左右子树都非空, 那么对左右子树递归__调用后用乘法原理__.
> 1. 如果是倒数第二个, 说明有一个子树为空, return的值就是 __2*递归调用非空子树__.

[ref](http://www.itint5.com/discuss/94/%E8%AF%B7%E5%A4%A7%E5%AE%B6%E6%8F%90%E4%B8%80%E4%BA%9B%E6%94%B9%E8%BF%9B%E6%84%8F%E8%A7%81)

### Code

__not written by me__. This code is REALLY 叼炸天。

    int helper(vector<int>& preorder, vector<int>& posorder, 
             int i1, int j1, int i2, int j2){
        if(i1 == j1) return 1;
        if(preorder[i1+1] == posorder[j2-1]){
            return 2*helper(preorder, posorder, i1+1, j1, i2, j2-1);
        }
        int k = i2;
        while(posorder[k] != preorder[i1+1]){ k++; }
        return helper(preorder, posorder, i1+1,i1+1+k-i2 ,i2 , k)
             * helper(preorder, posorder, i1+2+k-i2, j1, k+1, j2-1);
    }

    int countValidTrees(vector<int>& preorder, vector<int>& posorder) {
        int n = preorder.size();
        return helper(preorder, posorder, 0, n-1, 0, n-1);
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Excel Decimal Conversion]]></title>
    <link href="http://okckd.github.io/blog/2014/08/16/Excel-decimal-conversion/"/>
    <updated>2014-08-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/16/Excel-decimal-conversion</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#23)

> Excel中的行列数用A~Z 26个字母表示，A, B, C, D, …, Z, AA, AB, …, AZ, BA, BB, … 分别表示10进制数1, 2, 3, 4, …, 26, 27, 28, …, 52, 53, 54…。

> 请实现2个函数decToExcel和excelToDec，将10进制数转换为Excel数，以及将Excel数转换为10进制数。

### Solution

Note the indexing starts from 1, not from 0. This caused some trouble for me. 

### Code

__written by me__

    public String decToExcel(int decNum) {
        decNum--;
        int digits = 1;
        int exponen = 26;
        while (decNum >= exponen) {
            decNum -= exponen;
            exponen *= 26;
            digits++;
        }
        // now we know the total number of digits
        int num = decNum;
        int total = exponen / 26;
        String ans = "";
        for (int i = 0; i < digits; i++) {
            ans += (char) (num / total + 'A');
            num %= total;
            total /= 26;
        }
        return ans;
    }
    
    public int excelToDec(String excelNum) {
        int digits = excelNum.length();
        int total = 1;
        int sum = 1;
        for (int i = 1; i < digits; i++) {
            total *= 26;
            sum += total;
        }
        for (int i = 0; i < digits; i++) {
            sum += (excelNum.charAt(i) - 'A') * total;
            total /= 26;
        }
        return sum;
    }

__updated code__: we can actually do it recursively. The code is much more concise (the code is found in the eclipse project). 

    //将十进制数转换为excel数
	public String decToExcel(int decNum) {
		if (decNum == 0) {
			return "";
		}
		decNum--;
		char last = (char) ('A' + decNum % 26);
		return decToExcel(decNum / 26) + last;
	}
    
    //将excel数转换为十进制数
	public int excelToDec(String excelNum) {
		if (excelNum.equals("")) {
			return 0;
		}
		int len = excelNum.length();
		int last = 1 + excelNum.charAt(len - 1) - 'A';
		return excelToDec(excelNum.substring(0, len - 1)) * 26 + last;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] 跳马问题加强版]]></title>
    <link href="http://okckd.github.io/blog/2014/08/15/Knight-tour-jumpable-question/"/>
    <updated>2014-08-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/15/Knight-tour-jumpable-question</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#12)

> 有一个无限大的棋盘，棋盘上有一匹马，马可以从长宽分别为p和q的矩形一个角移动到对角。即假设马当前的位置为(x,y)，那么下一步可以移动到(x+p,y+q)，(x+p,y-q)，(x-p,y+q)，(x-p,y-q)，(x+q,y+p)，(x+q,y-p)，(x-q,y+p)或者(x-q,y-p)这8个位置。

> 问马是否能从坐标(x,y)按照上述移动规则移动到坐标(x2,y2)。

### Solution

[ref](http://www.itint5.com/discuss/16/%E8%B7%B3%E9%A9%AC%E9%97%AE%E9%A2%98%E5%8A%A0%E5%BC%BA%E7%89%88)

1. 计算dx=x-x2,dy=y-y2。
2. 求出p,q的最大公约数g，如果dx或者dy不能被g整除，那么很显然无解。
3. 将p,q,dx,dy都除以g，现在p和q互质了。
4. 注意到马可以跳到点(0,2p)（先(p,q)跳一下，然后(p,-q)跳一下），重复这个过程，马可以跳到任意(0,2kp)的点，由于对称性，也可以跳到任意(2kp,0)的点。 
5.下面这一步很关键，由于p,q互质，那么存在x,y满足px+qy=1（扩展欧几里德定理）。这样，马可以跳到(0,2)和和(2,0)，由于对称性，马可以跳到任意坐标都为偶数点。
6. 有了上面的结论，其实只用考虑(0,0),(0,1),(1,0),(1,1)这4个点是否可达。(0,0)是可达的，(0,1)和(1,0)由于对称性只用考虑(0,1)。
7. 对于(1,1)，其实是永远可达的。如果q,p都为奇数，可以先跳到(1+p,1+q)的点（利用5中的结论，可以跳到都是偶数的点），然后(-p,-q)跳到(1,1)。如果p,q一奇一偶，可以先跳到(1+p+q,1+q+p)的点（利用5中的结论），然后(-p,-q),(-q,-p)两步跳到(1,1)。
8. 对于(0,1)，如果p,q一奇一偶，那么也是永远可达的（同7可证）。如果p,q都是奇数，那么是不可能跳到(0,1)的，因为两个奇数不管怎么加减交替运算都不可能变成一奇一偶。

所以最后的结论就是：__第3步之后，如果p,q一奇一偶，那么可达。否则dx,dy同奇或同偶才可达__。

gcd的代码 (concise version):

	int gcd(int a, int b) {
		return b ? gcd(b, a % b) : a;
	}

### Code

__not written by me__

	int gcd(int a, int b){
	    return b? gcd(b, a%b) : a;
	}
	bool canJump(int p, int q, int x, int y, int x2, int y2) {
	    if(p==0 && q==0) return (x==x2)&&(y==y2);
	    int x1 = x2 - x, y1 = y2 - y;
	    int g1 = gcd(p, q);
	    if( x1 % g1 || y1 % g1) return false;
	    p = p/g1;
	    q = q/g1;
	    x1 = x1/g1;
	    y1 = y1/g1;
	    if((p-q)%2 ) return true;
	    else return (x1-y1)%2 == 0;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Greatest Common Divisor]]></title>
    <link href="http://okckd.github.io/blog/2014/08/15/Greatest-common-divisor/"/>
    <updated>2014-08-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/15/Greatest-common-divisor</id>
    <content type="html"><![CDATA[### Question 

> Get GCD in more efficient code

### Code

this is 掉渣天。

	public int gcd(int a, int b) {
		return b == 0 ? a : gcd(b, a % b);
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Maximum Circular Subarray Sum]]></title>
    <link href="http://okckd.github.io/blog/2014/08/11/max-circular-subarray/"/>
    <updated>2014-08-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/11/max-circular-subarray</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#9)

> Given n numbers (both +ve and -ve), arranged in a circle, fnd the maximum sum of consecutive number

### Solution

First pass: find max subarray sum.

Second pass: find min subarray sum, and subtract it from total sum. 

Suggested on [G4G](http://www.geeksforgeeks.org/maximum-contiguous-circular-sum/) 

### Code

__written by me__

    public int maxConsSum2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
        int soFar = 0;
		int max = 0;
		int totalSum = 0;
		for (Integer i: arr) {
			totalSum += i;
			// totalSum is used in next step
			soFar += i;
			soFar = Math.max(soFar, 0);
			max = Math.max(max, soFar);
		}
		int min = 0;
		// calculate the min subarray
		for (Integer i: arr) {
			soFar += i;
			soFar = Math.min(soFar, 0);
			min = Math.min(min, soFar);
		}
		return Math.max(max, totalSum - min);
    }
]]></content>
  </entry>
  
</feed>
