<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-08T23:41:00+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Max Sum of Non-Consecutive Elements]]></title>
    <link href="http://okckd.github.io/blog/2014/08/08/Max-sum-non-consecutive/"/>
    <updated>2014-08-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/08/Max-sum-non-consecutive</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2009/05/max-possible-sum-of-non-consecutive.html)

> There is an integer array consisting positive numbers only. 

> Find maximum possible sum of elements such that there are no 2 consecutive elements present in the sum.

### Solution

It's a little tricky to write the equation. Always remember the __basic principle of DP__ is to assume that solution is found for (i -1), and then we calculate solution for input (i). 

__Don't miss the (i-1) part__. 

### Code

__written by me__

	public int maxSumNonConsec(int[] input) {
		int len = input.length;
		int[] dp = new int[len];
		dp[0] = input[0];
		dp[1] = Math.max(input[0], input[1]);
		for (int i = 2; i < len; i++) {
			dp[i] = Math.max(dp[i - 1], input[i] + dp[i - 2]);
		}
		return dp[len - 1];
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Decimal to Hexadecimal]]></title>
    <link href="http://okckd.github.io/blog/2014/08/08/Decimal-to-Hex/"/>
    <updated>2014-08-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/08/Decimal-to-Hex</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/13465098/decimal-to-hexadecimal-converter-in-java)

> Decimal to Hexadecimal conversion. 

### Solution

Convert binary to hex as a group of 4 bits. 

Read code. 

### Code

__written by me__

	private final char[] hexDigits = { '0', '1', '2', '3', '4', '5', '6', '7',
			'8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
	private final int flag = 0x0F;

	public String decToHex(int dec) {
		char[] hex = new char[8];
		for (int i = 7; i >= 0; i--) {
			int oneDigit = flag & dec;
			dec >>= 4;
			hex[i] = hexDigits[oneDigit];
		}
		return String.valueOf(hex);
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Add Integers Without +/++]]></title>
    <link href="http://okckd.github.io/blog/2014/08/08/Add-integer-without-plus-sign/"/>
    <updated>2014-08-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/08/Add-integer-without-plus-sign</id>
    <content type="html"><![CDATA[### Question 

[link](http://javarevisited.blogspot.sg/2013/06/how-to-add-two-integer-numbers-without-plus-arithmetic-operator-java-example.html)

> Add two numbers (integers) without using + or plus arithmetic operator.

### Solution

__Bit operations__. 

We could not do this in 1 pass, because multiple rounding issues. 

So we do it in while-loop then! 2 solutions available: __iteratively and recursively__. 

### Code

__written by me__

	public int add(int x, int y) {
		// add y into x (and y results to 0)
		while (y != 0) {
			int carry = x & y;
			int sum = x ^ y;
			x = sum;
			y = carry << 1;
		}
		return x;
	}

__recursive__

	public int add2(int x, int y) {
		if (y == 0) {
			return x;
		}
		int carry = (x & y) << 1;
		return add2(x ^ y, carry);
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Memory-related Debugging Problem]]></title>
    <link href="http://okckd.github.io/blog/2014/08/07/Memory-related-debugging-problem/"/>
    <updated>2014-08-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/07/Memory-related-debugging-problem</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/4531742/debugging-a-program-that-crashes-10-times-in-different-places)

> You are given the source to an application which is crashing during run time. After running it 10 times in a debugger, you find it never crashes in the same place. 

> What programming errors could be causing this crash? How would you test each one?

### Analysis

1. code depends on timer/RNG

1. disk full, i.e. other processes may delete a different file causing more space to be available

1. memory issue, i.e. other processes allocate and/or free memory

1. a pointer points to a random location in memory that is changed by another process causing some values be "valid" (very rare though)

[In general](http://stackoverflow.com/a/4531769) a situation with other process is likely.

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Shuffle a Given Array]]></title>
    <link href="http://okckd.github.io/blog/2014/08/01/Shuffle-an-array/"/>
    <updated>2014-08-01T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/01/Shuffle-an-array</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/shuffle-a-given-array/)

> Given an array, generate a random permutation of array elements. 

### Analysis

This is called __[Fisher–Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)__. Proof can be seen at question post: 

> The probability that ith element goes to second last position can be proved to be 1/n by dividing it in two cases.

> Case 1: i = n-1 (index of last element):

> The probability of last element going to second last position is = (probability that last element doesn't stay at its original position) x (probability that the index picked in previous step is picked again so that the last element is swapped)

> So the probability = ((n-1)/n) x (1/(n-1)) = 1/n

> Case 2: 0 < i < n-1 (index of non-last):

> The probability of ith element going to second position = (probability that ith element is not picked in previous iteration) x (probability that ith element is picked in this iteration)

> So the probability = ((n-1)/n) x (1/(n-1)) = 1/n

> We can easily generalize above proof for any other position. 

### Solution

O(n) time complexity. 

	To shuffle an array a of n elements (indices 0..n-1):
	  for i from n − 1 downto 1 do
	       j ← random integer with 0 ≤ j ≤ i
	       exchange a[j] and a[i]

Note the RNG is having limit from 0 to i, and number i keeps decreasing. 

### Code

__not written by me__

	def sattoloCycle(items):
	    i = len(items)
	    while i > 1:
	        i = i - 1
	        j = randrange(i)  # 0 <= j <= i-1
	        items[j], items[i] = items[i], items[j]
	    return
]]></content>
  </entry>
  
</feed>
