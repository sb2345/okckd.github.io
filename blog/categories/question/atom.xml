<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-13T03:38:29+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Number of Occurence of Given Sub-sequence]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/numer-of-occurrence-given-subsequence/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/numer-of-occurrence-given-subsequence</id>
    <content type="html"><![CDATA[### Question

[link](http://stackoverflow.com/questions/6877249/find-the-number-of-occurrences-of-a-subsequence-in-a-string)

> Given a digit '3141592653', find number of occurence of subsequence "123". Note that the sequence occurs twice:

    3141592653
     1    2  3
       1  2  3

> Output 2.

### Solution

Refer to __[LeetCode 115] Distinct Subsequences__. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Number of Distinct Sub-sequence]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/numer-of-distinct-subsequence/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/numer-of-distinct-subsequence</id>
    <content type="html"><![CDATA[### Question

[link](http://stackoverflow.com/questions/5151483/how-to-find-the-number-of-distinct-subsequences-of-a-string)

> Find the number of distinct subsequences of a string (include "" as a subsequence). 

> For example, Input 

    AAA 
    ABCDEFG 
    CODECRAFT 

> Output 

    4 
    128 
    496 

### Solution

In __[LeetCode 115] Distinct Subsequences__, we discuss finding occurence of a given subsequence. 

Now if we do not specify a subsequence, __we want the total number of distinct subsequence__. 

The solution is DP, with the following equation: 

    Let, 

    dp[i] = number of distinct subsequences ending with a[i]

    last[i] = last position of character i in the given string.

__Equation__: 

    dp[i] = dp[last[i] - 1] + ... + dp[i - 1]

The final result is: 

    Distinct Subsequences = dp[1] + ... dp[len - 1]

Example 1: 

    Input   : - A B C
    dp array: 1 1 2 4
    Total = 8

Example 2: 

    Input   : - A A C
    dp array: 1 1 1 3
    Total = 6

The code is posted below. 

### Optimize Solution

There is a good optimization of this DP solution, which is to __keep another dp array 'sum'__, which sum[i] = dp[1] + dp[2] + ... + dp[i]. The final answer would be sum[len - 1]. 

This nice idea is from [this post](http://stackoverflow.com/a/5152203). Credit goes to __IVlad__. 

### Code

un-optimized code. calculate dp[0] ... dp[n], then sum to final result. 

	public int countDistinctSubseq(String input) {
		int len = input.length();
		int[] dp = new int[len + 1];
		// dp[i] denotes the number of distinct subseq within first 'i' chars
		dp[0] = 1;
		// the first 0 chars is "" - we consider it as 1 subseq

		for (int i = 1; i <= len; i++) {
			// set dp[i]
			// dp[i] = dp[i-1] + ... + dp[k] where input{k} == input{i}
			int p = i - 1;
			while (p >= 0) {
				dp[i] += dp[p];
				if (p > 0 && input.charAt(p - 1) == input.charAt(i - 1)) {
					// when meeting a same char ahead of position i, stop
					// adding to dp[i]
					break;
				}
				p--;
			}
		}
		int sum = 0;
		for (int i : dp) {
			sum += i;
		}
		return sum;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Amazon] Longest Repeating Substring]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/longest-repeating-substring/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/longest-repeating-substring</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=9182781)

> Finding the longest repeated substring. 

> Example: "banana" ==> "ana"

### Solution

There are 2 solutions: Suffix array, and Suffix tree. 

__1. Suffix array__. Simple code, explained [here](http://www.careercup.com/question?id=9182781).

> Bentley's programming pearl book has the simplest implementation (less than 15 lines code) which sort all suffix, and then check common prefix length among adjacent suffix. The time complexity is O(n^2logn) for sorting the suffix (which has avg length of O(n)). 

A detailed step-by-step [explanation](http://nriverwang.blogspot.com/2013/04/longest-repeated-substring.html): 

    str = banana, its suffixes are:
    banana
    anana
    nana
    ana
    na
    a

after sort, the suffix array looks like:

    a
    ana
    anana
    banana
    na
    nana

Then for each two adjacent suffixes, check the length of the common prefix.

The answer is "ana" (if overlapping is allowed, otherwise, should be "an"). 

__2. Suffix tree__. Suggest by [this post](http://qr.ae/6W9yJ), Or [this](http://www.careercup.com/question?id=9182781):

> a good solution is to create a suffix tree for the given word and then find the deepest internal node in that tree (node with at least 2 descendants under it)...

For a nice PPT presentation about suffix tree, look [here](https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/suffixtrees.pdf). 

### Code

Suffix array approach. 

	public String longestRepeat(String input) {
		int len = input.length();
		String[] suffixArray = new String[len];
		for (int i = 0; i < len; i++) {
			suffixArray[i] = input.substring(i);
		}
		// now sort the suffix array
		Arrays.sort(suffixArray);
		String longest = "";
		// start to compare neighborhood suffixes, and check LCP
		for (int i = 0; i < suffixArray.length - 1; i++) {
			String lcp = longestCommonPrefix(suffixArray[i], suffixArray[i + 1]);
			if (lcp.length() > longest.length()) {
				longest = lcp;
			}
		}
		return longest;
	}

	private String longestCommonPrefix(String s1, String s2) {
		int p = 0;
		while (p < s1.length() && p < s2.length()) {
			if (s1.charAt(p) != s2.charAt(p)) {
				break;
			}
			p++;
		}
		return s1.substring(0, p);
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LinkedIn] Find All Repeating Substring With Given Length]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/all-repeating-substring-given-length/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/all-repeating-substring-given-length</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=6495932900179968)

> Find all the repeating substring of specified length in a large string sequence.

> For e.g. 

    Input String: "ABCACBABC" 
    repeated sub-string length: 3 
    Output: ABC 

> eg. 

    Input String: "ABCABCA" 
    repeated sub-string length: 2 
    Output: AB, BC, CA

### Solution

Similar to __[Amazon] Longest Repeating Substring__, the best solution is to do __Suffix Tree__, or suffix array. We then need to print nodes on a certain level, who has more than 1 descendant. 

However, since the length of substring is given, we can also do simply iteration: insert all substring with given length into a HashSet, and check repetition. [ref](https://github.com/techpanja/interviewproblems/blob/master/src/strings/repeatingstringsofspecifiedlength/RepeatingStringOfSpecificLength.java)

### Code

Suffix tree solution: not written. 

Hashset code:

	public List<String> solve(String input, int k) {
		List<String> ans = new ArrayList<String>();
		HashSet<String> set = new HashSet<String>();
		for (int i = 0; i <= input.length() - k; i++) {
			String sub = input.substring(i, i + k);
			if (set.contains(sub)) {
				ans.add(sub);
			}
			set.add(sub);
		}
		return ans;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] All Distinct Subsequences With Given Length]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/all-distinct-subsequences-given-length%20-%20Copy/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/all-distinct-subsequences-given-length - Copy</id>
    <content type="html"><![CDATA[### Question

[link](http://11011110.livejournal.com/254164.html)

> Find a polynomial-time algorithm that takes a string of length n, and a number k, output the number of distinct k-character subsequences.

> For instance, input "food" and number k=2, output should be 4. There are four distinct 2-character subsequences of "food": "fo", "fd", "oo", and "od".

### Solution

Similar to __[Question] Number of distinct sub-sequence__, we solve this problem with DP. The dp equation is a bit difficult to write. 

The idea come from comment from [gareth_rees](http://11011110.livejournal.com/254164.html): 

> Let θ(S, k) be the number of distinct k-character subsequences in the string S of length n. 

> Clearly θ(S, k) = 1 if n = k or k = 0 

> and θ(S, k) = 0 if n < k. 

> Otherwise, __choose 1 unique char from S__, and deduct k by 1, then do the DP calculation with the remaining part of S. 

Look at this example: 

    θ("food", 2) = θ("ood", 1) + θ("od", 1) + θ("", 1)
    = (θ("od", 0) + θ("", 0)) + (θ("d", 0) + θ("", 0)) + 0
    = (1 + 1) + (1 + 1)
    = 4

__"food" is divided into 3 parts__. First part we choose "f" to be the first char, thus the value is θ("ood", 1). Second part we choose "o", and final part we choose "d". 

__Note that when we choose a char, it must never have been chosen before__. In case of "food", we only choose 'f', 'o', 'd' once for each. 

This is a very difficult DP question, but the explanation really makes the answer easier. Read my implementation below. 

### Code

	public int countSubSeq(String input, int k) {
		// assuming all input chars are small letter
		return choose(input, 0, k);
	}

	private int choose(String input, int start, int numChar) {
		int charLeft = input.length() - start;
		if (charLeft == numChar || numChar == 0) {
			return 1;
		} else if (charLeft < numChar || numChar < 0) {
			return 0;
		}
		// now numChar is smaller than charLeft, and larger than 0
		// start to pick a char (which is at first appearance)
		int total = 0;
		HashSet<Character> chosen = new HashSet<Character>();
		while (start < input.length()) {
			char currentChar = input.charAt(start);
			if (!chosen.contains(currentChar)) {
				// pick the char pointer by 'start'
				total += choose(input, start + 1, numChar - 1);
				chosen.add(currentChar);
			}
			start++;
		}
		return total;
	}
]]></content>
  </entry>
  
</feed>
