<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: question | Shuatiblog.com]]></title>
  <link href="www.shuatiblog.com/blog/categories/question/atom.xml" rel="self"/>
  <link href="www.shuatiblog.com/"/>
  <updated>2015-04-13T23:58:26+08:00</updated>
  <id>www.shuatiblog.com/</id>
  <author>
    <name><![CDATA[CodeMonkey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Palantir] MultiMap in Java without using Collections ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/12/multi-map-java/"/>
    <updated>2015-04-12T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/12/multi-map-java</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=18479662)

> Explain how you would implement a multi-map in Java without using any collections?

### Solution

This question is pretty strange in a tech interview. But still, if you are asked, I think the most obvious solution is pointed out by [careercup user Abhi](http://www.careercup.com/question?id=18479662). 

The basic idea is to build a nested list structure ourselves, without considering the time complexity. See code below. 

### Code

    public class Node {
        Object key;
        Node next;
        ValueNode vnode;
    }
    public class ValueNode {
        Object Value;
        ValueNode next;
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Palantir] Find Duplicate within K Distance ]]></title>
    <link href="www.shuatiblog.com/blog/2015/04/12/duplicate-within-k-distance/"/>
    <updated>2015-04-12T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/04/12/duplicate-within-k-distance</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=18517665)

> Given an array of values, design and code an algorithm that returns whether there are two duplicates within k indices of each other? 

### Solution

We can keep a HashMap for storing the previous occuring position of a number. 

### Code

    public boolean dupWithinK(int k, int[] arr) {
        Set<Integer> set = new HashSet<Integer>();
        for (int i = 0; i < arr.length; i++) {
            if (set.contains(arr[i])) {
                return true;
            }
            if (i < k) {
                // the first k numbers
                set.add(arr[i]);
            } else {
                // the (k+1) th number and onwards
                set.add(arr[i]);
                set.remove(arr[i - k]);
            }
        }
        return false;
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LinkedIn] Sort part to make entire array sorted ]]></title>
    <link href="www.shuatiblog.com/blog/2015/02/13/sort-part-and-make-whole-array-sorted/"/>
    <updated>2015-02-13T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/02/13/sort-part-and-make-whole-array-sorted</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/minimum-length-unsorted-subarray-sorting-which-makes-the-complete-array-sorted/)

> Given an unsorted array arr[0..n-1] of size n, find the minimum length subarray arr[s..e] such that sorting this subarray makes the whole array sorted.

### Solution

The solution from [gfg](http://www.geeksforgeeks.org/minimum-length-unsorted-subarray-sorting-which-makes-the-complete-array-sorted/) is definitely good, but I find [this graphic explanation](http://stackoverflow.com/a/15855670) a really great resource. 

The idea is, find min and max in the unsorted proportion, and trim the original array. 

### Code

not written.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LinkedIn] Unique combination of factors (因式分解) ]]></title>
    <link href="www.shuatiblog.com/blog/2015/02/13/combination-of-factors/"/>
    <updated>2015-02-13T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/02/13/combination-of-factors</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t1/JobHunting/32803907_0_1.html)

> A question by dongfeiwww: 

> 打印一个数的所有乘数组合，从大到小，不要有重复

> Print all unique combinations of factors of a positive integer. For example given 24:

    24*1
    12*2
    8*3
    6*4
    6*2*2
    4*3*2
    3*2*2*2

### Solution

Simple DFS.

### Code

	public List<List<Integer>> factorCombinations(int n) {
		List<List<Integer>> ans = new ArrayList<List<Integer>>();
		helper(ans, n, n / 2, new ArrayList<Integer>());
		return ans;
	}

	private void helper(List<List<Integer>> ans, int num, int largestFactor,
			List<Integer> path) {
		if (num == 1) {
			ans.add(new ArrayList<Integer>(path));
			return;
		}
		for (int i = largestFactor; i > 1; i--) {
			if (num % i == 0) {
				path.add(i);
				helper(ans, num / i, i, path);
				path.remove(path.size() - 1);
			}
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LinkedIn] Sum of integer weighted by depth ]]></title>
    <link href="www.shuatiblog.com/blog/2015/02/13/Sum-integer-weighted-by-depth/"/>
    <updated>2015-02-13T00:00:00+08:00</updated>
    <id>www.shuatiblog.com/blog/2015/02/13/Sum-integer-weighted-by-depth</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5139875124740096)

    /** 
    * Given a nested list of integers, returns the sum of all integers in the list weighted by their depth 
    * For example, given the list {(1,1),2,(1,10)} the function should return 10 (four 1's at depth 2, one 2 at depth 1) 
    * Given the list {1,{4,{6}}} the function should return 27 (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3) 
    */ 
    public int depthSum (List<NestedInteger> input) 
    { // ur implementation here} 


    ** 
    * This is the interface that represents nested lists. 
    * You should not implement it, or speculate about its implementation. 
    */ 
    public interface NestedInteger 
    { 
    /** @return true if this NestedInteger holds a single integer, rather than a nested list */ 
    boolean isInteger(); 

    /** @return the single integer that this NestedInteger holds, if it holds a single integer 
    * Return null if this NestedInteger holds a nested list */ 
    Integer getInteger(); 

    /** @return the nested list that this NestedInteger holds, if it holds a nested list 
    * Return null if this NestedInteger holds a single integer */ 
    List<NestedInteger> getList(); 
    }

### Solution

DFS recurse. 

### Code

The algo:

	public int depthSum(List<NestedInteger> input, int weight) {
		// ur implementation here
		int sum = 0;
		for (NestedInteger ni : input) {
			if (ni.isInteger()) {
				sum += ni.getInteger() * weight;
			} else {
				sum += depthSum(ni.getList(), weight + 1);
			}
		}
		return sum;
	}

Interface and Impl:

    /*
     * This is the interface that represents nested lists. You should not implement
     * it, or speculate about its implementation.
     */
    interface NestedInteger {
        /**
         * @return true if this NestedInteger holds a single integer, rather than a
         *         nested list
         */
        boolean isInteger();

        /**
         * @return the single integer that this NestedInteger holds, if it holds a
         *         single integer Return null if this NestedInteger holds a nested
         *         list
         */
        Integer getInteger();

        /**
         * @return the nested list that this NestedInteger holds, if it holds a
         *         nested list Return null if this NestedInteger holds a single
         *         integer
         */
        List<NestedInteger> getList();
    }

    class NestedIntegerImpl implements NestedInteger {

        int num;
        List<NestedInteger> list = new ArrayList<NestedInteger>();

        public NestedIntegerImpl(int number) {
            num = number;
            list = null;
        }

        public NestedIntegerImpl(List<NestedInteger> inputList) {
            num = -1;
            list = inputList;
        }

        @Override
        public boolean isInteger() {
            return list == null;
        }

        @Override
        public Integer getInteger() {
            if (isInteger()) {
                return num;
            }
            return -1;
        }

        @Override
        public List<NestedInteger> getList() {
            return list;
        }
    }
]]></content>
  </entry>
  
</feed>
