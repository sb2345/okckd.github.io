<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-10T12:51:58+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Most Frequent Word From a Book]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/most-frequent-word-from-book/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/most-frequent-word-from-book</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=5715664853532672)

> Let's say I gave you a long String and I wanted you to tell me the most common word in that String. How would you do that? 

> Follow-up: how about if I gave you the entire works of Alexandre Dumas, one of the most prolific authors in history. How would your solution work? How could you change it to solve this more specific problem? 

### Solution

There are 2 solutions. Either __HashMap__ or __Trie__. It's easy to think of first, but remember that Trie is designed to do this kind of job. 

> A trie will be more useful in the second situation where you will have millions of words. You can have a counter at every node to see its frequency

__Now the follow up__. For big data problems, we can always do __divide and conquer__ by hash value. 

Alternatively, the comment by [Prince](http://www.careercup.com/question?id=5715664853532672) mentioned how to solve with __Map Reduce__: 

> Instead of loading it as a string first I would stream data so that I avoid memory spike. Further our map size might increases as new words are added to it. Also, we can use map reduce type job were we create map<word, frequency> of each play in parallel and later join/collapse them this will reduce the time it will take to get result. 

> Common phrase should be no different then above algorithm. However we need to rebuild our index with <phase, frequency>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Match Triplet With Reverse Order]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/match-triplet-with-reverse-order/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/match-triplet-with-reverse-order</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=11655778)

> Find the substring of length 3 which is present in the reverse order from the string. 

> Ex: if the string is abcdcba (cba is the reverse of abc) so we should return cba. 

### Solution

1. __HashMap (recommended)__. Hash all substrings of length 3. O(n). Look up all reverse substrings of length 3 in this hash set. O(n) time and O(n) space. 

1. __KMP Algo__. Take every substring of length 3. Reverse it and find it in the input using KMP. O(n^2) time and O(1) space. 

1. __Build suffix tree__ of height 3. Then in reverse order, check triplets. 

The 3 solutions above all work well. Pick the one you love. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Longest Common Contiguous Intersection (Longest Common Substring)]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/longest-common-substring/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/longest-common-substring</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=12862670)

> Write Program to find longest common contiguous intersection from 2 lists provided to the function. 

> Example: list1: abcrfghwetf 
>
> list2: abrfghwwetxyab 

> Ans: rfghw

### Solution

This is a classic [Longest common substring](http://en.wikipedia.org/wiki/Longest_common_substring_problem) problem.

Solution 1: __Suffix tree__. Building the tree is O(n) time and the whole program is O(n + m) time. 

Solution 2: __DP__, which takes O(nm) time and space. The code for DP is posted below. 

### Code

__dp__

	public String LCSubstr(String s, String t) {
		int longest = 0;
		int tPos = -1;

		// dp[i][j] represents the LCSubstr ending at position i and j
		int[][] dp = new int[t.length() + 1][s.length() + 1];
		for (int i = 1; i <= t.length(); i++) {
			for (int j = 1; j <= s.length(); j++) {
				if (t.charAt(i - 1) == s.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1] + 1;
					if (dp[i][j] > longest) {
						longest = dp[i][j];
						tPos = i;
					}
				}
			}
		}
		return t.substring(tPos - longest, tPos);
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Epic] Patient Disease Data Structure]]></title>
    <link href="http://okckd.github.io/blog/2014/12/08/patient-disease-data-structure/"/>
    <updated>2014-12-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/12/08/patient-disease-data-structure</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t0/JobHunting/32844253.html)

> Suppose N patients and M diseases. N is sufficiently large number and M is 
relatively small, say 30-ish. Each patient can have possible 0 to M kinds of
diseases.

> Given one patient’s name, show me a list of similar patients sharing same 
deseases within 2-3 seconds.

### Solution

__Use 1 bit to represent a disease__. So every patient's conditin can be put into an integer of 32 bits. 

How do we calculate the similarity of 2 patients?

Refer to __[CC150v5] 5.5 Calculate Bits Conversion Required__ for a special bit operation (remove last '1' from bit): 

> c = c & (c - l) clears the least significant bit of '1'. 
>
> Keep doing this until all '1's are cleared. 

For each patient, we simply calculate the XOR and count '1's. 

### Code

no code. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Interleave Positive and Negative Numbers]]></title>
    <link href="http://okckd.github.io/blog/2014/10/08/interleave-positive-negative/"/>
    <updated>2014-10-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/10/08/interleave-positive-negative</id>
    <content type="html"><![CDATA[### Question

[link](http://mp.weixin.qq.com/s?__biz=MzA5MzE4MjgyMw==&mid=200355650&idx=1&sn=f94e87cb391fb12af9531cedb452dba1&key=d232b50733c41de56b96f855d9cdea5824f24c712e158651b45d7fe139a94610a7561da1fab0104e968592b01f2439d4&ascene=7&uin=MzM2NjQyNQ%3D%3D&pass_ticket=i7pJQweQbuRdnUFUt5cdOmapPc%2FDW6Xk40U7%2Bcg%2F0o8%3D)

> 给一个包含正负整数的数组，要求对这个数组中的数进行重新排列，使得其正负交替出现。首先出现负数，然后是正数，然后是负数。有多余的数的一方，就放在末尾。

> 如 [1, 2, 3, -4]->[-4, 1, 2, 3]，[1,-3,2,-4,-5]->[-3,1,-4,2,-5]. 要求使用O(1)的额外空间。

> 如果需要保持正数序列和负数序列各自原来的顺序，如何做？

> 如果不需要保持正数序列和负数序列各自原来的顺序，如何做？

### Solution

I only solve this question if we __do not have to keep the original ordering__. 

Basically, 2 pointers search from beginning to end. If there're more + than -, move the extra positive values to the back of the array. Vice versa. 

### Code

__written by me__

	public void solve(int[] A) {
		int len = A.length;
		int neg = 0;
		int pos = 1;
		while (neg < len || pos < len) {

			while (neg < len && A[neg] < 0) {
				neg += 2;
			}
			while (pos < len && A[pos] > 0) {
				pos += 2;
			}
			// neg points to a positive value
			// pos points to a negative value
			// swap them (if they're valid position)
			if (neg >= len && pos >= len) {
				return;
			} else if (neg >= len) {
				// neg is done, there's more - then +
				// put all negative values pointed by pos to the back
				int right = len - 1;
				if (right % 2 == 0) {
					right--;
				}
				while (pos < right) {
					while (pos < len && A[pos] > 0) {
						pos += 2;
					}
					while (right >= 0 && A[right] < 0) {
						right -= 2;
					}
					// pos point to a negative value, right to positive value
					if (pos > right) {
						break;
					} else {
						swap(A, pos, right);
					}
				}
				return;
			} else if (pos >= len) {
				// pos is done, there's more + then -
				int right = len - 1;
				if (right % 2 == 1) {
					right--;
				}
				while (neg < right) {
					while (neg < len && A[neg] < 0) {
						neg += 2;
					}
					while (right >= 0 && A[right] > 0) {
						right -= 2;
					}
					if (neg > right) {
						break;
					} else {
						swap(A, neg, right);
					}
				}
				return;
			} else {
				swap(A, neg, pos);
			}
		}
	}

	private void swap(int[] array, int a, int b) {
		int temp = array[a];
		array[a] = array[b];
		array[b] = temp;
	}
]]></content>
  </entry>
  
</feed>
