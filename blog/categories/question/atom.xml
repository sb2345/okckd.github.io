<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-02-05T10:42:53+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Amazon] Grep Command Interview Question]]></title>
    <link href="http://okckd.github.io/blog/2015/02/04/grep-command-interview-question/"/>
    <updated>2015-02-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/04/grep-command-interview-question</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=1799)

> You have 50,000 html files, some of which contain phone numbers. How would you create a list of all the files which contain phone numbers? 

### Solution

This is a famous inteview question by former Amazon engineer [Steve Yegge](https://sites.google.com/site/steveyegge2/five-essential-phone-screen-questions): 

> About 25% to 35% of all software development engineer candidates, independent of experience level, cannot solve this problem, even given the entire interview hour and lots of hints. 

This question tests your understanding of scripting languages. 

### Code

    grep -l -R --perl-regexp "\b(\(\d{3}\)\s*|\d{3}-)\d{3}-\d{4}\b" * > output.txt
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Stock Span Problem (Couting BST)]]></title>
    <link href="http://okckd.github.io/blog/2015/02/01/stock-span-problem/"/>
    <updated>2015-02-01T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/01/stock-span-problem</id>
    <content type="html"><![CDATA[### Question 

> Given stock price of Amazon for some consecutive days. Need to find the maximum span of each day’s stock price. 

Definition of 'span' have got 2 variant: 

### Variant 1

[link](http://www.geeksforgeeks.org/the-stock-span-problem/)

> Span is the number of consecutive days right before that day, which have less or equal stock value. 

> (Or in GFG language): The span Si of the stock’s price on a given day i is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the current day is less than or equal to its price on the given day.

### Solution

<img class="middle" src="/assets/images/StockSpanProblem1.png">

Use stack. 

### Variant 2

[link](http://www.careercup.com/question?id=4825417139617792)

> Span is the amount of days before the given day where the stock price is less than that of given day. 

### Solution

The top answer in [here](http://www.careercup.com/question?id=4825417139617792) is wrong. Eg. {1,3,2,4}, the count for 4 would be 2, instead of 3. 

Instead, the __BST (AVL tree) solution is correct__. It's commented by user zahidbuet106. 

> insert numbers in a AVL tree one by one from right to left. During each insert we will keep updating the __size of left subtree__ at the node being inserted. This will give us our desired smaller element count. 

> We also need to handle balancing the tree while insert. 

__The key of this question is the special BST, where each node stores an additional counting number__. 

This type of special BST is extremely frequntly used in Computer Science, especially when we want to dynamically insert elements and find out it's ranking within the past history. 

Read another very interesting post: __[CC150v5] 11.8 Get Rank in Stream of Integers__.

### Code

	class TreeNodePlus extends TreeNode {
		int leftCount;
		int dupCount;

		public TreeNodePlus(int v, int leftC) {
			super(v);
			this.leftCount = leftC;
			this.dupCount = 1;
		}

		public int findRank(TreeNodePlus node) {
			TreeNodePlus leftBranch = (TreeNodePlus) this.left;
			TreeNodePlus rightBranch = (TreeNodePlus) this.right;

			if (this == node) {
				return 0;
			} else if (node.val < this.val) {
				if (this.left == null) {
					return 0;
				} else {
					return leftBranch.findRank(node);
				}
			} else {
				if (this.right == null) {
					return this.leftCount + this.dupCount;
				} else {
					return this.leftCount + this.dupCount
							+ rightBranch.findRank(node);
				}
			}
		}

		public TreeNodePlus insertNum(int num) {
			TreeNodePlus leftBranch = (TreeNodePlus) this.left;
			TreeNodePlus rightBranch = (TreeNodePlus) this.right;

			if (num == this.val) {
				this.dupCount++;
				return this;
			} else if (num < this.val) {
				// insert num to the left branch
				this.leftCount++;
				if (this.left == null) {
					this.left = new TreeNodePlus(num, 0);
					return (TreeNodePlus) this.left;
				} else {
					return leftBranch.insertNum(num);
				}
			} else {
				// insert num to the right branch
				// this.leftCount does not change
				if (this.right == null) {
					this.right = new TreeNodePlus(num, 0);
					return (TreeNodePlus) this.right;
				} else {
					return rightBranch.insertNum(num);
				}
			}
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Greedy] Each Employee 2 Events]]></title>
    <link href="http://okckd.github.io/blog/2015/02/01/each-employee-two-events/"/>
    <updated>2015-02-01T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/01/each-employee-two-events</id>
    <content type="html"><![CDATA[[link](http://www.careercup.com/question?id=7894677)

### Question 

> You are given N ranges of date offsets when N employees are present in an organization. Something like 

        1-4 (i.e. employee will come on 1st, 2nd, 3rd and 4th day ) 
        2-6 
        8-9 
        .. 
        1-14 

> Organize an event on minimum number of days such that each employee can attend the event at least twice.

### Solution

__Greedy algorithm__, according to the [top answer](http://www.careercup.com/question?id=7894677): 

1. First, sort all ranges based on ENDING date in increasing order (bucket or counting sort). 

1. For each range, select last two days (because they produce maximum possibility to overlap next range) 

1. Skip following ranges that also contains those two days, until:

    1. a range that either covers only one day (we then select last day of this range) or 
    1. does not cover any of the two (we then select last two days of this range). 

1. Then continue.

### Code

not written
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Greedy] Activity Selection Problem]]></title>
    <link href="http://okckd.github.io/blog/2015/02/01/Activity-Selection-Problem/"/>
    <updated>2015-02-01T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/01/Activity-Selection-Problem</id>
    <content type="html"><![CDATA[[link](http://www.geeksforgeeks.org/greedy-algorithms-set-1-activity-selection-problem/)

### Question 

> Given n activities with their start and finish times. 

> Select maximum number of activities that can be performed in one run. 

> Example:

         start[]  =  {1, 3, 0, 5, 8, 5};
         finish[] =  {2, 4, 6, 7, 9, 9};

         output[] = {0, 1, 3, 4}

### Solution

__Greedy algorithm__, according to [gfg](http://www.geeksforgeeks.org/greedy-algorithms-set-1-activity-selection-problem/): 

1. Sort the activities according to their finishing time

1. Select the first activity from the sorted array and print it.

1. For the rest, if start time is greater than previous finish time, then select this activity.

### Code

not written.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] 2D Bin Packing]]></title>
    <link href="http://okckd.github.io/blog/2015/01/30/2d-bin-packing/"/>
    <updated>2015-01-30T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/30/2d-bin-packing</id>
    <content type="html"><![CDATA[### Question 

[link](http://en.wikipedia.org/wiki/Bin_packing_problem)

> Objects of different volumes must be packed into a finite number of bins or containers each of volume V in a way that minimizes the number of bins used.

<img class="middle" src="/assets/images/bin-packing.png">

### Solution

Explanation from [here](http://stackoverflow.com/a/8765049): 

1. Build a binary tree. Each branch in the tree contains a sprite. 
1. Each __leaf node represents available space__. 
1. Initially the tree has just the root node, which represents all available space. 
1. To add a sprite to the tree, search the tree for an unoccupied (leaf) node __big enough__ to hold the sprite. 
1. Turn that node from a leaf into a branch by setting the sprite as the node's occupant and giving the node two children. 
1. One child represents the remaining space to the right of the sprite; 
1. the other represents the remaining space below the sprite and the first child.

For detailed implementation and code, refer to [this](http://codeincomplete.com/posts/2011/5/7/bin_packing/) comprehensite guide. BTW, it's used for __auto generating CSS Sprites__ which puts images into a large graph. 
]]></content>
  </entry>
  
</feed>
