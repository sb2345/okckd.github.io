<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-26T21:05:09+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Test hashCode() Function]]></title>
    <link href="http://okckd.github.io/blog/2014/08/26/Test-hashcode-function/"/>
    <updated>2014-08-26T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/26/Test-hashcode-function</id>
    <content type="html"><![CDATA[### Question

> How to test hashCode() function? Example: 

	public int hashCode(){
		int result = 17 + hashDouble(re);
		result = 31 * result + hashDouble(im);
		return result;
	}

### Solution

We need to test that the hash function is [reflexive, symmetric, and transitive](http://stackoverflow.com/a/4449791). 

### Code

Not including 'not equal' test. 

	@Test
	public void testEquals_Symmetric() {
		Person x = new Person("Foo Bar");  // equals and hashCode check name field value
		Person y = new Person("Foo Bar");
		Assert.assertTrue(x.equals(y) && y.equals(x));
		Assert.assertTrue(x.hashCode() == y.hashCode());
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Square Count of Matchstick Graph]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Square-count-in-matchstick-graph/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Square-count-in-matchstick-graph</id>
    <content type="html"><![CDATA[### Question 

> 给出下面这个图 设计数据结构和算法求出图中__所有的正方形数量__ (count the number of squares). 

<img class="middle" src="/assets/images/matchstick-square-count.jpg">

### Solution

1. __Pre-processing__: 从每一个点开始存储上下左右四个方向最多延伸到的位置

1. __Main algorithm__: 枚举右下角位置 然后枚举正方形边长 

1. 根据预处理的延伸情况判断是否能够有一个正方形被构造出来 

Total time complexity is O(n^3). 

> 预处理可以O(n^2) 预处理是有递推关系的 
>
> 但是后面枚举的部分，只能O(n^3)
>
> __不能动态规划的原因是__：他给定了一个可以变化的图，这个图上规模为n的图和规模为n-1的图中正方形个数之间不存在递推关系。 

And 一般来说处理矩阵的问题，大部分都是O(n^3)

### Code

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Ways of Dice Throw]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Dice-roll-DP-question/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Dice-roll-DP-question</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/dice-throw-problem/)

> Given n dice each with m faces, numbered from 1 to m, find the number of ways to get sum X. X is the summation of values on each face when all the dice are thrown. 

### Solution

__DP__

> Sum(m, n, X) = Sum(m, n - 1, X - 1) + 
>
>                Sum(m, n - 1, X - 2) +
>
>                .................... + 
>
>                Sum(m, n - 1, X - m)

So we can have dp(n)(X) and for each, iterate m time. Total time is O(m * n * X). 

### Code

__not written by me__.

	int findWays(int m, int n, int x)
	{
	    // Create a table to store results of subproblems.  One extra 
	    // row and column are used for simpilicity (Number of dice
	    // is directly used as row index and sum is directly used
	    // as column index).  The entries in 0th row and 0th column
	    // are never used.
	    int table[n + 1][x + 1];
	    memset(table, 0, sizeof(table)); // Initialize all entries as 0
	 
	    // Table entries for only one dice
	    for (int j = 1; j <= m && j <= x; j++)
	        table[1][j] = 1;
	 
	    // Fill rest of the entries in table using recursive relation
	    // i: number of dice, j: sum
	    for (int i = 2; i <= n; i++)
	        for (int j = 1; j <= x; j++)
	            for (int k = 1; k <= m && k < j; k++)
	                table[i][j] += table[i-1][j-k];
	 
	    /* Uncomment these lines to see content of table
	    for (int i = 0; i <= n; i++)
	    {
	      for (int j = 0; j <= x; j++)
	        cout << table[i][j] << " ";
	      cout << endl;
	    } */
	    return table[n][x];
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Count Set Bit in Binary Number]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Count-set-bit-in-binary-number/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Count-set-bit-in-binary-number</id>
    <content type="html"><![CDATA[### Question 

> Count Set Bit in Binary Number.

> 3 = 00000011 => 2

> 128 = 10000000 => 1

### Solution

__Bits counting algorithm__ (Brian Kernighan). Basic idea is __clear 1 bit at a time__. 

This algorithm goes through as many iterations as there are set bits. In the worst case, it will pass once per bit. An integer n has log(n) bits, hence [the worst case](http://stackoverflow.com/a/12381102) is O(log(n)).

### Code

	public int countSetBit(String binary) {
		int num = Integer.parseInt(binary, 2);
		int count = 0;
		while (num != 0) {
			num &= num - 1;
			count++;
		}
		return count;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Count Level in Perfect Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/08/19/Count-level-in-perfect-BT/"/>
    <updated>2014-08-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/19/Count-level-in-perfect-BT</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/10721583/how-can-i-calculate-the-level-of-a-node-in-a-perfect-binary-tree-from-its-depth)

> A perfect binary tree, i.e. each node in the tree is either a leaf node, or has two children, and all leaf nodes are on the same level. Each node has an index in depth-first order. 

		  0
		/   \
	  1      4
	 / \    / \
	2   3  5   6

> Given the index (k) of a particular node, calculate its level. 

### Solution

__This is a [magical solution](http://stackoverflow.com/a/10721897)__.  It divides the tree in the middle with number k decrease by 1 each time. 

Beautiful, and hard to understand. 

### Code

__not written by me__.

	public int countLevel(TreeNode root, int k, int n) {
		int level = 0;
		while (k != 0) {
			k--;
			n = (n - 1) / 2;
			k = k % n;
			level++;
		}
		return level + 1;
	}
]]></content>
  </entry>
  
</feed>
