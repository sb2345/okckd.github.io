<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-02-04T22:43:41+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Snakes and Ladders]]></title>
    <link href="http://okckd.github.io/blog/2015/02/04/snakes-and-ladders/"/>
    <updated>2015-02-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/04/snakes-and-ladders</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=14955106)

> Given a board of snakes and ladders game, provide an algorithm to find the minimum number of dice rolls required to reach 100 from 1.

<img class="middle" src="/assets/images/">

### Solution 1

Recommended: __Graph (shortest path)__. [ref](http://www.careercup.com/question?id=14955106): 

1. k is linked to k + 1 k + 2, k + 3, k + 4, k + 5, k +6. 

2. If has a ladder, connect it too. 

3. Find shortest path.

Solution 2 is __DP__. 

### Variant

If the question asks: find the way to climb as many ladder as possible. Then this question would be solved differently.

Any ideas? 

Solution below. 

...

...

...

Read __[Greedy] Activity Selection Problem__. 

### Code

not written
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Number of Subtrees With Even Nodes]]></title>
    <link href="http://okckd.github.io/blog/2015/02/04/number-of-subtree-with-even-nodes/"/>
    <updated>2015-02-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/04/number-of-subtree-with-even-nodes</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t0/JobHunting/32348573.html)

> an arbitrary tree. split it into as many subtrees as you can. the 
number of nodes of the subtree must be even.

<img class="middle" src="/assets/images/">

### Solution

__This is a difficult question__. The idea is recursive solution, but be cautious deadling with NULL. 

__NULL can be regarded as a child branch of even node (0)__, but NULL could not be seen as a subtreee. 

1. traverse each and every node in the tree
1. for each node, take it as root, and find left and right branch with total sum of odd count of nodes. 
1. we do above step recursively
1. include NULL as a subtree of EVEN number of nodes. 

The code below is my code and I haven't seen any reference to this question. If you read this, please comment and discuss with me! 

### Code

	public void traverseAndFindEvenSubstrees(List<TreeNode> ans, TreeNode node) {
		if (node == null) {
			return;
		}
		List<TreeNode> evenSubtrees = this.getSubtrees(node, true);
		evenSubtrees.remove(null);
		ans.addAll(evenSubtrees);

		traverseAndFindEvenSubstrees(ans, node.left);
		traverseAndFindEvenSubstrees(ans, node.right);
	}

	private List<TreeNode> getSubtrees(TreeNode root, boolean isEven) {
		List<TreeNode> ans = new ArrayList<TreeNode>();
		if (root == null) {
			if (isEven) {
				// NULL is considered as a subtree with even number (0) of nodes
				ans.add(null);
			}
			return ans;
		}
		if (isEven) {
			// we need 2 subtrees to have a combined nodes of odd numbers
			for (int i = 0; i <= 1; i++) {
				List<TreeNode> leftGroup = getSubtrees(root.left, i == 0);
				List<TreeNode> rightGroup = getSubtrees(root.right, i != 0);
				// what we do here, is to make leftGroup and rightGroup have
				// different boolean parameter, thus a total of odd count
				for (TreeNode ln : leftGroup) {
					for (TreeNode rn : rightGroup) {
						// note that NULL is included in either leftGroup or
						// rightGroup. we'll use that
						TreeNode newSubtree = new TreeNode(root.val);
						newSubtree.left = ln;
						newSubtree.right = rn;
						ans.add(newSubtree);
					}
				}
			}
			// now we've added all subtrees into ans, whose head is the root
			// this means we does not inlcude NULL
		} else {
			for (int i = 0; i <= 1; i++) {
				List<TreeNode> leftGroup = getSubtrees(root.left, i == 0);
				List<TreeNode> rightGroup = getSubtrees(root.right, i == 0);
				for (TreeNode ln : leftGroup) {
					for (TreeNode rn : rightGroup) {
						TreeNode newSubtree = new TreeNode(root.val);
						newSubtree.left = ln;
						newSubtree.right = rn;
						ans.add(newSubtree);
					}
				}
			}
		}
		// now last step, add NULL (important)
		if (isEven) {
			ans.add(null);
		}
		return ans;
	}

Test data:

    Test start
    Input is a BST with this structure: 
    4 
    2 6 
    1 3 5 7 

    Total subtree count = 16
    They are: 
    Tree 1:
    4 
    2 6 
    3 
    Tree 2:
    4 
    2 6 
    3 5 7 
    Tree 3:
    4 
    2 6 
    1 
    Tree 4:
    4 
    2 6 
    1 5 7 
    Tree 5:
    4 
    6 
    Tree 6:
    4 
    6 
    5 7 
    Tree 7:
    4 
    2 6 
    7 
    Tree 8:
    4 
    2 6 
    5 
    Tree 9:
    4 
    2 
    Tree 10:
    4 
    2 6 
    1 3 7 
    Tree 11:
    4 
    2 6 
    1 3 5 
    Tree 12:
    4 
    2 
    1 3 
    Tree 13:
    2 
    3 
    Tree 14:
    2 
    1 
    Tree 15:
    6 
    7 
    Tree 16:
    6 
    5 
    Total time = 0.006
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Grep Command Interview Question]]></title>
    <link href="http://okckd.github.io/blog/2015/02/04/grep-command-interview-question/"/>
    <updated>2015-02-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/04/grep-command-interview-question</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=1799)

> You have 50,000 html files, some of which contain phone numbers. How would you create a list of all the files which contain phone numbers? 

### Solution

This is a famous inteview question by former Amazon engineer [Steve Yegge](https://sites.google.com/site/steveyegge2/five-essential-phone-screen-questions): 

> About 25% to 35% of all software development engineer candidates, independent of experience level, cannot solve this problem, even given the entire interview hour and lots of hints. 

This question tests your understanding of scripting languages. 

### Code

    grep -l -R --perl-regexp "\b(\(\d{3}\)\s*|\d{3}-)\d{3}-\d{4}\b" * > output.txt
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Collatz Conjecture (Oneness Property)]]></title>
    <link href="http://okckd.github.io/blog/2015/02/04/Collatz-Conjecture-oneness/"/>
    <updated>2015-02-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/04/Collatz-Conjecture-oneness</id>
    <content type="html"><![CDATA[### Collatz Conjecture

The [Collatz conjecture](http://en.wikipedia.org/wiki/Collatz_conjecture) is a conjecture in mathematics known as the 3n + 1 conjecture. 

Take any natural number n. 

1. If n is even, divide it by 2 to get n / 2. 
1. If n is odd, multiply it by 3 and add 1 to obtain 3n + 1. 

Repeat the process (which has been called "Half Or Triple Plus One", or HOTPO) indefinitely. The conjecture is that no matter what number you start with, __you will always eventually reach 1__. 

The property has also been called __oneness__. 

### Question 

[link](http://stackoverflow.com/questions/5437445/collatz-conjecture-related-interview)

> Collatz conjecture says that if you do the following

    If n is even, replace n by n/2.
    If n is odd, replace n by 3n+1.
    You ultimately end up with 1.

> For instance, 5 -> 16 -> 8 -> 4 -> 2 -> 1

> Chain length is the number of steps required to get to 1. (The chain length of 1 is 0).

> Now, the problem is given natural numbers n and k, find all numbers between 1 and n, such that the chain length is <= k. 

### Solution

Generate all numbers in backwards fashion, suggest by [templatetypedef](http://stackoverflow.com/a/5437672): 

                      1
                      |
                      2
                      |
                      4
                      |
                      8
                      |
                      16
                      | \
                      32 \
                      |   5
                      64  |
                     /|   10
                    / 128 | \
                   21     20 3

__Implementation__: using a queue and keep appending numbers. 

__Duplication handling__? 

> Assuming that the Collatz conjecture holds true, we'll never get any duplicates this way.

__Time complexity__ is O(S) time, where S is the number of numbers we need to output.

### Code

not written
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Stock Span Problem]]></title>
    <link href="http://okckd.github.io/blog/2015/02/01/stock-span-problem/"/>
    <updated>2015-02-01T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/01/stock-span-problem</id>
    <content type="html"><![CDATA[### Question 

> Given stock price of Amazon for some consecutive days. Need to find the maximum span of each day’s stock price. 

Definition of 'span' have got 2 variant: 

### Variant 1

[link](http://www.geeksforgeeks.org/the-stock-span-problem/)

> Span is the number of consecutive days right before that day, which have less or equal stock value. 

> (Or in GFG language): The span Si of the stock’s price on a given day i is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the current day is less than or equal to its price on the given day.

### Solution

<img class="middle" src="/assets/images/StockSpanProblem1.png">

Use stack. 

### Variant 2

[link](http://www.careercup.com/question?id=4825417139617792)

> Span is the amount of days before the given day where the stock price is less than that of given day. 

### Solution

The top answer in [here](http://www.careercup.com/question?id=4825417139617792) is wrong. Eg. {1,3,2,4}, the count for 4 would be 2, instead of 3. 

Instead, the __BST (AVL tree) solution is correct__. It's commented by user zahidbuet106. 

> insert numbers in a AVL tree one by one from right to left. During each insert we will keep updating the __size of left subtree__ at the node being inserted. This will give us our desired smaller element count. 

> We also need to handle balancing the tree while insert. 

__The key of this question is the special BST, where each node stores an additional counting number__. 

This type of special BST is extremely frequntly used in Computer Science, especially when we want to dynamically insert elements and find out it's ranking within the past history. 

Read another very interesting post: __[CC150v5] 11.8 Get Rank in Stream of Integers__.

### Code

	class TreeNodePlus extends TreeNode {
		int leftCount;
		int dupCount;

		public TreeNodePlus(int v, int leftC) {
			super(v);
			this.leftCount = leftC;
			this.dupCount = 1;
		}

		public int findRank(TreeNodePlus node) {
			TreeNodePlus leftBranch = (TreeNodePlus) this.left;
			TreeNodePlus rightBranch = (TreeNodePlus) this.right;

			if (this == node) {
				return 0;
			} else if (node.val < this.val) {
				if (this.left == null) {
					return 0;
				} else {
					return leftBranch.findRank(node);
				}
			} else {
				if (this.right == null) {
					return this.leftCount + this.dupCount;
				} else {
					return this.leftCount + this.dupCount
							+ rightBranch.findRank(node);
				}
			}
		}

		public TreeNodePlus insertNum(int num) {
			TreeNodePlus leftBranch = (TreeNodePlus) this.left;
			TreeNodePlus rightBranch = (TreeNodePlus) this.right;

			if (num == this.val) {
				this.dupCount++;
				return this;
			} else if (num < this.val) {
				// insert num to the left branch
				this.leftCount++;
				if (this.left == null) {
					this.left = new TreeNodePlus(num, 0);
					return (TreeNodePlus) this.left;
				} else {
					return leftBranch.insertNum(num);
				}
			} else {
				// insert num to the right branch
				// this.leftCount does not change
				if (this.right == null) {
					this.right = new TreeNodePlus(num, 0);
					return (TreeNodePlus) this.right;
				} else {
					return rightBranch.insertNum(num);
				}
			}
		}
	}
]]></content>
  </entry>
  
</feed>
