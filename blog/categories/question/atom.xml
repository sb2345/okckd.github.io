<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-28T08:13:24+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Push and Pop Sequences of Stacks]]></title>
    <link href="http://okckd.github.io/blog/2015/01/26/Push-and-Pop-Sequences-Stacks/"/>
    <updated>2015-01-26T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/26/Push-and-Pop-Sequences-Stacks</id>
    <content type="html"><![CDATA[### Question 

[link](http://codercareer.blogspot.sg/2011/11/no-21-push-and-pop-sequences-of-stacks.html)

> Given two integer sequences, one of which is the push sequence of a stack, please check whether the other sequence is a corresponding pop sequence or not. 

> For example, if 1, 2, 3, 4, 5 is a push sequence, 4, 5, 3, 2, 1 is a corresponding pop sequence, but the sequence 4, 3, 5, 1, 2 is not.

### Solution

Refer to [this answer](http://stackoverflow.com/a/17828345): 

> Construct the stack: 
>
> For each number X in the pop order:

    If this number is not the same as the top of the stack (or the stack is empty), 
    push numbers from the push order until you pushed X. 
    
    If you pushed all numbers and didn't find X, there's no way to get the pop order.
    
    Pop X

### Code

	public boolean validSequence(int[] input, int[] sequenc) {
		// keep a pointer p in the input[] array
		int len = input.length;
		int p = 0;
		Stack<Integer> stack = new Stack<Integer>();

		int i = 0;
		while (i < len) {
			if (stack.isEmpty()) {
				// just push an element to stack
				stack.push(input[p++]);
			} else {
				// stack got elements, then check top one
				if (stack.peek() == sequenc[i]) {
					// seq found, proceed to next number in seq
					stack.pop();
					i++;
				} else {
					// did not find seq, keep pushing to stack until done
					if (p == len) {
						return false;
					} else {
						stack.push(input[p++]);
					}
				}
			}
		}
		return i == len; // or just return true;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Palantir] Largest Basin Size in Matrix]]></title>
    <link href="http://okckd.github.io/blog/2015/01/20/basin-size-in-matrix/"/>
    <updated>2015-01-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/20/basin-size-in-matrix</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=15380670)

A group of farmers has some elevation data, and we’re going to help them understand how rainfall flows over their farmland.

We’ll represent the land as a two-dimensional array of altitudes and use the following model, based on the idea that water flows downhill:

If a cell’s neighboring cells all have higher altitudes, we call this cell a sink; water collects in sinks. Two cells are neighbors if the rows and columns each differ by at most one. Hence an interior cell will have eight neighbors, a cell on the edge will have five neighbors, and a cell in a corner will have three neighbors.

Otherwise, water will flow to the neighboring cell with the lowest altitude. If a cell is not a sink, you may assume it has a unique lowest neighbor and that this neighbor will be lower than the cell.
Cells that drain into the same sink – directly or indirectly – are said to be part of the same basin.
 
Your challenge is to partition the map into basins. In particular, given a map of elevations, your code should partition the map into basins and output the sizes of the basins, in descending order.
 
Assume the elevation maps are square. Input will begin with a line with one integer, S, the height (and width) of the map. The next S lines will each contain a row of the map, each with S integers – the elevations of the S cells in the row.  Some farmers have small land plots such as the examples below, while some have larger plots.  However, in no case will the total size of the farmland exceed 1000x1000.
 
Note: The input uses unix line endings (\n). If you try to view the sample inputs on a windows machine with a program that does not convert line endings (like Notepad), you will see the input appear all on a single line.
 
Your code should output a space-separated list of the basin sizes, in descending order. (Trailing spaces are ignored.)
 
While correctness and performance are the most important parts of this problem, a human will be reading your solution, so please make an effort to submit clean, readable code. In particular, do not write code as if you were solving a problem for a competition.
 
A few examples are below.
 
Input:

           3
           1 5 2
           2 4 7
           3 6 9

Output:

                7 2
 
The basins, labeled with A’s and B’s, are:

           A A B
           A A B
           A A A

Input:

           1
           10

Output:

           1
 
There is only one basin in this case.

Input:

           5
           1 0 2 5 8
           2 3 4 7 9
           3 5 7 9 9
           1 2 5 5 3
           3 3 5 1 0

Output:

           10 8 7

The basins, labeled with A’s, B’s, and C’s, are:

           A A A A A
           A A A A A
           B B B C C
           B B C C C
           B B C C C

Input:

           4
           0 3 2 3
           3 2 1 4
           3 4 3 3
           5 5 2 0

Output:

           6 5 5

The basins, labeled with A’s, B’s, and C’s, are:

           A A B B
           A A B B
           A B C C
           A C C C

### Solution

I did not find a 'best' solution online, but there's a good enough explanation available [here](http://stackoverflow.com/questions/24336686/find-the-largest-basin-size-in-a-given-matrix): 

1. First store index according to their heights.

1. Then iterate from smallest height to largest height.

1. If current index is not visited, make it Basin surface (where water can collect), and make all higher neighbours as Non-Basin surface.

1. Repeat step 3 till all indexes are visited.

1. DFS find each basin

### Code

I post my solution written in 2013. 

    public class MeSolution2013 {

        public static void main(String args[]) {

            String inputFile;
            int testCaseNumber = 1;

            while (true) {
                inputFile = "input" + testCaseNumber + ".txt";
                BufferedReader in;
                try {
                    URI uri = MeSolution2013.class.getResource(inputFile).toURI();
                    in = new BufferedReader(new FileReader(new File(uri)));
                } catch (Exception e) {
                    // there is not more test cases
                    break;
                }

                Scanner sc = new Scanner(in);
                int length = sc.nextInt();
                int[][] elevation = new int[length][length];
                for (int i = 0; i < length; i++) {
                    for (int j = 0; j < length; j++) {
                        elevation[i][j] = sc.nextInt();
                    }
                }

                List<Pair> sinkList = new ArrayList<Pair>();

                // first find out all sink nodes
                for (int i = 0; i < length; i++) {
                    for (int j = 0; j < length; j++) {
                        if (elevation[i][j] < lowestNeighbor(i, j, elevation)) {
                            // (i,j) is a sink point
                            sinkList.add(new Pair(i, j));
                        }
                    }
                }

                // then for each sink node, return the count
                int[] basinSize = new int[sinkList.size()];
                for (int i = 0; i < sinkList.size(); i++) {
                    basinSize[i] = count(sinkList.get(i).X, sinkList.get(i).Y,
                            elevation);
                }
                Arrays.sort(basinSize);

                for (int i = sinkList.size() - 1; i >= 0; i--) {
                    System.out.print(basinSize[i]);
                    if (i != 0)
                        System.out.print(" ");
                }
                System.out.println();
                testCaseNumber++;
            }
        }

        static int count(int x, int y, int[][] ele) {

            int num = 1;

            // if the neighbour is higher than current, add count to current count
            // if all neighbours are lower than current, return 1

            // diagonal neighbors
            if (withinBound(x - 1, y, ele) && rainFlowFrom(x, y, x - 1, y, ele)) { // upper
                                                                                    // elment
                num += count(x - 1, y, ele);
            }
            if (withinBound(x + 1, y, ele) && rainFlowFrom(x, y, x + 1, y, ele)) { // lower
                                                                                    // element
                num += count(x + 1, y, ele);
            }
            if (withinBound(x, y - 1, ele) && rainFlowFrom(x, y, x, y - 1, ele)) { // left
                                                                                    // hand
                                                                                    // side
                num += count(x, y - 1, ele);
            }
            if (withinBound(x, y + 1, ele) && rainFlowFrom(x, y, x, y + 1, ele)) { // right
                                                                                    // hand
                                                                                    // side
                num += count(x, y + 1, ele);
            }

            // diagonal neighbors
            if (withinBound(x - 1, y - 1, ele)
                    && rainFlowFrom(x, y, x - 1, y - 1, ele)) { // upper elment
                num += count(x - 1, y - 1, ele);
            }
            if (withinBound(x + 1, y + 1, ele)
                    && rainFlowFrom(x, y, x + 1, y + 1, ele)) { // lower element
                num += count(x + 1, y + 1, ele);
            }
            if (withinBound(x + 1, y - 1, ele)
                    && rainFlowFrom(x, y, x + 1, y - 1, ele)) { // left hand side
                num += count(x + 1, y - 1, ele);
            }
            if (withinBound(x - 1, y + 1, ele)
                    && rainFlowFrom(x, y, x - 1, y + 1, ele)) { // right hand side
                num += count(x - 1, y + 1, ele);
            }

            return num;
        }

        static Boolean withinBound(int x, int y, int[][] ele) {
            int bound = ele.length;
            return (x >= 0 && x < bound && y >= 0 && y < bound);
        }

        static Boolean rainFlowFrom(int a, int b, int c, int d, int[][] ele) {
            // rain in (c,d) flows into (a,b).
            if (ele[a][b] >= ele[c][d])
                // if (a,b) is higher than (c,d), impossible to flow this way
                return false;

            int lowest = lowestNeighbor(c, d, ele);

            return (ele[a][b] == lowest);
            // the question states "you may assume it has a unique lowest neighbor"
            // so if flow to (a,b), then that is the unique lowest height.
        }

        static int lowestNeighbor(int a, int b, int[][] ele) {
            int height = 9999999;

            // adjacent neighbor
            if (withinBound(a - 1, b, ele) && ele[a - 1][b] < height) {
                height = ele[a - 1][b];
            }
            if (withinBound(a + 1, b, ele) && ele[a + 1][b] < height) {
                height = ele[a + 1][b];
            }
            if (withinBound(a, b - 1, ele) && ele[a][b - 1] < height) {
                height = ele[a][b - 1];
            }
            if (withinBound(a, b + 1, ele) && ele[a][b + 1] < height) {
                height = ele[a][b + 1];
            }

            // diagonal neighbor
            if (withinBound(a - 1, b - 1, ele) && ele[a - 1][b - 1] < height) {
                height = ele[a - 1][b - 1];
            }
            if (withinBound(a + 1, b - 1, ele) && ele[a + 1][b - 1] < height) {
                height = ele[a + 1][b - 1];
            }
            if (withinBound(a - 1, b + 1, ele) && ele[a - 1][b + 1] < height) {
                height = ele[a - 1][b + 1];
            }
            if (withinBound(a + 1, b + 1, ele) && ele[a + 1][b + 1] < height) {
                height = ele[a + 1][b + 1];
            }
            return height;
        }
    }

    class Pair {

        public int X;
        public int Y;

        public Pair(int _x, int _y) {
            X = _x;
            Y = _y;
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Check if Given Point Inside Polygon]]></title>
    <link href="http://okckd.github.io/blog/2015/01/19/check-if-point-inside-polygon/"/>
    <updated>2015-01-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/19/check-if-point-inside-polygon</id>
    <content type="html"><![CDATA[### Question

[link](http://www.geeksforgeeks.org/how-to-check-if-a-given-point-lies-inside-a-polygon/)

> Given a polygon and a point ‘p’, find if ‘p’ lies inside the polygon or not. The points lying on the border are considered inside.

<img class="middle" src="/assets/images/point-in-polygon.png">

### Solution

Prerequisite reading: __[Question] Check if two line segments intersect__. 

Suggested by G4G, this is a simple idea to check:

<img class="middle" src="/assets/images/polygon31-300x169.png">

1. Draw a horizontal line to the right of each point and extend it to infinity

1. Count the number of times the line intersects with polygon edges.

1. A point is inside the polygon if either count of intersections is odd or point lies on an edge of polygon. 

1. Note the special case of point 'g'. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Check if Two Line Segments Intersect]]></title>
    <link href="http://okckd.github.io/blog/2015/01/19/check-if-line-segment-intersect/"/>
    <updated>2015-01-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/19/check-if-line-segment-intersect</id>
    <content type="html"><![CDATA[### Question

[link](http://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/)

> Given two line segments (p1, q1) and (p2, q2), check if 2 line segments intersect. 

### Orientation 

Considering 3 pointer, orientation can be: 

1. counterclockwise
1. clockwise
1. colinear (not considering direction)

<img class="middle" src="/assets/images/line-orientation.png">

Note that orientation only tells the order and sequence relationship of 3 points. __It tells nothing about intersection__. 

### Intersection

Considering 2 line segments: (p1,q1) and (p2,q2). 

#### Case 1: general

Two line segment intersect if __BOTH__ the 2 conditions hold: 

1. (p1, q1, p2) and (p1, q1, q2) have different orientations and
1. (p2, q2, p1) and (p2, q2, q1) have different orientations

<img class="middle" src="/assets/images/GeneralCaseExamples1.png">

<img class="middle" src="/assets/images/examplesGeneralCase211.png">

#### Case 2: special

The speical case is: __what if all 4 pointers (p1, q1, p2, q2) are all on the same line__!!! Well, this definitely can happen. 

If so, check if the values of x-axis and y-axis intersect. I.e. the below 2 cases: 

<img class="middle" src="/assets/images/examplesSpecialCase1.png">

### Code 

Translated from G4G: 

	public boolean intersect(Pair p1, Pair q1, Pair p2, Pair q2) {

		int o1 = orientation(p1, q1, p2);
		int o2 = orientation(p1, q1, q2);
		int o3 = orientation(p2, q2, p1);
		int o4 = orientation(p2, q2, q1);

		// General case
		if (o1 != o2 && o3 != o4) {
			// 2 lines intersect
			return true;
		}

		// Special Cases
		Segment seg1 = new Segment(p1, q1);
		Segment seg2 = new Segment(p2, q2);

		// p1, q1 and p2 are colinear and p2 lies on segment p1q1
		if (o1 == 0 && onSegment(seg1, p2))
			return true;

		// p1, q1 and p2 are colinear and q2 lies on segment p1q1
		if (o2 == 0 && onSegment(seg1, q2))
			return true;

		// p2, q2 and p1 are colinear and p1 lies on segment p2q2
		if (o3 == 0 && onSegment(seg2, p1))
			return true;

		// p2, q2 and q1 are colinear and q1 lies on segment p2q2
		if (o4 == 0 && onSegment(seg2, q1))
			return true;

		return false; // Doesn't fall in any of the above cases
	}

	private boolean onSegment(Segment seg, Pair q) {
		// check if q lies on line segment seg(p1, p2)
		if (q.x <= Math.max(seg.p1.x, seg.p2.x)
				&& q.x >= Math.min(seg.p1.x, seg.p2.x)
				&& q.y <= Math.max(seg.p1.y, seg.p2.y)
				&& q.y >= Math.min(seg.p1.y, seg.p2.y))
			return true;

		return false;
	}

	private int orientation(Pair first, Pair second, Pair third) {
		int val = (second.y - first.y) * (third.x - second.x)
				- (second.x - first.x) * (third.y - second.y);
		if (val == 0) {
			// colinear
			return 0;
		} else {
			// clock or counterclock wise (1 or -1)
			return val / Math.abs(val);
		}
	}

	class Segment {
		Pair p1;
		Pair p2;

		public Segment(Pair p1, Pair p2) {
			this.p1 = p1;
			this.p2 = p2;
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Maximum Square Sub-matrix With All 1s]]></title>
    <link href="http://okckd.github.io/blog/2015/01/18/max-squre-with-all-1/"/>
    <updated>2015-01-18T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/18/max-squre-with-all-1</id>
    <content type="html"><![CDATA[### Question

[link](http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/)

> Given a binary matrix, find out the maximum size square sub-matrix with all 1s. For example, consider the below binary matrix.

       0  1  1  0  1 
       1  1  0  1  0 
       0  1  1  1  0
       1  1  1  1  0
       1  1  1  1  1
       0  0  0  0  0

> The maximum square sub-matrix with all set bits is size 9. Note we only find __square__, not rectangles! (this makes it much easier)

### Solution

Since __square only__, we can use DP. [Quoted answer](http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/) below: 

> Let the given binary matrix be M[R][C]. The idea of the algorithm is to construct an auxiliary size matrix S[][] in which each entry S[i][j] represents size of the square sub-matrix with all 1s including M[i][j] where M[i][j] is the rightmost and bottommost entry in sub-matrix.

> 1. Construct a sum matrix S[R][C] for the given M[R][C].
>
>   1. Copy first row and first columns as it is from M[][] to S[][]
>
>   1. For other entries, use following expressions to construct S[][]

             If M[i][j] is 1 then
                S[i][j] = min(S[i][j-1], S[i-1][j], S[i-1][j-1]) + 1
             Else /*If M[i][j] is 0*/
                S[i][j] = 0
]]></content>
  </entry>
  
</feed>
