<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-27T20:59:38+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Equilibrium Points in 2D Array]]></title>
    <link href="http://okckd.github.io/blog/2014/08/27/equilibrium-points-in-2d-array/"/>
    <updated>2014-08-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/27/equilibrium-points-in-2d-array</id>
    <content type="html"><![CDATA[### Question

[link](http://get-that-job-at-google.blogspot.sg/2013/01/twitter-programming-test.html)

> In a 2D matrix of dimensions M*N, find number of "equilibrium" points.  A point (i, j) is said to be an "equilibrium" point only if all following conditions hold:

> a) sum of rows 1...(i-1) =  sum of rows (i+1)...M

> b) sum of columns 1...(j-1)  = sum of columns (j+1)...N

### Solution

This is __a generalize question of __Equilibrium index__. For now, I got no better idea then checking Equilibrium index for every single node in the matrix. 

So this question literally becomes [this](http://www.geeksforgeeks.org/equilibrium-index-of-an-array/): 

> Equilibrium index of an array is an index such that the sum of elements at lower indexes is equal to the sum of elements at higher indexes. For example, in an arrya A:

> A[0] = -7, A[1] = 1, A[2] = 5, A[3] = 2, A[4] = -4, A[5] = 3, A[6]=0

> 3 is an equilibrium index, because:
A[0] + A[1] + A[2] = A[4] + A[5] + A[6]

> 6 is also an equilibrium index, because sum of zero elements is zero, i.e., A[0] + A[1] + A[2] + A[3] + A[4] + A[5]=0

__The idea__ is to get total sum of array first. Then Iterate through the array and keep updating the left sum. 

### Code

__code for [findning EI in 1-D array](http://rosettacode.org/wiki/Equilibrium_index#Java)__

	public List<Integer> findEI(int[] array) {
		List<Integer> ans = new ArrayList<Integer>();
		int sum = 0;
		for (int i = 0; i < array.length; i++) {
			sum += array[i];
		}
		int runningSum = 0;
		for (int i = 0; i < array.length; i++) {
			if (2 * runningSum + array[i] == sum) {
				ans.add(i);
			}
			runningSum += array[i];
		}
		return ans;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Duplicate Rows in Matrix]]></title>
    <link href="http://okckd.github.io/blog/2014/08/27/Duplicate-rows-in-matrix/"/>
    <updated>2014-08-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/27/Duplicate-rows-in-matrix</id>
    <content type="html"><![CDATA[### Question 1

[link](http://www.careercup.com/question?id=6488077455327232)

> Given a 2D array (n x m) of integers, find all duplicate rows and print their index.

### Solution

This is a [google question](http://get-that-job-at-google.blogspot.sg/2012/12/google-interview-experience.html).

__Use HashMap__ (but make your own). Computer hash value of each row and insert into HashMap as value pair of HashMap(hashValue, rowNumber). When there's a collision, just check the rowNumber stored in HashMap with current row. 

This requires O(n*m) time and O(n) space. Note that __we're not store the entire row into HashMap__ cuz it'll take up too much space. 

We (probably) can also use Trie. 

### Question 2

[link](http://www.careercup.com/question?id=9478119)

> Given a binary matrix of N X N of integers, you need to return only unique rows of binary arrays. 

    input: 
    0 1 0 0 1 
    1 0 1 1 0 
    0 1 0 0 1 
    1 1 1 0 0 
    
    ans: 
    0 1 0 0 1 
    1 0 1 1 0 
    1 1 1 0 0

### Solution

Different from __Question 1__, this input is only 0 and 1. 

__The solution is to use Trie__. Each node [only have 2 children](http://www.geeksforgeeks.org/print-unique-rows/) (that's why Trie is perfect solution here). 

### Code

__Using binary trie node__, refactored by me.

	public int[][] getUniqueRows(int[][] matrix) {
		int m = matrix.length;
		int n = matrix[0].length;

		TrieNode root = new TrieNode();
		TrieNode p;
		int uniqueCount = 0;
		boolean[] isUnique = new boolean[m];
		// isUnique is used to mark the lines that would appear in final result

		// start to build the trie
		for (int i = 0; i < m; i++) {
			// insert number matrix[i][] into the trie
			p = root;
			// root element would be an empty heading for all numbers
			for (int j = 0; j < n; j++) {
				int digit = matrix[i][j];
				if (p.kids == null) {
					p.kids = new TrieNode[2];
				}
				if (p.kids[digit] == null) {
					// this is a whole new branch, create a new node here
					p.kids[digit] = new TrieNode();
					if (j == n - 1) {
						uniqueCount++;
						isUnique[i] = true;
					}
				}
				p = p.kids[digit];
			}
		}
		System.out.println("uniqueCount is " + uniqueCount);
		int[][] result = new int[uniqueCount][];
		int k = 0;
		for (int w = 0; w < isUnique.length; w++) {
			if (isUnique[w]) {
				result[k++] = matrix[w];
			}
		}
		return result;
	}

	class TrieNode {
		TrieNode[] kids = null;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Test hashCode() Function]]></title>
    <link href="http://okckd.github.io/blog/2014/08/26/Test-hashcode-function/"/>
    <updated>2014-08-26T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/26/Test-hashcode-function</id>
    <content type="html"><![CDATA[### Question

> How to test hashCode() function? Example: 

	public int hashCode(){
		int result = 17 + hashDouble(re);
		result = 31 * result + hashDouble(im);
		return result;
	}

### Solution

We need to test that the hash function is [reflexive, symmetric, and transitive](http://stackoverflow.com/a/4449791). 

### Code

Not including 'not equal' test. 

	@Test
	public void testEquals_Symmetric() {
		Person x = new Person("Foo Bar");  // equals and hashCode check name field value
		Person y = new Person("Foo Bar");
		Assert.assertTrue(x.equals(y) && y.equals(x));
		Assert.assertTrue(x.hashCode() == y.hashCode());
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Square Count of Matchstick Graph]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Square-count-in-matchstick-graph/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Square-count-in-matchstick-graph</id>
    <content type="html"><![CDATA[### Question 

> 给出下面这个图 设计数据结构和算法求出图中__所有的正方形数量__ (count the number of squares). 

<img class="middle" src="/assets/images/matchstick-square-count.jpg">

### Solution

1. __Pre-processing__: 从每一个点开始存储上下左右四个方向最多延伸到的位置

1. __Main algorithm__: 枚举右下角位置 然后枚举正方形边长 

1. 根据预处理的延伸情况判断是否能够有一个正方形被构造出来 

Total time complexity is O(n^3). 

> 预处理可以O(n^2) 预处理是有递推关系的 
>
> 但是后面枚举的部分，只能O(n^3)
>
> __不能动态规划的原因是__：他给定了一个可以变化的图，这个图上规模为n的图和规模为n-1的图中正方形个数之间不存在递推关系。 

And 一般来说处理矩阵的问题，大部分都是O(n^3)

### Code

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Ways of Dice Throw]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Dice-roll-DP-question/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Dice-roll-DP-question</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/dice-throw-problem/)

> Given n dice each with m faces, numbered from 1 to m, find the number of ways to get sum X. X is the summation of values on each face when all the dice are thrown. 

### Solution

__DP__

> Sum(m, n, X) = Sum(m, n - 1, X - 1) + 
>
>                Sum(m, n - 1, X - 2) +
>
>                .................... + 
>
>                Sum(m, n - 1, X - m)

So we can have dp(n)(X) and for each, iterate m time. Total time is O(m * n * X). 

### Code

__not written by me__.

	int findWays(int m, int n, int x)
	{
	    // Create a table to store results of subproblems.  One extra 
	    // row and column are used for simpilicity (Number of dice
	    // is directly used as row index and sum is directly used
	    // as column index).  The entries in 0th row and 0th column
	    // are never used.
	    int table[n + 1][x + 1];
	    memset(table, 0, sizeof(table)); // Initialize all entries as 0
	 
	    // Table entries for only one dice
	    for (int j = 1; j <= m && j <= x; j++)
	        table[1][j] = 1;
	 
	    // Fill rest of the entries in table using recursive relation
	    // i: number of dice, j: sum
	    for (int i = 2; i <= n; i++)
	        for (int j = 1; j <= x; j++)
	            for (int k = 1; k <= m && k < j; k++)
	                table[i][j] += table[i-1][j-k];
	 
	    /* Uncomment these lines to see content of table
	    for (int i = 0; i <= n; i++)
	    {
	      for (int j = 0; j <= x; j++)
	        cout << table[i][j] << " ";
	      cout << endl;
	    } */
	    return table[n][x];
	}
]]></content>
  </entry>
  
</feed>
