<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-10-18T00:08:48+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Interleave Positive and Negative Numbers]]></title>
    <link href="http://okckd.github.io/blog/2014/10/08/interleave-positive-negative/"/>
    <updated>2014-10-08T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/10/08/interleave-positive-negative</id>
    <content type="html"><![CDATA[### Question

[link](http://mp.weixin.qq.com/s?__biz=MzA5MzE4MjgyMw==&mid=200355650&idx=1&sn=f94e87cb391fb12af9531cedb452dba1&key=d232b50733c41de56b96f855d9cdea5824f24c712e158651b45d7fe139a94610a7561da1fab0104e968592b01f2439d4&ascene=7&uin=MzM2NjQyNQ%3D%3D&pass_ticket=i7pJQweQbuRdnUFUt5cdOmapPc%2FDW6Xk40U7%2Bcg%2F0o8%3D)

> 给一个包含正负整数的数组，要求对这个数组中的数进行重新排列，使得其正负交替出现。首先出现负数，然后是正数，然后是负数。有多余的数的一方，就放在末尾。

> 如 [1, 2, 3, -4]->[-4, 1, 2, 3]，[1,-3,2,-4,-5]->[-3,1,-4,2,-5]. 要求使用O(1)的额外空间。

> 如果需要保持正数序列和负数序列各自原来的顺序，如何做？

> 如果不需要保持正数序列和负数序列各自原来的顺序，如何做？

### Solution

I only solve this question if we __do not have to keep the original ordering__. 

Basically, 2 pointers search from beginning to end. If there're more + than -, move the extra positive values to the back of the array. Vice versa. 

### Code

__written by me__

	public void solve(int[] A) {
		int len = A.length;
		int neg = 0;
		int pos = 1;
		while (neg < len || pos < len) {

			while (neg < len && A[neg] < 0) {
				neg += 2;
			}
			while (pos < len && A[pos] > 0) {
				pos += 2;
			}
			// neg points to a positive value
			// pos points to a negative value
			// swap them (if they're valid position)
			if (neg >= len && pos >= len) {
				return;
			} else if (neg >= len) {
				// neg is done, there's more - then +
				// put all negative values pointed by pos to the back
				int right = len - 1;
				if (right % 2 == 0) {
					right--;
				}
				while (pos < right) {
					while (pos < len && A[pos] > 0) {
						pos += 2;
					}
					while (right >= 0 && A[right] < 0) {
						right -= 2;
					}
					// pos point to a negative value, right to positive value
					if (pos > right) {
						break;
					} else {
						swap(A, pos, right);
					}
				}
				return;
			} else if (pos >= len) {
				// pos is done, there's more + then -
				int right = len - 1;
				if (right % 2 == 1) {
					right--;
				}
				while (neg < right) {
					while (neg < len && A[neg] < 0) {
						neg += 2;
					}
					while (right >= 0 && A[right] > 0) {
						right -= 2;
					}
					if (neg > right) {
						break;
					} else {
						swap(A, neg, right);
					}
				}
				return;
			} else {
				swap(A, neg, pos);
			}
		}
	}

	private void swap(int[] array, int a, int b) {
		int temp = array[a];
		array[a] = array[b];
		array[b] = temp;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Celebrity Problem]]></title>
    <link href="http://okckd.github.io/blog/2014/09/11/celebrity-problem/"/>
    <updated>2014-09-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/11/celebrity-problem</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=13167666)

> You have a room with n people. A celebrity walks in. Everyone knows the celebrity, the celebrity knows no one. 

> Non-celebrities may/may not know anyone in the room. 

> Give an algorithm to find the celebrity. Discuss the complexity. 

### Solution

[Classic brute-force solution](http://www.geeksforgeeks.org/the-celebrity-problem/) would take O(n^2) time to build a map. That's not good, and we have a very simple solution that works in O(n) time: 

> Make all of them stand in a row. Let's say the people are a,b,c,d,e,f,g,h,i,j,.......n 

> Compare a and b. __If a knows b__, a is not celebrity. __If a doesn't know b__, b is not celebrity. 

> At the end, the probable celebrity who survives is the certain celebrity. (better do a check)

Total number of comparison is [3(N-1) times](http://www.geeksforgeeks.org/the-celebrity-problem/). 

### Code

__not written__

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Print Numbers Containing 5]]></title>
    <link href="http://okckd.github.io/blog/2014/09/04/print-numbers-containing-5/"/>
    <updated>2014-09-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/04/print-numbers-containing-5</id>
    <content type="html"><![CDATA[### Question

[link](http://www.mitbbs.com/article_t/JobHunting/32651839.html)

> 写一个function，对于参数n，输出从0到n之间所有含5的数字。eg. func(30) 应该输出5，15，25

> this is Groupon interview question

### Solution

Suggested by level 10 of [this forum](http://www.mitbbs.com/article_t/JobHunting/32651839.html). It's (surprisingly) a DFS question. 

### Code

__written by me__

	public void mySolution(int num) {
		if (num >= 5) {
			String str = String.valueOf(num);
			helper(num, "", 0, str.length(), false);
		}
	}

	private void helper(int max, String prefix, int pos, int len, boolean have5) {
		if (pos == len) {
			int cur = Integer.parseInt(prefix);
			if (cur <= max) {
				System.out.print(cur + ", ");
			}
			return;
		}
		for (int i = 0; i < 10; i++) {
			if (pos == len - 1 && !have5 && i != 5) {
				continue;
			}
			helper(max, prefix + i, pos + 1, len, have5 || i == 5);
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Split an Integer or Coin]]></title>
    <link href="http://okckd.github.io/blog/2014/09/02/Split-an-integer-or-coin/"/>
    <updated>2014-09-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/02/Split-an-integer-or-coin</id>
    <content type="html"><![CDATA[### Question

[link](http://blog.csdn.net/hackbuteer1/article/details/8035261)

> 整数的拆分问题

> 如，对于正整数n=6，可以拆分为：

    6
    5+1
    4+2, 4+1+1
    3+3, 3+2+1, 3+1+1+1
    2+2+2, 2+2+1+1, 2+1+1+1+1
    1+1+1+1+1+1+1

> 现在的问题是，对于给定的正整数n，程序输出该整数的拆分种类数(HDOJ  1028)。

### Solution 

This is very similar to another question I posted before: __Coin Change Problem__. 

__The DP equation is__: 

> q(n,k) = q(n,k-1) + q(n-k,k)

### Code

__not written by me__

    int main(void) {  
        int n,i,j,dp[121][121];  
        for(i = 1 ; i < 121 ; ++i)  
        {  
            for(j = 1 ; j < 121 ; ++j)  
            {  
                if(i == 1 ||  j == 1)  
                    dp[i][j] = 1;  
                else if(i > j)  
                    dp[i][j] = dp[i][j-1] + dp[i-j][j];  
                else if(i == j)  
                    dp[i][j] = dp[i][j-1] + 1;  
                else  
                    dp[i][j] = dp[i][i];  
            }  
        }  

        while(scanf("%d",&n)!=EOF)  
        {  
            cout<<dp[n][n]<<endl;  
        }  
        return 0;  
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Axis Aligned Rectangles]]></title>
    <link href="http://okckd.github.io/blog/2014/09/02/Axis-aligned-rectangle/"/>
    <updated>2014-09-02T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/02/Axis-aligned-rectangle</id>
    <content type="html"><![CDATA[### Question

[link](http://ankitsambyal.blogspot.sg/2013/10/finding-overlapping-rectangles-in-given.html), MIT handouts Person_A

> Describe an algorithm that takes an unsorted array of axis-aligned rectangles and returns __any pair of__ rectangles that overlaps, if there is such a pair. 

> Axis-aligned means that all the rectangle sides are either parallel or perpendicular to the x- and y-axis. 

> Each rectangle object has two variables: the x-y coordinates of the upper-left corner and the bottom-right corner.

### Analysis

A lot of different solutions on the internet, [eg](http://www.quora.com/Algorithms/Given-a-set-of-n-axis-aligned-rectangles-in-the-plane-find-how-big-is-the-largest-subset-of-these-rectangles-that-contain-a-common-point-in-O-n-3-and-then-in-order-O-nlogn) and [eg](http://ankitsambyal.blogspot.sg/2013/10/finding-overlapping-rectangles-in-given.html), and some questions asks you to return all overlapping pairs. For now, we just return __any pair__ that overlaps.

### Solution 

I concluded some solution and come up with this (the idea of BST is covered in the end of [this pdf](http://www.cs.princeton.edu/~rs/AlgsDS07/17GeometricSearch.pdf)): 

1. Sort the input by left edge. 
1. One by one, get one rectangle from the sorted input, and make a pair (rect.top, rect.bottom). 
1. Insert this pair into a __Interval Search Tree__. 
1. This tree is a BST, and use first value of the pair as BST key. 
1. Insert pair at the correct BST location. If conflicts, we've found 1 overlapping pair. 

The code for searching a intersect, and insert a pair looks like this: 

    Node x = root;
    while (x != null) {
        if (x.interval.intersects(lo, hi)) 
            return x.interval;
        else if (x.left == null)  x = x.right;
        else if (x.left.max < lo) x = x.right;
        else                      x = x.left;
    }
    return null;
]]></content>
  </entry>
  
</feed>
