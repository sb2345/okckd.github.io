<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-19T20:55:32+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Count Level in Perfect Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/08/19/Count-level-in-perfect-BT/"/>
    <updated>2014-08-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/19/Count-level-in-perfect-BT</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/10721583/how-can-i-calculate-the-level-of-a-node-in-a-perfect-binary-tree-from-its-depth)

> A perfect binary tree, i.e. each node in the tree is either a leaf node, or has two children, and all leaf nodes are on the same level. Each node has an index in depth-first order. 

		  0
		/   \
	  1      4
	 / \    / \
	2   3  5   6

> Given the index (k) of a particular node, calculate its level. 

### Solution

__This is a [magical solution](http://stackoverflow.com/a/10721897)__.  It divides the tree in the middle with number k decrease by 1 each time. 

Beautiful, and hard to understand. 

### Code

__not written by me__.

	public int countLevel(TreeNode root, int k, int n) {
		int level = 0;
		while (k != 0) {
			k--;
			n = (n - 1) / 2;
			k = k % n;
			level++;
		}
		return level + 1;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Numbers Concatenation to Get Max Value]]></title>
    <link href="http://okckd.github.io/blog/2014/08/17/Numbers-Concatenation-Max/"/>
    <updated>2014-08-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/17/Numbers-Concatenation-Max</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#45)

> 数组nums中有n个非负整数（整数用字符串表示），将它们以一定的顺序拼接，得到最大的整数。

> 样例：

> nums: ["54", "546", "548", "60"]

> 可以拼接得到的最大整数为"6054854654"，因此函数应该返回"6054854654"。

### Solution

__I will first list out 2 special cases__: 

> {40, 20, 201} => 4020201
>
> {40, 20, 203} => 4020320

Knowing about this 2 cases helps us to come up with a sorting-based algorithm. We only need to achieve this: 

> 201 < 20
>
> 20 < 203

By reading [this post](http://www.itint5.com/discuss/183/%E8%B0%81%E8%83%BD%E5%B8%AE%E6%88%91%E7%9C%8B%E4%B8%80%E4%B8%8B%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8Cn-200%E6%97%B6%E6%8F%90%E7%A4%BAsegmentation), I found the best comparator solution, defined as below: 

    String firstNum = s1 + s2;
    String secondNum = s2 + s1;
    return firstNum.compareTo(secondNum);

### Code

__written by me__.

	public String biggestNum(String[] nums) {
		Arrays.sort(nums, new SpecialComparator());
		StringBuilder sb = new StringBuilder();
		for (int i = nums.length - 1; i >= 0; i--) {
			sb.append(nums[i]);
		}
		return sb.toString();
	}

	class SpecialComparator implements Comparator<String> {
		public int compare(String s1, String s2) {
			// eg.
			// 40 > 20
			// 20 > 201
			// 203 > 20
			String firstNum = s1 + s2;
			String secondNum = s2 + s1;
			return firstNum.compareTo(secondNum);
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Number of Valid Trees Given Preorder and Postorder]]></title>
    <link href="http://okckd.github.io/blog/2014/08/17/Number-of-tree-given-preorder-postorder/"/>
    <updated>2014-08-17T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/17/Number-of-tree-given-preorder-postorder</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#28)

> 对于包含n个结点的二叉树（树中结点编号从1到n），已知前序和后序遍历序列，我们知道不一定能唯一的恢复这棵树。请计算出满足条件的二叉树的总数。

> Example

    前序遍历序列preorder：1 2
    后序遍历序列postorder：2 1

    一共有2棵满足条件的二叉树：
        1       1
       /         \
      2           2

### Solution

> 先看两种遍历的性质:

> pre-order: root, left *************, right #########
>
> post-order: **************left, ########right, root

> 所以 pre-order 的第一个元素一定等于 post-order 的最后一个元素. 然后在post-order中由前往后找, 找出等于pre-oder中第二个元素的位置, 也就是 left 的位置. 

> 1. 如果post-order中的这个位置不是倒数第二个, 说明左右子树都非空, 那么对左右子树递归__调用后用乘法原理__.
> 1. 如果是倒数第二个, 说明有一个子树为空, return的值就是 __2*递归调用非空子树__.

[ref](http://www.itint5.com/discuss/94/%E8%AF%B7%E5%A4%A7%E5%AE%B6%E6%8F%90%E4%B8%80%E4%BA%9B%E6%94%B9%E8%BF%9B%E6%84%8F%E8%A7%81)

### Code

__not written by me__. This code is REALLY 叼炸天。

    int helper(vector<int>& preorder, vector<int>& posorder, 
             int i1, int j1, int i2, int j2){
        if(i1 == j1) return 1;
        if(preorder[i1+1] == posorder[j2-1]){
            return 2*helper(preorder, posorder, i1+1, j1, i2, j2-1);
        }
        int k = i2;
        while(posorder[k] != preorder[i1+1]){ k++; }
        return helper(preorder, posorder, i1+1,i1+1+k-i2 ,i2 , k)
             * helper(preorder, posorder, i1+2+k-i2, j1, k+1, j2-1);
    }

    int countValidTrees(vector<int>& preorder, vector<int>& posorder) {
        int n = preorder.size();
        return helper(preorder, posorder, 0, n-1, 0, n-1);
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Excel Decimal Conversion]]></title>
    <link href="http://okckd.github.io/blog/2014/08/16/Excel-decimal-conversion/"/>
    <updated>2014-08-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/16/Excel-decimal-conversion</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#23)

> Excel中的行列数用A~Z 26个字母表示，A, B, C, D, …, Z, AA, AB, …, AZ, BA, BB, … 分别表示10进制数1, 2, 3, 4, …, 26, 27, 28, …, 52, 53, 54…。

> 请实现2个函数decToExcel和excelToDec，将10进制数转换为Excel数，以及将Excel数转换为10进制数。

### Solution

Note the indexing starts from 1, not from 0. This caused some trouble for me. 

### Code

__written by me__

    public String decToExcel(int decNum) {
        decNum--;
        int digits = 1;
        int exponen = 26;
        while (decNum >= exponen) {
            decNum -= exponen;
            exponen *= 26;
            digits++;
        }
        // now we know the total number of digits
        int num = decNum;
        int total = exponen / 26;
        String ans = "";
        for (int i = 0; i < digits; i++) {
            ans += (char) (num / total + 'A');
            num %= total;
            total /= 26;
        }
        return ans;
    }
    
    public int excelToDec(String excelNum) {
        int digits = excelNum.length();
        int total = 1;
        int sum = 1;
        for (int i = 1; i < digits; i++) {
            total *= 26;
            sum += total;
        }
        for (int i = 0; i < digits; i++) {
            sum += (excelNum.charAt(i) - 'A') * total;
            total /= 26;
        }
        return sum;
    }

__updated code__: we can actually do it recursively. The code is much more concise (the code is found in the eclipse project). 

    //将十进制数转换为excel数
	public String decToExcel(int decNum) {
		if (decNum == 0) {
			return "";
		}
		decNum--;
		char last = (char) ('A' + decNum % 26);
		return decToExcel(decNum / 26) + last;
	}
    
    //将excel数转换为十进制数
	public int excelToDec(String excelNum) {
		if (excelNum.equals("")) {
			return 0;
		}
		int len = excelNum.length();
		int last = 1 + excelNum.charAt(len - 1) - 'A';
		return excelToDec(excelNum.substring(0, len - 1)) * 26 + last;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] 跳马问题加强版]]></title>
    <link href="http://okckd.github.io/blog/2014/08/15/Knight-tour-jumpable-question/"/>
    <updated>2014-08-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/15/Knight-tour-jumpable-question</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#12)

> 有一个无限大的棋盘，棋盘上有一匹马，马可以从长宽分别为p和q的矩形一个角移动到对角。即假设马当前的位置为(x,y)，那么下一步可以移动到(x+p,y+q)，(x+p,y-q)，(x-p,y+q)，(x-p,y-q)，(x+q,y+p)，(x+q,y-p)，(x-q,y+p)或者(x-q,y-p)这8个位置。

> 问马是否能从坐标(x,y)按照上述移动规则移动到坐标(x2,y2)。

### Solution

[ref](http://www.itint5.com/discuss/16/%E8%B7%B3%E9%A9%AC%E9%97%AE%E9%A2%98%E5%8A%A0%E5%BC%BA%E7%89%88)

1. 计算dx=x-x2,dy=y-y2。
2. 求出p,q的最大公约数g，如果dx或者dy不能被g整除，那么很显然无解。
3. 将p,q,dx,dy都除以g，现在p和q互质了。
4. 注意到马可以跳到点(0,2p)（先(p,q)跳一下，然后(p,-q)跳一下），重复这个过程，马可以跳到任意(0,2kp)的点，由于对称性，也可以跳到任意(2kp,0)的点。 
5.下面这一步很关键，由于p,q互质，那么存在x,y满足px+qy=1（扩展欧几里德定理）。这样，马可以跳到(0,2)和和(2,0)，由于对称性，马可以跳到任意坐标都为偶数点。
6. 有了上面的结论，其实只用考虑(0,0),(0,1),(1,0),(1,1)这4个点是否可达。(0,0)是可达的，(0,1)和(1,0)由于对称性只用考虑(0,1)。
7. 对于(1,1)，其实是永远可达的。如果q,p都为奇数，可以先跳到(1+p,1+q)的点（利用5中的结论，可以跳到都是偶数的点），然后(-p,-q)跳到(1,1)。如果p,q一奇一偶，可以先跳到(1+p+q,1+q+p)的点（利用5中的结论），然后(-p,-q),(-q,-p)两步跳到(1,1)。
8. 对于(0,1)，如果p,q一奇一偶，那么也是永远可达的（同7可证）。如果p,q都是奇数，那么是不可能跳到(0,1)的，因为两个奇数不管怎么加减交替运算都不可能变成一奇一偶。

所以最后的结论就是：__第3步之后，如果p,q一奇一偶，那么可达。否则dx,dy同奇或同偶才可达__。

gcd的代码 (concise version):

	int gcd(int a, int b) {
		return b ? gcd(b, a % b) : a;
	}

### Code

__not written by me__

	int gcd(int a, int b){
	    return b? gcd(b, a%b) : a;
	}
	bool canJump(int p, int q, int x, int y, int x2, int y2) {
	    if(p==0 && q==0) return (x==x2)&&(y==y2);
	    int x1 = x2 - x, y1 = y2 - y;
	    int g1 = gcd(p, q);
	    if( x1 % g1 || y1 % g1) return false;
	    p = p/g1;
	    q = q/g1;
	    x1 = x1/g1;
	    y1 = y1/g1;
	    if((p-q)%2 ) return true;
	    else return (x1-y1)%2 == 0;
	}
]]></content>
  </entry>
  
</feed>
