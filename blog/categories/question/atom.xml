<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-02-12T15:56:28+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[LinkedIn] Executive's Schedule]]></title>
    <link href="http://okckd.github.io/blog/2015/02/12/executives-schedule/"/>
    <updated>2015-02-12T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/12/executives-schedule</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t/JobHunting/32884889.html)

> Develop an algorithm to schedule an executive's day, given a list of people 
the executive has to meet with, the amount of time they request to see the 
executive, and the priority of the meeting. 

### Solution

Refer to __[Question] 0-1 Knapsack Problem__. 

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LinkedIn] Isomorphic Strings]]></title>
    <link href="http://okckd.github.io/blog/2015/02/11/isomorphic-strings/"/>
    <updated>2015-02-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/11/isomorphic-strings</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5389627422670848)

> Given two (dictionary) words as Strings, determine if they are isomorphic. 

> Two words are called isomorphic if the letters in one word can be remapped to get the second word. Remapping a letter means replacing all occurrences of it with another letter while the ordering of the letters remains unchanged. No two letters may map to the same letter, but a letter may map to itself. 

> Example: 

    given "foo", "app"; returns true 
    we can map 'f' -> 'a' and 'o' -> 'p' 

    given "bar", "foo"; returns false 
    we can't map both 'a' and 'r' to 'o' 

    given "turtle", "tletur"; returns true 
    we can map 't' -> 't', 'u' -> 'l', 'r' -> 'e', 'l' -> 'u', 'e' -'r' 

    given "ab", "ca"; returns true 
    we can map 'a' -> 'c', 'b'

### Solution

My first thought was: map char to char, then check in the hashmap. However, __this will not work__! 

    input: abc, pzz
    check a -> p
    check b -> z
    check c -> z

Using a hashmap __ does not show us __whether 2 chars match to the same char__. In above example, b and c both match to z. 

__Best Solution__, suggested by [urik](http://www.careercup.com/question?id=5389627422670848): 

> HashMap (char, firstSeenIndice) for each string. The encoding of firstSeenIndices shud match. 
>
> E.g. Foo and app both encode to 011 
>
> Abcd and hole both encode to 0123 

### Code

	public boolean isomorphic(String s, String t) {
		if (s.length() != t.length()) {
			return false;
		}
		return (sequence(s).equals(sequence(t)));
	}

	private String sequence(String s) {
		HashMap<Character, Integer> map = new HashMap<Character, Integer>();
		StringBuilder sb = new StringBuilder();

		for (int i = 0; i < s.length(); i++) {
			if (map.containsKey(s.charAt(i))) {
				sb.append(map.get(s.charAt(i)));
			} else {
				map.put(s.charAt(i), i);
			}
		}
		return sb.toString();
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Count Multiples of Array]]></title>
    <link href="http://okckd.github.io/blog/2015/02/09/count-multiples-of-array/"/>
    <updated>2015-02-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/09/count-multiples-of-array</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t/JobHunting/32882735.html)

> N是一个很大的正整数——可能到10^15次方，

> 简单起见，不考虑溢出，或者假设用python

> A 是一个array，里面存着一些正整数，up to 1000个

> 从1 - N这N个数，有多少个数，不能被A中的任何一个数整除的？

### Solution

It's a very difficult question. 

We can't do it like a Sieve of Eratosthenes, cuz N is too large. The best solution is at [this post](http://www.mitbbs.com/article_t/JobHunting/32882735.html), level 9: 

Consider the simplest case: A={2}, then any odd number below N is OK, so the result would be (N - N/2). Then consider A={2, 3}, any number below N that is not mutiply of 2 or 3 is OK, so the result would be (N - N/2 - N/3 + N/6). Then consider A={2, 3, 5}, __the result would be (N - N/2 - N/3 - N/5 + N/6 
+ N/10 + N/15 - N/30)__. 

So there is a general rule: 

for A={a1, a2, ..., aN}, if ai is not dividable by aj for any i != j, then we could:

1. for i from 1 to N, calc r1 = N - SUM(N/ai);
2. for i, j from 1 to N, i != j, calc r2 = r1 + SUM(N/(ai*aj));
3. for i, j, k from 1 to N, i != j != k, calc r3 = r2 - SUM(N/(ai*aj*ak));
4. ...
5. until all numbers in A are chosen.
6. then the final rN is the result.

So for the problem, first we preprocess A to __eliminate any multiplies in A__. For example, A={2, 4, 5}, we can eliminate 4 because it is a mutiply of 2 which is also in A. So A'={2, 5}, then we calc:

r1 = 10 - 10/2 - 10/5 = 10 - 5 - 2 = 3;
r2 = r1 + 10/10 = 3 + 1 = 4;

then the final result is 4.

Refer to __[Question] Multiples of 3 and 5__.

### Code

not written
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Reservoir Sampling]]></title>
    <link href="http://okckd.github.io/blog/2015/02/07/reservoir-sampling/"/>
    <updated>2015-02-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/07/reservoir-sampling</id>
    <content type="html"><![CDATA[[Reservoir sampling](http://en.wikipedia.org/wiki/Reservoir_sampling) is a family of randomized algorithms for randomly choosing k samples from a list of n items, where n is either __a very large number__. Typically n is large enough that the list __doesn’t fit into main memory__. For example, a list of search queries in Google and Facebook.

### Question 

[link](http://www.geeksforgeeks.org/reservoir-sampling/)

> given a big array (or stream) of numbers (to simplify), and we need to write an efficient function to randomly select k numbers where 1 <= k <= n. Let the input array be stream[].

### Solution

__O(n)__ time!

1. Create an array sample[0..k-1] and copy first k items of stream[] to it.

1. Now one by one consider all items from (k+1)th item to nth item.

    1. Generate a random number 'j' from 0 to i where i is index of current item in stream[]. 

    1. If j is in range 0 to k-1, replace sample[j] with stream[i]

### Code

not written
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Check String With No Common Letters (Bitmask)]]></title>
    <link href="http://okckd.github.io/blog/2015/02/07/check-string-no-common-char/"/>
    <updated>2015-02-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/07/check-string-no-common-char</id>
    <content type="html"><![CDATA[### Question 

RT. This is a very very common requirements in the area of string manipulation. We want it to be done very efficiently. 

### Solution

Normally, we would use a hashmap. However, we can also use __bitmask__ or bitmap. 

Work for a-z only, we use 1 integer to represent each letter, and set an integer for each string. 

We do (mask1 & mask2 == 0) to find no common letters. Read more at this question, __[Google] Max prodcut of strings that have no common char__. 
]]></content>
  </entry>
  
</feed>
