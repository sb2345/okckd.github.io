<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: question | Shuati.info]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-04-04T00:35:37+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[shuati]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[LinkedIn] Sort part to make entire array sorted ]]></title>
    <link href="http://okckd.github.io/blog/2015/02/13/sort-part-and-make-whole-array-sorted/"/>
    <updated>2015-02-13T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/13/sort-part-and-make-whole-array-sorted</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/minimum-length-unsorted-subarray-sorting-which-makes-the-complete-array-sorted/)

> Given an unsorted array arr[0..n-1] of size n, find the minimum length subarray arr[s..e] such that sorting this subarray makes the whole array sorted.

### Solution

The solution from [gfg](http://www.geeksforgeeks.org/minimum-length-unsorted-subarray-sorting-which-makes-the-complete-array-sorted/) is definitely good, but I find [this graphic explanation](http://stackoverflow.com/a/15855670) a really great resource. 

The idea is, find min and max in the unsorted proportion, and trim the original array. 

### Code

not written.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LinkedIn] Unique combination of factors (因式分解) ]]></title>
    <link href="http://okckd.github.io/blog/2015/02/13/combination-of-factors/"/>
    <updated>2015-02-13T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/13/combination-of-factors</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t1/JobHunting/32803907_0_1.html)

> A question by dongfeiwww: 

> 打印一个数的所有乘数组合，从大到小，不要有重复

> Print all unique combinations of factors of a positive integer. For example given 24:

    24*1
    12*2
    8*3
    6*4
    6*2*2
    4*3*2
    3*2*2*2

### Solution

Simple DFS.

### Code

	public List<List<Integer>> factorCombinations(int n) {
		List<List<Integer>> ans = new ArrayList<List<Integer>>();
		helper(ans, n, n / 2, new ArrayList<Integer>());
		return ans;
	}

	private void helper(List<List<Integer>> ans, int num, int largestFactor,
			List<Integer> path) {
		if (num == 1) {
			ans.add(new ArrayList<Integer>(path));
			return;
		}
		for (int i = largestFactor; i > 1; i--) {
			if (num % i == 0) {
				path.add(i);
				helper(ans, num / i, i, path);
				path.remove(path.size() - 1);
			}
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LinkedIn] Sum of integer weighted by depth ]]></title>
    <link href="http://okckd.github.io/blog/2015/02/13/Sum-integer-weighted-by-depth/"/>
    <updated>2015-02-13T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/13/Sum-integer-weighted-by-depth</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5139875124740096)

    /** 
    * Given a nested list of integers, returns the sum of all integers in the list weighted by their depth 
    * For example, given the list {(1,1),2,(1,10)} the function should return 10 (four 1's at depth 2, one 2 at depth 1) 
    * Given the list {1,{4,{6}}} the function should return 27 (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3) 
    */ 
    public int depthSum (List<NestedInteger> input) 
    { // ur implementation here} 


    ** 
    * This is the interface that represents nested lists. 
    * You should not implement it, or speculate about its implementation. 
    */ 
    public interface NestedInteger 
    { 
    /** @return true if this NestedInteger holds a single integer, rather than a nested list */ 
    boolean isInteger(); 

    /** @return the single integer that this NestedInteger holds, if it holds a single integer 
    * Return null if this NestedInteger holds a nested list */ 
    Integer getInteger(); 

    /** @return the nested list that this NestedInteger holds, if it holds a nested list 
    * Return null if this NestedInteger holds a single integer */ 
    List<NestedInteger> getList(); 
    }

### Solution

DFS recurse. 

### Code

The algo:

	public int depthSum(List<NestedInteger> input, int weight) {
		// ur implementation here
		int sum = 0;
		for (NestedInteger ni : input) {
			if (ni.isInteger()) {
				sum += ni.getInteger() * weight;
			} else {
				sum += depthSum(ni.getList(), weight + 1);
			}
		}
		return sum;
	}

Interface and Impl:

    /*
     * This is the interface that represents nested lists. You should not implement
     * it, or speculate about its implementation.
     */
    interface NestedInteger {
        /**
         * @return true if this NestedInteger holds a single integer, rather than a
         *         nested list
         */
        boolean isInteger();

        /**
         * @return the single integer that this NestedInteger holds, if it holds a
         *         single integer Return null if this NestedInteger holds a nested
         *         list
         */
        Integer getInteger();

        /**
         * @return the nested list that this NestedInteger holds, if it holds a
         *         nested list Return null if this NestedInteger holds a single
         *         integer
         */
        List<NestedInteger> getList();
    }

    class NestedIntegerImpl implements NestedInteger {

        int num;
        List<NestedInteger> list = new ArrayList<NestedInteger>();

        public NestedIntegerImpl(int number) {
            num = number;
            list = null;
        }

        public NestedIntegerImpl(List<NestedInteger> inputList) {
            num = -1;
            list = inputList;
        }

        @Override
        public boolean isInteger() {
            return list == null;
        }

        @Override
        public Integer getInteger() {
            if (isInteger()) {
                return num;
            }
            return -1;
        }

        @Override
        public List<NestedInteger> getList() {
            return list;
        }
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LinkedIn] Executive's Schedule ]]></title>
    <link href="http://okckd.github.io/blog/2015/02/12/executives-schedule/"/>
    <updated>2015-02-12T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/12/executives-schedule</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t/JobHunting/32884889.html)

> Develop an algorithm to schedule an executive's day, given a list of people 
the executive has to meet with, the amount of time they request to see the 
executive, and the priority of the meeting. 

### Solution

Refer to __[Question] 0-1 Knapsack Problem__. 

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LinkedIn] Isomorphic Strings ]]></title>
    <link href="http://okckd.github.io/blog/2015/02/11/isomorphic-strings/"/>
    <updated>2015-02-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/11/isomorphic-strings</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=5389627422670848)

> Given two (dictionary) words as Strings, determine if they are isomorphic. 

> Two words are called isomorphic if the letters in one word can be remapped to get the second word. Remapping a letter means replacing all occurrences of it with another letter while the ordering of the letters remains unchanged. No two letters may map to the same letter, but a letter may map to itself. 

> Example: 

    given "foo", "app"; returns true 
    we can map 'f' -> 'a' and 'o' -> 'p' 

    given "bar", "foo"; returns false 
    we can't map both 'a' and 'r' to 'o' 

    given "turtle", "tletur"; returns true 
    we can map 't' -> 't', 'u' -> 'l', 'r' -> 'e', 'l' -> 'u', 'e' -'r' 

    given "ab", "ca"; returns true 
    we can map 'a' -> 'c', 'b'

### Solution

My first thought was: map char to char, then check in the hashmap. However, __this will not work__! 

    input: abc, pzz
    check a -> p
    check b -> z
    check c -> z

Using a hashmap __ does not show us __whether 2 chars match to the same char__. In above example, b and c both match to z. 

__Best Solution__, suggested by [urik](http://www.careercup.com/question?id=5389627422670848): 

> HashMap (char, firstSeenIndice) for each string. The encoding of firstSeenIndices shud match. 
>
> E.g. Foo and app both encode to 011 
>
> Abcd and hole both encode to 0123 

### Code

	public boolean isomorphic(String s, String t) {
		if (s.length() != t.length()) {
			return false;
		}
		return (sequence(s).equals(sequence(t)));
	}

	private String sequence(String s) {
		HashMap<Character, Integer> map = new HashMap<Character, Integer>();
		StringBuilder sb = new StringBuilder();

		for (int i = 0; i < s.length(); i++) {
			if (map.containsKey(s.charAt(i))) {
				sb.append(map.get(s.charAt(i)));
			} else {
				map.put(s.charAt(i), i);
			}
		}
		return sb.toString();
	}
]]></content>
  </entry>
  
</feed>
