<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-09T19:58:55+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Most Frequent Word From a Book]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/most-frequent-word-from-book/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/most-frequent-word-from-book</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=5715664853532672)

> Let's say I gave you a long String and I wanted you to tell me the most common word in that String. How would you do that? 

> Follow-up: how about if I gave you the entire works of Alexandre Dumas, one of the most prolific authors in history. How would your solution work? How could you change it to solve this more specific problem? 

### Solution

There are 2 solutions. Either __HashMap__ or __Trie__. It's easy to think of first, but remember that Trie is designed to do this kind of job. 

> A trie will be more useful in the second situation where you will have millions of words. You can have a counter at every node to see its frequency

__Now the follow up__. For big data problems, we can always do __divide and conquer__ by hash value. 

Alternatively, the comment by [Prince](http://www.careercup.com/question?id=5715664853532672) mentioned how to solve with __Map Reduce__: 

> Instead of loading it as a string first I would stream data so that I avoid memory spike. Further our map size might increases as new words are added to it. Also, we can use map reduce type job were we create map<word, frequency> of each play in parallel and later join/collapse them this will reduce the time it will take to get result. 

> Common phrase should be no different then above algorithm. However we need to rebuild our index with <phase, frequency>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Match Triplet With Reverse Order]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/match-triplet-with-reverse-order/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/match-triplet-with-reverse-order</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=11655778)

> Find the substring of length 3 which is present in the reverse order from the string. 

> Ex: if the string is abcdcba (cba is the reverse of abc) so we should return cba. 

### Solution

1. __HashMap (recommended)__. Hash all substrings of length 3. O(n). Look up all reverse substrings of length 3 in this hash set. O(n) time and O(n) space. 

1. __KMP Algo__. Take every substring of length 3. Reverse it and find it in the input using KMP. O(n^2) time and O(1) space. 

1. __Build suffix tree__ of height 3. Then in reverse order, check triplets. 

The 3 solutions above all work well. Pick the one you love. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Longest Common Contiguous Intersection (Longest Common Substring)]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/longest-common-substring/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/longest-common-substring</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=12862670)

> Write Program to find longest common contiguous intersection from 2 lists provided to the function. 

> Example: list1: abcrfghwetf 
>
> list2: abrfghwwetxyab 

> Ans: rfghw

### Solution

This is a classic [Longest common substring](http://en.wikipedia.org/wiki/Longest_common_substring_problem) problem.

Solution 1: __Suffix tree__. Building the tree is O(n) time and the whole program is O(n + m) time. 

Solution 2: __DP__, which takes O(nm) time and space. The code for DP is posted below. 

### Code

__dp__

	public String LCSubstr(String s, String t) {
		int longest = 0;
		int tPos = -1;

		// dp[i][j] represents the LCSubstr ending at position i and j
		int[][] dp = new int[t.length() + 1][s.length() + 1];
		for (int i = 1; i <= t.length(); i++) {
			for (int j = 1; j <= s.length(); j++) {
				if (t.charAt(i - 1) == s.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1] + 1;
					if (dp[i][j] > longest) {
						longest = dp[i][j];
						tPos = i;
					}
				}
			}
		}
		return t.substring(tPos - longest, tPos);
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Duplicate Rows in Matrix]]></title>
    <link href="http://okckd.github.io/blog/2014/08/27/Duplicate-rows-in-matrix/"/>
    <updated>2014-08-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/27/Duplicate-rows-in-matrix</id>
    <content type="html"><![CDATA[### Question 1

[link](http://www.careercup.com/question?id=6488077455327232)

> Given a 2D array (n x m) of integers, find all duplicate rows and print their index.

### Solution

This is a [google question](http://get-that-job-at-google.blogspot.sg/2012/12/google-interview-experience.html).

__Use HashMap__ (but make your own). Computer hash value of each row and insert into HashMap as value pair of HashMap(hashValue, rowNumber). When there's a collision, just check the rowNumber stored in HashMap with current row. 

This requires O(n*m) time and O(n) space. Note that __we're not store the entire row into HashMap__ cuz it'll take up too much space. 

We (probably) can also use Trie. 

### Question 2

[link](http://www.careercup.com/question?id=9478119)

> Given a binary matrix of N X N of integers, you need to return only unique rows of binary arrays. 

    input: 
    0 1 0 0 1 
    1 0 1 1 0 
    0 1 0 0 1 
    1 1 1 0 0 
    
    ans: 
    0 1 0 0 1 
    1 0 1 1 0 
    1 1 1 0 0

### Solution

Different from __Question 1__, this input is only 0 and 1. 

__The solution is to use Trie__. Each node [only have 2 children](http://www.geeksforgeeks.org/print-unique-rows/) (that's why Trie is perfect solution here). 

### Code

__Using binary trie node__, refactored by me.

	public int[][] getUniqueRows(int[][] matrix) {
		int m = matrix.length;
		int n = matrix[0].length;

		TrieNode root = new TrieNode();
		TrieNode p;
		int uniqueCount = 0;
		boolean[] isUnique = new boolean[m];
		// isUnique is used to mark the lines that would appear in final result

		// start to build the trie
		for (int i = 0; i < m; i++) {
			// insert number matrix[i][] into the trie
			p = root;
			// root element would be an empty heading for all numbers
			for (int j = 0; j < n; j++) {
				int digit = matrix[i][j];
				if (p.kids == null) {
					p.kids = new TrieNode[2];
				}
				if (p.kids[digit] == null) {
					// this is a whole new branch, create a new node here
					p.kids[digit] = new TrieNode();
					if (j == n - 1) {
						uniqueCount++;
						isUnique[i] = true;
					}
				}
				p = p.kids[digit];
			}
		}
		System.out.println("uniqueCount is " + uniqueCount);
		int[][] result = new int[uniqueCount][];
		int k = 0;
		for (int w = 0; w < isUnique.length; w++) {
			if (isUnique[w]) {
				result[k++] = matrix[w];
			}
		}
		return result;
	}

	class TrieNode {
		TrieNode[] kids = null;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Square Count of Matchstick Graph]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Square-count-in-matchstick-graph/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Square-count-in-matchstick-graph</id>
    <content type="html"><![CDATA[### Question 

> 给出下面这个图 设计数据结构和算法求出图中__所有的正方形数量__ (count the number of squares). 

<img class="middle" src="/assets/images/matchstick-square-count.jpg">

### Solution

1. __Pre-processing__: 从每一个点开始存储上下左右四个方向最多延伸到的位置

1. __Main algorithm__: 枚举右下角位置 然后枚举正方形边长 

1. 根据预处理的延伸情况判断是否能够有一个正方形被构造出来 

Total time complexity is O(n^3). 

> 预处理可以O(n^2) 预处理是有递推关系的 
>
> 但是后面枚举的部分，只能O(n^3)
>
> __不能动态规划的原因是__：他给定了一个可以变化的图，这个图上规模为n的图和规模为n-1的图中正方形个数之间不存在递推关系。 

And 一般来说处理矩阵的问题，大部分都是O(n^3)

### Code

]]></content>
  </entry>
  
</feed>
