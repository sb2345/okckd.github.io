<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-02-10T17:18:47+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Count Multiples of Array]]></title>
    <link href="http://okckd.github.io/blog/2015/02/09/count-multiples-of-array/"/>
    <updated>2015-02-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/09/count-multiples-of-array</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.mitbbs.com/article_t/JobHunting/32882735.html)

> N是一个很大的正整数——可能到10^15次方，

> 简单起见，不考虑溢出，或者假设用python

> A 是一个array，里面存着一些正整数，up to 1000个

> 从1 - N这N个数，有多少个数，不能被A中的任何一个数整除的？

### Solution

It's a very difficult question. 

We can't do it like a Sieve of Eratosthenes, cuz N is too large. The best solution is at [this post](http://www.mitbbs.com/article_t/JobHunting/32882735.html), level 9: 

Consider the simplest case: A={2}, then any odd number below N is OK, so the result would be (N - N/2). Then consider A={2, 3}, any number below N that is not mutiply of 2 or 3 is OK, so the result would be (N - N/2 - N/3 + N/6). Then consider A={2, 3, 5}, __the result would be (N - N/2 - N/3 - N/5 + N/6 
+ N/10 + N/15 - N/30)__. 

So there is a general rule: 

for A={a1, a2, ..., aN}, if ai is not dividable by aj for any i != j, then we could:

1. for i from 1 to N, calc r1 = N - SUM(N/ai);
2. for i, j from 1 to N, i != j, calc r2 = r1 + SUM(N/(ai*aj));
3. for i, j, k from 1 to N, i != j != k, calc r3 = r2 - SUM(N/(ai*aj*ak));
4. ...
5. until all numbers in A are chosen.
6. then the final rN is the result.

So for the problem, first we preprocess A to __eliminate any multiplies in A__. For example, A={2, 4, 5}, we can eliminate 4 because it is a mutiply of 2 which is also in A. So A'={2, 5}, then we calc:

r1 = 10 - 10/2 - 10/5 = 10 - 5 - 2 = 3;
r2 = r1 + 10/10 = 3 + 1 = 4;

then the final result is 4.

Refer to __[Question] Multiples of 3 and 5__.

### Code

not written
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Reservoir Sampling]]></title>
    <link href="http://okckd.github.io/blog/2015/02/07/reservoir-sampling/"/>
    <updated>2015-02-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/07/reservoir-sampling</id>
    <content type="html"><![CDATA[[Reservoir sampling](http://en.wikipedia.org/wiki/Reservoir_sampling) is a family of randomized algorithms for randomly choosing k samples from a list of n items, where n is either __a very large number__. Typically n is large enough that the list __doesn’t fit into main memory__. For example, a list of search queries in Google and Facebook.

### Question 

[link](http://www.geeksforgeeks.org/reservoir-sampling/)

> given a big array (or stream) of numbers (to simplify), and we need to write an efficient function to randomly select k numbers where 1 <= k <= n. Let the input array be stream[].

### Solution

__O(n)__ time!

1. Create an array sample[0..k-1] and copy first k items of stream[] to it.

1. Now one by one consider all items from (k+1)th item to nth item.

    1. Generate a random number 'j' from 0 to i where i is index of current item in stream[]. 

    1. If j is in range 0 to k-1, replace sample[j] with stream[i]

### Code

not written
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Check String With No Common Letters (Bitmask)]]></title>
    <link href="http://okckd.github.io/blog/2015/02/07/check-string-no-common-char/"/>
    <updated>2015-02-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/07/check-string-no-common-char</id>
    <content type="html"><![CDATA[### Question 

RT. This is a very very common requirements in the area of string manipulation. We want it to be done very efficiently. 

### Solution

Normally, we would use a hashmap. However, we can also use __bitmask__ or bitmap. 

Work for a-z only, we use 1 integer to represent each letter, and set an integer for each string. 

We do (mask1 & mask2 == 0) to find no common letters. Read more at this question, __[Google] Max prodcut of strings that have no common char__. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Amazon] Grep Command Interview Question]]></title>
    <link href="http://okckd.github.io/blog/2015/02/04/grep-command-interview-question/"/>
    <updated>2015-02-04T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/04/grep-command-interview-question</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.careercup.com/question?id=1799)

> You have 50,000 html files, some of which contain phone numbers. How would you create a list of all the files which contain phone numbers? 

### Solution

This is a famous inteview question by former Amazon engineer [Steve Yegge](https://sites.google.com/site/steveyegge2/five-essential-phone-screen-questions): 

> About 25% to 35% of all software development engineer candidates, independent of experience level, cannot solve this problem, even given the entire interview hour and lots of hints. 

This question tests your understanding of scripting languages. 

### Code

    grep -l -R --perl-regexp "\b(\(\d{3}\)\s*|\d{3}-)\d{3}-\d{4}\b" * > output.txt
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Stock Span Problem (Couting BST)]]></title>
    <link href="http://okckd.github.io/blog/2015/02/01/stock-span-problem/"/>
    <updated>2015-02-01T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/02/01/stock-span-problem</id>
    <content type="html"><![CDATA[### Question 

> Given stock price of Amazon for some consecutive days. Need to find the maximum span of each day’s stock price. 

Definition of 'span' have got 2 variant: 

### Variant 1

[link](http://www.geeksforgeeks.org/the-stock-span-problem/)

> Span is the number of consecutive days right before that day, which have less or equal stock value. 

> (Or in GFG language): The span Si of the stock’s price on a given day i is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the current day is less than or equal to its price on the given day.

### Solution

<img class="middle" src="/assets/images/StockSpanProblem1.png">

Use stack. 

### Variant 2

[link](http://www.careercup.com/question?id=4825417139617792)

> Span is the amount of days before the given day where the stock price is less than that of given day. 

### Solution

The top answer in [here](http://www.careercup.com/question?id=4825417139617792) is wrong. Eg. {1,3,2,4}, the count for 4 would be 2, instead of 3. 

Instead, the __BST (AVL tree) solution is correct__. It's commented by user zahidbuet106. 

> insert numbers in a AVL tree one by one from right to left. During each insert we will keep updating the __size of left subtree__ at the node being inserted. This will give us our desired smaller element count. 

> We also need to handle balancing the tree while insert. 

__The key of this question is the special BST, where each node stores an additional counting number__. 

This type of special BST is extremely frequntly used in Computer Science, especially when we want to dynamically insert elements and find out it's ranking within the past history. 

Read another very interesting post: __[CC150v5] 11.8 Get Rank in Stream of Integers__.

### Code

	class TreeNodePlus extends TreeNode {
		int leftCount;
		int dupCount;

		public TreeNodePlus(int v, int leftC) {
			super(v);
			this.leftCount = leftC;
			this.dupCount = 1;
		}

		public int findRank(TreeNodePlus node) {
			TreeNodePlus leftBranch = (TreeNodePlus) this.left;
			TreeNodePlus rightBranch = (TreeNodePlus) this.right;

			if (this == node) {
				return 0;
			} else if (node.val < this.val) {
				if (this.left == null) {
					return 0;
				} else {
					return leftBranch.findRank(node);
				}
			} else {
				if (this.right == null) {
					return this.leftCount + this.dupCount;
				} else {
					return this.leftCount + this.dupCount
							+ rightBranch.findRank(node);
				}
			}
		}

		public TreeNodePlus insertNum(int num) {
			TreeNodePlus leftBranch = (TreeNodePlus) this.left;
			TreeNodePlus rightBranch = (TreeNodePlus) this.right;

			if (num == this.val) {
				this.dupCount++;
				return this;
			} else if (num < this.val) {
				// insert num to the left branch
				this.leftCount++;
				if (this.left == null) {
					this.left = new TreeNodePlus(num, 0);
					return (TreeNodePlus) this.left;
				} else {
					return leftBranch.insertNum(num);
				}
			} else {
				// insert num to the right branch
				// this.leftCount does not change
				if (this.right == null) {
					this.right = new TreeNodePlus(num, 0);
					return (TreeNodePlus) this.right;
				} else {
					return rightBranch.insertNum(num);
				}
			}
		}
	}
]]></content>
  </entry>
  
</feed>
