<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-16T17:41:23+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Excel Decimal Conversion]]></title>
    <link href="http://okckd.github.io/blog/2014/08/16/Excel-decimal-conversion/"/>
    <updated>2014-08-16T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/16/Excel-decimal-conversion</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#23)

> Excel中的行列数用A~Z 26个字母表示，A, B, C, D, …, Z, AA, AB, …, AZ, BA, BB, … 分别表示10进制数1, 2, 3, 4, …, 26, 27, 28, …, 52, 53, 54…。

> 请实现2个函数decToExcel和excelToDec，将10进制数转换为Excel数，以及将Excel数转换为10进制数。

### Solution

Note the indexing starts from 1, not from 0. This caused some trouble for me. 

### Code

__written by me__

    public String decToExcel(int decNum) {
        decNum--;
        int digits = 1;
        int exponen = 26;
        while (decNum >= exponen) {
            decNum -= exponen;
            exponen *= 26;
            digits++;
        }
        // now we know the total number of digits
        int num = decNum;
        int total = exponen / 26;
        String ans = "";
        for (int i = 0; i < digits; i++) {
            ans += (char) (num / total + 'A');
            num %= total;
            total /= 26;
        }
        return ans;
    }
    
    public int excelToDec(String excelNum) {
        int digits = excelNum.length();
        int total = 1;
        int sum = 1;
        for (int i = 1; i < digits; i++) {
            total *= 26;
            sum += total;
        }
        for (int i = 0; i < digits; i++) {
            sum += (excelNum.charAt(i) - 'A') * total;
            total /= 26;
        }
        return sum;
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] 跳马问题加强版]]></title>
    <link href="http://okckd.github.io/blog/2014/08/15/Knight-tour-jumpable-question/"/>
    <updated>2014-08-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/15/Knight-tour-jumpable-question</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#12)

> 有一个无限大的棋盘，棋盘上有一匹马，马可以从长宽分别为p和q的矩形一个角移动到对角。即假设马当前的位置为(x,y)，那么下一步可以移动到(x+p,y+q)，(x+p,y-q)，(x-p,y+q)，(x-p,y-q)，(x+q,y+p)，(x+q,y-p)，(x-q,y+p)或者(x-q,y-p)这8个位置。

> 问马是否能从坐标(x,y)按照上述移动规则移动到坐标(x2,y2)。

### Solution

[ref](http://www.itint5.com/discuss/16/%E8%B7%B3%E9%A9%AC%E9%97%AE%E9%A2%98%E5%8A%A0%E5%BC%BA%E7%89%88)

1. 计算dx=x-x2,dy=y-y2。
2. 求出p,q的最大公约数g，如果dx或者dy不能被g整除，那么很显然无解。
3. 将p,q,dx,dy都除以g，现在p和q互质了。
4. 注意到马可以跳到点(0,2p)（先(p,q)跳一下，然后(p,-q)跳一下），重复这个过程，马可以跳到任意(0,2kp)的点，由于对称性，也可以跳到任意(2kp,0)的点。 
5.下面这一步很关键，由于p,q互质，那么存在x,y满足px+qy=1（扩展欧几里德定理）。这样，马可以跳到(0,2)和和(2,0)，由于对称性，马可以跳到任意坐标都为偶数点。
6. 有了上面的结论，其实只用考虑(0,0),(0,1),(1,0),(1,1)这4个点是否可达。(0,0)是可达的，(0,1)和(1,0)由于对称性只用考虑(0,1)。
7. 对于(1,1)，其实是永远可达的。如果q,p都为奇数，可以先跳到(1+p,1+q)的点（利用5中的结论，可以跳到都是偶数的点），然后(-p,-q)跳到(1,1)。如果p,q一奇一偶，可以先跳到(1+p+q,1+q+p)的点（利用5中的结论），然后(-p,-q),(-q,-p)两步跳到(1,1)。
8. 对于(0,1)，如果p,q一奇一偶，那么也是永远可达的（同7可证）。如果p,q都是奇数，那么是不可能跳到(0,1)的，因为两个奇数不管怎么加减交替运算都不可能变成一奇一偶。

所以最后的结论就是：__第3步之后，如果p,q一奇一偶，那么可达。否则dx,dy同奇或同偶才可达__。

gcd的代码 (concise version):

	int gcd(int a, int b) {
		return b ? gcd(b, a % b) : a;
	}

### Code

__not written by me__

	int gcd(int a, int b){
	    return b? gcd(b, a%b) : a;
	}
	bool canJump(int p, int q, int x, int y, int x2, int y2) {
	    if(p==0 && q==0) return (x==x2)&&(y==y2);
	    int x1 = x2 - x, y1 = y2 - y;
	    int g1 = gcd(p, q);
	    if( x1 % g1 || y1 % g1) return false;
	    p = p/g1;
	    q = q/g1;
	    x1 = x1/g1;
	    y1 = y1/g1;
	    if((p-q)%2 ) return true;
	    else return (x1-y1)%2 == 0;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Greatest Common Divisor]]></title>
    <link href="http://okckd.github.io/blog/2014/08/15/Greatest-common-divisor/"/>
    <updated>2014-08-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/15/Greatest-common-divisor</id>
    <content type="html"><![CDATA[### Question 

> Get GCD in more efficient code

### Code

this is 掉渣天。

	public int gcd(int a, int b) {
		return b == 0 ? a : gcd(b, a % b);
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Maximum Circular Subarray Sum]]></title>
    <link href="http://okckd.github.io/blog/2014/08/11/max-circular-subarray/"/>
    <updated>2014-08-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/11/max-circular-subarray</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#9)

> Given n numbers (both +ve and -ve), arranged in a circle, fnd the maximum sum of consecutive number

### Solution

First pass: find max subarray sum.

Second pass: find min subarray sum, and subtract it from total sum. 

Suggested on [G4G](http://www.geeksforgeeks.org/maximum-contiguous-circular-sum/) 

### Code

__written by me__

    public int maxConsSum2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
        int soFar = 0;
		int max = 0;
		int totalSum = 0;
		for (Integer i: arr) {
			totalSum += i;
			// totalSum is used in next step
			soFar += i;
			soFar = Math.max(soFar, 0);
			max = Math.max(max, soFar);
		}
		int min = 0;
		// calculate the min subarray
		for (Integer i: arr) {
			soFar += i;
			soFar = Math.min(soFar, 0);
			min = Math.min(min, soFar);
		}
		return Math.max(max, totalSum - min);
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Test Command Line Copy]]></title>
    <link href="http://okckd.github.io/blog/2014/08/09/Test-command-line-copy/"/>
    <updated>2014-08-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/09/Test-command-line-copy</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/6591652/how-do-i-test-the-copy-command-in-the-windows-environment)

> testing the copy command in windows environment 

### Solution

[The most important point](http://stackoverflow.com/a/6591999) is to __come up with different domains of inputs and scenarios__. 

### Copying between:

1. network share
1. A really slow network share across the Internet
1. partitions
1. disks
1. disks of different types (flash, usb, external sata, SSD, etc...)
1. directories
1. within the same directory

### Naming

1. Normal file name
1. Filename that exceeds 8.3 (verylongfilename.whatever)
1. Copying a very long file name, but referencing it by it's 8.3 name (copy verylo~1.wha d:\)
1. A full directory path that exeeds MAX_PATH (260) characters (e.g. c:\a\very\long\directory\name\that\goes\on\forever\in\length......foo.txt)
1. By absolute addressing (\\?\\c:\foo\foo.txt)
1. wildcards (e.g. *.* *.txt foo?.txt )
1. A filename with unicode characters
1. A filename with illegal characters in it (there are creative ways to get these files on disk)

### Attributes

1. Testing with different file attributes (read-only, hidden, system, archive, etc...)
1. Validate timestamp is preserved across copies
1. Validate timestamp is preserved across network file share copies when the destination machine is in another timezone
1. NTFS ACLs are preserved

### Addressing types

1. reference by absolute path (e.g. copy c:\some\directory\foo.txt c:\other\place\foo.txt)
1. reference by relative path (e.g. copy ..\..\documents\whatever\foo.txt subdirectory/foo.txt)
1. By absolute drive letter into current working directoroy of destination (with no path (e.g. copy foo.txt d:)
1. Network share mounted to a drive letter

### Failure cases, edge cases, and hack attacks

1. Try to copy a file onto itself (e.g copy c:\foo.txt c:\foo.txt)
1. Copy when the network share is down.
1. Unplug the network cable in the middle of a network file copy
1. copy to a read only directory
1. copy when the source file is locked.
1. copy the when destination file exists but the destination file exists and is read only
1. Detach the external disk right before the file copy starts
1. disk is near full (But would be full before the entire copy finishes)
1. disk is full
1. Unplug the power cable in the middle of the copy!
1. During a very long copy, start another copy with the same source file, but to another destination
1. During a very long copy, start another copy with a different source file, but the the same destination
1. During a very long copy, start another copy with the same source and destination files!

### File types

1. ascii file
1. unicode file
1. binary file

### Environments

1. RAID configurations
1. FAT and NTFS
1. Windows XP, Vista, 7, Server 2003, etc... (you can quantify this by asking the requirement of "which OS" up front)
1. Virtual Machine (VMWare, virtual PC, hypervisor, etc...)
1. Intel and AMD
]]></content>
  </entry>
  
</feed>
