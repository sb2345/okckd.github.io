<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-11T19:01:38+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Number of Occurence of Given Sub-sequence]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/numer-of-occurrence-given-subsequence/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/numer-of-occurrence-given-subsequence</id>
    <content type="html"><![CDATA[### Question

[link](http://stackoverflow.com/questions/6877249/find-the-number-of-occurrences-of-a-subsequence-in-a-string)

> Given a digit '3141592653', find number of occurence of subsequence "123". Note that the sequence occurs twice:

    3141592653
     1    2  3
       1  2  3

> Output 2.

### Solution

Refer to __[LeetCode 115] Distinct Subsequences__. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Number of Distinct Sub-sequence]]></title>
    <link href="http://okckd.github.io/blog/2015/01/11/numer-of-distinct-subsequence/"/>
    <updated>2015-01-11T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/11/numer-of-distinct-subsequence</id>
    <content type="html"><![CDATA[### Question

[link](http://stackoverflow.com/questions/5151483/how-to-find-the-number-of-distinct-subsequences-of-a-string)

> Find the number of distinct subsequences of a string (include "" as a subsequence). 

> For example, Input 

    AAA 
    ABCDEFG 
    CODECRAFT 

> Output 

    4 
    128 
    496 

### Solution

In __[LeetCode 115] Distinct Subsequences__, we discuss finding occurence of a given subsequence. 

Now if we do not specify a subsequence, __we want the total number of distinct subsequence__. 

The solution is DP, with the following equation: 

    Let, 

    dp[i] = number of distinct subsequences ending with a[i]

    last[i] = last position of character i in the given string.

Equation: 

    __dp[i] = dp[last[i] - 1] + ... + dp[i - 1]__

The final result is: 

    Distinct Subsequences = dp[1] + ... dp[len - 1]

Example 1: 

    Input   : _ A B C
    dp array: 1 1 2 4
    Total = 8

Example 2: 

    Input   : _ A A C
    dp array: 1 1 1 3
    Total = 6

The code is posted below. 

### Optimize Solution

There is a good optimization of this DP solution, which is to __keep another dp array 'sum'__, which sum[i] = dp[1] + dp[2] + ... + dp[i]. The final answer would be sum[len - 1]. 

This nice idea is from [this post](http://stackoverflow.com/a/5152203). Credit goes to __IVlad__. 

### Code


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Amazon] Mininum Range That Includes at Least One]]></title>
    <link href="http://okckd.github.io/blog/2015/01/10/minimum-range-inclueds-at-least-1/"/>
    <updated>2015-01-10T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/10/minimum-range-inclueds-at-least-1</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=5103437989543936)

> There are many sorted arrays. Find a minimum range, so that in each array there's at least one integer within this range.

### Solution

__Min-heap__. [source](http://www.careercup.com/question?id=16759664)

> There are k lists of sorted integers. Make a min heap of size k containing 1 element from each list. Keep track of min and max element and calculate the range. 

> In min heap, minimum element is at top. Delete the minimum element and another element instead of that from the same list to which minimum element belong. Repeat the process till any one of the k list gets empty. 

### Code 

	public void printMinRange(int[][] input) {
		Comparator<Pointer> compr = new HeapComparator(input);
		// Note that we pass in 'input' arrays to the comparator
		PriorityQueue<Pointer> heap = new PriorityQueue<Pointer>(SIZE, compr);

		int maxVal = Integer.MIN_VALUE;
		for (int i = 0; i < SIZE; i++) {
			heap.add(new Pointer(i, 0));
			// insert the head of each array into the heap
			maxVal = Math.max(maxVal, input[i][0]);
			// keep additional value to keep track of the max value in heap
		}

		int left = 0;
		int right = Integer.MAX_VALUE;
		while (heap.size() == SIZE) {
			Pointer p = heap.remove();
			// first, update the range
			if (maxVal - input[p.index][p.position] < right - left) {
				right = maxVal;
				left = input[p.index][p.position];
			}
			// then, push the next element after 'p' to the heap
			// meanwhile, update 'maxVal'
			if (p.position + 1 < input[p.index].length) {
				Pointer nextP = new Pointer(p.index, p.position + 1);
				heap.add(nextP);
				maxVal = Math.max(maxVal, input[nextP.index][nextP.position]);
			}
			// when 'p' is the last element in the row, terminate loop
		}
		System.out.println("Left boundary: " + left);
		System.out.println("Right boundary: " + right);
	}

	class HeapComparator implements Comparator<Pointer> {

		int[][] arrays = null;

		public HeapComparator(int[][] input) {
			arrays = input;
		}

		public int compare(Pointer p1, Pointer p2) {
			return arrays[p1.index][p1.position]
					- arrays[p2.index][p2.position];
		}
	}

	class Pointer {
		int index, position;

		public Pointer(int x, int y) {
			index = x;
			position = y;
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Most Frequent Word From a Book]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/most-frequent-word-from-book/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/most-frequent-word-from-book</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=5715664853532672)

> Let's say I gave you a long String and I wanted you to tell me the most common word in that String. How would you do that? 

> Follow-up: how about if I gave you the entire works of Alexandre Dumas, one of the most prolific authors in history. How would your solution work? How could you change it to solve this more specific problem? 

### Solution

There are 2 solutions. Either __HashMap__ or __Trie__. It's easy to think of first, but remember that Trie is designed to do this kind of job. 

> A trie will be more useful in the second situation where you will have millions of words. You can have a counter at every node to see its frequency

__Now the follow up__. For big data problems, we can always do __divide and conquer__ by hash value. 

Alternatively, the comment by [Prince](http://www.careercup.com/question?id=5715664853532672) mentioned how to solve with __Map Reduce__: 

> Instead of loading it as a string first I would stream data so that I avoid memory spike. Further our map size might increases as new words are added to it. Also, we can use map reduce type job were we create map<word, frequency> of each play in parallel and later join/collapse them this will reduce the time it will take to get result. 

> Common phrase should be no different then above algorithm. However we need to rebuild our index with <phase, frequency>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Match Triplet With Reverse Order]]></title>
    <link href="http://okckd.github.io/blog/2015/01/09/match-triplet-with-reverse-order/"/>
    <updated>2015-01-09T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2015/01/09/match-triplet-with-reverse-order</id>
    <content type="html"><![CDATA[### Question

[link](http://www.careercup.com/question?id=11655778)

> Find the substring of length 3 which is present in the reverse order from the string. 

> Ex: if the string is abcdcba (cba is the reverse of abc) so we should return cba. 

### Solution

1. __HashMap (recommended)__. Hash all substrings of length 3. O(n). Look up all reverse substrings of length 3 in this hash set. O(n) time and O(n) space. 

1. __KMP Algo__. Take every substring of length 3. Reverse it and find it in the input using KMP. O(n^2) time and O(1) space. 

1. __Build suffix tree__ of height 3. Then in reverse order, check triplets. 

The 3 solutions above all work well. Pick the one you love. 
]]></content>
  </entry>
  
</feed>
