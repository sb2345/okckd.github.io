<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Question | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/question/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-12-01T11:39:50+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Duplicate Rows in Matrix]]></title>
    <link href="http://okckd.github.io/blog/2014/08/27/Duplicate-rows-in-matrix/"/>
    <updated>2014-08-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/27/Duplicate-rows-in-matrix</id>
    <content type="html"><![CDATA[### Question 1

[link](http://www.careercup.com/question?id=6488077455327232)

> Given a 2D array (n x m) of integers, find all duplicate rows and print their index.

### Solution

This is a [google question](http://get-that-job-at-google.blogspot.sg/2012/12/google-interview-experience.html).

__Use HashMap__ (but make your own). Computer hash value of each row and insert into HashMap as value pair of HashMap(hashValue, rowNumber). When there's a collision, just check the rowNumber stored in HashMap with current row. 

This requires O(n*m) time and O(n) space. Note that __we're not store the entire row into HashMap__ cuz it'll take up too much space. 

We (probably) can also use Trie. 

### Question 2

[link](http://www.careercup.com/question?id=9478119)

> Given a binary matrix of N X N of integers, you need to return only unique rows of binary arrays. 

    input: 
    0 1 0 0 1 
    1 0 1 1 0 
    0 1 0 0 1 
    1 1 1 0 0 
    
    ans: 
    0 1 0 0 1 
    1 0 1 1 0 
    1 1 1 0 0

### Solution

Different from __Question 1__, this input is only 0 and 1. 

__The solution is to use Trie__. Each node [only have 2 children](http://www.geeksforgeeks.org/print-unique-rows/) (that's why Trie is perfect solution here). 

### Code

__Using binary trie node__, refactored by me.

	public int[][] getUniqueRows(int[][] matrix) {
		int m = matrix.length;
		int n = matrix[0].length;

		TrieNode root = new TrieNode();
		TrieNode p;
		int uniqueCount = 0;
		boolean[] isUnique = new boolean[m];
		// isUnique is used to mark the lines that would appear in final result

		// start to build the trie
		for (int i = 0; i < m; i++) {
			// insert number matrix[i][] into the trie
			p = root;
			// root element would be an empty heading for all numbers
			for (int j = 0; j < n; j++) {
				int digit = matrix[i][j];
				if (p.kids == null) {
					p.kids = new TrieNode[2];
				}
				if (p.kids[digit] == null) {
					// this is a whole new branch, create a new node here
					p.kids[digit] = new TrieNode();
					if (j == n - 1) {
						uniqueCount++;
						isUnique[i] = true;
					}
				}
				p = p.kids[digit];
			}
		}
		System.out.println("uniqueCount is " + uniqueCount);
		int[][] result = new int[uniqueCount][];
		int k = 0;
		for (int w = 0; w < isUnique.length; w++) {
			if (isUnique[w]) {
				result[k++] = matrix[w];
			}
		}
		return result;
	}

	class TrieNode {
		TrieNode[] kids = null;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Square Count of Matchstick Graph]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Square-count-in-matchstick-graph/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Square-count-in-matchstick-graph</id>
    <content type="html"><![CDATA[### Question 

> 给出下面这个图 设计数据结构和算法求出图中__所有的正方形数量__ (count the number of squares). 

<img class="middle" src="/assets/images/matchstick-square-count.jpg">

### Solution

1. __Pre-processing__: 从每一个点开始存储上下左右四个方向最多延伸到的位置

1. __Main algorithm__: 枚举右下角位置 然后枚举正方形边长 

1. 根据预处理的延伸情况判断是否能够有一个正方形被构造出来 

Total time complexity is O(n^3). 

> 预处理可以O(n^2) 预处理是有递推关系的 
>
> 但是后面枚举的部分，只能O(n^3)
>
> __不能动态规划的原因是__：他给定了一个可以变化的图，这个图上规模为n的图和规模为n-1的图中正方形个数之间不存在递推关系。 

And 一般来说处理矩阵的问题，大部分都是O(n^3)

### Code

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Ways of Dice Throw]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Dice-roll-DP-question/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Dice-roll-DP-question</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/dice-throw-problem/)

> Given n dice each with m faces, numbered from 1 to m, find the number of ways to get sum X. X is the summation of values on each face when all the dice are thrown. 

### Solution

__DP__

> Sum(m, n, X) = Sum(m, n - 1, X - 1) + 
>
>                Sum(m, n - 1, X - 2) +
>
>                .................... + 
>
>                Sum(m, n - 1, X - m)

So we can have dp(n)(X) and for each, iterate m time. Total time is O(m * n * X). 

### Code

__not written by me__.

	int findWays(int m, int n, int x)
	{
	    // Create a table to store results of subproblems.  One extra 
	    // row and column are used for simpilicity (Number of dice
	    // is directly used as row index and sum is directly used
	    // as column index).  The entries in 0th row and 0th column
	    // are never used.
	    int table[n + 1][x + 1];
	    memset(table, 0, sizeof(table)); // Initialize all entries as 0
	 
	    // Table entries for only one dice
	    for (int j = 1; j <= m && j <= x; j++)
	        table[1][j] = 1;
	 
	    // Fill rest of the entries in table using recursive relation
	    // i: number of dice, j: sum
	    for (int i = 2; i <= n; i++)
	        for (int j = 1; j <= x; j++)
	            for (int k = 1; k <= m && k < j; k++)
	                table[i][j] += table[i-1][j-k];
	 
	    /* Uncomment these lines to see content of table
	    for (int i = 0; i <= n; i++)
	    {
	      for (int j = 0; j <= x; j++)
	        cout << table[i][j] << " ";
	      cout << endl;
	    } */
	    return table[n][x];
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Count Set Bit in Binary Number]]></title>
    <link href="http://okckd.github.io/blog/2014/08/20/Count-set-bit-in-binary-number/"/>
    <updated>2014-08-20T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/20/Count-set-bit-in-binary-number</id>
    <content type="html"><![CDATA[### Question 

> Count Set Bit in Binary Number.

> 3 = 00000011 => 2

> 128 = 10000000 => 1

### Solution

__Bits counting algorithm__ (Brian Kernighan). Basic idea is __clear 1 bit at a time__. 

This algorithm goes through as many iterations as there are set bits. In the worst case, it will pass once per bit. An integer n has log(n) bits, hence [the worst case](http://stackoverflow.com/a/12381102) is O(log(n)).

### Code

	public int countSetBit(String binary) {
		int num = Integer.parseInt(binary, 2);
		int count = 0;
		while (num != 0) {
			num &= num - 1;
			count++;
		}
		return count;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Count Level in Perfect Binary Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/08/19/Count-level-in-perfect-BT/"/>
    <updated>2014-08-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/19/Count-level-in-perfect-BT</id>
    <content type="html"><![CDATA[### Question 

[link](http://stackoverflow.com/questions/10721583/how-can-i-calculate-the-level-of-a-node-in-a-perfect-binary-tree-from-its-depth)

> A perfect binary tree, i.e. each node in the tree is either a leaf node, or has two children, and all leaf nodes are on the same level. Each node has an index in depth-first order. 

		  0
		/   \
	  1      4
	 / \    / \
	2   3  5   6

> Given the index (k) of a particular node, calculate its level. 

### Solution

__This is a [magical solution](http://stackoverflow.com/a/10721897)__.  It divides the tree in the middle with number k decrease by 1 each time. 

Beautiful, and hard to understand. 

### Code

__not written by me__.

	public int countLevel(TreeNode root, int k, int n) {
		int level = 0;
		while (k != 0) {
			k--;
			n = (n - 1) / 2;
			k = k % n;
			level++;
		}
		return level + 1;
	}
]]></content>
  </entry>
  
</feed>
