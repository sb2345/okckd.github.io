<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ninechap | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/ninechap/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2015-01-24T17:52:26+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[NineChap 10] Additional Questions]]></title>
    <link href="http://okckd.github.io/blog/2014/07/07/NineChap-additional/"/>
    <updated>2014-07-07T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/07/NineChap-additional</id>
    <content type="html"><![CDATA[<p>The following questions does not appear in NineChap, but they all worth reading.</p>

<h3>Question List</h3>

<ol>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-04-27-longest-substring-without-repeating%20%}">Longest Substring Without Repeating Characters </a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-21-Minimum-Window-Substring%20%}">Minimum Window Substring </a></strong> &ndash; very difficult</p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-23-Scramble-String%20%}">Scramble String </a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-25-Recover-Binary-Search-Tree%20%}">Recover Binary Search Tree </a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-04-26-Median-of-Two-Sorted-Arrays%20%}">Median of Two Sorted Arrays </a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-14-Sudoku-Solver%20%}">Sudoku Solver </a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-21-Word-Search%20%}">Word Search </a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-21-Simplify-Path%20%}">Simplify Path</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-04-29-Regular-Expression-Matching%20%}">Regular Expression Matching</a></strong> &ndash; very difficult</p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-15-Wildcard-Matching%20%}">Wildcard Matching</a></strong> &ndash; difficult</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[NineChap 8] High Frequency Questions]]></title>
    <link href="http://okckd.github.io/blog/2014/06/28/NineChap-High-frequency/"/>
    <updated>2014-06-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/28/NineChap-High-frequency</id>
    <content type="html"><![CDATA[<h2>Number &amp; Bit questions</h2>

<ol>
<li><strong><a href="{%%20post_url%20/leetcode/2014-06-01-Single-Number%20%}">Single Number</a></strong></li>
<li><strong><a href="{%%20post_url%20/leetcode/2014-06-01-Single-Number-II%20%}">Single Number II</a></strong></li>
<li><strong><a href="{%%20post_url%20/question/2014-06-28-Single-Number-III%20%}">Single Number III</a></strong></li>
<li><strong><a href="{%%20post_url%20/question/2014-06-28-Single-Number-IV%20%}">Single Number IV</a></strong></li>
<li><strong><a href="{%%20post_url%20/lintcode/2014-06-28-Majority-Number%20%}">Majority Number</a></strong></li>
<li><strong><a href="{%%20post_url%20/lintcode/2014-06-28-Majority-Number-II%20%}">Majority Number II</a></strong></li>
<li><strong><a href="{%%20post_url%20/lintcode/2014-06-28-Majority-Number-III%20%}">Majority Number III</a></strong></li>
</ol>


<h2>Subarray questions</h2>

<p>Always using the idea of 前缀和.</p>

<ol>
<li><strong><a href="{%%20post_url%20/leetcode/2014-05-28-Best-Time-to-Buy-and-Sell-Stock%20%}">Best Time to Buy and Sell Stock</a></strong> &ndash; 贪心法</li>
<li><strong><a href="{%%20post_url%20/leetcode/2014-05-28-Best-Time-to-Buy-and-Sell-Stock-II%20%}">Best Time to Buy and Sell Stock II</a></strong></li>
<li><strong><a href="{%%20post_url%20/leetcode/2014-05-28-Best-Time-to-Buy-and-Sell-Stock-III%20%}">Best Time to Buy and Sell Stock III</a></strong></li>
<li><strong><a href="{%%20post_url%20/leetcode/2014-05-20-Maximum-Subarray%20%}">Maximum Subarray</a></strong></li>
<li><strong><a href="{%%20post_url%20/lintcode/2014-06-28-Minimum-subarray%20%}">Minimum Subarray </a></strong></li>
<li><strong><a href="{%%20post_url%20/lintcode/2014-06-28-Maximum-subarray-II%20%}">Maximum Subarray II</a></strong></li>
<li><strong><a href="{%%20post_url%20/question/2014-07-04-Subarray-with-0-Sum%20%}">Subarray with 0 Sum</a></strong></li>
<li><strong><a href="{%%20post_url%20/question/2014-07-04-Subarray-with-Particular-Sum%20%}">Subarray with Particular Sum</a></strong></li>
<li><strong><a href="{%%20post_url%20/question/2014-07-04-Subarray-with-Sum-Closest%20%}">Subarray with Sum Closest</a></strong></li>
</ol>


<h2>N Sum questions</h2>

<ol>
<li><strong><a href="{%%20post_url%20/leetcode/2014-04-26-two-sum%20%}">Two Sum</a></strong> &ndash; difficult</li>
<li><strong><a href="{%%20post_url%20/leetcode/2014-05-02-3Sum%20%}">3 Sum</a></strong></li>
<li><strong><a href="{%%20post_url%20/leetcode/2014-05-02-3Sum-Closest%20%}">3 Sum Closest</a></strong></li>
<li><strong><a href="{%%20post_url%20/leetcode/2014-05-03-4Sum%20%}">4 Sum</a></strong> &ndash; doing a O(n<sup>3</sup>) solution is good enough.</li>
<li><strong>k sum questions</strong> are basically solved with O(n<sup>k-1</sup>) time. Faster solution is available but too complex.</li>
</ol>


<h2>L 家最爱</h2>

<ol>
<li><strong><a href="{%%20post_url%20/leetcode/2014-05-15-PowXN%20%}">Pow(x,n)</a></strong></li>
<li><strong><a href="{%%20post_url%20/leetcode/2014-05-21-SqrtX%20%}">Sqrt(x)</a></strong></li>
<li><strong><a href="{%%20post_url%20/lintcode/2014-07-02-Trailing-Zero-of-Factorial%20%}">Trailing Zeros of Factorial</a></strong></li>
<li><strong><a href="{%%20post_url%20/question/2014-07-04-Check-Power-of-2%20%}">Check Power of 2</a></strong></li>
</ol>


<h2>Additional questions</h2>

<ol>
<li><strong><a href="{%%20post_url%20/lintcode/2014-06-28-Partition-array%20%}">Partition Array</a></strong></li>
<li><strong><a href="{%%20post_url%20/leetcode/2014-05-21-Sort-Colors%20%}">Sort Color</a></strong></li>
</ol>


<h2>Code</h2>

<h4>Number questions</h4>

<p><strong>Single Number</strong></p>

<pre><code>public int singleNumber(int[] A) {
    int x = 0;
    for (Integer a: A) {
        x = x ^ a;
    }
    return x;
}
</code></pre>

<p><strong>Single Number II</strong></p>

<p>Last time, I used an array of size 32 to store count, but it&rsquo;s actually not necessary.</p>

<pre><code>public int singleNumber(int[] A) {
    int ans = 0;
    for (int i = 0; i &lt; 32; i++) {
        int count = 0;
        for (Integer a: A) {
            count += ((a &gt;&gt; i) &amp; 1);
        }
        ans |= (count % 3) &lt;&lt; i;
    }
    return ans;
}
</code></pre>

<h4>Subarray questions</h4>

<p><strong>Best Time to Buy and Sell Stock</strong></p>

<pre><code>public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int min = prices[0];
    int profit = 0;
    for (Integer p: prices) {
        min = Math.min(min, p);
        profit = Math.max(profit, p - min);
    }
    return profit;
}
</code></pre>

<p><strong>Best Time to Buy and Sell Stock II</strong></p>

<pre><code>public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int pre = prices[0];
    int profit = 0;
    for (Integer p: prices) {
        if (p &gt; pre) {
            profit += p - pre;
        }
        pre = p;
    }
    return profit;
}
</code></pre>

<p><strong>Best Time to Buy and Sell Stock III</strong></p>

<p>It&rsquo;s important to note the 2nd last line of the code, where we consider the corner case of doing only 1 transaction.</p>

<p>It&rsquo;s always best to list a simple test case and walk it thru before submitting the code.</p>

<pre><code>public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int len = prices.length;
    int[] dpLeft = new int[len];
    int leftMin = prices[0];
    for (int i = 1; i &lt; len; i++) {
        dpLeft[i] = Math.max(dpLeft[i - 1], prices[i] - leftMin);
        leftMin = Math.min(leftMin, prices[i]);
    }
    int[] dpRight = new int[len];
    int rightMax = prices[len - 1];
    for (int i = len - 2; i &gt;= 0; i--) {
        dpRight[i] = Math.max(dpRight[i + 1], rightMax - prices[i]);
        rightMax = Math.max(rightMax, prices[i]);
    }
    // now iterate the 2 DP array and find out the largest possible profit
    int profit = 0;
    for (int i = 0; i &lt; len - 1; i++) {
        profit = Math.max(profit, dpLeft[i] + dpRight[i + 1]);
    }
    int oneTransaction = Math.max(dpLeft[len - 1], dpRight[0]);
    return Math.max(profit, oneTransaction);
}
</code></pre>

<p><strong>Maximum Subarray</strong></p>

<pre><code>public int maxSubArray(int[] A) {
    if (A == null || A.length == 0) {
        return 0;
    }
    int max = Integer.MIN_VALUE;
    int pre = 0;
    // the largest sum ending at previous position in the array
    for (Integer a: A) {
        max = Math.max(max, pre + a);
        pre = Math.max(0, pre + a);
    }
    return max;
}
</code></pre>

<h4>3Sum questions</h4>

<p><strong>Two Sum</strong></p>

<p>This solution is O(nlgn) time.</p>

<p>Alternatively, we can use HashMap to solve this problem with O(n) time.</p>

<pre><code>public int[] twoSum(int[] numbers, int target) {
    // write your code here
    int[] ans = new int[2];
    if (numbers == null || numbers.length == 0) {
        return ans;
    }
    int len = numbers.length;
    Pair[] pairs = new Pair[len];
    for (int i = 0; i &lt; len; i++) {
        pairs[i] = new Pair(numbers[i], i + 1);
    }
    Arrays.sort(pairs);
    int left = 0;
    int right = len - 1;
    while (left &lt; right) {
        if (pairs[left].num + pairs[right].num == target) {
            ans[0] = pairs[left].index;
            ans[1] = pairs[right].index;
            Arrays.sort(ans);
            break;
        } else if (pairs[left].num + pairs[right].num &gt; target) {
            right--;
        } else {
            left++;
        }
    }
    return ans;
}

class Pair implements Comparable&lt;Pair&gt; {
    int num;
    int index;

    public Pair(int a, int b) {
        num = a;
        index = b;
    }

    public int compareTo(Pair another) {
        return this.num - another.num;
    }
}
</code></pre>

<p><strong>3 Sum</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(int[] numbers) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (numbers == null || numbers.length == 0) {
        return ans;
    }
    Arrays.sort(numbers);
    int len = numbers.length;
    for (int i = 0; i &lt; len; i++) {
        if (i &gt; 0 &amp;&amp; numbers[i - 1] == numbers[i]) {
            continue;
        }
        int left = i + 1;
        int right = len - 1;
        // find 2 numbers that sums to - number[i]
        while (left &lt; right) {
            int diff = numbers[left] + numbers[right] + numbers[i];
            if (diff == 0) {
                ArrayList&lt;Integer&gt; triplet = new ArrayList&lt;Integer&gt;();
                triplet.add(numbers[i]);
                triplet.add(numbers[left]);
                triplet.add(numbers[right]);
                ans.add(triplet);
            }
            if (diff &lt;= 0) {
                left++;
                while (left &lt; len &amp;&amp; numbers[left - 1] == numbers[left]) {
                    left++;
                }
            }
            if (diff &gt;= 0) {
                right--;
                while (right &gt;= 0 &amp;&amp; numbers[right + 1] == numbers[right]) {
                    right--;
                }
            }
        }
    }
    return ans;
}
</code></pre>

<p><strong>3 Sum Closest</strong></p>

<pre><code>public int threeSumClosest(int[] numbers, int target) {
    if (numbers == null || numbers.length == 0) {
        return 0;
    }
    Arrays.sort(numbers);
    int sum = 0;
    int diff = Integer.MAX_VALUE;
    int len = numbers.length;
    for (int i = 0; i &lt; len; i++) {
        int left = i + 1;
        int right = len - 1;
        while (left &lt; right) {
            int triple = numbers[left] + numbers[right] + numbers[i];
            if (triple == target) {
                return target;
            } else if (triple &lt; target) {
                left++;
            } else {
                right--;
            }
            if (Math.abs(target - triple) &lt; diff) {
                diff = Math.abs(target - triple);
                sum = triple;
            }
        }
    }
    return sum;
}
</code></pre>

<p><strong>4 Sum</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; fourSum(int[] numbers, int target) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (numbers == null || numbers.length == 0) {
        return ans;
    }
    Arrays.sort(numbers);
    int len = numbers.length;
    for (int i = 0; i &lt; len - 3; i++) {
        if (i &gt; 0 &amp;&amp; numbers[i - 1] == numbers[i]) {
            continue;
        }
        for (int j = i + 1; j &lt; len - 2; j++) {
            if (j &gt; i + 1 &amp;&amp; numbers[j - 1] == numbers[j]) {
                continue;
            }
            int left = j + 1;
            int right = len - 1;
            while (left &lt; right) {
                int diff = numbers[left] + numbers[right] + numbers[i] + numbers[j] - target;
                if (diff == 0) {
                    ArrayList&lt;Integer&gt; triplet = new ArrayList&lt;Integer&gt;();
                    triplet.add(numbers[i]);
                    triplet.add(numbers[j]);
                    triplet.add(numbers[left]);
                    triplet.add(numbers[right]);
                    ans.add(triplet);
                }
                if (diff &lt;= 0) {
                    left++;
                    while (left &lt; len &amp;&amp; numbers[left - 1] == numbers[left]) {
                        left++;
                    }
                }
                if (diff &gt;= 0) {
                    right--;
                    while (right &gt;= 0 &amp;&amp; numbers[right + 1] == numbers[right]) {
                        right--;
                    }
                }
            }
        }
    }
    return ans;
}
</code></pre>

<h4>L 家最爱</h4>

<p><strong>Pow(x,n)</strong></p>

<p>It&rsquo;s important to note that in Line 16, wrting &lsquo;while (pow * 2 &lt;= y)&rsquo; would not work (because of overflow). It took me a long time to find this bug.</p>

<pre><code>public double pow(double x, int n) {
    if (n &lt; 0) {
        return 1.0 / helper (x, 0 - n);
    } else {
        return helper(x, n);
    }
}

private double helper(double x, int y) {
    if (y == 0) {
        return 1.0;
    }
    int pow = 1;
    double num = x;
    while (pow &lt;= y / 2) {
        num *= num;
        pow &lt;&lt;= 1;
    }
    return num * helper(x, y - pow);
}
</code></pre>

<p><strong>Sqrt(x)</strong></p>

<p>Note that in Line 8, we must declare left and right as &lsquo;long&rsquo;, not &lsquo;int&rsquo;, otherwise there will be overflow problems. It took me a long time to find this bug.</p>

<pre><code>public int sqrt(int x) {
    if (x &lt; 0) {
        return -1;
    } else if (x &lt; 2) {
        return x;
    }
    long left = 1;
    long right = x;
    while (left + 1 &lt; right) {
        long mid = left + (right - left) / 2;
        if (mid * mid &lt; x) {
            left = mid;
        } else if (mid * mid &gt; x) {
            right = mid;
        } else {
            return (int) mid;
        }
    }
    return (int) left;
}
</code></pre>

<h4>Additional</h4>

<p><strong>Sort Color</strong></p>

<pre><code>public void sortColors(int[] A) {
    if (A == null || A.length == 0) {
        return;
    }
    int len = A.length;
    partition(A, 0, len - 1, 0);
    int p = 0;
    while (p &lt; len &amp;&amp; A[p] == 0) {
        p++;
    }
    partition(A, p, len - 1, 1);
}

private void partition(int[] A, int start, int end, int target) {
    // find the target and put it on the left side of the array
    while (start &lt; end) {
        while (start &lt; A.length &amp;&amp; A[start] == target) {
            start++;
        }
        while (end &gt;= 0 &amp;&amp; A[end] != target) {
            end--;
        }
        if (start &gt; end) {
            break;
        } else {
            int temp = A[start];
            A[start] = A[end];
            A[end] = temp;
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[NineChap 7] Data Structure]]></title>
    <link href="http://okckd.github.io/blog/2014/06/28/NineChap-Data-structure/"/>
    <updated>2014-06-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/28/NineChap-Data-structure</id>
    <content type="html"><![CDATA[<h2>Data Structure</h2>

<p>Data structure is a way to manage data. It provides some methods to handle data stream. For example, DB is a DS.</p>

<h3>Stack and Queue</h3>

<ol>
<li><p><strong><a href="{%%20post_url%20/question/2014-07-01-Min-Stack%20%}">Min-stack</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/question/2014-07-01-Implement-queue-with-stack%20%}">Implement a queue by two stacks</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-23-Largest-Rectangle-in-Histogram%20%}">Largest Rectangle in histogram</a></strong></p></li>
</ol>


<h3>Hash</h3>

<h4>Hash function</h4>

<ol>
<li>MD5</li>
<li>Magic number 33 (<strong>PHP hash function <a href="http://events.ccc.de/congress/2011/Fahrplan/attachments/2007_28C3_Effective_DoS_on_web_application_platforms.pdf">DJBX33A</a></strong>)</li>
</ol>


<p>Magic Number:</p>

<pre><code>int hashfunc(String key) {
    int sum = 0;
    for (int i = 0; i &lt; key.length(); i++) {
        sum = sum * 33 + (int)(key.charAt(i));
        sum = sum % HASH_TABLE_SIZE;
    }
    return sum
}
</code></pre>

<h4>Collision</h4>

<ol>
<li><p><strong>Close hashing (also called Open addressing)</strong></p>

<p> Resolves conflict by probing, or searching through alternate locations in the array</p>

<p> Suck scheme may cause the lookup cost to skyrocket. Not good to use.</p></li>
<li><p><strong>Open hashing</strong></p>

<p> Keys stored in linked lists attached to cells of the hash table.</p>

<p> Practically, hash size set around 10 times the size of data</p>

<p> Used by Java and most other languages.</p></li>
</ol>


<h4>Rehashing</h4>

<ol>
<li><p>Memcached is a general-purpose distributed memory caching system. One of its bottleneck is rehashing, which locks down the entire hash.</p></li>
<li><p>Dynamic resizing (normally size * 2) and copy all elements into the new hash.</p></li>
<li><p>Extremely slow process, we should try to avoid it by setting a large enough initial size.</p></li>
</ol>


<h4>Hash questions:</h4>

<ol>
<li><p><strong><a href="{%%20post_url%20/question/2014-07-01-Implement-Hashmap%20%}">Implement a hashmap</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/design/2014-07-01-Hashmap-Hashtable-Hashset%20%}">HashMap vs Hashtable vs HashSet</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-06-03-LRU-Cache%20%}">LRU Cache</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-29-Longest-Consecutive-Sequence%20%}">Longest consecutive sequence</a></strong></p></li>
</ol>


<h3>Heap</h3>

<ol>
<li>Child is always larger than parent</li>
<li>Heap is not a sorted structure, but it&rsquo;s partially ordered</li>
<li>Heap is always balanced</li>
</ol>


<p>Heap is better than array because average of 3 operations is O(logn), but array is O(n).</p>

<blockquote><p>Add O(log N)</p>

<p>Remove O(log N)</p>

<p>Min/Max O(1)</p></blockquote>

<h4>Heap implementation:</h4>

<ol>
<li><p>Low Level: dynamic array, not list</p></li>
<li><p>Internal Method: Shiftup, Shiftdown operations</p></li>
<li><p>A heap is a complete binary tree (最优二叉树) <strong>represented by an array</strong></p></li>
<li><p>When removing element from heap, we actually uses HashMap to find that element.</p></li>
</ol>


<blockquote><p>Heaps are usually implemented in an array, and do not require pointers between elements.</p>

<p>Full and almost full binary heaps may be represented in a very space-efficient way using an array alone. The first element will contain the root. The next two elements of the array contain its children. The next four contain the four children of the two child nodes, etc.</p>

<p>Thus the children of the node at position n would be at positions 2n+1 and 2n+2.</p></blockquote>

<p>So to summarize:</p>

<ol>
<li>elems[1] &ndash; root, also the minimum elem in elems.</li>
<li>elems[i]: left child is elems[i<em>2], right child is elems[i</em>2+1]</li>
</ol>


<p>Implementation code:</p>

<pre><code>Add:
    Push back to elems; size ++; Siftup;
Remove:
    Replace the elem to be removed with the last elem; 
    size --; 
    Siftup and Siftdown.
</code></pre>

<h4>Heap questions:</h4>

<ol>
<li><p><strong><a href="{%%20post_url%20/question/2014-07-01-Median-in-stream-of-integers%20%}">Median in a stream of integers</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/question/2014-07-01-The-Skyline-Problem%20%}">The Skyline Problem</a></strong></p></li>
</ol>


<h3>Interval Tree</h3>

<p>Easily find the max/min value in an interval. 2 example questions are:</p>

<ol>
<li>Find min/max/sum in an interval</li>
<li>最长的连续1</li>
</ol>


<h2>Code</h2>

<p><strong>Largest Rectangle in histogram</strong></p>

<pre><code>public int largestRectangleArea(int[] height) {
    if (height == null || height.length == 0) {
        return 0;
    }
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    stack.add(0);
    int len = height.length;
    int area = 0;
    for (int i = 1; i &lt;= len; i++) {
        int h = i == len ? 0 : height[i];
        // pop a element and calculate its max area
        // pop until the top element is smaller than h, then push h
        while (!stack.isEmpty() &amp;&amp; h &lt; height[stack.peek()]) {
            int pos = stack.pop();
            int width = stack.isEmpty() ? i : i - stack.peek() - 1;
            area = Math.max(area, height[pos] * width);
        }
        stack.push(i);
    }
    return area;
}
</code></pre>

<p><strong>LRU Cache</strong></p>

<p>I posted code in the new post.</p>

<p><strong>Longest consecutive sequence</strong></p>

<pre><code>public int longestConsecutive(int[] num) {
    if (num == null || num.length == 0) {
        return 0;
    }
    HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
    for (Integer i: num) {
        set.add(i);
    }
    int longest = 0;
    for (Integer i: num) {
        if (!set.contains(i)) {
            continue;
        }
        int left = i - 1;
        while (set.contains(left)) {
            set.remove(left--);
        }
        int right = i + 1;
        while (set.contains(right)) {
            set.remove(right++);
        }
        longest = Math.max(longest, right - left - 1);
        set.remove(i);
    }
    return longest;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[NineChap 6] Graph and Search]]></title>
    <link href="http://okckd.github.io/blog/2014/06/26/NineChap-Graph/"/>
    <updated>2014-06-26T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/26/NineChap-Graph</id>
    <content type="html"><![CDATA[<h2>Graph</h2>

<p>For graph, there are only 2 high-frequency questions, which is &lsquo;clone graph&rsquo; and &lsquo;topology sorting&rsquo;.</p>

<h3>Question list</h3>

<ol>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-30-Clone-Graph%20%}">Clone Graph</a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="{%%20post_url%20/question/2014-06-27-Topology-sorting%20%}">Topology Sorting</a></strong></p></li>
</ol>


<h2>Search</h2>

<p>Search have either DFS or BFS.</p>

<p>First, we will cover permutations and combinations using DFS. In this section we solve the famous N-queens question.</p>

<p>Then, there&rsquo;s a few BFS questions. Graph traversal is BFS, and Word ladder is also a classic BFS question.</p>

<h3>Question list</h3>

<ol>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-22-Subsets%20%}">Subsets</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-22-Subsets-II%20%}">Subsets II</a></strong></p>

<p> difficult</p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-14-Permutations%20%}">Permutations</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-14-Permutations-II%20%}">Permutations II</a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-16-N-Queens%20%}">N-Queens</a></strong></p>

<p> how to use hashmap (and some space) to make it faster? 3 hashmaps to store the row, the (x,y) diff and sum. This will make isValid() method O(1).</p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-16-N-Queens-II%20%}">N-Queens II</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-12-Next-Permutation%20%}">Next Permutation</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/lintcode/2014-06-27-Previous-Permutation%20%}">Previous Permutation</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-29-Palindrome-Partitioning%20%}">Palindrome Partitioning</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-30-Palindrome-Partitioning-II%20%}">Palindrome Partitioning II</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-13-Combination-Sum%20%}">Combination Sum</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-13-Combination-Sum%20%}">Combination Sum II</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-29-Word-Ladder%20%}">Word Ladder</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-30-Word-Ladder-II%20%}">Word Ladder II</a></strong></p></li>
</ol>


<h3>Additional questions</h3>

<ol>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-24-Restore-IP-Addresses%20%}">Restore IP Addresses</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-22-Combinations%20%}">Combinations</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-02-Letter-Combinations-of-a-Phone-Number%20%}">Letter Combinations of a Phone Number</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-19-Permutation-Sequence%20%}">Permutation Sequence</a></strong></p></li>
</ol>


<h2>Code</h2>

<h3>Graph</h3>

<p><strong>Clone Graph</strong></p>

<pre><code>public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if (node == null) return null;
    HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = 
            new HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt;();
    Queue&lt;UndirectedGraphNode&gt; queue = new LinkedList&lt;UndirectedGraphNode&gt;();
    map.put(node, new UndirectedGraphNode(node.label));
    queue.add(node);
    while (!queue.isEmpty()) {
        UndirectedGraphNode cur = queue.remove();
        UndirectedGraphNode copy = map.get(cur);
        // here the 'copy' must exist. why? because all neighbors 
        // has been added to the map when they're pushed to queue.
        // so 'cur' must have a corresponding copy in the hashmap. 
        for (UndirectedGraphNode neib: cur.neighbors) {
            if (!map.containsKey(neib)) {
                queue.add(neib);
                map.put(neib, new UndirectedGraphNode(neib.label));
            }
            copy.neighbors.add(map.get(neib));
        }
    }
    return map.get(node);
}
</code></pre>

<p><strong>Topology Sorting</strong></p>

<p>A new post is written for it.</p>

<h3>Search</h3>

<p><strong>Subsets</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; subsets(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (num == null || num.length == 0) {
        return ans;
    }
    Arrays.sort(num);
    helper(ans, new LinkedList&lt;Integer&gt;(), num, 0);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num, int pos) {
    ans.add(new LinkedList&lt;Integer&gt;(path));
    for (int i = pos; i &lt; num.length; i++) {
        path.add(num[i]);
        helper(ans, path, num, i + 1);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Subsets II</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (num == null || num.length == 0) {
        return ans;
    }
    Arrays.sort(num);
    helper(ans, new LinkedList&lt;Integer&gt;(), num, 0);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num, int pos) {
    ans.add(new LinkedList&lt;Integer&gt;(path));
    for (int i = pos; i &lt; num.length; i++) {
        if (i &gt; pos &amp;&amp; num[i - 1] == num[i]) {
            continue;
        }
        path.add(num[i]);
        helper(ans, path, num, i + 1);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Permutations</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (num == null || num.length == 0) {
        return ans;
    }
    helper(ans, new LinkedList&lt;Integer&gt;(), num);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num){
    if (path.size() == num.length) {
        ans.add(new LinkedList&lt;Integer&gt;(path));
    }
    for (int i = 0; i &lt; num.length; i++) {
        if (path.contains(num[i])) {
            continue;
        }
        path.add(num[i]);
        helper(ans, path, num);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Permutations II</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (num == null || num.length == 0) {
        return ans;
    }
    Arrays.sort(num);
    helper(ans, new LinkedList&lt;Integer&gt;(), num, new int[num.length]);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num, int[] visited){
    if (path.size() == num.length) {
        ans.add(new LinkedList&lt;Integer&gt;(path));
        return;
    }
    for (int i = 0; i &lt; num.length; i++) {
        if (visited[i] == 1) {
            continue;
        }
        if (i &gt; 0 &amp;&amp; visited[i - 1] == 1 &amp;&amp; visited[i] == 0 &amp;&amp; num[i - 1] == num[i]) {
            // if current number is same as previous, then don't visit current
            continue;
        }
        path.add(num[i]);
        visited[i] = 1;

        helper(ans, path, num, visited);

        path.remove(path.size() - 1);
        visited[i] = 0;
    }
}
</code></pre>

<p><strong>N-Queens</strong></p>

<p>一次通关！高兴。</p>

<pre><code>public List&lt;String[]&gt; solveNQueens(int n) {
    List&lt;String[]&gt; ans = new LinkedList&lt;String[]&gt;();
    if (n &lt;= 0) {
        return ans;
    }
    helper(ans, new int[n], n, 0);
    return ans;
}

private void helper(List&lt;String[]&gt; ans, int[] path, int n, int pos) {
    if (pos &gt;= n) {
        ans.add(convert(path, n));
        return;
    }
    for (int i = 0; i &lt; n; i++) {
        path[pos] = i;
        if (!isValid(path, pos)) {
            continue;
        }
        helper(ans, path, n, pos + 1);
    }
}

private String[] convert(int[] path, int n) {
    String[] ans = new String[n];
    for (int j = 0; j &lt; n; j++) {
        ans[j] = "";
        for (int i = 0; i &lt; n; i++) {
            ans[j] += (j == path[i]) ? 'Q' : '.';
        }
    }
    return ans;
}

private boolean isValid(int[] path, int pos) {
    for (int i = 0; i &lt; pos; i++) {
        // check path[i] and path[pos]
        if (path[i] == path[pos]) {
            return false;
        }
        if (path[i] - path[pos] == pos - i) {
            return false;
        }
        if (path[pos] - path[i] == pos - i) {
            return false;
        }
    }
    return true;
}
</code></pre>

<p><strong>N-Queens II</strong></p>

<pre><code>int total;

public int totalNQueens(int n) {
    if (n &lt;= 0) {
        return 0;
    }
    helper(new int[n], n, 0);
    return total;
}

private void helper(int[] path, int n, int pos) {
    if (pos &gt;= n) {
        total++;
        return;
    }
    for (int i = 0; i &lt; n; i++) {
        path[pos] = i;
        if (!isValid(path, pos)) {
            continue;
        }
        helper(path, n, pos + 1);
    }
}

private boolean isValid(int[] path, int pos) {
    for (int i = 0; i &lt; pos; i++) {
        // check path[i] and path[pos]
        if (path[i] == path[pos]) {
            return false;
        }
        if (path[i] - path[pos] == pos - i) {
            return false;
        }
        if (path[pos] - path[i] == pos - i) {
            return false;
        }
    }
    return true;
}
</code></pre>

<p><strong>Next Permutation</strong></p>

<pre><code>public void nextPermutation(int[] num) {
    if (num == null || num.length &lt;= 1) {
        return;
    }
    int len = num.length;
    int p = len - 2;
    while (p &gt;= 0 &amp;&amp; num[p] &gt;= num[p + 1]) {
        p--;
    }
    if (p &lt; 0) {
        Arrays.sort(num);
    } else {
        int k = len - 1;
        while (k &gt;= 0 &amp;&amp; num[k] &lt;= num[p]) {
            k--;
        }
        swap(num, p, k);
        reverse(num, p + 1, len - 1);
    }
}

private void swap(int[] num, int p, int k) {
    num[p] = num[p] + num[k];
    num[k] = num[p] - num[k];
    num[p] = num[p] - num[k];
}

private void reverse(int[] num, int s, int d) {
    while (s &lt; d) {
        swap(num, s++, d--);
    }
}
</code></pre>

<p><strong>Previous Permutation</strong></p>

<p>Plz look at the new post.</p>

<p><strong>Palindrome Partitioning</strong></p>

<p>一次通关 again！very 高兴。</p>

<pre><code>public ArrayList&lt;ArrayList&lt;String&gt;&gt; partition(String s) {
    ArrayList&lt;ArrayList&lt;String&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;String&gt;&gt;();
    if (s == null || s.length() == 0) {
        return ans;
    }
    boolean[][] map = palinMap(s);
    helper(ans, new ArrayList&lt;String&gt;(), s, map, 0);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;String&gt;&gt; ans, ArrayList&lt;String&gt; path, String s, boolean[][] map, int pos) {
    int len = s.length();
    if (pos == len) {
        ans.add(new ArrayList&lt;String&gt;(path));
        return;
    }
    for (int i = pos; i &lt; len; i++) {
        if (!map[pos][i]) {
            continue;
        }
        path.add(s.substring(pos, i + 1));
        helper(ans, path, s, map, i + 1);
        path.remove(path.size() - 1);
    }
}

private boolean[][] palinMap(String s) {
    int len = s.length();
    boolean[][] map = new boolean[len][len];
    for (int i = len - 1; i &gt;= 0; i--) {
        for (int j = 0; j &lt; len; j++) {
            if (i &gt; j) {
                continue;
            } else if (i == j) {
                map[i][j] = true;
            } else if (j - i == 1) {
                map[i][j] = s.charAt(i) == s.charAt(j);
            } else {
                map[i][j] = map[i + 1][j - 1] &amp; 
                        s.charAt(i) == s.charAt(j);
            }
        }
    }
    return map;
}
</code></pre>

<p><strong>Palindrome Partitioning II</strong></p>

<p>This is DP, not Graph &amp; Search.</p>

<p><strong>Combination Sum</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (candidates == null || candidates.length == 0) {
        return ans;
    }
    Arrays.sort(candidates);
    helper(ans, new ArrayList&lt;Integer&gt;(), candidates, target, 0);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans, ArrayList&lt;Integer&gt; path, 
        int[] candidates, int target, int pos) {
    if (target == 0) {
        ans.add(new ArrayList&lt;Integer&gt;(path));
        return;
    } else if (target &lt; 0) {
        return;
    }
    for (int i = pos; i &lt; candidates.length; i++) {
        if (target &lt; candidates[i]) {
            continue;
        }
        path.add(candidates[i]);
        helper(ans, path, candidates, target - candidates[i], i);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Combination Sum II</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (candidates == null || candidates.length == 0) {
        return ans;
    }
    Arrays.sort(candidates);
    helper(ans, new ArrayList&lt;Integer&gt;(), candidates, target, 0);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans, ArrayList&lt;Integer&gt; path, 
        int[] candidates, int target, int pos) {
    if (target == 0) {
        ans.add(new ArrayList&lt;Integer&gt;(path));
        return;
    } else if (target &lt; 0) {
        return;
    }
    for (int i = pos; i &lt; candidates.length; i++) {
        if (target &lt; candidates[i]) {
            continue;
        }
        if (i &gt; pos &amp;&amp; candidates[i - 1] == candidates[i]) {
            continue;
        }
        path.add(candidates[i]);
        helper(ans, path, candidates, target - candidates[i], i + 1);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Word Ladder</strong></p>

<p>Note that this is a <strong>BFS question, not DFS</strong>. I made it wrong and it took me a long time.</p>

<pre><code>public int ladderLength(String start, String end, Set&lt;String&gt; dict) {
    Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();
    queue.add(start);
    int length = 1;

    while (!queue.isEmpty()) {
        int currentSize = queue.size();
        for (int k = 0; k &lt; currentSize; k++) {
            String word = queue.remove();
            // insert all adjacent strings of word
            if (word.equals(end)) {
                return length;
            }
            for (int i = 0; i &lt; word.length(); i++) {
                char[] letters = word.toCharArray();
                char originalLetter = letters[i];
                for (char c = 'a'; c &lt;= 'z'; c++) {
                    if (c == originalLetter) continue;
                    letters[i] = c;
                    String newLetters = String.valueOf(letters);
                    if (dict.contains(newLetters)) {
                        queue.add(newLetters);
                        dict.remove(newLetters);
                    }
                }
                letters[i] = originalLetter;
            }
        }
        length++;
    }
    return 0;
}
</code></pre>

<p><strong>Word Ladder II</strong></p>

<p>unsolvable</p>

<h3>Additional questions</h3>

<p><strong>Restore IP Addresses</strong></p>

<pre><code>public List&lt;String&gt; restoreIpAddresses(String s) {
    List&lt;String&gt; ans = new ArrayList&lt;String&gt;();
    if (s == null || s.length() == 0) {
        return ans;
    }
    helper(ans, new ArrayList&lt;String&gt;(), s, 0);
    return ans;
}

private void helper(List&lt;String&gt; ans, List&lt;String&gt; path, String s, int pos) {
    if (path.size() == 4) {
        if (pos == s.length()) {
            ans.add(convert(path));
        }
        return;
    }
    for (int i = pos + 1; i &lt;= s.length() &amp;&amp; i &lt;= pos + 3; i++) {
        String nextNum = s.substring(pos, i);
        if (!isValid(nextNum)) {
            continue;
        }
        path.add(nextNum);
        helper(ans, path, s, i);
        path.remove(path.size() - 1);
    }
}

private boolean isValid(String str) {
    if (str.length() == 1) {
        return true;
    } else if (str.charAt(0) == '0') {
        return false;
    } else {
        int num = Integer.parseInt(str);
        return 0 &lt;= num &amp;&amp; num &lt;= 255;
    }
}

private String convert(List&lt;String&gt; path) {
    String str = "";
    for (String s: path) {
        str += "." + s;
    }
    return str.substring(1);
}
</code></pre>

<p><strong>Combinations</strong></p>

<p>skip</p>

<p><strong>Letter Combinations of a Phone Number</strong></p>

<p>skip</p>

<p><strong>Permutation Sequence</strong></p>

<pre><code>public String getPermutation(int n, int k) {
    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
    int fact = 1;
    for (int i = 1; i &lt;= n; i++) {
        list.add(i);
        fact *= i;
    }
    String ans = "";
    for (int i = n; i &gt; 0; i--) {
        fact = fact / i;
        int rank = (k - 1) / fact;
        k = (k - 1) % fact + 1;

        int curNum = list.remove(rank);
        ans += String.valueOf(curNum);
    }
    return ans;
}
</code></pre>

<h2>Conclusion</h2>

<h4>DFS (O(2<sup>n</sup>), O(n!))</h4>

<ol>
<li>Find all possible solutions</li>
<li>Permutations / Subsets</li>
</ol>


<h4>BFS (O(m), O(n))</h4>

<ol>
<li>Graph traversal</li>
<li>Find shortest path in a simple graph</li>
</ol>


<p><strong>Two most canonical BFS questions</strong>:</p>

<ol>
<li>Graph traversal and toposort</li>
<li>Word Ladder</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[NineChap 5.1] Dynamic Programming]]></title>
    <link href="http://okckd.github.io/blog/2014/06/24/NineChap-Dynamic-Programming/"/>
    <updated>2014-06-24T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/06/24/NineChap-Dynamic-Programming</id>
    <content type="html"><![CDATA[<h2>Dynamic Programming</h2>

<p>The fundamental of DP is &lsquo;merorized search&rsquo;. It&rsquo;s easy to implement but bad for memory. And it&rsquo;s generally useless in the industry.</p>

<h3>When to use DP?</h3>

<ol>
<li>Input cannot sort</li>
<li>Find minimum/maximum result</li>
<li>Check the feasibility</li>
<li>Count all possible solutions</li>
</ol>


<p>If question asks you to find all possible solutions, it&rsquo;s gonna be DFS, not DP.</p>

<h3>5 Types of DP</h3>

<ol>
<li>Matrix DP (10%)</li>
<li>Sequence/Two Sequences DP (80%)</li>
<li>Interval DP (5%)</li>
<li>Tree DP (5%)</li>
<li>States Compressing DP (0%)</li>
</ol>


<p>Type 3 to 5 are less important.</p>

<h3>Question List</h3>

<p><strong>Type 1: Matrix DP</strong></p>

<ol>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-27-Triangle%20%}">Triangle</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-20-Unique-Paths%20%}">Unique Paths </a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-20-Unique-Paths-II%20%}">Unique Paths II  </a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-20-Minimum-Path-Sum%20%}">Minimum Path Sum </a></strong></p></li>
</ol>


<p><strong>Type 2.1: Sequence Dp</strong></p>

<ol>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-21-Climbing-Stairs%20%}">Climbing Stairs </a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-16-Jump-Game%20%}">Jump Game </a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-14-Jump-Game-II%20%}">Jump Game II</a></strong> &ndash; tricky, index handling</p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-30-Palindrome-Partitioning-II%20%}">Palindrome Partitioning II </a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-06-02-Word-Break%20%}">Word Break </a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-06-02-Word-Break-II%20%}">Word Break II</a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-23-Decode-Ways%20%}">Decode Ways </a></strong> &ndash; tricky, initial state</p></li>
<li><p><strong><a href="{%%20post_url%20/lintcode/2014-06-24-Longest-Increasing-Subsequence%20%}">Longest Increasing Subsequence</a></strong></p></li>
</ol>


<p><strong>Type 2.2: Two Sequences Dp</strong></p>

<ol>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-27-Distinct-Subsequences%20%}">Distinct Subsequences </a></strong> &ndash; difficult, state transition formula</p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-21-Edit-Distance%20%}">Edit Distance </a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-24-Interleaving-String%20%}">Interleaving String </a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/lintcode/2014-06-24-Longest-Common-Subsequence%20%}">Longest Common Subsequence</a></strong></p></li>
</ol>


<p><strong>Type 3: Interval Dp</strong></p>

<p><a href="http://wikioi.com/problem/1048/">Merge Stone</a></p>

<p><strong>Type 4: Tree Dp</strong></p>

<ol>
<li><strong><a href="{%%20post_url%20/leetcode/2014-05-28-Binary-Tree-Maximum-Path-Sum%20%}">Binary Tree Maximum Path Sum</a></strong></li>
</ol>


<p><strong>Type 5: States Compressing DP</strong></p>

<p>Ignore.</p>

<p>Additional questions</p>

<ol>
<li><p><strong><a href="{%%20post_url%20/leetcode/2014-05-20-Maximum-Subarray%20%}">Maximum Subarray </a></strong></p></li>
<li><p><strong><a href="{%%20post_url%20/question/2014-06-30-Coin-Changing-Problem%20%}">Coin Change Problem</a></strong></p></li>
</ol>


<h2>Code</h2>

<h4>Type 1: Matrix DP</h4>

<p><strong>Triangle</strong></p>

<pre><code>public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) {
    if (triangle == null || triangle.size() == 0) {
        return 0;
    }
    int len = triangle.size();
    int[][] dp = new int[len][len];
    for (int i = len - 1; i &gt;= 0; i--) {
        // bottom-up approach (row by row)
        for (int j = 0; j &lt;= i; j++) {
            if (i == len - 1) {
                dp[i][j] = triangle.get(i).get(j);
            } else {
                dp[i][j] = triangle.get(i).get(j)
                        + Math.min(dp[i+1][j], dp[i+1][j+1]);
            }
        }
    }
    return dp[0][0];
}
</code></pre>

<p><strong>Unique Paths</strong></p>

<pre><code>public int uniquePaths(int m, int n) {
    if (m == 0 &amp;&amp; n == 0) {
        return 0;
    }
    int[][] dp = new int[m][n];
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (i == 0 || j == 0) {
                dp[i][j] = 1;
            } else {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
    }
    return dp[m-1][n-1];
}
</code></pre>

<p><strong>Unique Paths II</strong></p>

<pre><code>public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    if (obstacleGrid == null) {
        return 0;
    }
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;
    int[][] dp = new int[m][n];
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (obstacleGrid[i][j] != 0) {
                dp[i][j] = 0;
            } else if (i == 0 &amp;&amp; j == 0) {
                dp[i][j] = 1;
            } else if (i == 0) {
                dp[i][j] = dp[i][j-1];
            } else if (j == 0) {
                dp[i][j] = dp[i-1][j];
            } else {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
    }
    return dp[m-1][n-1];
}
</code></pre>

<p><strong>Minimum Path Sum</strong></p>

<pre><code>public int minPathSum(int[][] grid) {
    if (grid == null) {
        return 0;
    }
    int m = grid.length;
    int n = grid[0].length;
    int[][] dp = new int[m][n];
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (i == 0 &amp;&amp; j == 0) {
                dp[i][j] = grid[i][j];
            } else if (i == 0) {
                dp[i][j] = dp[i][j-1] + grid[i][j];
            } else if (j == 0) {
                dp[i][j] = dp[i-1][j] + grid[i][j];
            } else {
                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[m-1][n-1];
}
</code></pre>

<h4>Type 2.1: Sequence Dp</h4>

<p><strong>Climbing Stairs</strong></p>

<pre><code>public int climbStairs(int n) {
    if (n &lt;= 2) {
        return n;
    }
    int[] dp = new int[n];
    dp[0] = 1;
    dp[1] = 2;
    for (int i = 2; i &lt; n; i++) {
        dp[i] = dp[i - 2] + dp[i - 1];
    }
    return dp[n - 1];
}
</code></pre>

<p><strong>Jump Game</strong></p>

<pre><code>public boolean canJump(int[] A) {
    if (A == null || A.length == 0) 
        return false;
    int reach = 0;
    int len = A.length;
    for (int i = 0; i &lt; len; i++) {
        if (i &gt; reach) 
            break;
        reach = Math.max(reach, i + A[i]);
        if (reach &gt;= len - 1)   
            return true;
    }
    return false;
}
</code></pre>

<p><strong>Jump Game II</strong></p>

<pre><code>public int jump(int[] A) {
    if (A == null || A.length &lt;= 1) 
        return 0;
    int[] dp = new int[A.length];
    int cur = 1;
    for (int i = 0; i &lt; A.length - 1; i++) {
        while (cur &lt;= i + A[i] &amp;&amp; cur &lt; dp.length) {
            dp[cur] = dp[i] + 1;
            cur++;
        }
        if (cur == dp.length) {
            break;
        }
    }
    return dp[A.length - 1];
}
</code></pre>

<p><strong>Palindrome Partitioning II</strong></p>

<pre><code>public int minCut(String s) {
    if (s == null || s.length() &lt;= 1) {
        return 0;
    }
    boolean[][] map = palindromeMap(s);
    int len = s.length();
    int[] dp = new int[len + 1];
    dp[0] = -1;
    for (int i = 1; i &lt;= len; i++) {
        dp[i] = Integer.MAX_VALUE;
        for (int j = 1; j &lt;= i; j++) {
            if (map[i-1][j-1]) {
                dp[i] = Math.min(dp[i], dp[j-1] + 1);
            }
        }
    }
    return dp[len];
}

private boolean[][] palindromeMap(String s) {
    int len = s.length();
    boolean[][] map = new boolean[len][len];
    char[] ss = s.toCharArray();
    for (int i = 0; i &lt; len; i++) {
        for (int j = i; j &gt;= 0; j--) {
            if (i == j) {
                map[i][j] = true;
            } else if (i - j == 1) {
                map[i][j] = ss[i] == ss[j];
            } else {
                map[i][j] = (ss[i] == ss[j]) &amp; map[i - 1][j + 1];
            }
        }
    }
    return map;
}
</code></pre>

<p><strong>Word Break</strong></p>

<pre><code>public boolean wordBreak(String s, Set&lt;String&gt; dict) {
    if (s == null || s.length() == 0) {
        return true;
    }
    int len = s.length();
    boolean[] dp = new boolean[len + 1];
    dp[0] = true;
    for (int i = 1; i &lt;= len; i++) {
        for (int j = 0; j &lt; i; j++) {
            if (!dp[j]) {
                continue;
            }
            if (dict.contains(s.substring(j, i))) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[len];
}
</code></pre>

<p><strong>Word Break II</strong></p>

<p>My code is definitely correct, although it got TLE.</p>

<p>See original post for more.</p>

<p><strong>Decode Ways</strong></p>

<pre><code>public int numDecodings(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    int len = s.length();
    int[] dp = new int[len + 1];
    dp[0] = 1;
    dp[1] = 1; // pay attention to the initial state
    if (!isValidNumber(s.substring(0, 1))) {
        return 0;
    }
    for (int i = 2; i &lt;= len; i++) {
        if (isValidNumber(s.substring(i - 1, i))) {
            dp[i] += dp[i - 1];
        }
        if (isValidNumber(s.substring(i - 2, i))) {
            dp[i] += dp[i - 2];
        }
    }
    return dp[len];
}

private boolean isValidNumber(String input) {
    if (input.length() == 0 || input.length() &gt; 2 || input.charAt(0) == '0') {
        return false;
    }
    int num = Integer.parseInt(input);
    return (1 &lt;= num &amp;&amp; num &lt;= 26);
}
</code></pre>

<p><strong>Longest Increasing Subsequence</strong></p>

<p>There&rsquo;s a new post in &lsquo;Lintcode&rsquo; category.</p>

<h4>Type 2.2: Two Sequences Dp</h4>

<p><strong>Distinct Subsequences</strong></p>

<pre><code>public int numDistinct(String S, String T) {
    int m = S.length(), n = T.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 0; i &lt;= m; i++) {
        for (int j = 0; j &lt;= n; j++) {
            if (j == 0) {
                dp[i][j] = 1;
            } else if (i == 0) {
                dp[i][j] = 0;
            } else {
                dp[i][j] = dp[i - 1][j];
                if (S.charAt(i - 1) == T.charAt(j - 1)) {
                    dp[i][j] += dp[i - 1][j - 1];
                }
            }
        }
    }
    return dp[m][n];
}
</code></pre>

<p><strong>Edit Distance</strong></p>

<pre><code>public int minDistance(String A, String B) {
    if (A == null || B == null)
        return 0;
    int m = A.length(), n = B.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 0; i &lt;= m; i++) {
        for (int j = 0; j &lt;= n; j++) {
            if (i == 0) {
                dp[i][j] = j;
            } else if (j == 0) {
                dp[i][j] = i;
            } else {
                if (A.charAt(i - 1) == B.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j]);
                    dp[i][j] = Math.min(dp[i][j], dp[i][j - 1]);
                    dp[i][j]++;
                }
            }
        }
    }
    return dp[m][n];
}
</code></pre>

<p><strong>Interleaving String</strong></p>

<pre><code>public boolean isInterleave(String s1, String s2, String s3) {
    if (s1 == null || s2 == null) {
        return false;
    }
    int m = s1.length(), n = s2.length();
    if (m + n != s3.length()) {
        return false;
    }
    boolean[][] dp = new boolean[m + 1][n + 1];
    for (int i = 0; i &lt;= m; i++) {
        for (int j = 0; j &lt;= n; j++) {
            if (i == 0) {
                dp[i][j] = s2.substring(0, j).equals(s3.substring(0, j));
                continue;
            } else if (j == 0) {
                dp[i][j] = s1.substring(0, i).equals(s3.substring(0, i));
                continue;
            }
            if (i &gt; 0 &amp;&amp; dp[i - 1][j]
                    &amp;&amp; s1.charAt(i - 1) == s3.charAt(i + j - 1)) {
                dp[i][j] = true;
            }
            if (j &gt; 0 &amp;&amp; dp[i][j - 1]
                    &amp;&amp; s2.charAt(j - 1) == s3.charAt(i + j - 1)) {
                dp[i][j] = true;
            }
        }
    }
    return dp[m][n];
}
</code></pre>

<p><strong>Longest Common Subsequence</strong></p>

<p>There&rsquo;s a new post in &lsquo;Lintcode&rsquo; category.</p>

<h3>Type 3: Interval Dp</h3>

<p><strong>Merge Stone</strong></p>

<blockquote><p>有n堆石子排成一列，每堆石子有一个重量w[i], 每次合并可以合并相邻的两堆石子，一次合并的代价为两堆石子的重量和w[i]+w[i+1]。问安排怎样的合并顺序，能够使得总合并代价达到最小。</p></blockquote>

<p><a href="http://wikioi.com/problem/1048/">link</a></p>

<p>Solution explained:</p>

<blockquote><p>sum[i[用于记录从第1堆到第i堆（包含i）石子的总重量。</p>

<p>dp[i][j]表示从第i堆（包含i）到第j堆（包含j）石子的合并的最小代价。</p>

<p>状态转移方程为：dp[i][j] = minimize{dp[i][k] + dp[k+1][j] + sum[j] &ndash; sum[i-1]}, k从i到j（不包含j）。</p>

<p>len=2表示第一次合并的情况，此时合并的石子为2堆。此时，i从1到n-len+1，j=i+len-1。</p></blockquote>

<p>Quoted from <a href="http://blog.csdn.net/kingzone_2008/article/details/12361327">this blog</a> and the solution is well explained on <a href="http://wikioi.com/solution/list/1048/">wikiio</a>.</p>

<h3>Type 4: Tree Dp</h3>

<p><strong>Binary Tree Maximum Path Sum</strong></p>

<p>This is a difficult question, but I solved it. I feel happy.</p>

<pre><code>private class ResultType {
    int maxPath;
    int depth;

    ResultType(int a, int b) {
        this.maxPath = a;
        this.depth = b;
    }
}

public int maxPathSum(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return helper(root).maxPath;
}

private ResultType helper(TreeNode node) {
    if (node == null) {
        return new ResultType(Integer.MIN_VALUE, 0);
    }
    ResultType ll = helper(node.left);
    ResultType rr = helper(node.right);
    int maxPath = node.val + ll.depth + rr.depth;
    maxPath = Math.max(maxPath, ll.maxPath);
    maxPath = Math.max(maxPath, rr.maxPath);
    int depth = 0;
    depth = Math.max(depth, node.val + Math.max(ll.depth, rr.depth));
    return new ResultType(maxPath, depth);
}
</code></pre>

<h3>Additional questions</h3>

<p><strong>Maximum Subarray</strong></p>

<pre><code>public int maxSubArray(int[] A) {
    if (A == null || A.length == 0) {
        return 0;
    }
    int len = A.length;
    int[] dp = new int[len];
    dp[0] = A[0];
    for (int i = 1; i &lt; len; i++) {
        dp[i] = A[i];
        if (dp[i - 1] &gt; 0)
            dp[i] += dp[i - 1];
    }
    int max = Integer.MIN_VALUE;
    for (Integer i : dp)
        max = Math.max(max, i);
    return max;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
