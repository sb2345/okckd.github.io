<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ninechap | Shuatiblog.com]]></title>
  <link href="http://www.shuatiblog.com/blog/categories/ninechap/atom.xml" rel="self"/>
  <link href="http://www.shuatiblog.com/"/>
  <updated>2015-08-26T15:18:33+08:00</updated>
  <id>http://www.shuatiblog.com/</id>
  <author>
    <name><![CDATA[CodeMonkey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[NineChap Sys] System Design Class 1 ]]></title>
    <link href="http://www.shuatiblog.com/blog/2015/08/23/SysDesign-class-1/"/>
    <updated>2015-08-23T00:00:00+08:00</updated>
    <id>http://www.shuatiblog.com/blog/2015/08/23/SysDesign-class-1</id>
    <content type="html"><![CDATA[# System Design

## defination 

the process of defining the __architecture, components, modules, interfaces and data__ to satisfy specified __requirements__. 

1. conceptual design (macro)
2. logical design
3. physical design (micro)

### Top-down design

Eg. MS Office, Huawei Security System

### Bottom-up design

Most start-up use, MVP first using Medetor + MongoDb. 

## 5 steps (SNAKE Principle):

1. __Scenario__: case/interface - input
1. __Necessary__: constrain/hypothesis - input
1. __Application__: service/algorithm - output
1. __Kilobit__: data - output
1. __Evolve__ - solution

# A top-down example

Example one: __design a radio__

## Step One, Scenario

1. brain storm

    1. register/log in
    1. play music
    1. recommendation

1. prioritize

    1. play music
        1. Get channel
        1. select a channel
        1. play

## Step Two, Necessary

1. ask

    1. total user - 100,000,000
    1. __daily users - 1,000,000__

1. predict

    1. user analysis
    1. Traffic analysis
    1. Memory analysis
    1. QPS

Details:

1. user analysis

    > Avg Concurrent users = daily users __/ 5__ = 200,000
    >
    > Peak Concurrent users = concurrent user __\* 3__ = 600,000

    considering your product may grow in the next 3 month:
    
    > Max Peak users in 3 month = Peak users __\* 10__ = 6,000,000

1. Traffic analysis

	> Request of new music per user: 1 music/min
	>
	> Music size = 3MB
	>
	> Max peak traffic (in 3 months) = 6,000,000 \* 3MB / 60 = 300GB/s

1. Memory analysis

	> Memory per user (metadata) = 10KB
	>
	> Max daily memory = 1,000,000 \* 10 \* 10 = 100 million KB = 100GB
    >
    > (10 times of avg daily user)

## Step Three, Application

1. Replay the case, one service for each
1. Merge the services

{% img middle /assets/images/design-class1-basic-receptionist.png %}

## Step Four, Kilobit: data

1. Append 1 dataset for each service

    Eg. User service: stability, more addition, less modify and deletion.

    Eg. Channel Service: high concurrency, MongoDB

    Eg. Music Service: MP3 File Systems

{% img middle /assets/images/design-class1-reco-5.png %}

## Last Step, Evolve

1. Better: constrains 

    eg. able to handle 300GB/s traffic?

1. Broader: new cases

    share music? delete user account?

1. Deeper: details design

From views of __Performance, Scalability and Robustness__.

{% img middle /assets/images/design-class1-snake.jpg %}

# A bottom-up example

Example two: __design a recommendation module__

## A simple algo: 

    u1={m3,m5,m7,m11}
    u2={m1,m2,m3,m4,m5,m6,m7,m8,m9}
    Similarity( u1, u2 ) = 3
    
m - music

u - user

Similarity = # of same music for different users

## Adv algo: 

find his __top-1 similar user__. Stay tuned for future posts. 

## Use the 5 Steps (SNAKE)

1. Step One, Scenario
1. Step Two, Necessary
1. Step Three, Application
1. Step Four, Kilobit: data
1. Last Step, Evolve

Because this question is relatively easy, we will not do case-analysis (Macro). 

__Instead, we do micro design__ by starting at the interface. 

## Step One, Scenario

Interface 

    class Recommender {
        public int findSimilarUser(int userId) {
            //
        }
    }

## Step Two, Necessary

1. ask
    1. total users = 100,000,000
    1. total music = 10,000,000
    1. peak users in 3 month = 6,000,000
    
    However, not everyone is logged in. Thus we won't need to recommend for everybody. On average, the logged-in ratio is 1% - 30%. Let's assume 5%. 
    
    1. participation percentage = 5%
    
    And user's interest won't change every minute. Let's recalculate only after 10 minutes.
    
    1. calculation frequency = 1 update/10min/user

1. predict

    1. user analysis (skip)
    1. Traffic analysis (skip)
    1. Memory analysis (skip)
    1. QPS
    
    Peak QPS = 6,000,000 \* 5% / (10 \* 60) = 500/s

## Step Three, Application

__The simpliest algorithm: BF compare__. The complexity is O(m n) for each user, where m is # of music a person likes, and n is # of total users. For k users, it takes O(k m n) time (k can be = peak concurrent users). 

This is roughly 0.2s per user. Thus __Max QPS = 5__. 

> One word about complexity-to-seconds estimation. 
>
> O(n ^ 3) -> 1s
>
> O(n ^ 2) -> 0.2s
>
> O(n) -> 20ms
>
> O(k) -> k ms

## Step Four, Kilobit: data

Very simple:

{% img middle /assets/images/design-class1-reco-1.png %}

## Last Step, Evolve

Read on. 

# How to go from Level 0 to Level 1

Refer to the previous question. How can we improve???

1. performance
1. scalability
1. robustness

## performance

A better algo: Inverted Index

{% img middle /assets/images/design-class1-reco-2.png %}

Avg performance increase to ~ 20ns (with some optimization of MapReduce procedure, discuss later). 

__Max QPS increase to 50__. 

## scalability

Use a __dispatcher__ to re-direct the requests to multiple machines. 

{% img middle /assets/images/design-class1-reco-3.png %}

### How many machines do we need then? 

Well we need 500 QPS. The algo above achieves ~ 50 QPS. __Should we need 10 machines__?

The answer is NO. A machine with 8 (or 16) core CPU could be able to handle. 

We can also have a __hot-standby__, to be safe. 

> hot standby is used as a failover mechanism to provide reliability in system configurations. 
>
> When a key component fails, the hot spare is switched into operation. 

## robustness

Tips about system design for senior engineers: 

> __Draw 1 machine first__. This machine can contains multiple datasets and run multiple processes. 
>
> On top of this machine, the interface layer is __one single Manager process__. The Manager is in charge of almost everything: handling data lost, handle high concurrency, copy multiple instance of itself... 
>
> Like this: 

{% img middle /assets/images/design-class1-reco-6.png %}

### Back-end

Now we need __a cluster of datasets__ (which has Manager on top of it), and __a cluster of Recommenders__. Manager is in charge of copying multiple instances. 

Dataset can be put in different physical locations. Recommender don't really need, cuz it's only do calculation job. 

### Receiving requests

Just now we used __Receptionist (or Dispatcher)__ to handle request. Now we use a __Web service__ (eg. Apache). It's not necessary to make it a cluster. 

### Big Brother

We need a __monitor system__ to oversee everything. 

Also, Big Brother is in charge of heart-beat. If not received, Big Brother have some double-check machanism. 

{% img middle /assets/images/design-class1-reco-4.png %}

### Connecting the dots

__Dispatcher__ is used to connect the 4 components. It's like a messaging queue that collects and distributes jobs among everybody (eg. control and distributed info). 

It can be stateful or stateless. 

Keep in mind __the connection between Dataset and Recommender__ remains. It's slow going thru Dispatcher. 

### Distribute it

During development, the 5 components can be put on same machine. When we deploy distributely, we use __Socket connection (keep alive)__ to connect them. 

Notice the Web Service is __connection heavy__, which consume large CPU and RAM resource. It's better to seperate to one machine. 

Big brother is read/write heavy, so it's OKAY to put on same machine with Dispatcher. 

Since Dataset and Recommender have data exchange, it's a good idea to put on same machine. 

### Additional questions

Implement Dispatcher with __consumer-producer__ model. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[NineChap 10] Additional Questions]]></title>
    <link href="http://www.shuatiblog.com/blog/2014/07/07/NineChap-additional/"/>
    <updated>2014-07-07T00:00:00+08:00</updated>
    <id>http://www.shuatiblog.com/blog/2014/07/07/NineChap-additional</id>
    <content type="html"><![CDATA[The following questions does not appear in NineChap, but they all worth reading. 

### Question List 

1. __[Longest Substring Without Repeating Characters ]({% post_url /leetcode/2014-04-27-longest-substring-without-repeating %})__

1. __[Minimum Window Substring ]({% post_url /leetcode/2014-05-21-Minimum-Window-Substring %})__ - very difficult

1. __[Scramble String ]({% post_url /leetcode/2014-05-23-Scramble-String %})__

1. __[Recover Binary Search Tree ]({% post_url /leetcode/2014-05-25-Recover-Binary-Search-Tree %})__

1. __[Median of Two Sorted Arrays ]({% post_url /leetcode/2014-04-26-Median-of-Two-Sorted-Arrays %})__ - difficult

1. __[Sudoku Solver ]({% post_url /leetcode/2014-05-14-Sudoku-Solver %})__ - difficult

1. __[Word Search ]({% post_url /leetcode/2014-05-21-Word-Search %})__

1. __[Simplify Path]({% post_url /leetcode/2014-05-21-Simplify-Path %})__

1. __[Regular Expression Matching]({% post_url /leetcode/2014-04-29-Regular-Expression-Matching %})__ - very difficult

1. __[Wildcard Matching]({% post_url /leetcode/2014-05-15-Wildcard-Matching %})__ - difficult
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[NineChap 9] Big Date, System Design and Resume (`)]]></title>
    <link href="http://www.shuatiblog.com/blog/2014/06/30/NineChap-Big-date-system-design-resume/"/>
    <updated>2014-06-30T00:00:00+08:00</updated>
    <id>http://www.shuatiblog.com/blog/2014/06/30/NineChap-Big-date-system-design-resume</id>
    <content type="html"><![CDATA[## Resume

1. Do not write anything unrelated to CS. 
1. Do not write too long - 1 or 2 pages are fine. Senior engineer 3 pages. 
1. Do not write low GPA
1. Never ever write "proficient in anything"

## Big Data

Most classic question is "Frequent items" (refer to July's blog). 

### Find top k hot queries in a daily access log of Google. 

Variation:

1. k = 1 vs k = 100000 - majority numbers
1. low RAM vs sufficient RAM
1. single machine vs multiple machines
1. accurate vs inaccurate

Sufficient RAM

1. HashTable + Heap (min-heap)
1. Time O(n * logk), Space O(n)

Low RAM

1. Split into 1000 (i.e. LOG/M) files by hash(query) % 1000
1. Using HashTable + Heap to get top k for each files
1. Collect 1000 top k queries and get global top k
1. This method requires a lot of disk access and r/w, still slow. 

Inaccurate (reduce memory from O(n) to O(k))

1. Hash Count (only need to know this one)
    Limit the size of HashMap. The bigger the RAM, the more accurate is the result. 
1. Space Saving
1. Lossy Counting
1. Sticky Sampling
1. Count Sketch

Bloom Filter

1. Regular bloom filter - use 4 线性无关 formula
1. Counting bloom filter - support delete
1. Better DS than HashMap, but can loose some accuracy

Trie

Bitmap

Find all unique queries - use bigmap to store 3 types of states

## System Design

### Design a short url system

1. Cache 

> to store hot urls

1. Load Balance 

> Too many click in short time

1. Storage balance

> Hash value of an url and then store in 
individual machine
>
> Expansibility?

1. Consistent Hash

> Node, can increase # of machines to store information

> Migration process

1. Router

> check which machine response my query
>
> light-weight calculations
>
> what is router is down?

1. Locale

> url frequently access by China, then put the url storage in Beijing

### Need-to-know Design patterns

1. Singleton
1. Factory
1. Master-slave (esp. for relational DB)

[MapReduce: Simplified Data Processing on Large Clusters](http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf)

[The Google File System](http://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf)

[BigTable: A Distributed Storage System for Structured Data](http://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf)
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[NineChap 8] High Frequency Questions]]></title>
    <link href="http://www.shuatiblog.com/blog/2014/06/28/NineChap-High-frequency/"/>
    <updated>2014-06-28T00:00:00+08:00</updated>
    <id>http://www.shuatiblog.com/blog/2014/06/28/NineChap-High-frequency</id>
    <content type="html"><![CDATA[## Number & Bit questions

1. __[Single Number]({% post_url /leetcode/2014-06-01-Single-Number %})__
1. __[Single Number II]({% post_url /leetcode/2014-06-01-Single-Number-II %})__
1. __[Single Number III]({% post_url /question/2014-06-28-Single-Number-III %})__
1. __[Single Number IV]({% post_url /question/2014-06-28-Single-Number-IV %})__
1. __[Majority Number]({% post_url /lintcode/2014-06-28-Majority-Number %})__
1. __[Majority Number II]({% post_url /lintcode/2014-06-28-Majority-Number-II %})__
1. __[Majority Number III]({% post_url /lintcode/2014-06-28-Majority-Number-III %})__

## Subarray questions

Always using the idea of 前缀和. 

1. __[Best Time to Buy and Sell Stock]({% post_url /leetcode/2014-05-28-Best-Time-to-Buy-and-Sell-Stock %})__ - 贪心法
1. __[Best Time to Buy and Sell Stock II]({% post_url /leetcode/2014-05-28-Best-Time-to-Buy-and-Sell-Stock-II %})__
1. __[Best Time to Buy and Sell Stock III]({% post_url /leetcode/2014-05-28-Best-Time-to-Buy-and-Sell-Stock-III %})__
1. __[Maximum Subarray]({% post_url /leetcode/2014-05-20-Maximum-Subarray %})__
1. __[Minimum Subarray ]({% post_url /lintcode/2014-06-28-Minimum-subarray %})__
1. __[Maximum Subarray II]({% post_url /lintcode/2014-06-28-Maximum-subarray-II %})__
1. __[Subarray with 0 Sum]({% post_url /question/2014-07-04-Subarray-with-0-Sum %})__
1. __[Subarray with Particular Sum]({% post_url /question/2014-07-04-Subarray-with-Particular-Sum %})__
1. __[Subarray with Sum Closest]({% post_url /question/2014-07-04-Subarray-with-Sum-Closest %})__

## N Sum questions

1. __[Two Sum]({% post_url /leetcode/2014-04-26-two-sum %})__ - difficult
1. __[3 Sum]({% post_url /leetcode/2014-05-02-3Sum %})__
1. __[3 Sum Closest]({% post_url /leetcode/2014-05-02-3Sum-Closest %})__
1. __[4 Sum]({% post_url /leetcode/2014-05-03-4Sum %})__ - doing a O(n^3) solution is good enough.
1. __k sum questions__ are basically solved with O(n^(k-1)) time. Faster solution is available but too complex. 

## L 家最爱

1. __[Pow(x,n)]({% post_url /leetcode/2014-05-15-PowXN %})__
1. __[Sqrt(x)]({% post_url /leetcode/2014-05-21-SqrtX %})__
1. __[Trailing Zeros of Factorial]({% post_url /lintcode/2014-07-02-Trailing-Zero-of-Factorial %})__
1. __[Check Power of 2]({% post_url /question/2014-07-04-Check-Power-of-2 %})__

## Additional questions

1. __[Partition Array]({% post_url /lintcode/2014-06-28-Partition-array %})__
1. __[Sort Color]({% post_url /leetcode/2014-05-21-Sort-Colors %})__

## Code

#### Number questions

__Single Number__

    public int singleNumber(int[] A) {
        int x = 0;
        for (Integer a: A) {
            x = x ^ a;
        }
        return x;
    }

__Single Number II__

Last time, I used an array of size 32 to store count, but it's actually not necessary. 

    public int singleNumber(int[] A) {
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            int count = 0;
            for (Integer a: A) {
                count += ((a >> i) & 1);
            }
            ans |= (count % 3) << i;
        }
        return ans;
    }

#### Subarray questions

__Best Time to Buy and Sell Stock__

    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int min = prices[0];
        int profit = 0;
        for (Integer p: prices) {
            min = Math.min(min, p);
            profit = Math.max(profit, p - min);
        }
        return profit;
    }

__Best Time to Buy and Sell Stock II__

    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int pre = prices[0];
        int profit = 0;
        for (Integer p: prices) {
            if (p > pre) {
                profit += p - pre;
            }
            pre = p;
        }
        return profit;
    }

__Best Time to Buy and Sell Stock III__

It's important to note the 2nd last line of the code, where we consider the corner case of doing only 1 transaction. 

It's always best to list a simple test case and walk it thru before submitting the code. 

    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int len = prices.length;
        int[] dpLeft = new int[len];
        int leftMin = prices[0];
        for (int i = 1; i < len; i++) {
            dpLeft[i] = Math.max(dpLeft[i - 1], prices[i] - leftMin);
            leftMin = Math.min(leftMin, prices[i]);
        }
        int[] dpRight = new int[len];
        int rightMax = prices[len - 1];
        for (int i = len - 2; i >= 0; i--) {
            dpRight[i] = Math.max(dpRight[i + 1], rightMax - prices[i]);
            rightMax = Math.max(rightMax, prices[i]);
        }
        // now iterate the 2 DP array and find out the largest possible profit
        int profit = 0;
        for (int i = 0; i < len - 1; i++) {
            profit = Math.max(profit, dpLeft[i] + dpRight[i + 1]);
        }
        int oneTransaction = Math.max(dpLeft[len - 1], dpRight[0]);
        return Math.max(profit, oneTransaction);
    }

__Maximum Subarray__

    public int maxSubArray(int[] A) {
        if (A == null || A.length == 0) {
            return 0;
        }
        int max = Integer.MIN_VALUE;
        int pre = 0;
        // the largest sum ending at previous position in the array
        for (Integer a: A) {
            max = Math.max(max, pre + a);
            pre = Math.max(0, pre + a);
        }
        return max;
    }

#### 3Sum questions

__Two Sum__

This solution is O(nlgn) time. 

Alternatively, we can use HashMap to solve this problem with O(n) time. 

    public int[] twoSum(int[] numbers, int target) {
        // write your code here
        int[] ans = new int[2];
        if (numbers == null || numbers.length == 0) {
            return ans;
        }
        int len = numbers.length;
        Pair[] pairs = new Pair[len];
        for (int i = 0; i < len; i++) {
            pairs[i] = new Pair(numbers[i], i + 1);
        }
        Arrays.sort(pairs);
        int left = 0;
        int right = len - 1;
        while (left < right) {
            if (pairs[left].num + pairs[right].num == target) {
                ans[0] = pairs[left].index;
                ans[1] = pairs[right].index;
                Arrays.sort(ans);
                break;
            } else if (pairs[left].num + pairs[right].num > target) {
                right--;
            } else {
                left++;
            }
        }
        return ans;
    }
	
    class Pair implements Comparable<Pair> {
        int num;
        int index;
        
        public Pair(int a, int b) {
            num = a;
            index = b;
        }
        
        public int compareTo(Pair another) {
            return this.num - another.num;
        }
    }

__3 Sum__

    public ArrayList<ArrayList<Integer>> threeSum(int[] numbers) {
        ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();
        if (numbers == null || numbers.length == 0) {
            return ans;
        }
        Arrays.sort(numbers);
        int len = numbers.length;
        for (int i = 0; i < len; i++) {
            if (i > 0 && numbers[i - 1] == numbers[i]) {
                continue;
            }
            int left = i + 1;
            int right = len - 1;
            // find 2 numbers that sums to - number[i]
            while (left < right) {
                int diff = numbers[left] + numbers[right] + numbers[i];
                if (diff == 0) {
                    ArrayList<Integer> triplet = new ArrayList<Integer>();
                    triplet.add(numbers[i]);
                    triplet.add(numbers[left]);
                    triplet.add(numbers[right]);
                    ans.add(triplet);
                }
                if (diff <= 0) {
                    left++;
                    while (left < len && numbers[left - 1] == numbers[left]) {
                        left++;
                    }
                }
                if (diff >= 0) {
                    right--;
                    while (right >= 0 && numbers[right + 1] == numbers[right]) {
                        right--;
                    }
                }
            }
        }
        return ans;
    }

__3 Sum Closest__

    public int threeSumClosest(int[] numbers, int target) {
        if (numbers == null || numbers.length == 0) {
            return 0;
        }
        Arrays.sort(numbers);
        int sum = 0;
        int diff = Integer.MAX_VALUE;
        int len = numbers.length;
        for (int i = 0; i < len; i++) {
            int left = i + 1;
            int right = len - 1;
            while (left < right) {
                int triple = numbers[left] + numbers[right] + numbers[i];
                if (triple == target) {
                    return target;
                } else if (triple < target) {
                    left++;
                } else {
                    right--;
                }
                if (Math.abs(target - triple) < diff) {
                    diff = Math.abs(target - triple);
                    sum = triple;
                }
            }
        }
        return sum;
    }

__4 Sum__

    public ArrayList<ArrayList<Integer>> fourSum(int[] numbers, int target) {
        ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();
        if (numbers == null || numbers.length == 0) {
            return ans;
        }
        Arrays.sort(numbers);
        int len = numbers.length;
        for (int i = 0; i < len - 3; i++) {
            if (i > 0 && numbers[i - 1] == numbers[i]) {
                continue;
            }
            for (int j = i + 1; j < len - 2; j++) {
                if (j > i + 1 && numbers[j - 1] == numbers[j]) {
                    continue;
                }
                int left = j + 1;
                int right = len - 1;
                while (left < right) {
                    int diff = numbers[left] + numbers[right] + numbers[i] + numbers[j] - target;
                    if (diff == 0) {
                        ArrayList<Integer> triplet = new ArrayList<Integer>();
                        triplet.add(numbers[i]);
                        triplet.add(numbers[j]);
                        triplet.add(numbers[left]);
                        triplet.add(numbers[right]);
                        ans.add(triplet);
                    }
                    if (diff <= 0) {
                        left++;
                        while (left < len && numbers[left - 1] == numbers[left]) {
                            left++;
                        }
                    }
                    if (diff >= 0) {
                        right--;
                        while (right >= 0 && numbers[right + 1] == numbers[right]) {
                            right--;
                        }
                    }
                }
            }
        }
        return ans;
    }

#### L 家最爱

__Pow(x,n)__

It's important to note that in Line 16, wrting 'while (pow * 2 <= y)' would not work (because of overflow). It took me a long time to find this bug. 

    public double pow(double x, int n) {
        if (n < 0) {
            return 1.0 / helper (x, 0 - n);
        } else {
            return helper(x, n);
        }
    }
    
    private double helper(double x, int y) {
        if (y == 0) {
            return 1.0;
        }
        int pow = 1;
        double num = x;
        while (pow <= y / 2) {
            num *= num;
            pow <<= 1;
        }
        return num * helper(x, y - pow);
    }

__Sqrt(x)__

Note that in Line 8, we must declare left and right as 'long', not 'int', otherwise there will be overflow problems. It took me a long time to find this bug. 

    public int sqrt(int x) {
        if (x < 0) {
            return -1;
        } else if (x < 2) {
            return x;
        }
        long left = 1;
        long right = x;
        while (left + 1 < right) {
            long mid = left + (right - left) / 2;
            if (mid * mid < x) {
                left = mid;
            } else if (mid * mid > x) {
                right = mid;
            } else {
                return (int) mid;
            }
        }
        return (int) left;
    }

#### Additional

__Sort Color__

    public void sortColors(int[] A) {
        if (A == null || A.length == 0) {
			return;
		}
		int len = A.length;
		partition(A, 0, len - 1, 0);
		int p = 0;
		while (p < len && A[p] == 0) {
			p++;
		}
		partition(A, p, len - 1, 1);
    }
	
	private void partition(int[] A, int start, int end, int target) {
		// find the target and put it on the left side of the array
		while (start < end) {
			while (start < A.length && A[start] == target) {
				start++;
			}
			while (end >= 0 && A[end] != target) {
				end--;
			}
			if (start > end) {
				break;
			} else {
				int temp = A[start];
				A[start] = A[end];
				A[end] = temp;
			}
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[NineChap 7] Data Structure]]></title>
    <link href="http://www.shuatiblog.com/blog/2014/06/28/NineChap-Data-structure/"/>
    <updated>2014-06-28T00:00:00+08:00</updated>
    <id>http://www.shuatiblog.com/blog/2014/06/28/NineChap-Data-structure</id>
    <content type="html"><![CDATA[## Data Structure

Data structure is a way to manage data. It provides some methods to handle data stream. For example, DB is a DS.

### Stack and Queue

1. __[Min-stack]({% post_url /question/2014-07-01-Min-Stack %})__

1. __[Implement a queue by two stacks]({% post_url /question/2014-07-01-Implement-queue-with-stack %})__

1. __[Largest Rectangle in histogram]({% post_url /leetcode/2014-05-23-Largest-Rectangle-in-Histogram %})__

### Hash

#### Hash function

1. MD5
1. Magic number 33 (__PHP hash function [DJBX33A](http://events.ccc.de/congress/2011/Fahrplan/attachments/2007_28C3_Effective_DoS_on_web_application_platforms.pdf)__)

Magic Number: 

    int hashfunc(String key) {
        int sum = 0;
        for (int i = 0; i < key.length(); i++) {
            sum = sum * 33 + (int)(key.charAt(i));
            sum = sum % HASH_TABLE_SIZE;
        }
        return sum
    }
    
#### Collision

1. __Close hashing (also called Open addressing)__

    Resolves conflict by probing, or searching through alternate locations in the array
        
    Suck scheme may cause the lookup cost to skyrocket. Not good to use.

1. __Open hashing__

    Keys stored in linked lists attached to cells of the hash table.
    
    Practically, hash size set around 10 times the size of data
    
    Used by Java and most other languages. 

#### Rehashing

1. Memcached is a general-purpose distributed memory caching system. One of its bottleneck is rehashing, which locks down the entire hash.

1. Dynamic resizing (normally size * 2) and copy all elements into the new hash. 

1. Extremely slow process, we should try to avoid it by setting a large enough initial size. 

#### Hash questions:

1. __[Implement a hashmap]({% post_url /question/2014-07-01-Implement-Hashmap %})__

1. __[HashMap vs Hashtable vs HashSet]({% post_url /design/2014-07-01-Hashmap-Hashtable-Hashset %})__

1. __[LRU Cache]({% post_url /leetcode/2014-06-03-LRU-Cache %})__

1. __[Longest consecutive sequence]({% post_url /leetcode/2014-05-29-Longest-Consecutive-Sequence %})__

### Heap

1. Child is always larger than parent
1. Heap is not a sorted structure, but it's partially ordered
1. Heap is always balanced 

Heap is better than array because average of 3 operations is O(logn), but array is O(n). 

>Add O(log N)
>
>Remove O(log N)
>
>Min/Max O(1)

#### Heap implementation: 

1. Low Level: dynamic array, not list

1. Internal Method: Shiftup, Shiftdown operations

1. A heap is a complete binary tree (最优二叉树) __represented by an array__

1. When removing element from heap, we actually uses HashMap to find that element.

> Heaps are usually implemented in an array, and do not require pointers between elements.
>
> Full and almost full binary heaps may be represented in a very space-efficient way using an array alone. The first element will contain the root. The next two elements of the array contain its children. The next four contain the four children of the two child nodes, etc. 
>
> Thus the children of the node at position n would be at positions 2n+1 and 2n+2. 

So to summarize: 

1. elems[1] - root, also the minimum elem in elems.
1. elems[i]: left child is elems[i*2], right child is elems[i*2+1]

Implementation code: 

    Add:
        Push back to elems; size ++; Siftup;
    Remove:
        Replace the elem to be removed with the last elem; 
        size --; 
        Siftup and Siftdown.

#### Heap questions:

1. __[Median in a stream of integers]({% post_url /question/2014-07-01-Median-in-stream-of-integers %})__

1. __[The Skyline Problem]({% post_url /question/2014-07-01-The-Skyline-Problem %})__

### Interval Tree

Easily find the max/min value in an interval. 2 example questions are: 

1. Find min/max/sum in an interval
1. 最长的连续1

## Code

__Largest Rectangle in histogram__

    public int largestRectangleArea(int[] height) {
        if (height == null || height.length == 0) {
            return 0;
        }
        Stack<Integer> stack = new Stack<Integer>();
        stack.add(0);
        int len = height.length;
        int area = 0;
        for (int i = 1; i <= len; i++) {
            int h = i == len ? 0 : height[i];
            // pop a element and calculate its max area
            // pop until the top element is smaller than h, then push h
            while (!stack.isEmpty() && h < height[stack.peek()]) {
                int pos = stack.pop();
                int width = stack.isEmpty() ? i : i - stack.peek() - 1;
                area = Math.max(area, height[pos] * width);
            }
            stack.push(i);
        }
        return area;
    }

__LRU Cache__

I posted code in the new post. 

__Longest consecutive sequence__

    public int longestConsecutive(int[] num) {
        if (num == null || num.length == 0) {
            return 0;
        }
        HashSet<Integer> set = new HashSet<Integer>();
        for (Integer i: num) {
            set.add(i);
        }
        int longest = 0;
        for (Integer i: num) {
            if (!set.contains(i)) {
                continue;
            }
            int left = i - 1;
            while (set.contains(left)) {
                set.remove(left--);
            }
            int right = i + 1;
            while (set.contains(right)) {
                set.remove(right++);
            }
            longest = Math.max(longest, right - left - 1);
            set.remove(i);
        }
        return longest;
    }
]]></content>
  </entry>
  
</feed>
