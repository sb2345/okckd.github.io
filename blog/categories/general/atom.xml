<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: General | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/general/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-07-30T19:21:41+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Peripheral of a Complete Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/07/30/Peripheral-Of-Complete-Tree/"/>
    <updated>2014-07-30T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/30/Peripheral-Of-Complete-Tree</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2010/09/peripheral-boundary-of-complete-tree.html)

> Write a program to find the anti-clock-wise peripheral (boundary) of a complete tree. 

> For a complete tree peripheral (boundary) is defined as

    1. First the root
    1. Then nodes on left edge
    1. Then leaf nodes
    1. Then nodes on right edge

<img class="left" src="/assets/images/peripheral-of-tree.png">

> For the above tree, peripheral will be: 0 1 3 7 8 9 10 11 12 13 14 6 2

### Solution

__It's a very tricky solution__. Very clever I would say. 

1. print root node
1. print left nodes and leafs of left subtree in same order
1. print leafs and right nodes of right subtree in same order

Do practise this question again in the future! 

### Code

__written by me__

I used an Enum in the code. 

	public enum PeriType {
		LEFT, RIGHT, LEAF
	}

	private void peripheral(TreeNode root) {
		printNode(root);
		helper(root.left, PeriType.LEFT);
		helper(root.right, PeriType.RIGHT);
		System.out.println();
	}

	private void helper(TreeNode node, PeriType type) {
		if (node == null) {
			return;
		}
		switch (type) {
		case LEFT:
			printNode(node);
			helper(node.left, PeriType.LEFT);
			helper(node.right, PeriType.LEAF);
			break;
		case RIGHT:
			helper(node.left, PeriType.LEAF);
			helper(node.right, PeriType.RIGHT);
			printNode(node);
			break;
		case LEAF:
			if (node.left == null && node.right == null) {
				printNode(node);
			} else {
				helper(node.left, PeriType.LEAF);
				helper(node.right, PeriType.LEAF);
			}
			break;
		}
	}

	private void printNode(TreeNode root) {
		System.out.print(root.val + " ");
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Nth Fibonacci Number in O(LogN)]]></title>
    <link href="http://okckd.github.io/blog/2014/07/30/Nth-Fibonacci-Number-In-LogN/"/>
    <updated>2014-07-30T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/30/Nth-Fibonacci-Number-In-LogN</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2010/09/nth-fibbonacci-number-in-ologn.html)

> Find Nth fibonacci number in O(logN) time complexity.

### Analysis

<img class="middle" src="/assets/images/fibonacci_matrix.png">

It's a recursive sequence, where we can get the following equation: 

	A* [ F(1) F(0) ] = [ F(2) F(1) ]
	A* [ F(2) F(1) ] = [ F(3) F(2) ] = A^2 * [ F(1) F(0) ]
	A* [ F(3) F(2) ] = [ F(4) F(3) ] = A^3 * [ F(1) F(0) ]
	..
	..
	..
	..
	A* [ F(n) F(n-1) ] = [ F(n+1) F(n) ] = A^n * [ F(1) F(0) ]

### Solution


### Code

__not written by me__


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Which Loop Is Faster]]></title>
    <link href="http://okckd.github.io/blog/2014/07/29/Which-is-faster/"/>
    <updated>2014-07-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/29/Which-is-faster</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2010/09/which-loop-is-faster.html)

> A very basic programming puzzle is being asked in programming interviews since last few years. Which of the below two loops will run faster? 

	/* First */  
	for(i=0;i<100;i++)  
	 for(j=0;j<10;j++)  
	     //do somthing

	/* Second */  
	for(i=0;i<10;i++)  
	 for(j=0;j<100;j++)  
	     //do somthing  

### Solution

1. The First executes assignment operations 101 times, while Second executes only 11 times.
1. The First does 101 + 1100 = 1201 comparisons, while the Second does 11 + 1010 = 1021 comparisons. 
1. The First executes 1100 increments, while the Second executes 1010 increments. 

### Code

The following code proves why First is faster. 

	public static void solution() {
		int i, j, k, l;
		k = 0;
		l = 0;
		/* FIRST */
		for (i = 0, l++; i < 10; i++, k++)
			for (j = 0, l++; j < 100; j++, k++)
				;
		// printf("First Loop: %d\t%d\n", k, l);
		System.out.println(k);
		System.out.println(l);

		k = 0;
		l = 0;
		/* SECOND */
		for (i = 0, l++; i < 100; i++, k++)
			for (j = 0, l++; j < 10; j++, k++)
				;
		// printf("Second Loop: %d\t%d\n", k, l);
		System.out.println(k);
		System.out.println(l);
	}

output is : 1010, 11, 1100, 101
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Remove Chars in Pairs]]></title>
    <link href="http://okckd.github.io/blog/2014/07/29/Remove-char-in-Pairs/"/>
    <updated>2014-07-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/29/Remove-char-in-Pairs</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/recursively-remove-adjacent-duplicates-given-string/)

> Given a string, recursively remove adjacent duplicate characters from string. The output string should not have any adjacent duplicates.

> Input:  azxxzy
>
> Output: ay
>
> First "azxxzy" is reduced to "azzy". The string "azzy" contains duplicates, so it is further reduced to "ay". 

### Analysis

We could do it recursively until all pairs are removed, but it's not good. 

There's an O(n) solution. 

### Solution

__Most obvious solution is to use a stack__. In the end, the stack stores all unmatched chars. 

But we can also __do it without using space__ (assuming the input is char array). Just use the original char array to store result, with the helper of 2 pointers. [The code](http://tech-queries.blogspot.sg/2011/02/remove-pairs.html) is very much concise. 

### Code

__Refactored code by me__

	public static String remove_pair(char[] input) {
		int len = input.length;
		int right = 1, left = 0;

		while (right < len) {
			// Cancel pairs
			while (right < len && left >= 0 && input[right] == input[left]) {
				right++;
				left--;
			}
			if (right == len) {
				break;
			}
			input[++left] = input[right++];
		}
		return String.valueOf(input).substring(0, left + 1);
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Find Min & Max in an Array Using Minimum Comparisons]]></title>
    <link href="http://okckd.github.io/blog/2014/07/29/Find-Min-Max-in-Array/"/>
    <updated>2014-07-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/29/Find-Min-Max-in-Array</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.programcreek.com/2014/02/find-min-max-in-an-array-using-minimum-comparisons/)

> Given an array of integers find the maximum and minimum elements by using minimum comparisons. 

### Solution

__[Compare in Pairs](http://www.geeksforgeeks.org/maximum-and-minimum-in-an-array/)__.

1. If n is odd then initialize min and max as first element.
1. If n is even then initialize min and max as minimum and maximum of the first two elements respectively.
1. For rest of the elements, pick them in pairs and compare their maximum and minimum with max and min respectively. 

Number of comparison is 1.5*n. 

There's also a __Tournament Method__ from G4G, but the implementation is a bit difficult. 

### Code

__not written by me__

    public static void minmax2(int[] a) {
        if (a == null || a.length < 1)
            return;

        int min, max;

        // if only one element
        if (a.length == 1) {
            max = a[0];
            min = a[0];
            System.out.println("min: " + min + "\nmax: " + max);
            return;
        }

        if (a[0] > a[1]) {
            max = a[0];
            min = a[1];
        } else {
            max = a[1];
            min = a[0];
        }

        for (int i = 2; i <= a.length - 2;) {
            if (a[i] > a[i + 1]) {
                min = Math.min(min, a[i + 1]);
                max = Math.max(max, a[i]);
            } else {
                min = Math.min(min, a[i]);
                max = Math.max(max, a[i + 1]);
            }

            i = i + 2;
        }

        if (a.length % 2 == 1) {
            min = Math.min(min, a[a.length - 1]);
            max = Math.max(max, a[a.length - 1]);
        }

        System.out.println("min: " + min + "\nmax: " + max);
    }
]]></content>
  </entry>
  
</feed>
