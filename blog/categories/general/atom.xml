<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: General | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/general/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-08-01T17:29:50+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Max Sum in a 2D Array]]></title>
    <link href="http://okckd.github.io/blog/2014/08/01/Max-Sum-In-2D-Array/"/>
    <updated>2014-08-01T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/01/Max-Sum-In-2D-Array</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2010/05/find-max-sum-in-2d-array.html)

> Given a 2D array, find the maximum sum subarray in it. For example, in the following 2D array, the maximum sum subarray is highlighted with blue rectangle and sum of this subarray is 29.

<img class="middle" src="/assets/images/max-sum-2d-matrix.png">

### Analysis

Try convert this question to "__max sum in 1D array__" by sum up all numbers in the same column. (we know that in 1D array, the algo runs O(n) time)

There's in total O(n^2) combinations of ways to sum up a column. So the __total time complexity is O(n^3)__. 

### Solution

1. Traverse matrix at row level.

1. have a temporary 1-D array and initialize all members as 0.

1. For each row do following

    1. add value in temporary array for all rows below current row
    1. apply 1-D kadane on temporary array
    1. if your current result is greater than current maximum sum, update.

### Code

__written by me__

	public int maxSum(int[][] A) {
		int m = A.length;
		int n = A[0].length;
		int maxResult = Integer.MIN_VALUE;
		for (int i = 0; i < m; i++) {
			int[] temp = new int[n];
			for (int j = i; j < m; j++) {
				// from row#i to row#(m-1), add the number into temp[]
				for (int k = 0; k < n; k++) {
					temp[k] += A[j][k];
				}
				// find max sum for 1D array
				maxResult = Math.max(maxResult, maxSum(temp));
			}
		}
		return maxResult;
	}

	private int maxSum(int[] B) {
		int sumSoFar = 0;
		int maxSum = Integer.MIN_VALUE;
		for (int i = 0; i < B.length; i++) {
			maxSum = Math.max(maxSum, sumSoFar + B[i]);
			sumSoFar = Math.max(0, sumSoFar + B[i]);
		}
		return maxSum;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Arranging Sequence]]></title>
    <link href="http://okckd.github.io/blog/2014/08/01/Arranging-Sequence/"/>
    <updated>2014-08-01T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/01/Arranging-Sequence</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2008/11/arranging-sequence.html)

> We have an array of 2n elements like "a1 a2...an b1 b2...bn". WAP to rearrange the array as "a1 b1 a2 b2...an bn"

> time complexity is O(n) no extra array or memory can be taken.

> Input : 1 2 3 4 5 6 7 8 9 10 11 12 (even number input)
>
> Output: 1 7 2 8 3 9 4 10 5 11 6 12

> Input : 1 2 3 4 5 6 7 (odd number input)
>
> Output: 1 5 2 6 3 7 4

### Analysis

This is a difficult question. 

I did not find enough resources online, but have come up with 2 solutions.

### Solution

__First is like bubble sort (read it somewhere before)__. Always swap in pairs (starting from the middle): 

	1st: 1 2 3 4 5 6 7
	2nd: 1 2 3 5 4 6 7
	3rd: 1 2 5 3 6 4 7
	4th: 1 5 2 6 3 7 4
	done

__Second solution is to swap in cycles (put current value in its 'successor' position, and continue from there)__. But in order to identify cycles, additional space is used. I wrote the code (which make use of 'visited' array) is listed below. the time complexity is between O(n) and O(n^2). 

More info on this topic can be found on [wikipedia](http://en.wikipedia.org/wiki/In-place_matrix_transposition). 

### Code

__written by me__

	public void rearrange(int[] A) {
		int effLength = A.length;
		if (A.length % 2 == 0) {
			// for even number of input, last element is unchanged
			effLength--;
		}
		// make sure 'effLength' is an odd number.
		int half = effLength / 2 + 1;
		int pos = 1;
		int posValue = A[pos];
		int numSwaps = 0;
		boolean[] visited = new boolean[effLength];
		// visited is used as flag to avoid repeat swap
		// eg. when input is { 1, 2, 3, 4, 5, 6, 7 }, repeat swap as below:
		// 2 -> 3 -> 5 -> 2 -> 3 ...
		while (numSwaps < effLength - 1) {
			// swap (effLength - 1) times because 1st position is unchanged
			int newPos = getNewPosition(A, pos, half);
			if (visited[newPos]) {
				// if this new position is swap already, skip it
				pos = (pos + 1) % effLength;
				posValue = A[pos];
				continue;
			}
			int temp = A[newPos];
			A[newPos] = posValue;
			posValue = temp;
			pos = newPos;

			visited[newPos] = true;
			numSwaps++;
		}
	}

	private int getNewPosition(int[] array, int pos, int half) {
		if (pos < half) {
			return 2 * pos;
		} else {
			return 2 * (pos - half) + 1;
		}
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Run-Length Encoding]]></title>
    <link href="http://okckd.github.io/blog/2014/07/31/Run-Length-Encoding/"/>
    <updated>2014-07-31T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/31/Run-Length-Encoding</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2008/11/run-length-encoding.html)

> You are given a string like "aaaabbbcc", do an in place conversion which write frequency of each charater(which come continuosly) with that character. 

> Example:
>
>input: aaabbbcc
>
>output: a3b2c2

### Solution

The most important point is __whether or not you find the special cases__, and did you clarify how to handle them. 

__First special case is only 1 character__, should you append a '1' or not. Note that this question requires 'in place' conversion. So '1' is not supposed to be appended after single-occurance character. This is really important to know, if the question does not specify. (though sometimes, the question asks you to apppend a '1', eg. [here](http://www.geeksforgeeks.org/run-length-encoding/)). 

__Second case is when occurance >= 10__. We could not simply append ('0' + numberOfOccurance), because the number could be 12. This is another very important case to take note. 

The code can be seen anywhere. ]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Points on Globe Puzzle]]></title>
    <link href="http://okckd.github.io/blog/2014/07/31/Points-On-Globe/"/>
    <updated>2014-07-31T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/31/Points-On-Globe</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2009/08/points-on-globe.html)

> How many points are there on the globe where, by walking one mile south, one mile east, and one mile north, you reach the place where you started? 

### Solution

One point in the __North Pole__, and many circles in the __South Pole__. 

Read more at question post. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Number of Bus-Stations]]></title>
    <link href="http://okckd.github.io/blog/2014/07/31/Number-Of-Bus-Stations/"/>
    <updated>2014-07-31T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/31/Number-Of-Bus-Stations</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2009/05/number-of-bus-stations.html)

> At a bus-station, you have time-table for buses arrival and departure. You need to find the minimum number of platforms so that all the buses can be accommodated as per their schedule. 

> Example: Time table is like below:

    Bus         Arrival         Departure 
    BusA        0900 hrs        0930 hrs
    BusB        0915 hrs        1300 hrs
    BusC        1030 hrs        1100 hrs
    BusD        1045 hrs        1145 hrs

> The answer must be 3. 

### Solution

The answer is same as finding the maximum number of bus at the bus-station at the same time. 

__The suggestted solution__ from [here](http://tech-queries.blogspot.sg/2009/05/number-of-bus-stations.html): 

> So first sort all the arrival(A) and departure(D) time in an int array. Please save the corresponding arrival or departure in the array also. 

> After sorting our array will look like this:

    0900    0915    1930    1030    1045    1100    1145    1300
    A       A       D       A       A       D       D       D

Now use a counter. When sees an A, increment. When sees an D, decreament. In the end, return the largest counter value. 

Note: If you have a arriving and a departing at same time, put departure time first.
]]></content>
  </entry>
  
</feed>
