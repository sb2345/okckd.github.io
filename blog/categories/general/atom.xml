<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: General | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/general/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-07-29T00:16:18+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Matching Nuts and Bolts]]></title>
    <link href="http://okckd.github.io/blog/2014/07/28/Matching-Nuts-And-Bolts/"/>
    <updated>2014-07-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/28/Matching-Nuts-And-Bolts</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2011/01/nuts-and-bolts-algorithm.html)

> You are given a collection of nuts of different size and corresponding bolts. You can choose any nut & any bolt together, from which you can determine whether the nut is larger than bolt, smaller than bolt or matches the bolt exactly. However there is no way to compare two nuts together or two bolts together. Suggest an algorithm to match each bolt to its matching nut. 

### Analysis

Use the idea of quicksort. Find pivot and divide. 

### Solution

1. Take a nut from the nuts pile
1. Divide bolts around it in 2 parts, which are smaller and larger than this.
1. Find a matching bolt to this nut.
1. Divide nuts in 2 parts, which are smaller and larger than matching bolt.

Now we have 2 subsets of Nuts and Bolts. 

At every step, we will be able to divide these piles in 2 halves and reduce complexity by a factor of 2. 

__Average case time complexity will be O(nlogn)__, but O(n^2) when pivot is selection poor. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Check if Number Exists]]></title>
    <link href="http://okckd.github.io/blog/2014/07/28/Check-Number-Exists/"/>
    <updated>2014-07-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/28/Check-Number-Exists</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2011/02/check-if-number-exist.html)

> There is long list of natural numbers. Remove every 2nd no from list in 1st pass. Remove every 3rd no from list in 2nd pass. Find whether Nth natural no will exist after P passes. N and P are inputs.

    Example: N is 15 and p is 3.
    Initial: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
    After 1st pass: 1 3 5 7 9 11 13 15 17 19
    After 2nd pass: 1 3 7 9 13 15 19
    After 3rd pass: 1 3 7 13 15 19
    After 4th pass: 1 3 7 13 19

> So we see that 15 exists after 3 passes but vanishes after 4th pass.

### Analysis

We see that in any of the pass __new position will be decreased by no of elements deleted__ between 1 and current position. 

Example: originally number is 15. After 1st pass, it becomes 8th element. After 2nd pass, it becomes 8 - (8 / 3) = 6th element. 

We stop when either P(i-1)/(i+1) is an integer, or when number is smaller than pass. 

### Code

__not written by me__ 

    bool check_posiiton(int n, int p)  
    {  
     int cur = n;  
     int i = 0;  
     while (i <= p)  
     {  
         i++;  
         if (cur%(i+1) == 0)  
         {  
             //Vanishes in this pass  
             return false;  
         }  
         else if (cur < (i+1))  
         {  
             //Number exist denominator is greater than numerator  
             return true;  
         }  
         cur = cur - cur/(i+1);  
     }  
     return true;  
    }  
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Breaking Chocolate Bars]]></title>
    <link href="http://okckd.github.io/blog/2014/07/28/Breaking-Chocolate-Bars/"/>
    <updated>2014-07-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/28/Breaking-Chocolate-Bars</id>
    <content type="html"><![CDATA[### Game #1

[link](http://www.cut-the-knot.org/proofs/chocolad.shtml)

> Two players take turns breaking a chacolate bar (rectangle-shaped consist of squares). The last to break a piece wins the game. 

> Design the strategy. 

#### Solution

Each time the bar is broken, __total number of pieces increase by 1__. Suppose there're even number of squares, 1st player wins regardless of breaking strategy. And vice versa. 

### Problem #2

[link](http://www.cut-the-knot.org/proofs/chocolad.shtml)

> 75 teams took part in a competition where teams met 1-on-1. Each time the defeated team drops out. 

> How many meets are needed to before one team is declared a winner?

#### Solution

Each game will eliminate 1 game, so it needs 74 games. 

### Splitting Piles

[link](http://www.cut-the-knot.org/arithmetic/rapid/piles.shtml)

> Given a random number of items in a pile. Ask an audience to split a pile into two piles, multiply the numbers of items in the two new piles and keep adding the results. The process stops when there is no pile with more than 1 chip.

> For example, let start with 9 chips:

<table cellpadding="10">
<tbody><tr><td align="center">Piles</td><td align="center">Which is broken</td><td align="center">What's added</td><td align="center">Total</td></tr>
<tr><td colspan="4"><hr></td></tr>
<tr><td align="center">9</td><td align="center">9</td><td align="center">3*6</td><td align="center">18</td></tr>
<tr><td align="center">3,6</td><td align="center">3</td><td align="center">1*2</td><td align="center">20</td></tr>
<tr><td align="center">1,2,6</td><td align="center">6</td><td align="center">3*3</td><td align="center">29</td></tr>
<tr><td align="center">1,2,3,3</td><td align="center">3</td><td align="center">1*2</td><td align="center">31</td></tr>
<tr><td align="center">1,2,1,2,3</td><td align="center">2</td><td align="center">1*1</td><td align="center">32</td></tr>
<tr><td align="center">1,1,1,1,2,3</td><td align="center">2</td><td align="center">1*1</td><td align="center">33</td></tr>
<tr><td align="center">1,1,1,1,1,1,3</td><td align="center">3</td><td align="center">1*2</td><td align="center">35</td></tr>
<tr><td align="center">1,1,1,1,1,1,1,2</td><td align="center">2</td><td align="center">1*1</td><td align="center"><b>36</b></td></tr>
<tr><td align="center">1,1,1,1,1,1,1,1,1</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr>
</tbody></table>

> Before the audience told the final number, you immediately guess it's 36. How did you do it? 

#### Solution

The result does not depend on how the piles are split; but only on the initial size of the very first pile. __Answer is always N(N - 1)/2__.

This can be proved by [mathematical induction](http://www.cut-the-knot.org/arithmetic/rapid/piles.shtml). 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Reconstruct Tree From Pre-Order Traversal]]></title>
    <link href="http://okckd.github.io/blog/2014/07/27/Reconstruct-Tree-From-PreOrder-Traversal/"/>
    <updated>2014-07-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/27/Reconstruct-Tree-From-PreOrder-Traversal</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2011/06/reconstruct-tree-from-pre-order.html)

> A tree has a special property where leaves are represented with ‘2’ and non-leaf with ‘1’. Each node has either 0 or 2 children. If given preorder traversal of this tree, construct the tree. 

> Example: Given Pre Order string => 12122, output: 

           1
          / \
         2   1
            / \
           2   2

### Analysis

> [In normal scenario](http://tech-queries.blogspot.sg/2011/06/reconstruct-tree-from-pre-order.html), it’s not possible to detect where left subtree ends and right subtree starts using only pre-order traversal. But here, we are given a special property. Since every node has either 2 children or no child, we can surely say that if a node exists then its sibling also exists.

Keep a public variable and build the tree recursively until the list finishes. 

### Code

	ListNode list = null; // this is the input list public variable
    
    public TreeNode main(ListNode input) {
        list = input;
        return constructTree();
    }

	private TreeNode constructTree() {
		if (list == null) {
			return null;
		}
		TreeNode root = new TreeNode(list.val);
		list = list.next;

		if (root.val == 1) {
			root.left = constructTree();
			root.right = constructTree();
		}
		return root;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Knapsack Problem With Duplications]]></title>
    <link href="http://okckd.github.io/blog/2014/07/27/Knapsack-problem-with-duplication/"/>
    <updated>2014-07-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/27/Knapsack-problem-with-duplication</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2011/04/integer-knapsack-problem-duplicate.html)

> You have n types of items, where the ith item type has an integer size si and a real value vi. You need to ﬁll a knapsack of total capacity C with a selection of items of maximum value. You can add multiple items of the same type to the knapsack. 

> This is similar to "0-1 Knapsack Problem", but duplication is allowed for this question. 

### Analysis

Of course this is DP, and it's 1-D DP. However, __there is one very tricky special case__. 

### Solution

Using 'M(j)' to denote the max value for total weight j, 'w' to denote weight, and 'v' to denote value, the equation is: 

> M(j) = max{M(j − 1), max(i=1...n) M(j − wi) + vi}

__Note the 2 cases are__: 

1. when (j)th spot is not filled, the max value is __M(j-1)__
1. when (j)th spot is filled, the max value is __max(i=1...n) M(j − wi) + vi__

This question is trickier than "0-1 Knapsack Problem", if not more difficult. __Study the 2 question together__. 

### Code

__not written by me__ 

    int knapsack(int value[], int weight[], int n, int C, vector<int> backtrack) {
     int *M = new int[C+1];  
     int i, j, tmp, pos;  
     for(i=1; i<= C; i++) {  
         M[i] = M[i-1];  
         pos = i-1;               
         for(j=0; j< n; j++)  
         {  
             if (i >= weight[j])  
                 tmp = M[i-weight[j]] + value[j];  
             if (tmp > M[i]){  
                 M[i] = tmp;  
                 pos = i - weight[j];  
             }  
         }  
         backtrack.push_back(pos);  
     }   
     int ans = M[C];  
     delete[] M;        
     return ans;  
    }  
]]></content>
  </entry>
  
</feed>
