<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: General | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/general/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-07-28T01:50:24+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Reconstruct Tree From Pre-Order Traversal]]></title>
    <link href="http://okckd.github.io/blog/2014/07/27/Reconstruct-Tree-From-PreOrder-Traversal/"/>
    <updated>2014-07-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/27/Reconstruct-Tree-From-PreOrder-Traversal</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2011/06/reconstruct-tree-from-pre-order.html)

> A tree has a special property where leaves are represented with ‘2’ and non-leaf with ‘1’. Each node has either 0 or 2 children. If given preorder traversal of this tree, construct the tree. 

> Example: Given Pre Order string => 12122, output: 

           1
          / \
         2   1
            / \
           2   2

### Analysis

> [In normal scenario](http://tech-queries.blogspot.sg/2011/06/reconstruct-tree-from-pre-order.html), it’s not possible to detect where left subtree ends and right subtree starts using only pre-order traversal. But here, we are given a special property. Since every node has either 2 children or no child, we can surely say that if a node exists then its sibling also exists.

Keep a public variable and build the tree recursively until the list finishes. 

### Code

	ListNode list = null; // this is the input list public variable
    
    public TreeNode main(ListNode input) {
        list = input;
        return constructTree();
    }

	private TreeNode constructTree() {
		if (list == null) {
			return null;
		}
		TreeNode root = new TreeNode(list.val);
		list = list.next;

		if (root.val == 1) {
			root.left = constructTree();
			root.right = constructTree();
		}
		return root;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Knapsack Problem With Duplications]]></title>
    <link href="http://okckd.github.io/blog/2014/07/27/Knapsack-problem-with-duplication/"/>
    <updated>2014-07-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/27/Knapsack-problem-with-duplication</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2011/04/integer-knapsack-problem-duplicate.html)

> You have n types of items, where the ith item type has an integer size si and a real value vi. You need to ﬁll a knapsack of total capacity C with a selection of items of maximum value. You can add multiple items of the same type to the knapsack. 

> This is similar to "0-1 Knapsack Problem", but duplication is allowed for this question. 

### Analysis

Of course this is DP, and it's 1-D DP. However, __there is one very tricky special case__. 

### Solution

Using 'M(j)' to denote the max value for total weight j, 'w' to denote weight, and 'v' to denote value, the equation is: 

> M(j) = max{M(j − 1), max(i=1...n) M(j − wi) + vi}

__Note the 2 cases are__: 

1. when (j)th spot is not filled, the max value is __M(j-1)__
1. when (j)th spot is filled, the max value is __max(i=1...n) M(j − wi) + vi__

This question is trickier than "0-1 Knapsack Problem", if not more difficult. __Study the 2 question together__. 

### Code

__not written by me__ 

    int knapsack(int value[], int weight[], int n, int C, vector<int> backtrack) {
     int *M = new int[C+1];  
     int i, j, tmp, pos;  
     for(i=1; i<= C; i++) {  
         M[i] = M[i-1];  
         pos = i-1;               
         for(j=0; j< n; j++)  
         {  
             if (i >= weight[j])  
                 tmp = M[i-weight[j]] + value[j];  
             if (tmp > M[i]){  
                 M[i] = tmp;  
                 pos = i - weight[j];  
             }  
         }  
         backtrack.push_back(pos);  
     }   
     int ans = M[C];  
     delete[] M;        
     return ans;  
    }  
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Fit 1*2 Dominos in 2*N Strip]]></title>
    <link href="http://okckd.github.io/blog/2014/07/27/Fit-dominos-in-strip/"/>
    <updated>2014-07-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/27/Fit-dominos-in-strip</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2011/07/fit-12-dominos-in-2n-strip.html)

> In how many ways can one tile a 2 X N strip of square cells with 1 X 2 dominos?

<img class="left" src="/assets/images/Dominos.png">

### Solution

__X(n+1) = X(n) + X(n-1)__

It's a Fibonacci Series with X(1) = 1 and X(2) = 2.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Elephant and Bananas]]></title>
    <link href="http://okckd.github.io/blog/2014/07/27/Elephant-And-Bananas/"/>
    <updated>2014-07-27T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/27/Elephant-And-Bananas</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2011/04/elephant-and-banana.html)

> There's a elephant, which can carry max 1000 bananas. The elephant eats a banana every 1 Km (both forward and back).

> Now we want to transfer 3000 bananas to a place 1000 Km away. How many bananas can be left? 

> Also solved to generalized problem (write code for solution).

### Analysis

__If we subdivide distances for each kilometer__. Notice if elephant wants to shift all the bananas 1 km, __you will loose 5 bananas every km__. 

So we transferred 2995 (998+998+999) to one km distance. This process continues until after 200 km, we have only 2000 bananas left with remaining distance of 800 km. 

__Start from here, we only loose 3 bananas every km__. This goes on for another 334 km, we will have 998 bananas left, and the rest of the bananas can be transfered in a single journey. 

### Solution

__532 bananas__. 

### Code

__not written by me__

    double transferBananas(double N, double D, double C, double F) {  
        // base case: remaining bananas <= C,  
        // so carry all the bananas in one trip  
        // at this point if distance is more than N/F,  
        // elephant can never reach destination, return 0  
        if (N <= C) {
            double bananasAtDestination = N - D*F;  
            return (bananasAtDestination >= 0.0) ?  
                bananasAtDestination :  0.0;    // out of bananas!  
        }  

        // # trips you would travel back and forth  
        int numTrips = 2*(ceil(N/C) - 1) + 1;  

        // how many bananas you consume per km  
        double costPerKm = numTrips * F;  

        // remaining number of bananas after consumption, we want it  
        // as an integer multiple of C.  
        double remainingBananas = C*(ceil(N/C) - 1.0);  

        // this is the distance you are able to travel before you  
        // reach ONE LESS round trip fetching bananas  
        // derived from eq: N - costPerKm * traveled = remaining bananas  

        double traveled = (N - remainingBananas) / costPerKm;  

        // we are able to travel greater (or equal) than the remaining  
        // distance, so fetch the bananas right to the destination  
        if (traveled >= D)
            return N - D*costPerKm;  

        // calculate recursively as we travel ONE less round trip now.  
        return transferBananas(remainingBananas, D-traveled, C, F);  
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Truth Tell Brain Teaser]]></title>
    <link href="http://okckd.github.io/blog/2014/07/26/True-tell-brain-teaser/"/>
    <updated>2014-07-26T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/26/True-tell-brain-teaser</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2011/07/truth-or-lie.html)

> There are 100 people in a room. A person always speaks either lie or truth. 

> When asked:

    1st person says => all are liars
    2nd person says => at most 1 speaks truth
    3rd person says => at most 2 speak truth
    4th person says => at most 3 speak truth
    .
    .
    .
    100th person says => at most 99 speak truth

> "At most N" means "there're N or less than N". 

> How many people speak only truth?

### Solution

50. 

1. Assume 1st person speaks truth, then all including him should be liar. It means he doesn’t speak truth. 

1. Assume 2nd person speaks truth, then he is the only person who speaks truth. But if this statement is true then statements by all others are also true. I.e. if “at most 1 person speaks truth” is true then “at most N speak truth” is also true. So person 2 is also a liar.

1. Assume 3rd person is speaking truth. But then the statements of person 4-100 are also true, which contradicts his own statement. It means that person 3 is also a liar.

1. This process will continue since 50th person. So 1-50 people are liars.

1. 51st person says “at most 50 speak truth”. Lets say he is speaking truth. “at most 50” means any number from 0-50. It means that statements like “at most 51 speak truth” and “at most 70 speak truth” are also true. It means that people from 51 to 100 are speaking truth.

__Hence, 50 people speak truth__.
]]></content>
  </entry>
  
</feed>
