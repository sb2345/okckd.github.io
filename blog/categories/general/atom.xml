<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: General | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/general/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-07-30T12:22:49+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Peripheral of a Complete Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/07/30/Peripheral-Of-Complete-Tree/"/>
    <updated>2014-07-30T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/30/Peripheral-Of-Complete-Tree</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2010/09/peripheral-boundary-of-complete-tree.html)

> Write a program to find the anti-clock-wise peripheral (boundary) of a complete tree. 

> For a complete tree peripheral (boundary) is defined as

    1. First the root
    1. Then nodes on left edge
    1. Then leaf nodes
    1. Then nodes on right edge

<img class="left" src="/assets/images/peripheral-of-tree.png">

> For the above tree, peripheral will be: 0 1 3 7 8 9 10 11 12 13 14 6 2

### Solution

__It's a very tricky solution__. Very clever I would say. 

1. print root node
1. print left nodes and leafs of left subtree in same order
1. print leafs and right nodes of right subtree in same order

### Code


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Which Loop Is Faster]]></title>
    <link href="http://okckd.github.io/blog/2014/07/29/Which-is-faster/"/>
    <updated>2014-07-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/29/Which-is-faster</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2010/09/which-loop-is-faster.html)

> A very basic programming puzzle is being asked in programming interviews since last few years. Which of the below two loops will run faster? 

	/* First */  
	for(i=0;i<100;i++)  
	 for(j=0;j<10;j++)  
	     //do somthing

	/* Second */  
	for(i=0;i<10;i++)  
	 for(j=0;j<100;j++)  
	     //do somthing  

### Solution

1. The First executes assignment operations 101 times, while Second executes only 11 times.
1. The First does 101 + 1100 = 1201 comparisons, while the Second does 11 + 1010 = 1021 comparisons. 
1. The First executes 1100 increments, while the Second executes 1010 increments. 

### Code

The following code proves why First is faster. 

	public static void solution() {
		int i, j, k, l;
		k = 0;
		l = 0;
		/* FIRST */
		for (i = 0, l++; i < 10; i++, k++)
			for (j = 0, l++; j < 100; j++, k++)
				;
		// printf("First Loop: %d\t%d\n", k, l);
		System.out.println(k);
		System.out.println(l);

		k = 0;
		l = 0;
		/* SECOND */
		for (i = 0, l++; i < 100; i++, k++)
			for (j = 0, l++; j < 10; j++, k++)
				;
		// printf("Second Loop: %d\t%d\n", k, l);
		System.out.println(k);
		System.out.println(l);
	}

output is : 1010, 11, 1100, 101
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Remove Chars in Pairs]]></title>
    <link href="http://okckd.github.io/blog/2014/07/29/Remove-char-in-Pairs/"/>
    <updated>2014-07-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/29/Remove-char-in-Pairs</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/recursively-remove-adjacent-duplicates-given-string/)

> Given a string, recursively remove adjacent duplicate characters from string. The output string should not have any adjacent duplicates.

> Input:  azxxzy
>
> Output: ay
>
> First "azxxzy" is reduced to "azzy". The string "azzy" contains duplicates, so it is further reduced to "ay". 

### Analysis

We could do it recursively until all pairs are removed, but it's not good. 

There's an O(n) solution. 

### Solution

__Most obvious solution is to use a stack__. In the end, the stack stores all unmatched chars. 

But we can also __do it without using space__ (assuming the input is char array). Just use the original char array to store result, with the helper of 2 pointers. [The code](http://tech-queries.blogspot.sg/2011/02/remove-pairs.html) is very much concise. 

### Code

__Refactored code by me__

	public static String remove_pair(char[] input) {
		int len = input.length;
		int right = 1, left = 0;

		while (right < len) {
			// Cancel pairs
			while (right < len && left >= 0 && input[right] == input[left]) {
				right++;
				left--;
			}
			if (right == len) {
				break;
			}
			input[++left] = input[right++];
		}
		return String.valueOf(input).substring(0, left + 1);
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Find Min & Max in an Array Using Minimum Comparisons]]></title>
    <link href="http://okckd.github.io/blog/2014/07/29/Find-Min-Max-in-Array/"/>
    <updated>2014-07-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/29/Find-Min-Max-in-Array</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.programcreek.com/2014/02/find-min-max-in-an-array-using-minimum-comparisons/)

> Given an array of integers find the maximum and minimum elements by using minimum comparisons. 

### Solution

__[Compare in Pairs](http://www.geeksforgeeks.org/maximum-and-minimum-in-an-array/)__.

1. If n is odd then initialize min and max as first element.
1. If n is even then initialize min and max as minimum and maximum of the first two elements respectively.
1. For rest of the elements, pick them in pairs and compare their maximum and minimum with max and min respectively. 

Number of comparison is 1.5*n. 

There's also a __Tournament Method__ from G4G, but the implementation is a bit difficult. 

### Code

__not written by me__

    public static void minmax2(int[] a) {
        if (a == null || a.length < 1)
            return;

        int min, max;

        // if only one element
        if (a.length == 1) {
            max = a[0];
            min = a[0];
            System.out.println("min: " + min + "\nmax: " + max);
            return;
        }

        if (a[0] > a[1]) {
            max = a[0];
            min = a[1];
        } else {
            max = a[1];
            min = a[0];
        }

        for (int i = 2; i <= a.length - 2;) {
            if (a[i] > a[i + 1]) {
                min = Math.min(min, a[i + 1]);
                max = Math.max(max, a[i]);
            } else {
                min = Math.min(min, a[i]);
                max = Math.max(max, a[i + 1]);
            }

            i = i + 2;
        }

        if (a.length % 2 == 1) {
            min = Math.min(min, a[a.length - 1]);
            max = Math.max(max, a[a.length - 1]);
        }

        System.out.println("min: " + min + "\nmax: " + max);
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Construct a BST From Preorder Traversal]]></title>
    <link href="http://okckd.github.io/blog/2014/07/29/Construct-BST-from-preorder/"/>
    <updated>2014-07-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/29/Construct-BST-from-preorder</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/g-fact-17/)

> Given preorder, construct the BST. 

### Solution

We can get __Inorder traversal__ by sorting the given Preorder traversal. So we have the required two traversals to construct the Binary Search Tree. 

A very similar approach would be __always spliting the array__ by the head value. Time complexity is O(nlgn) for a balanced BST, or O(n^2) for a screwed tree. 

__Howver, there's [O(n) solutions](http://www.geeksforgeeks.org/construct-bst-from-given-preorder-traversa/)__. 

> The trick is to set a range {min .. max} for every node. Initialize the range as {INT_MIN .. INT_MAX}. The first node will definitely be in range, so create root node. To construct the left subtree, set the range as {INT_MIN â€¦root->data}. If a values is in the range {INT_MIN .. root->data}, the values is part part of left subtree. To construct the right subtree, set the range as {root->data..max .. INT_MAX}.

There's another __[O(n) solution](http://www.geeksforgeeks.org/construct-bst-from-given-preorder-traversal-set-2/) using stack__. 
]]></content>
  </entry>
  
</feed>
