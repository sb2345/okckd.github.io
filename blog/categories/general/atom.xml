<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: General | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/general/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-07-31T21:55:18+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question] Points on Globe Puzzle]]></title>
    <link href="http://okckd.github.io/blog/2014/07/31/Points-On-Globe/"/>
    <updated>2014-07-31T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/31/Points-On-Globe</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2009/08/points-on-globe.html)

> How many points are there on the globe where, by walking one mile south, one mile east, and one mile north, you reach the place where you started? 

### Solution

One point in the __North Pole__, and many circles in the __South Pole__. 

Read more at question post. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Inorder Successor in Binary Search Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/07/31/Inorder-Successor-BST/"/>
    <updated>2014-07-31T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/31/Inorder-Successor-BST</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.geeksforgeeks.org/inorder-successor-in-binary-search-tree/)

> In Binary Tree, Inorder successor of a node is the next node in Inorder traversal of the Binary Tree. Inorder Successor is NULL for the last node in Inoorder traversal.

> Write a program with: 

> 1. parent pointer provided
> 1. parent pointer not provided

### Solution

__If have parent pointer, it's easy__. Read solution [here](http://tech-queries.blogspot.sg/2010/04/inorder-succesor-in-binary-tree.html). 

__If no parent pointer, then we make use of the property of BST, can get an O(h) solution__. h is the height. 

A very good solution from [this blog](http://algorithmsandme.blogspot.sg/2013/08/binary-search-tree-inorder-successor.html).

1. Start with root.
2. If the node is given has less than root, then search on left side __and update successor__.
3. If the node is greater than root, then search in right part, __don't update successor__.
4. If we find the node
	1. if the node has right sub tree, then the minimum node on the right sub tree of node is the in-order successor.
	1. otherwise, just return successor

The most important point is: we only update __successor__ during left turn, and don't update during right turn. 

### Code

__written by me__

	public TreeNode inorderSuccessor(TreeNode root, TreeNode target) {
		if (target.right != null) {
			return this.findLeftMost(target.right);
		} else {
			return this.traverse(root, new TreeNode(-1), target);
		}
	}

	private TreeNode traverse(TreeNode cur, TreeNode pre, TreeNode target) {
		if (cur.val == target.val) {
			return pre;
		} else if (cur.val < target.val) {
			cur = cur.right;
			return traverse(cur, pre, target);
		} else {
			pre = cur;
			cur = cur.left;
			return traverse(cur, pre, target);
		}
	}

	private TreeNode findLeftMost(TreeNode node) {
		while (node.left != null) {
			node = node.left;
		}
		return node;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Peripheral of a Complete Tree]]></title>
    <link href="http://okckd.github.io/blog/2014/07/30/Peripheral-Of-Complete-Tree/"/>
    <updated>2014-07-30T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/30/Peripheral-Of-Complete-Tree</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2010/09/peripheral-boundary-of-complete-tree.html)

> Write a program to find the anti-clock-wise peripheral (boundary) of a complete tree. 

> For a complete tree peripheral (boundary) is defined as

    1. First the root
    1. Then nodes on left edge
    1. Then leaf nodes
    1. Then nodes on right edge

<img class="left" src="/assets/images/peripheral-of-tree.png">

> For the above tree, peripheral will be: 0 1 3 7 8 9 10 11 12 13 14 6 2

### Solution

__It's a very tricky solution__. Very clever I would say. 

1. print root node
1. print left nodes and leafs of left subtree in same order
1. print leafs and right nodes of right subtree in same order

Do practise this question again in the future! 

### Code

__written by me__

I used an Enum in the code. 

	public enum PeriType {
		LEFT, RIGHT, LEAF
	}

	private void peripheral(TreeNode root) {
		printNode(root);
		helper(root.left, PeriType.LEFT);
		helper(root.right, PeriType.RIGHT);
		System.out.println();
	}

	private void helper(TreeNode node, PeriType type) {
		if (node == null) {
			return;
		}
		switch (type) {
		case LEFT:
			printNode(node);
			helper(node.left, PeriType.LEFT);
			helper(node.right, PeriType.LEAF);
			break;
		case RIGHT:
			helper(node.left, PeriType.LEAF);
			helper(node.right, PeriType.RIGHT);
			printNode(node);
			break;
		case LEAF:
			if (node.left == null && node.right == null) {
				printNode(node);
			} else {
				helper(node.left, PeriType.LEAF);
				helper(node.right, PeriType.LEAF);
			}
			break;
		}
	}

	private void printNode(TreeNode root) {
		System.out.print(root.val + " ");
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Nth Fibonacci Number in O(LogN)]]></title>
    <link href="http://okckd.github.io/blog/2014/07/30/Nth-Fibonacci-Number-In-LogN/"/>
    <updated>2014-07-30T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/30/Nth-Fibonacci-Number-In-LogN</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2010/09/nth-fibbonacci-number-in-ologn.html)

> Find Nth fibonacci number in O(logN) time complexity.

### Solution

<img class="middle" src="/assets/images/fibonacci_matrix.png">

It's a recursive sequence, where we can get the following equation: 

	A* [ F(1) F(0) ] = [ F(2) F(1) ]
	A* [ F(2) F(1) ] = [ F(3) F(2) ] = A^2 * [ F(1) F(0) ]
	A* [ F(3) F(2) ] = [ F(4) F(3) ] = A^3 * [ F(1) F(0) ]
	..
	..
	..
	..
	A* [ F(n) F(n-1) ] = [ F(n+1) F(n) ] = A^n * [ F(1) F(0) ]

Which means: 

<img class="middle" src="/assets/images/fibonacci_equation.png">

So all that is left is finding the nth power of the matrix A. Well, this can be computed in O(log n) time, by recursive doubling. For more, see question post or [here](http://www.codechef.com/wiki/tutorial-dynamic-programming#Finding_nth_Finobacci_number_in_Olog_n). 

### Code

__not written__


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Which Loop Is Faster]]></title>
    <link href="http://okckd.github.io/blog/2014/07/29/Which-is-faster/"/>
    <updated>2014-07-29T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/29/Which-is-faster</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2010/09/which-loop-is-faster.html)

> A very basic programming puzzle is being asked in programming interviews since last few years. Which of the below two loops will run faster? 

	/* First */  
	for(i=0;i<100;i++)  
	 for(j=0;j<10;j++)  
	     //do somthing

	/* Second */  
	for(i=0;i<10;i++)  
	 for(j=0;j<100;j++)  
	     //do somthing  

### Solution

1. The First executes assignment operations 101 times, while Second executes only 11 times.
1. The First does 101 + 1100 = 1201 comparisons, while the Second does 11 + 1010 = 1021 comparisons. 
1. The First executes 1100 increments, while the Second executes 1010 increments. 

### Code

The following code proves why First is faster. 

	public static void solution() {
		int i, j, k, l;
		k = 0;
		l = 0;
		/* FIRST */
		for (i = 0, l++; i < 10; i++, k++)
			for (j = 0, l++; j < 100; j++, k++)
				;
		// printf("First Loop: %d\t%d\n", k, l);
		System.out.println(k);
		System.out.println(l);

		k = 0;
		l = 0;
		/* SECOND */
		for (i = 0, l++; i < 100; i++, k++)
			for (j = 0, l++; j < 10; j++, k++)
				;
		// printf("Second Loop: %d\t%d\n", k, l);
		System.out.println(k);
		System.out.println(l);
	}

output is : 1010, 11, 1100, 101
]]></content>
  </entry>
  
</feed>
