<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: General | My Octopress Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/general/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-07-28T17:50:22+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Question]]]></title>
    <link href="http://okckd.github.io/blog/2014/07/28/aaa/"/>
    <updated>2014-07-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/28/aaa</id>
    <content type="html"><![CDATA[### Question 

[link]()

> 

### Analysis



### Solution



### Code

__not written by me__ 


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question]]]></title>
    <link href="http://okckd.github.io/blog/2014/07/28/aa/"/>
    <updated>2014-07-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/28/aa</id>
    <content type="html"><![CDATA[### Question 

[link]()

> 

### Analysis



### Solution



### Code

__not written by me__ 


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Matching Nuts and Bolts]]></title>
    <link href="http://okckd.github.io/blog/2014/07/28/Matching-Nuts-And-Bolts/"/>
    <updated>2014-07-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/28/Matching-Nuts-And-Bolts</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2011/01/nuts-and-bolts-algorithm.html)

> You are given a collection of nuts of different size and corresponding bolts. You can choose any nut & any bolt together, from which you can determine whether the nut is larger than bolt, smaller than bolt or matches the bolt exactly. However there is no way to compare two nuts together or two bolts together. Suggest an algorithm to match each bolt to its matching nut. 

### Analysis

Use the idea of quicksort. Find pivot and divide. 

### Solution

1. Take a nut from the nuts pile
1. Divide bolts around it in 2 parts, which are smaller and larger than this.
1. Find a matching bolt to this nut.
1. Divide nuts in 2 parts, which are smaller and larger than matching bolt.

Now we have 2 subsets of Nuts and Bolts. 

At every step, we will be able to divide these piles in 2 halves and reduce complexity by a factor of 2. 

__Average case time complexity will be O(nlogn)__, but O(n^2) when pivot is selection poor. 
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Check if Number Exists]]></title>
    <link href="http://okckd.github.io/blog/2014/07/28/Check-Number-Exists/"/>
    <updated>2014-07-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/28/Check-Number-Exists</id>
    <content type="html"><![CDATA[### Question 

[link](http://tech-queries.blogspot.sg/2011/02/check-if-number-exist.html)

> There is long list of natural numbers. Remove every 2nd no from list in 1st pass. Remove every 3rd no from list in 2nd pass. Find whether Nth natural no will exist after P passes. N and P are inputs.

    Example: N is 15 and p is 3.
    Initial: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
    After 1st pass: 1 3 5 7 9 11 13 15 17 19
    After 2nd pass: 1 3 7 9 13 15 19
    After 3rd pass: 1 3 7 13 15 19
    After 4th pass: 1 3 7 13 19

> So we see that 15 exists after 3 passes but vanishes after 4th pass.

### Analysis

We see that in any of the pass __new position will be decreased by no of elements deleted__ between 1 and current position. 

Example: originally number is 15. After 1st pass, it becomes 8th element. After 2nd pass, it becomes 8 - (8 / 3) = 6th element. 

We stop when either P(i-1)/(i+1) is an integer, or when number is smaller than pass. 

### Code

__not written by me__ 

    bool check_posiiton(int n, int p)  
    {  
     int cur = n;  
     int i = 0;  
     while (i <= p)  
     {  
         i++;  
         if (cur%(i+1) == 0)  
         {  
             //Vanishes in this pass  
             return false;  
         }  
         else if (cur < (i+1))  
         {  
             //Number exist denominator is greater than numerator  
             return true;  
         }  
         cur = cur - cur/(i+1);  
     }  
     return true;  
    }  
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Question] Breaking Chocolate Bars]]></title>
    <link href="http://okckd.github.io/blog/2014/07/28/Breaking-Chocolate-Bars/"/>
    <updated>2014-07-28T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/28/Breaking-Chocolate-Bars</id>
    <content type="html"><![CDATA[### Game #1

[link](http://www.cut-the-knot.org/proofs/chocolad.shtml)

> Two players take turns breaking a chacolate bar (rectangle-shaped consist of squares). The last to break a piece wins the game. 

> Design the strategy. 

#### Solution

Each time the bar is broken, __total number of pieces increase by 1__. Suppose there're even number of squares, 1st player wins regardless of breaking strategy. And vice versa. 

### Problem #2

[link](http://www.cut-the-knot.org/proofs/chocolad.shtml)

> 75 teams took part in a competition where teams met 1-on-1. Each time the defeated team drops out. 

> How many meets are needed to before one team is declared a winner?

#### Solution

Each game will eliminate 1 game, so it needs 74 games. 

### Splitting Piles

[link](http://www.cut-the-knot.org/arithmetic/rapid/piles.shtml)

> Given a random number of items in a pile. Ask an audience to split a pile into two piles, multiply the numbers of items in the two new piles and keep adding the results. The process stops when there is no pile with more than 1 chip.

> For example, let start with 9 chips:

<table cellpadding="10">
<tbody><tr><td align="center">Piles</td><td align="center">Which is broken</td><td align="center">What's added</td><td align="center">Total</td></tr>
<tr><td colspan="4"><hr></td></tr>
<tr><td align="center">9</td><td align="center">9</td><td align="center">3*6</td><td align="center">18</td></tr>
<tr><td align="center">3,6</td><td align="center">3</td><td align="center">1*2</td><td align="center">20</td></tr>
<tr><td align="center">1,2,6</td><td align="center">6</td><td align="center">3*3</td><td align="center">29</td></tr>
<tr><td align="center">1,2,3,3</td><td align="center">3</td><td align="center">1*2</td><td align="center">31</td></tr>
<tr><td align="center">1,2,1,2,3</td><td align="center">2</td><td align="center">1*1</td><td align="center">32</td></tr>
<tr><td align="center">1,1,1,1,2,3</td><td align="center">2</td><td align="center">1*1</td><td align="center">33</td></tr>
<tr><td align="center">1,1,1,1,1,1,3</td><td align="center">3</td><td align="center">1*2</td><td align="center">35</td></tr>
<tr><td align="center">1,1,1,1,1,1,1,2</td><td align="center">2</td><td align="center">1*1</td><td align="center"><b>36</b></td></tr>
<tr><td align="center">1,1,1,1,1,1,1,1,1</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr>
</tbody></table>

> Before the audience told the final number, you immediately guess it's 36. How did you do it? 

#### Solution

The result does not depend on how the piles are split; but only on the initial size of the very first pile. __Answer is always N(N - 1)/2__.

This can be proved by [mathematical induction](http://www.cut-the-knot.org/arithmetic/rapid/piles.shtml). 
]]></content>
  </entry>
  
</feed>
