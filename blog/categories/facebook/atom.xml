<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Facebook | Woodstock Blog]]></title>
  <link href="http://okckd.github.io/blog/categories/facebook/atom.xml" rel="self"/>
  <link href="http://okckd.github.io/"/>
  <updated>2014-12-01T16:31:20+08:00</updated>
  <id>http://okckd.github.io/</id>
  <author>
    <name><![CDATA[Charlie Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Facebook] Hamming Distance of Array]]></title>
    <link href="http://okckd.github.io/blog/2014/09/01/Hamming-distance-of-array/"/>
    <updated>2014-09-01T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/09/01/Hamming-distance-of-array</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.glassdoor.com/Interview/-a-first-write-a-function-to-calculate-the-hamming-distance-between-two-binary-numbers-b-write-a-function-that-takes-QTN_450885.htm)

> [Hamming distance](http://en.wikipedia.org/wiki/Hamming_distance) between two strings of equal length is the number of positions at which the corresponding symbols are different. 

> Write a function that takes a list of binary numbers and returns the sum of the hamming distances for each pair. 

> Do it in O(n) time. 

### Solution

The naive solution is O(n^2), so we simplify this question by using {0,0,0,1,1} as input. The output in this case would be 6. Why? Because 3 x 2 = 6. 

So the equation for solution would be: 

> distance (for a bit) = number of '1's * number of '0's

The final answer would be the sum of distances for all bits. The solution is from [this blog](http://se7so.blogspot.sg/2014/02/how-to-prepare-for-interview-9.html). 

### Code

Great solution, __not written by me__ 

	int hammingDist(int[] nums) {

		int[] bits = new int[32];

		for (int i = 0; i < nums.length; i++) {
			int one = 1;
			int j = 0;

			while (nums[i] != 0) {
				if ((nums[i] & one) != 0)
					bits[j]++;
				j++;
				nums[i] = nums[i] >> 1;
			}
		}

		int ans = 0;
		for (int i = 0; i < 32; i++) {
			ans += bits[i] * (nums.length - bits[i]);
		}

		return ans;
	}
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Facebook] Task Scheduling Question (`)]]></title>
    <link href="http://okckd.github.io/blog/2014/08/15/Task-scheduling-question/"/>
    <updated>2014-08-15T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/15/Task-scheduling-question</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#10)

> 有n个任务需要完成（编号1到n），任务之间有一些依赖关系，如果任务a依赖于任务b和c，那么只有当任务b和任务c完成之后才能完成任务a。给定所有的依赖关系，判断这些任务是否能够完成。如果能够完成，请给出一个合法的任务完成序列。

> 样例：
>
>n=5
>
>1->2,3
>
>3->4
>
>上述样例中任务1依赖于任务2和任务3，任务3依赖于任务4，那么存在合法的任务完成序列4,3,2,1,5

### Solution

http://www.itint5.com/discuss/8/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6java%E7%A8%8B%E5%BA%8F

### Code


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Facebook] Large String Find Substring]]></title>
    <link href="http://okckd.github.io/blog/2014/08/14/Large-string-find-substring/"/>
    <updated>2014-08-14T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/08/14/Large-string-find-substring</id>
    <content type="html"><![CDATA[### Question 

[link](http://www.itint5.com/oj/#15)

> 有一个长度为n的字符串str，有非常多的关键字query（长度不超过10），需要判断每个关键字是否是str的子串。

> 注意：query是动态的输入进行查询的，预先并不知道所有的query。

### Solution

__Basic idea of the solution is to use Prefix Tree (Trie)__ and similar alternatives. 

__Solution 1__ is [an nice idea using HashMap](http://www.itint5.com/discuss/27/%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%A2%84%E5%A4%84%E7%90%86). 

> 我是把所有长度< =10的子串，哈希一下存放到10个哈希表中。

> 至于哈希函数的选取，随便选一个应该都不会超时。

__Solution 2__ is using so-called '__prefix array__'. The most important point of this idea is to only make a substring instance __for every 10 characters__. 

> 只用=10的子串。然后二分查找

> 用=10的字串排序即可，如包含更短的串会使得预处理变成O(10nlg(10n))。 查找的复杂度可能没什么变化，使用<=10会是O(lg(10n))，而只使用=10子串初始化的话，因为可能还要进行短query跟长子串间的前缀比较，复杂度会是O(10lgn)，稍微有点提高。

Which is to say, using substring length == 10, we comsume __less time for pre-processing__, and a little __more time when querying__. 

### Code

__read it from [here](http://www.itint5.com/discuss/203/%E8%B6%85%E7%AE%80%E5%8D%95%E7%9A%84prefix-array-java-code)__, note written by me

    private List<String> prefixList;
    
    // pre-process the large string
    public void initWithString(String str) {
        Set<String> strs = new HashSet<String>();

        for(int i = 0; i < str.length(); ++i) {
            strs.add(str.substring(i, Math.min(str.length(), i + 10)));
        }
        prefixList = new ArrayList<String>(strs);
        Collections.sort(prefixList);
    }
    
    // find the query substring
    public boolean existSubString(String query) {
        int low = 0;
        int high = prefixList.size() - 1;
        while(low <= high) {
            int mid = (low + high) / 2;
            int comp = prefixList.get(mid).compareTo(query);
            if(comp == 0)  {
                return true;
            }
            if(prefixList.get(mid).startsWith(query)) {
                return true;
            }
            if(comp > 0) //mid > query
            {
                high = mid - 1;
            }else{
                low = mid + 1;
            }
        }
        return false;
    }
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Facebook] F Question List]]></title>
    <link href="http://okckd.github.io/blog/2014/07/19/F-question-list/"/>
    <updated>2014-07-19T00:00:00+08:00</updated>
    <id>http://okckd.github.io/blog/2014/07/19/F-question-list</id>
    <content type="html"><![CDATA[### Leetcode Questions

1. Inverse Integer
1. Anagrams
1. Edit distance

### Difficult Questions

1. Binary hamming code
1. 有一个长度为n的字符串str，有非常多的关键字query（长度不超过10），需要判断每个关键字是否是str的子串。
1. Given a dictionary and some words. Check whether these words exists in the dictionary. 

]]></content>
  </entry>
  
</feed>
