<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8" />
		<title>[Design] Big Data - Real Time Top k  - Woodstock Blog</title>
		<meta name="author" content="Charlie Brown">
		
		<meta name="description" content="Question link Given a continuous twitter feed, design an algorithm to return the 100 most
frequent words used at this minute, this hour and this day &hellip;">
    	
    	<meta name="viewport" content="width=device-width; initial-scale=1; maximum-scale=1">
    
		<link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
	    <link href="/favicon.png" rel="shortcut icon">
	    <link rel="canonical" href="">
		<link rel="stylesheet" type="text/css" href="/stylesheets/style.css" />
		<link rel="stylesheet" type="text/css" href="/stylesheets/syntax.css" />
		<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
		
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


	</head>

	<body>
		<div id="logo">
	<span id="tags"> 编程 / 思考 / 阅读 / 生活 </span>
	<h1><a href="/">Woodstock Blog</a></h1>
</div>
		<div id="wrapper">
			<div id="content">
				<a target="_blank" style="float:right;margin-top:15px" href="http://twitter.com/share?url=http://blog.libingcun.com/blog/2015/01/09/big-data-real-time-top-k/&via=libingcun&text=[Design] Big Data - Real Time Top k "><span class="balloon">retweet</span></a>
				<h2>[Design] Big Data - Real Time Top k </h2>
				<div class="cnt">
					<h3>Question</h3>

<p><a href="http://stackoverflow.com/questions/10189685/realtime-tracking-of-top-100-twitter-words-per-min-hour-day">link</a></p>

<blockquote><p>Given a continuous twitter feed, design an algorithm to return the 100 most
frequent words used at this minute, this hour and this day.</p></blockquote>

<h3>Analysis</h3>

<p>This is a frequent and useful problem for companies like Google and Twitter.</p>

<p>The first solution below is <strong>an approximation method</strong> which select keywords that occur more than a certain threshold.</p>

<p>The second solution is <strong>more accurate</strong> but RAM-intensive.</p>

<h3>Lossy Count</h3>

<p><strong>Solution 1 is a modified version of <a href="http://stackoverflow.com/a/8033083">Lossy Count</a></strong>. The detailed steps are explained <a href="http://stackoverflow.com/a/3260905">here</a>:</p>

<blockquote><p>Start with an empty map (red-black tree). The keys will be search terms, and the values will be a counter for the term.</p>

<ol>
<li><p>Look at each item in the stream.</p></li>
<li><p>If the term exists in the map, increment the associated counter.</p></li>
<li><p>Otherwise, if the map has fewer candidates than you&rsquo;re looking for, add it to the map with a count of one.</p></li>
<li><p>However, if the map is &ldquo;full&rdquo;, decrement the counter in each entry. If any counter reaches zero during this process, remove it from the map.</p></li>
</ol>
</blockquote>

<p><a href="http://www.cse.ust.hk/vldb2002/VLDB2002-proceedings/slides/S10P03slides.pdf">This slide show</a> explains <strong>Lossy Count</strong>, which is to divide input data into chunks. Then count elements and decrease counter by 1 after each chunk.</p>

<p><strong>Note that the result is NOT the top frequency items</strong>. Instead, the final results are <strong>order-dependent</strong>, giving heavier weight to the counts processed last. It maybe helpful in some cases, cuz we want to check the latest trend. However, if we want more accurate top keywords for all data, we will <strong>do a second pass over the log data</strong>.</p>

<p>Now let&rsquo;s discuss the threshold. Use &ldquo;aaabcd&rdquo; and map size = 2 as example. &lsquo;a&rsquo; will be inserted into map with occurance = 3. Then &lsquo;b&rsquo; is inserted, and removed. &lsquo;c&rsquo; is inserted, and removed. &rsquo;d&#8217; is inserted. Since we always decrease 1 at each step, &lsquo;a&rsquo; should only have occurance of 1 at the end. As explained <a href="http://stackoverflow.com/a/3260905">here</a>:</p>

<blockquote><p>If we limit the map to 99 entries, we are guaranteed to find any term that occurs more than 1/(1 + 99) (1%) of the time.</p></blockquote>

<p>We change the size of the map to change the threshold. The occurance of in the final result does not matter.</p>

<h3>Solution 2</h3>

<p>The lossy count does not actually produce the hourly, daily and monthly result accurately. Solution 2 will discuss how we deal with retiring old data in an accurate way.</p>

<p>Suggested by <a href="http://stackoverflow.com/a/3260768">this answer</a>, <strong>we keep a 30-day list for each keyword</strong>, that counts the daily occurance. This list is FIFO. When we remove and insert a new counter value, we update monthly total.</p>

<p>Alaternatively, <a href="http://stackoverflow.com/a/10190836">this answer</a> suggests keeping 1440 (24 * 60) HashMaps, each storing the information for one minute. <strong>And another 2 HashMap for the rolling total for the past hour, and past day</strong>.</p>

<blockquote><p>You need an array of 1440 (24*60) word+count hash maps organized the way that you describe; these are your minute-by-minute counts. You need two additional hash maps &ndash; for the rolling total of the hour and the day.</p>

<p>Define two operations on hash maps &ndash; add and subtract, with the semantic of merging counts of identical words, and removing words when their count drops to zero.</p>

<p>Each minute you start a new hash map, and update counts from the feed. At the end of the minute, you place that hash map into the array for the current minute, add it to the rolling total for the hour and for the day, and then subtract the hash map of an hour ago from the hourly running total, and subtract the hash map of 24 hours ago from the daily running total.</p></blockquote>

<p>This is a very good solution, which I would recommend as the standard solution to this &ldquo;Real Time Top k&rdquo; problem.</p>

					<br />
					--EOF--
					<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
				</div>
				<div id="disqus_thread"></div>
				

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://okckd.github.io/blog/2015/01/09/big-data-real-time-top-k/';
        var disqus_url = 'http://okckd.github.io/blog/2015/01/09/big-data-real-time-top-k/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>


			</div>
			
			<div id="footer">
				<span style="color:#bbb;font-size:12px">To do less than best is a sin.</span>
<p style="clear:both"></p>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.1/jquery.min.js"></script>
			</div>
		</div>
	</body>
</html>

