
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Woodstock Blog</title>
  <meta name="author" content="Charlie Brown">

  
  <meta name="description" content="Question Given a sorted array of strings which is interspersed with empty strings, write a method to find the location of a given string. Example: &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/6">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Woodstock Blog</a></h1>
  
    <h2>What's the good of living if you don't try a few things?</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/07/search-array-containing-empty-string/">[CC150v4] 9.5 Search Array Containing Empty String</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-07T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<blockquote><p>Given a sorted array of strings which is interspersed with empty strings, write a method to find the location of a given string.</p>

<p>Example: find “ball” in [“at”, “”, “”, “”, “ball”, “”, “”, “car”, “”, “”, “dad”, “”, “”] will return 4</p>

<p>Example: find “ballcar” in [“at”, “”, “”, “”, “”, “ball”, “car”, “”, “”, “dad”, “”, “”] will return -1</p></blockquote>

<h3>Solution</h3>

<p>The solution is binary search, but when reads empty, <strong>advance to the next non-empty string</strong>.</p>

<p>But wait, <strong>there can be a very big problem that causes looping forever</strong>. Eg.</p>

<blockquote><p>&ldquo;a&rdquo;, &ldquo;&rdquo;, &ldquo;&rdquo;, &ldquo;&rdquo;, &ldquo;c&rdquo; (5 items), look for &ldquo;b&rdquo;</p>

<p>Now &lsquo;left&rsquo; points to 1st string(&ldquo;a&rdquo;) and &lsquo;right&rsquo; points to 4th(&ldquo;&rdquo;). If we read read &lsquo;mid&rsquo; value and advance to the next non-empty string, it&rsquo;ll be &ldquo;c&rdquo;.</p>

<p>since &ldquo;c&rdquo; is large than &ldquo;b&rdquo;, &lsquo;right&rsquo; is set to the 4th index. It&rsquo;s a endless loop!</p></blockquote>

<p>There&rsquo;re various ways to solve this. The book suggests <strong>locate &lsquo;right&rsquo; pointer at non-empty string</strong> by moving left, and then <strong>locate &lsquo;mid&rsquo; pointer at non-empty</strong> by moving right. This avoids endless loop.</p>

<p>My approach is to use 2 instances of &lsquo;mid&rsquo;:</p>

<ol>
<li>calculatedMid</li>
<li>comparisonMid</li>
</ol>


<p>Both ways are fine.</p>

<h3>Code</h3>

<pre><code>public static int search(String[] input, String target) {
    if (target == null || target.length() == 0) {
        return -1;
    }
    int len = input.length;
    int left = 0, right = len - 1;
    while (left &lt; right) {
        int calculatedMid = left + (right - left) / 2;
        int comparisonMid = calculatedMid;
        while (comparisonMid &lt; len &amp;&amp; input[comparisonMid].length() == 0) {
            comparisonMid++;
        }
        if (input[comparisonMid].equals(target)) {
            return comparisonMid;
        } else if (input[comparisonMid].compareTo(target) &lt; 0) {
            left = comparisonMid + 1;
        } else {
            right = calculatedMid - 1;
        }
    }
    if (left &lt; len &amp;&amp; input[left].equals(target)) {
        return left;
    } else {
        return -1;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/07/generate-permutation-recursively/">[CC150v4] 8.4 Generate Permutation Recursively</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-07T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<blockquote><p>Write a method to compute all permutations of a string.</p>

<p>Do it recursively.</p></blockquote>

<h3>Solution</h3>

<ol>
<li><p>Get first char.</p></li>
<li><p>Permute the reminder of the string.</p></li>
<li><p>Insert that char into all possible positions.</p></li>
</ol>


<p>The code is more concise that doing it iteratively, <strong>and no visited array needed</strong>!</p>

<h3>Code</h3>

<pre><code>public static ArrayList&lt;String&gt; getPerms(String s) {
    ArrayList&lt;String&gt; ans = new ArrayList&lt;String&gt;();
    if (s.length() == 1) {
        ans.add(s);
        return ans;
    }
    char single = s.charAt(0);
    ArrayList&lt;String&gt; partialPerms = getPerms(s.substring(1));
    for (String part : partialPerms) {
        for (int i = 0; i &lt;= part.length(); i++) {
            ans.add(part.substring(0, i) + single + part.substring(i));
        }
    }
    return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/07/find-missing-number/">[CC150v4] 5.7 Find Missing Number</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-07T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<blockquote><p>An array A[1&hellip;n] contains all the integers from 0 to n except for one number which is missing. In this problem, we cannot access an entire integer in A with a single operation.</p>

<p>The elements of A are represented in binary, and the only operation we can use to access them is “fetch the jth bit of A[i]”, which takes constant time. Write code to find the missing integer. Can you do it in O(n) time?</p></blockquote>

<h3>Solution</h3>

<p><strong>This is a difficult bit operation question</strong>.</p>

<p>The main thing to understand is, for a particular bit:</p>

<blockquote><p>if the bit value of the removed number is 0, then count(0) &lt;= count(1)</p>

<p>if the bit value of the removed number is 1, then count(0) > count(1)</p></blockquote>

<p>By using this principle, we can easily find the missing value for each bit.</p>

<p><strong>However, we must know when to stop checking</strong>. For example:</p>

<blockquote><p>input: 000, 001, 011</p></blockquote>

<p>We know that the last bit is 0, second last is 1. We shall stop here and return the result &ldquo;010&rdquo;. If we did not stop, the result value would be &ldquo;110&rdquo;, which is wrong. How this is handled is by <strong>passing only half of the input list each time</strong>, and we also add one condition at the beginning:</p>

<pre><code>if (list.size() == 0)
    return 0;
</code></pre>

<p>By doing this, we always limit the input list to a smaller range, until we finish finding all bits.</p>

<h3>Code</h3>

<p><strong>hard to write</strong></p>

<pre><code>public static int findMissing(List&lt;BitInteger&gt; list) {
    return helper(list, BitInteger.INTEGER_SIZE - 1);
}

private static int helper(List&lt;BitInteger&gt; list, int col) {
    if (list.size() == 0)
        return 0;
    List&lt;BitInteger&gt; zeroList = new ArrayList&lt;BitInteger&gt;();
    List&lt;BitInteger&gt; oneList = new ArrayList&lt;BitInteger&gt;();
    for (BitInteger bit : list) {
        if (bit.fetch(col) == 0) {
            zeroList.add(bit);
        } else {
            oneList.add(bit);
        }
    }
    if (zeroList.size() &lt;= oneList.size()) {
        // this means the missing value contains a 0
        return helper(zeroList, col - 1) &lt;&lt; 1;
    } else {
        // the missing value contains 1
        return helper(oneList, col - 1) &lt;&lt; 1 | 1;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/07/cover-the-chess-board/">[Brain Teaser] 6.2 Cover the Chess Board</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-07T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<blockquote><p>There is an 8x8 chess board in which two diagonally opposite squares have been cut off. You are given 31 dominos, and a single domino can cover exactly two squares.</p>

<p>Can you use the 31 dominos to cover the entire board? Prove your answer (by providing an example, or showing why it’s impossible).</p></blockquote>

<h3>Solution</h3>

<p>The chess board initially has 32 black and 32 white squares. By removing opposite corners, we&rsquo;re left with 30 of one color and 32 of the other color.</p>

<p>31 dominos must cover 31 of one color and 31 of the other color.</p>

<p>So, impossible.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/07/convert-integer-to-binary/">[CC150v4] 5.2 Convert Integer to Binary Form</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-07T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<blockquote><p>Given a (decimal &ndash; e.g. 3.72) number that is passed in as a string, print the binary representation.</p>

<p>If the number can not be represented accurately in binary, print “ERROR”</p></blockquote>

<h3>Solution</h3>

<p>Convert the integer part is easy.</p>

<p><strong>The difficulty is how to convert a floating point (the decimal part) to binary form</strong>. The idea suggested in the book is to keep x2, and subtract 1 when necessary. Eg.</p>

<blockquote><p>0.625 x 2 = 1.25, append 1</p>

<p>0.25 x 2 = 0.5, append 0</p>

<p>0.5 x 2 = 1, append 1</p>

<p>the binary form of 0.625 would be 0.101.</p></blockquote>

<p>We must declarify the max number of digits in the decimal part. In the book, <strong>the answer assumes a maximum digits of 32 bits</strong> (i.e. when binary length grows more than 32 bits, return &ldquo;Error&rdquo;).</p>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public static String printBinary(String n) {
    String[] num = n.split("\\.");
    int integer = Integer.parseInt(num[0]);
    double decimal = Double.parseDouble("0." + num[1]);

    // now convert decimal part, if can't convert, return ERROR
    StringBuilder sb = new StringBuilder();
    while (decimal != 0) {
        if (sb.length() &gt; 32) {
            return "ERROR";
        }
        double newDoub = 2 * decimal;
        sb.append(newDoub &gt;= 1 ? "1" : "0");
        decimal = newDoub % 1;
    }

    // now convert integer part
    String intStr = "";
    while (integer != 0) {
        intStr = ((integer &amp; 1) == 1 ? "1" : "0") + intStr;
        integer = integer &gt;&gt; 1;
    }

    // return the 2 parts connected with a dot
    return intStr + "." + sb.toString();
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/06/sort-stack/">[CC150v4] 3.6 Sort Stack</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-06T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<blockquote><p>Write a program to sort a stack in ascending order. You should not make any assumptions about how the stack is implemented.</p>

<p>The following are the only functions that should be used to write this program: push | pop | peek | isEmpty.</p></blockquote>

<h3>Solution</h3>

<p>This is a very good question that tests stack operations.</p>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public static Stack&lt;Integer&gt; sort(Stack&lt;Integer&gt; s) {
    Stack&lt;Integer&gt; result = new Stack&lt;Integer&gt;();
    while (!s.isEmpty()) {
        Integer nextNum = s.pop();
        while (!result.isEmpty() &amp;&amp; result.peek() &lt; nextNum) {
            s.push(result.pop());
        }
        result.push(nextNum);
    }
    return result;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/06/print-path-sum-to-value/">[CC150v4] 4.8 Print Path Sum to Value</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-06T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<blockquote><p>You are given a binary tree in which each node contains a value. Design an algorithm to print all paths which sum up to that value. Note that it can be any path in the tree &ndash; it does not have to start at the root.</p></blockquote>

<h3>Solution</h3>

<p><strong>Keep a list of items as buffer</strong>, and check the following condition:</p>

<blockquote><p>“does this node complete a path with the sum?”</p></blockquote>

<p>There&rsquo;re n nodes in total, and the max size of buffer is lg(n), so the time complexity is O(nlgn).</p>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public static void find(TreeNode head, int target) {
    findSum(head, target, new ArrayList&lt;Integer&gt;());
}

private static void findSum(TreeNode node, int target, List&lt;Integer&gt; buffer) {
    if (node == null)
        return;

    buffer.add(node.data);
    int sum = 0;
    for (int i = buffer.size() - 1; i &gt;= 0; i--) {
        sum += buffer.get(i);
        if (sum == target) {
            // from (i)th element until the last element is a valid path
            printPath(buffer, i);
        }
    }

    List&lt;Integer&gt; clone1 = new ArrayList&lt;Integer&gt;(buffer);
    findSum(node.left, target, clone1);

    List&lt;Integer&gt; clone2 = new ArrayList&lt;Integer&gt;(buffer);
    findSum(node.right, target, clone2);
}

private static void printPath(List&lt;Integer&gt; buffer, int start) {
    System.out.print("Path: ");
    for (int i = start; i &lt; buffer.size(); i++) {
        System.out.print(buffer.get(i) + " ");
    }
    System.out.println();
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/06/hanoi-tower/">[CC150v4] 3.4 Towers of Hanoi</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-06T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<blockquote><p>In the classic problem of the Towers of Hanoi, you have 3 rods and N disks of di!erent sizes which can slide onto any tower. The puzzle starts with disks sorted in ascending order of size from top to bottom (e.g., each disk sits on top of an even larger one). You have the following constraints:</p></blockquote>

<ol>
<li>Only one disk can be moved at a time.</li>
<li>A disk is slid o! the top of one rod onto the next rod.</li>
<li>A disk can only be placed on top of a larger disk.</li>
</ol>


<blockquote><p>Write a program to move the disks from the &ldquo;rst rod to the last using Stacks.</p></blockquote>

<h3>Solution</h3>

<p>This is a <strong>classic recursive question</strong>. The solution code is supposed to be very concise.</p>

<h3>Code</h3>

<p><strong>written by me</strong>, slightly different from the answer in the book, but good.</p>

<p>Main class:</p>

<pre><code>public class HanoiMyAnswer {

    private static Rod r0, r1, r2;
    private static final int NUM_DISKS = 5;

    public static void main(String[] args) {
        // Hanoi Tower always have 3 rods
        r0 = new Rod(0);
        r1 = new Rod(1);
        r2 = new Rod(2);

        // Put some disks on the 1st rod, leaving 2nd and 3rd rod empty
        r0.setDisks(NUM_DISKS);

        // start main algorithm
        System.out.println("My answer: ");
        moveDisks(NUM_DISKS, r0, r2, r1);
    }

    private static void moveDisks(int number, Rod from, Rod to, Rod buffer) {
        if (number == 1) {
            int topValue = from.disks.pop();
            to.disks.push(topValue);
            displayMessage(topValue, from.name, to.name);
        } else {
            moveDisks(number - 1, from, buffer, to);
            int bottomValue = from.disks.pop();
            to.disks.push(bottomValue);
            displayMessage(bottomValue, from.name, to.name);
            moveDisks(number - 1, buffer, to, from);
        }
    }

    private static void displayMessage(int disk, int from, int to) {
        System.out.println("Disk[" + disk + "]: Rod" + from + "--&gt;" + to);
    }
}
</code></pre>

<p>Rod.java</p>

<pre><code>class Rod {

    int name;
    Stack&lt;Integer&gt; disks = new Stack&lt;Integer&gt;();

    public Rod(int rodIndex) {
        this.name = rodIndex;
    }

    public void setDisks(int n) {
        // this method will insert n disks on this Rod
        // the bottom disk is indexed as (n-1) and top one is 0
        disks.clear();
        for (int i = n - 1; i &gt;= 0; i--) {
            disks.push(i);
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/06/find-next-node-bst/">[CC150v4] 4.5 Find Next Node in BST</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-06T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<blockquote><p>Write an algorithm to find the ‘next’ node (i.e., in-order successor) of a given node in a binary search tree where each node has a link to its parent.</p></blockquote>

<h3>Solution</h3>

<ol>
<li><p><strong>If current node have a right child</strong>, return the leftmost leaf of right child.</p></li>
<li><p><strong>If current node have no right child</strong>:</p>

<ol>
<li><p>If current is parent&rsquo;s left child, then return parent node.</p></li>
<li><p>If current is parent&rsquo;s right child, look all the way up until find a right-turning parent.</p></li>
<li><p>If all parent is not right-turning. Return null.</p></li>
</ol>
</li>
</ol>


<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public static TreeNode inorderSucc(TreeNode e) {
    if (e == null)
        return null;
    if (e.right != null) {
        TreeNode p = e.right;
        while (p.left != null) {
            p = p.left;
        }
        return p;
    } else {
        TreeNode p = e.parent;
        while (p != null &amp;&amp; p.right == e) {
            e = p;
            p = e.parent;
        }
        return p;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/06/check-subtree/">[CC150v4] 4.7 Check Subtree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-06T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<blockquote><p>You have two very large binary trees: T1, with millions of nodes, and T2, with hundreds of nodes. Create an algorithm to decide if T2 is a subtree of T1.</p></blockquote>

<h3>Solution 1</h3>

<p><strong>The best solution is to print inorder and preorder traversal</strong> of both trees. Find whether the 2 traversal string of T2 <strong>is substring of the traversal of T1</strong>. This is a very good idea of checking subtree of a Binary Tree.</p>

<p><strong>Updated on Sep 15th, 2014</strong>: we must use sentinals for this purpose. Otherwise, if a node have a child, we cannot tell whether it&rsquo;s the left or right child.</p>

<p>However, this solution is very <strong>memory intensive</strong>.</p>

<h3>Solution 2</h3>

<p><strong>The alternative solution</strong> simply checks the tree similarity for each and every node.</p>

<p>Time complexity:</p>

<p>If k is the number of occurrences of T2’s root in T1, the worst case runtime can be characterized as O(n + k * m).</p>

<p><strong>However, there can be a lot of pruning for this solution</strong>, so it&rsquo;s NOT necessarily slower than Solution 1. There can be a lot of discussions on this (<strong>refer to CC150v5 Q4.8 for more</strong>).</p>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public static boolean containsTree(TreeNode t1, TreeNode t2) {
    if (t1 == null) {
        return false;
    } else if (matchTree(t1, t2)) {
        return true;
    } else {
        return containsTree(t1.left, t2) || containsTree(t1.right, t2);
    }
}

private static boolean matchTree(TreeNode t1, TreeNode t2) {
    if (t2 == null) {
        return true;
    } else if (t1 == null) {
        return false;
    } else if (t1.data != t2.data) {
        return false;
    } else {
        return matchTree(t1.left, t2.left) &amp;&amp; matchTree(t1.right, t2.right);
    }
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/7">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/5">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/classic/'>classic (3)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (51)</a></li>
<li class='category'><a href='/blog/categories/facebook/'>facebook (4)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (35)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (156)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>octopress (1)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (86)</a></li>
<li class='category'><a href='/blog/categories/string-search/'>string search (5)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (7)</a></li>
<li class='category'><a href='/blog/categories/top-k/'>top k (5)</a></li>
<li class='category'><a href='/blog/categories/twitter/'>twitter (3)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/10/08/interleave-positive-negative/">[Question] Interleave Positive and Negative Numbers</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/03/Leetcode-third-1/">[Leetcode] Leetcode Third Round (1)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/02/longest-word-made-from-other/">[CC150v5] 18.7 Longest Word Made From Other Words</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/01/optimal-unconcatenate-doc/">[CC150v5] 17.14 Optimal Way to Unconcatenate Doc</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/30/convert-bst-doubly-linked-list/">[CC150v5] 17.13 Convert BST to Doubly-Linked List</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Charlie Brown -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
