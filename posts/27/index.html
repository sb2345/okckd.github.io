
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="Question link Given a sorted array of integers, find the starting and ending position of a given target value. Your algorithm&#8217;s runtime &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/27">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Search-for-a-Range/">[LeetCode 34] Search for a Range</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/search-for-a-range/">link</a></p>

<div class="question-content">
            <p></p><p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>

<p>Your algorithm&#8217;s runtime complexity must be in the order of <i>O</i>(log <i>n</i>).</p>

<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>

<p>
For example,<br>
Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>
return <code>[3, 4]</code>.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">Difficult</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>The key to solve this problem is binary search</strong>. Previously my solution is to find the element first, then check left bound and right bound 1 by 1. In worst case, this will take O(n) time. I wrote the code in 20 minutes and passed, but unfortunately, this is not the correct solution.</p>

<p>There are many possible binary search solutions, and I will list out 2 solutions from the Internet.</p>

<p><strong>First solution is from <a href="http://xixiaogualu.blogspot.sg/2013/09/search-for-range.html">this blog</a></strong>. Using binary search to search twice &ndash; once for left bound, and once for right bound. Code is below.</p>

<p><strong>Second solution is from <a href="http://rleetcode.blogspot.sg/2014/02/search-for-range-java.html">this blog</a></strong>. This idea is still using binary search, but a tricky way. Instead of searching the number, it searches (number &ndash; 0.5) and (number + 0.5).</p>

<h3>Solution</h3>

<p>I will not explains the code, since it&rsquo;s easy to understand (but hard to write). It&rsquo;s important that I <strong>practice implementing this code by myself</strong> some time.</p>

<h3>My code</h3>

<p>Solution 1</p>

<pre><code>public int[] searchRange(int[] A, int target) {
    int i = 0, j = A.length - 1;
    int[] result = { -1, -1 };
    // the idea is to put the lower bound in i
    while (i &lt; j) {
        int mid = i + (j - i) / 2;
        if (target &lt;= A[mid]) j = mid;
        else i = mid + 1;
    }
    if (A[i] == target) result[0] = i;
    else return result;
    i = 0; 
    j = A.length;
    // the idea is to put the upper bound in j-1
    while (i &lt; j) {
        int mid = i + (j - i) / 2;
        if (target &gt;= A[mid]) i = mid + 1;
        else j = mid;
    }
    result[1] = j - 1;
    return result;
}
</code></pre>

<p>Solution 2</p>

<pre><code>public int[] searchRange(int[] A, int target) {
    if (A == null) return null;
    int[] result = { -1, -1 };
    int low = binarySearch(A, target - 0.5);
    // Be care for there , low&gt;=A.length must be checked
    if (low &gt;= A.length || A[low] != target) return result;
    result[0] = low;
    result[1] = binarySearch(A, target + 0.5) - 1;
    return result;
}

public int binarySearch(int[] A, double t) {
    int low = 0, high = A.length - 1;
    while (low &lt;= high) {
        int m = (low + high) / 2;
        if (A[m] &lt; t) low = m + 1;
        if (A[m] &gt; t) high = m - 1;
    }
    return low;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Search-Insert-Position/">[LeetCode 35] Search Insert Position</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/search-insert-position/">link</a></p>

<div class="question-content">
            <p></p><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>

<p>You may assume no duplicates in the array.</p>

<p>
Here are few examples.<br>
<code>[1,3,5,6]</code>, 5 → 2<br>
<code>[1,3,5,6]</code>, 2 → 1<br>
<code>[1,3,5,6]</code>, 7 → 4<br>
<code>[1,3,5,6]</code>, 0 → 0
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very basic, yet very difficult question</strong>. It is not easy to get it correct within less then 3 attempts.</p>

<h3>Solution</h3>

<p>I post 2 solutions, first written by me, second copied from <a href="http://blog.csdn.net/fightforyourdream/article/details/14216321">this blog</a>. Both works the same.</p>

<h3>My code</h3>

<pre><code>public int searchInsert(int[] A, int target) {
    int len = A.length;
    if (len == 0) return 0;
    int left = 0, right = len - 1;
    while (left &lt; right) {
        int mid = (left + right) / 2;
        if (A[mid] &gt;= target) right = mid;
        else left = mid + 1;
    }
    if (A[left] &lt; target) return left + 1;
    return left;
}
</code></pre>

<p>Another code</p>

<pre><code>public int searchInsert(int[] A, int target) {
    int len = A.length;
    if (len == 0) return 0;
    int left = 0, right = len - 1;
    while (left &lt;= right) {
        int mid = (left + right) / 2;
        if (A[mid] &gt; target) right = mid - 1;
        else if (A[mid] &lt; target) left = mid + 1;
        else return mid;
    }
    return left;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Next-Permutation/">[LeetCode 31] Next Permutation</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/next-permutation/">link</a></p>

<div class="question-content">
            <p></p><p>
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
</p>
<p>
If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).
</p>
<p>
The replacement must be in-place, do not allocate extra memory.
</p>
<p>
Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br>
<code>1,2,3</code> → <code>1,3,2</code><br>
<code>3,2,1</code> → <code>1,2,3</code><br>
<code>1,1,5</code> → <code>1,5,1</code><br>
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">half hour</td>
    </tr>
</table>


<h3>Analysis</h3>

<p><strong>There is only 1 popular solution on the Internet</strong>, which is same as mine.</p>

<p>The image below explains it very well (for the input number &ldquo;687432&rdquo;).</p>

<p><img class="middle" src="/assets/images/next_permutation.png"></p>

<h3>Solution</h3>

<p>My first attempted code is a bit lenthy but works perfectly.</p>

<p>Second time, I read <a href="http://blog.csdn.net/havenoidea/article/details/12176737">this blog</a> and optimized my code. It&rsquo;s same solution, actually.</p>

<h3>My code</h3>

<p>My first code.</p>

<pre><code>public void nextPermutation(int[] num) {
    if (num.length &lt; 2) return;
    // locate 2 pointers: m and n
    int m = num.length - 2;
    while (m &gt;= 0 &amp;&amp; num[m] &gt;= num[m+1]) m --;
    if (m == -1) {
        Arrays.sort(num);
        return;
    }
    int n = num.length - 1;
    while (num[n] &lt;= num[m]) n --;
    // now number pointer by m and n should be swopped
    num = swopNum(num, m, n);
    // then, head and tail swop from position (m+1) to the end
    int left = m + 1, right = num.length - 1;
    while (left &lt; right)
        num = swopNum(num, left++, right--);
}

private int[] swopNum(int[] num, int a, int b) {
    num[a] = num[a] + num[b];
    num[b] = num[a] - num[b];
    num[a] = num[a] - num[b];
    return num;
}
</code></pre>

<p>Second time code.</p>

<pre><code>public void nextPermutation(int[] num) {
    int len = num.length;
    if (len &lt; 2) return;
    int posStartReverse = 0, last = len - 1;
    for (int i = len - 2; i &gt;= 0; i --) {
        if (num[i] &gt;= num[i+1]) continue;
        for (int j = len - 1; j &gt; i; j --) 
            if (num[i] &lt; num[j]) {
                swapNum(num, i, j);
                break;
            }
        posStartReverse = i + 1;
        break;
    }
    while (posStartReverse &lt; last) swapNum(num, posStartReverse++, last--);
}

private int[] swapNum(int[] num, int a, int b) {
    num[a] = num[a] + num[b];
    num[b] = num[a] - num[b];
    num[a] = num[a] - num[b];
    return num;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Longest-Valid-Parentheses/">[LeetCode 32] Longest Valid Parentheses</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/longest-valid-parentheses/">link</a></p>

<div class="question-content">
            <p></p><p>Given a string containing just the characters <code>'('</code> and <code>')'</code>, find the length of the longest valid (well-formed) parentheses substring.
</p>
<p>
For <code>"(()"</code>, the longest valid parentheses substring is <code>"()"</code>, which has length = 2.
</p>
<p>
Another example is <code>")()())"</code>, where the longest valid parentheses substring is <code>"()()"</code>, which has length = 4.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<h3>Analysis</h3>

<p><strong>There are 2 ways to solve this problem</strong>, stack and DP. I will <strong>not cover DP for now</strong>, but this can be a future task.</p>

<p>There are various way to solve this problem with stack.</p>

<h3>Solution</h3>

<p><strong>Stack method 1 is more straight-forward</strong> (code shown below). The idea is to keep a stack of &ldquo;(&rdquo; indexes, and another variable called &ldquo;last&rdquo;. <strong>Note that only &ldquo;)&rdquo; can violates a pattern</strong>. So whenever I see a &ldquo;(&rdquo;, just push to stack. When the pattern is violated by a &ldquo;)&rdquo;, I update last. The code explains itself very well. If not, <a href="http://discuss.leetcode.com/questions/212/longest-valid-parentheses/1488">look here</a></p>

<p><strong>Stack method 2 is more tricky</strong>. This time I will not only push the index of &ldquo;(&rdquo; to stack, but also the index of &ldquo;)&rdquo; when the pattern got violated. It&rsquo;s hard to explain, and hard to think of at first.</p>

<p><strong>The DP solution is not very difficult</strong>. Basically create an array of same length as string s. dp[i] denotes the length of valid parenthese ending with index i. The idea is similar to <a href="http://blog.csdn.net/abcbc/article/details/8826782">this blog</a>, but he used reverse DP, and I use normal DP.</p>

<p>I will explain DP with an example of input &ldquo;<strong>)()()</strong>&rdquo;. For this string, we have <strong>dp[0] = 0, dp[1] = 0, dp[2] = 2, dp[3] = 0</strong>. For dp[4], I check the 3rd position first, and find that dp[4] = 2. Then I also have to add dp[2] into dp[4] to make it complete. The end result is dp[4] = 2 + 2 = 4.</p>

<h3>My code</h3>

<p>Stack method 1</p>

<pre><code>public int longestValidParentheses(String s) {
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    int last = -1, max = 0;
    char[] ss = s.toCharArray();
    for (int i = 0; i &lt; ss.length; i++) {
        if (ss[i] == '(') stack.push(i);
        else if (stack.isEmpty()) last = i;
        else {
            stack.pop();
            if (stack.isEmpty()) max = Math.max(max, i - last);
            else max = Math.max(max, i - stack.peek());
        }
    }
    return max;
}
</code></pre>

<p>Stack method 2</p>

<pre><code>public int longestValidParentheses(String s) {
    int res = 0;
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    char[] arr = s.toCharArray();
    for (int i = 0; i &lt; arr.length; i++) {
        if (arr[i] == ')' &amp;&amp; !stack.isEmpty() &amp;&amp; arr[stack.peek()] == '(') {
            stack.pop();
            if (stack.isEmpty()) res = i + 1;
            else res = Math.max(res, i - stack.peek());
        } else stack.push(i);
    }
    return res;
}
</code></pre>

<p>DP solution</p>

<pre><code>public int longestValidParentheses(String s) {
    int len = s.length();
    if (len &lt;= 1) return 0;
    int max = Integer.MIN_VALUE;
    int[] dp = new int[len];
    for (int i = 1; i &lt; len; i ++) {
        if (s.charAt(i) == '(') dp[i] = 0;
        else {
            int j = i - 1 - dp[i - 1];
            if (j &gt;= 0 &amp;&amp; s.charAt(j) =='(') {
                dp[i] = dp[i - 1] + 2;
                if (j &gt;= 1) dp[i] += dp[j - 1];
            }
            else dp[i] = 0;
        }
        max = Math.max(max, dp[i]);
    }
    return max;
}
</code></pre>

<p><strong>Updated on July 18th, 2014</strong>, rewrite the stack method 1.</p>

<pre><code>public int longestValidParentheses(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    int start = -1;
    int longest = 0;
    char[] input = s.toCharArray();
    for (int i = 0; i &lt; input.length; i++) {
        if (input[i] == '(') {
            stack.push(i);
        } else if (input[i] == ')' &amp;&amp; stack.isEmpty()) {
            start = i;
        } else if (input[i] == ')') {
            stack.pop();
            if (stack.isEmpty()) {
                longest = Math.max(longest, i - start);
            } else {
                longest = Math.max(longest, i - stack.peek());
            }
        }
    }
    return longest;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/11/Reverse-Nodes-in-k-Group/">[LeetCode 25] Reverse Nodes in k-Groups</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-11T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/reverse-nodes-in-k-group/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a linked list, reverse the nodes of a linked list <i>k</i> at a time and return its modified list.
</p>

<p>
If the number of nodes is not a multiple of <i>k</i> then left-out nodes in the end should remain as it is.</p>

<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>

<p>Only constant memory is allowed.</p>

<p>
For example,<br>
Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>
</p>

<p>
For <i>k</i> = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code>
</p>

<p>
For <i>k</i> = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code>
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">having some difficulty</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>I solved this problem at first, but second time when I try to do it again, I am faced with great difficulty (maybe I didn&rsquo;t slept well laterly?).</p>

<p><strong>The problem is solved in 2 steps</strong>. First, get the next k-group. If remaining items is less than k, terminate the program. Otherwise, reserve this k-group and keep going.</p>

<p>To solve this question is very tricky. <strong>We need to be clear about this: 4 nodes need to be kept track of</strong>: 2 elements before and after the k-group, and 2 elements within the k-group.</p>

<p><strong>The difficult point is while and after reverse the k-group</strong>, how to maintain the &lsquo;pre&rsquo; node and future &lsquo;pre&rsquo; node correctly.</p>

<h3>Solution</h3>

<p>Used template to solve.</p>

<h3>My code</h3>

<p>A standard solution from <a href="http://blog.csdn.net/linhuanmars/article/details/19957455">this blog</a></p>

<pre><code>public ListNode reverseKGroup(ListNode head, int k) {  
    if(head == null) return null;
    ListNode dummy = new ListNode(0);  
    dummy.next = head;  
    int count = 0;  
    ListNode pre = dummy, cur = head;  
    while(cur != null) {  
        cur = cur.next;
        if(++count == k) {
            pre = reverse(pre, cur);  
            count = 0; 
        }
    }
    return dummy.next;  
}  
private ListNode reverse(ListNode pre, ListNode end) {
    ListNode head = pre.next;  
    ListNode cur = pre.next.next;  
    while(cur!=end) {  
        ListNode next = cur.next;  
        cur.next = pre.next;  
        pre.next = cur;  
        cur = next;  
    }  
    head.next = end;  
    return head;  
} 
</code></pre>

<p><strong>Updated on June 21st, 2014</strong>, I used Linkedlist Template from NineChap and solved this problem fast and neat!</p>

<pre><code>public ListNode reverseKGroup(ListNode head, int k) {
    ListNode p = head;
    int count = 0;
    while (p != null) {
        p = p.next;
        count++;
    }
    return helper(head, k, count);
}

public ListNode helper(ListNode head, int k, int count) {
    if (head == null || k &lt; 1 || count &lt; k) {
        return head;
    }
    ListNode result = null;
    ListNode cur = head;
    for (int i = 0; i &lt; k; i++) {
        if (cur == null) break;
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
    }
    head.next = helper(cur, k, count - k);
    return result;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/11/Merge-k-Sorted-Lists/">[LeetCode 23] Merge K Sorted Lists</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-11T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/merge-k-sorted-lists/">link</a></p>

<div class="question-content">
            <p></p><p>
Merge <i>k</i> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">Difficult</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>There are two ways to solve this problem.</p>

<ul>
<li>k &ndash; number of lists</li>
<li>n &ndash; String length of each list</li>
</ul>


<p><strong>First approach is merge sort</strong>. Using divide and conquer approach, divide the entire input into halves, and then merge 2 list each time. Instead of merging 1 by 1 which the time complexity is O(nk x (k-1)), the 2 lists to be merged is always similar length, thus time complexity is reduced to O(nk x logk).</p>

<p><strong>You may wonder how I calculate time complexity</strong>. See, each round of sort, nk nodes are read and sorted. This happened O(logk) times, where k is the number of lists. Thus totoal time take is O(nk x logk).</p>

<p><strong>Second approach is heap sort</strong>. The idea of this is to always keep a sorted list of the head of each list. But before the code, what actually is heap/priority queue?</p>

<blockquote><p><strong><a href="http://en.wikipedia.org/wiki/Heap_%28data_structure%29">Heap</a> is a specialized tree-based data structure</strong>. Heap is crucial in Dijkstra&rsquo;s algorithm and heapsort.</p>

<p>We take max heap for example. The keys of parent nodes are always greater than or equal to the children node.</p>

<p><strong>The heap is an implementation of priority queue</strong>. In fact, priority queues are often referred to as &ldquo;heaps&rdquo;, regardless of how they may be implemented.</p>

<p>Note that despite the similarity of the name &ldquo;heap&rdquo; to &ldquo;stack&rdquo; and &ldquo;queue&rdquo;, the latter two are <strong>abstract data types</strong>, while a heap is a <strong>specific data structure</strong>, and &ldquo;priority queue&rdquo; is the proper term for the abstract data type.</p></blockquote>



<table class="tg">
  <tr>
    <th class="tg-s6z2">Heap</th>
    <th class="tg-s6z2">Time</th>
  </tr>
  <tr>
    <td class="tg-031e">Find max</td>
    <td class="tg-s6z2">O(1)</td>
  </tr>
  <tr>
    <td class="tg-031e">Delete</td>
    <td class="tg-s6z2">O(lgn)</td>
  </tr>
  <tr>
    <td class="tg-031e">Insert</td>
    <td class="tg-s6z2">O(lgn)</td>
  </tr>
  <tr>
    <td class="tg-031e">Merge</td>
    <td class="tg-s6z2">O(n)</td>
  </tr>
</table>


<br />


<p>Both method are well explained in <a href="http://blog.csdn.net/linhuanmars/article/details/19899259">this csdn blog</a>. Time complexity analysis is given by <a href="http://n00tc0d3r.blogspot.sg/2013/04/merge-k-sorted-lists.html">nootcoder blog</a>.</p>

<h3>Solution</h3>

<p>First, divide and conquer code is lengthy but medium difficulty.</p>

<p>Second solution, however, is not as easy. <strong>Especially when we have to write Comparator on our own</strong>.  A priority queue (heap) is implemented and head of each list is inserted into the heap. Then poll elements out from the heap until heap is empty.</p>

<h3>My code</h3>

<p>Merge sort code.</p>

<pre><code>public ListNode mergeKLists(List&lt;ListNode&gt; lists) {
    if (lists == null || lists.size() == 0) {
        return null;
    }
    return mergeHelper(lists, 0, lists.size() - 1);
}

private ListNode mergeHelper(List&lt;ListNode&gt; lists, int start, int end) {
    if (start == end) {
        return lists.get(start);
    } 
    int mid = start + (end - start) / 2;
    ListNode firstHalf = mergeHelper(lists, start, mid);
    ListNode secondHalf = mergeHelper(lists, mid + 1, end);
    return mergeTwo(firstHalf, secondHalf);
}

private ListNode mergeTwo(ListNode head1, ListNode head2) {
    ListNode dummy = new ListNode(0);
    ListNode p = dummy;
    while (head1 != null &amp;&amp; head2 != null) {
        if (head1.val &lt; head2.val) {
            p.next = head1;
            head1 = head1.next;
            p = p.next;
        } else {
            p.next = head2;
            head2 = head2.next;
            p = p.next;
        }
    }
    if (head1 == null) {
        p.next = head2;
    } else {
        p.next = head1;
    }
    return dummy.next;
}
</code></pre>

<p>Heap sort code, written by me. <a href="http://answer.ninechapter.com/solutions/merge-k-sorted-lists/">source</a></p>

<p><strong>Look at how a Comparator is implemented</strong>!</p>

<pre><code>private Comparator&lt;ListNode&gt; listNodeComparator = new Comparator&lt;ListNode&gt;() {
    public int compare(ListNode o1, ListNode o2) {
        return o1.val - o2.val;
    }
};

public ListNode mergeKLists(List&lt;ListNode&gt; lists) {
    if (lists == null || lists.size() == 0) {
        return null;
    }
    Queue&lt;ListNode&gt; heap = new PriorityQueue&lt;ListNode&gt;(lists.size(),
            listNodeComparator);
    for (ListNode node : lists) {
        if (node != null) {
            heap.add(node);
        }
    }
    ListNode dummy = new ListNode(0);
    ListNode p = dummy;
    while (!heap.isEmpty()) {
        ListNode smallest = heap.poll();
        p.next = smallest;
        p = p.next;
        if (smallest.next != null) {
            heap.add(smallest.next);
        }
    }
    return dummy.next;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/10/Substring-with-Concatenation-All-Words/">[LeetCode 30] Substring With Concatenation of All Words</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/substring-with-concatenation-of-all-words/">link</a></p>

<div class="question-content">
            <p></p><p>
You are given a string, <b>S</b>, and a list of words, <b>L</b>, that are all of the same length. Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters.
</p>

<p>
For example, given:<br>
<b>S</b>: <code>"barfoothefoobarman"</code><br>
<b>L</b>: <code>["foo", "bar"]</code>
</p>

<p>
You should return the indices: <code>[0,9]</code>.<br>
(order does not matter).
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">more than hour</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>There are 2 ways to solve this question. <strong>The naive approach takes around 1200ms to pass</strong>, and <strong>the KPM-like approach takes around half of that time</strong>. Both methods are explained well in <a href="http://n00tc0d3r.blogspot.sg/2013/06/substring-with-concatenation-of-all.html">this blog</a>.</p>

<h4>The HashMap</h4>

<p>Before the solution, I will like to do a recap on <strong>HashMap</strong>.</p>

<blockquote cite="http://www.sparknotes.com/cs/searching/hashtables/section1.html">
<div>
<a href="http://www.sparknotes.com/cs/searching/hashtables/section1.html">link</a>
</div>
<p>
A hash table is made up of two parts: an array (the actual table where the data to be searched is stored) and a mapping function, known as a hash function. 
</p>
<p>
The hash function is a mapping from the input space to the integer space that defines the indices of the array. In other words, the hash function provides a way for assigning numbers to the input data such that the data can then be stored at the array index corresponding to the assigned number.
</p>
</blockquote>


<p>For example, if I want to store &lt;&ldquo;Durant&rdquo;>, I pass &ldquo;Durant&rdquo; into the hash function, and get (let&rsquo;s say) number 3. So in the Hash Table, it will store table(3 &ndash;> &ldquo;Durant&rdquo;).</p>

<p>In this way, the <strong>searching of HashMap can almost achieve  O(1) time in best case</strong> (like array access).</p>

<p>However,</p>

<blockquote cite="http://stackoverflow.com/a/9214421">
<div>
<a href="http://stackoverflow.com/a/9214421">link</a>
</div>
<p>
For average case, It really is (as the wikipedia page says) O(1+n/k) where K is the hash table size. If K is large enough, then the result is effectively O(1). But suppose K is 10 and N is 100. In that case each bucket will have on average 10 entries, so the search time is definitely not O(1); it is a linear search through up to 10 entries.
</p>
</blockquote>


<p>In practise, we will just assume search in HashMap always O(1).</p>

<p>Below is a great conclusion.</p>

<blockquote cite="http://stackoverflow.com/a/9214594">
<div>
<a href="http://stackoverflow.com/a/9214594">link</a>
</div>
<p><a href="http://en.wikipedia.org/wiki/Hash_table">Hash tables</a> are <code>O(1)</code> <strong>average and <a href="http://en.wikipedia.org/wiki/Amortized_analysis">amortized</a></strong> case complexity, however is suffers from <code>O(n)</code> <strong>worst case</strong> time complexity. [And I think this is where your confusion is]</p>

<p>Hash tables suffer from <code>O(n)</code> worst time complexity due to two reasons:</p>

<ol>
<li>If too many elements were hashed into the same key: looking inside this key may take <code>O(n)</code> time.</li>
<li>Once a hash table has passed its <a href="http://en.wikipedia.org/wiki/Load_balancing_%28computing%29">load balance</a> - it has to rehash [create a new bigger table, and re-insert each element to the table]. </li>
</ol>

<p>However, it is said to be <code>O(1)</code> average and amortized case because:</p>

<ol>
<li>It is very rare that many items will be hashed to the same key [if you chose a good hash function and you don&#8217;t have too big load balance.</li>
<li>The rehash operation, which is <code>O(n)</code>, can at most happen after <code>n/2</code> ops, which are all assumed <code>O(1)</code>: Thus when you sum the average time per op, you get : <code>(n*O(1) + O(n)) / n) = O(1)</code></li>
</ol>
</blockquote>


<h3>Solution</h3>

<p><strong>The naive approach uses a HashMap</strong>. Reason 1 is because there can be duplications in L, and reason 2 is the searching is faster.</p>

<p><strong>Time complexity of this solution is O((n &ndash; k * m) x m)</strong>, and <strong>space is the size of list L, O(m)</strong>. If m is not very big, the time can be regarded as O(n).</p>

<p><strong>some variables used in this question</strong>.</p>

<ul>
<li>n &ndash; length of the input string</li>
<li>L &ndash; a list of words (dictionary)</li>
<li>m &ndash; the size of L</li>
<li>k &ndash; the length of each word in L (all words have same length)</li>
<li>(k * m) &ndash; this is the length of a possible concatenation</li>
<li>(n &ndash; k * m) &ndash; this is the number of possible concatenation exist</li>
</ul>


<h3>My code</h3>

<p><strong>Updated on July 7th</strong>, code.</p>

<pre><code>public List&lt;Integer&gt; findSubstring(String S, String[] L) {
    List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();
    if (S == null || L == null || S.length() == 0 || L.length == 0) {
        return ans;
    }
    HashMap&lt;String, Integer&gt; set = new HashMap&lt;String, Integer&gt;();
    for (String str: L) {
        if (set.containsKey(str)) {
            set.put(str, set.get(str) + 1);
        } else {
            set.put(str, 1);
        }
    }
    int num = L.length;
    int len = L[0].length();
    for (int i = 0; i &lt;= S.length() - num * len; i++) {
        // start from i, check (num) words of length (len)
        HashMap&lt;String, Integer&gt; setCopy = new HashMap&lt;String, Integer&gt;(set);
        for (int j = 0; j &lt; num; j++) {
            String cur = S.substring(i + j * len, i + (j + 1) * len);
            if (setCopy.containsKey(cur)) {
                if (setCopy.get(cur) == 1) {
                    setCopy.remove(cur);
                } else {
                    setCopy.put(cur, setCopy.get(cur) - 1);
                }
            } else {
                break;
            }
        }
        if (setCopy.isEmpty()) {
            ans.add(i);
        }
    }
    return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/10/Implement-strStr/">[LeetCode 28] Implement strStr</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/implement-strstr/">link</a></p>

<div class="question-content">
            <p></p><p>
Implement strStr().
</p>
<p>
Returns a pointer to the first occurrence of needle in haystack, or <b>null</b> if needle is not part of haystack.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">KMP is difficult</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>There are 2 ways to solve this problem. <strong>The most easy and common way</strong> is to use nested loop (many online solutions use this method).</p>

<p>However, <strong>this question can also be solved by <a href="http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">KPM algorithm</a></strong>.</p>

<h3>Solution</h3>

<p>I post my standard solution below. This is the most standard solution online, for example it is in <a href="http://goo.gl/2MNOS2">this post</a>.</p>

<p><strong>I have yet to written KPM solution</strong>. <a href="http://discuss.leetcode.com/questions/76/implement-strstr">This blog</a> and <a href="http://fisherlei.blogspot.sg/2012/12/leetcode-implement-strstr.html">this blog</a> have good KMP solution posted.</p>

<h3>My code</h3>

<p><strong>Simple solution</strong></p>

<pre><code>public String strStr(String haystack, String needle) {
        if (needle.length() == 0) return haystack;
        for (int i = 0; i &lt;= haystack.length() - needle.length(); i ++) {
                if (haystack.charAt(i) != needle.charAt(0)) continue;
                int j = 0;
                for (; j &lt; needle.length(); j ++) {
                        if (haystack.charAt(i + j) != needle.charAt(j)) break;
                }
                if (j == needle.length()) return haystack.substring(i);
        }
        return null;
}
</code></pre>

<p><strong>KPM solution</strong></p>

<p>Only need to understand to principles.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/10/Divide-Two-Integers/">[LeetCode 29] Divide Two Integers</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/divide-two-integers/">link</a></p>

<div class="question-content">
            <p></p><p>
Divide two integers without using multiplication, division and mod operator.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">really long time</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question is more difficult than you thought</strong>!</p>

<p>I had little experience with <strong>Java bit operation</strong>, so I was struggling in the beginning. I&rsquo;m still not good at it now. Below is a quick tutorial on this topic.</p>

<table border="2">
  <tr>
    <th>operator</th>
    <th>what is means</th>
  </tr>
  <tr>
    <td>~</td>
    <td>invert every bit</td>
  </tr>
  <tr>
    <td>&lt;&lt;</td>
    <td>shift left (same as *2)</td>
  </tr>
  <tr>
    <td>&gt;&gt;</td>
    <td>signed shift right</td>
  </tr>
  <tr>
    <td>&gt;&gt;&gt;</td>
    <td>unsigned shift right</td>
  </tr>
  <tr>
    <td>^</td>
    <td>XOR</td>
  </tr>
  <tr>
    <td>|</td>
    <td>OR</td>
  </tr>
</table>


<br />


<p>Note the unsigned right shift operator &ldquo;>>>&rdquo; shifts a <strong>zero into the leftmost position</strong>, while the leftmost position after &ldquo;>>&rdquo; <strong>depends on sign extension</strong>.</p>

<p>After the knowledge barriers of big operation is cleared, this problem basically is <strong>a while loop that keeps subtracting (divisor * (2 ^ n)) from dividend</strong>. There is various ways to do it.</p>

<p><strong>But remember that overflow always can happen</strong>, especially when you dealing with Integer.MAX_VALUE and Integer.MIN_VALUE.</p>

<h3>Solution</h3>

<p>I will post 2 solutions, <strong>first of which is written by me</strong> using the idea from <a href="http://leetcodenotes.wordpress.com/2013/10/19/divide-two-integers/">this blog</a>. This is also the most common solution from the net.</p>

<p><strong>Second solution is from</strong> <a href="http://discuss.leetcode.com/questions/209/divide-two-integers/385">this post</a> and I translated the c++ into Java with a bit refactoring work. This code is extremely concise and beautiful.</p>

<h3>My code</h3>

<p><strong>First code is written by me</strong>. Please take a look at this line:</p>

<blockquote><p>a = 0 &ndash; (long) dividend;</p></blockquote>

<p>Previously I was using the 2 pieces of code below, and both won&rsquo;t work:</p>

<blockquote><p>a = dividend * -1;</p>

<p>a = 0 &ndash; dividend;</p></blockquote>

<p>Some extra attentions should be taken on this.</p>

<pre><code>public int divide(int dividend, int divisor) {
    long sign = 1, a = dividend, b = divisor;
    if (dividend &lt; 0) {
        sign *= -1;
        // this is where caused my error for last submission
        a = 0 - (long) dividend;
    }
    if (divisor &lt; 0) {
        sign *= -1;
        b = 0 - (long) divisor;
    }
    return (int) (sign * helper(a, b));
}

public long helper(long a, long b) {
    if (a &lt; b) return 0;
    long remain = a, ans = 0;
    while (remain != 0) {
        long count = 1, num = b;
        if (num &gt; remain) {
            remain = 0;
            break;
        }
        while (num + num &gt; 0 &amp;&amp; num + num &lt;= remain) {
            num = num &lt;&lt; 1;
            count = count &lt;&lt; 1;
        }
        remain -= num;
        ans += count;
    }
    return ans;
}
</code></pre>

<p><strong>Second code, translated from c plus plus</strong>.</p>

<pre><code>public int divide(int dividend, int divisor) {
    long a = dividend &gt;&gt;&gt; 31 == 0 ? dividend : 0 - (long) dividend;
    long b = divisor &gt;&gt;&gt; 31 == 0 ? divisor : 0 - (long) divisor;
    long ret = 0;
    while (a &gt;= b) {
        long c = b;
        int i = 0;
        while (a &gt;= c) {
            a -= c;
            ret += 1 &lt;&lt; i++;
            c &lt;&lt;= 1;
        }
    }
    return (int) ((dividend ^ divisor) &gt;&gt;&gt; 31 == 0 ? ret : 0 - ret);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Valid-Parentheses/">[LeetCode 20] Valid Parentheses</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/valid-parentheses/">link</a></p>

<div class="question-content">
            <p></p><p>Given a string containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.</p>

<p>The brackets must close in the correct order, <code>"()"</code> and <code>"()[]{}"</code> are all valid but <code>"(]"</code> and <code>"([)]"</code> are not.</p>
<p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>Standard solution around the internet is to use stack</strong>.</p>

<p>I though using String is also fine, so I tried it. I also works.</p>

<h3>Solution</h3>

<p>The code is easy.</p>

<h3>My code</h3>

<pre><code>public boolean isValid(String s) {
        String p = "";
        for (int i = 0; i &lt; s.length(); i ++) {
            char cur = s.charAt(i);
            if (cur == '(' || cur == '{' || cur == '[') {
                p += cur;
            } else {
                if (p.length() == 0) return false;
                if (p.charAt(p.length()-1) - cur &lt;= 2)
                    p = p.substring(0, p.length()-1);
            }
        }
        if (p.length() == 0) return true;
        return false;
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/28">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/26">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150/'>cc150 (1)</a></li>
<li class='category'><a href='/blog/categories/collection/'>collection (5)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (20)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (12)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (154)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (65)</a></li>
<li class='category'><a href='/blog/categories/thoughts/'>thoughts (4)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/08/06/Leetcode-second-two/">[Leetcode] Leetcode Second Round 2</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/05/Write-a-RNG/">[Google] Write a Random Number Generator</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/05/Web-server-application-server/">[Design] Application Server vs. Web Server</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/05/Upcasting-and-Object-Slicing/">[Design] Upcasting, Downcasting and Object Slicing</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/05/Replace-Question-Mark-WIth-Number/">[Google] Replace Question Mark With Number</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
