
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Woodstock Blog</title>
  <meta name="author" content="Charlie Brown">

  
  <meta name="description" content="Question link Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/42">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Woodstock Blog</a></h1>
  
    <h2>What's the good of living if you don't try a few things?</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Remove-Element/">[LeetCode 27] Remove Element</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/09/Remove-Element/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/09/Remove-Element/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/remove-element/">link</a></p>

<div class="question-content">
            <p></p><p>Given an array and a value, remove all instances of that value in place and return the new length.
</p>

<p>
The order of elements can be changed. It doesn&#8217;t matter what you leave beyond the new length.
</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Solution</h3>

<p>Similar to the question <strong>[LeetCode 26] Remove Duplicates From Sorted Array</strong>. Use 2 pointers.</p>

<h3>Let&rsquo;s play a game</h3>

<p>The code I gave is 21 lines. It&rsquo;s too long. Can we solve this problem with less code?</p>

<p>Sure we can! I have a 10-line version:</p>

<pre><code>public class Solution {
    public int removeElement(int[] A, int elem) {
        int left = 0, right = 0;
        while (right &lt; A.length) {
            if (A[right] == elem) right++;
            else A[left++] = A[right++];
        }
        return left;
    }
}
</code></pre>

<p>Now for a moment I thought the above code is the most concise, until I read <a href="http://needjobasap.blogspot.sg/2014/01/removeelement-leetcode.html">this blog</a>. The code is:</p>

<pre><code>public class Solution {
    public int removeElement(int[] A, int elem) {
        int p = 0;
        for (int i = 0; i &lt; A.length; i++)
            if (A[i] != elem) A[p++] = A[i];
        return p;
    }
}
</code></pre>

<p>OK game over. Look at the standard answer below. Happy Leetcoding!</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public int removeElement(int[] A, int elem) {
        if (A == null || A.length == 0) {
            return 0;
        }
        int len = A.length;
        int left = 0;
        int right = 0;
        while (right &lt; len) {
            // skip all instances of elem 
            while (right &lt; len &amp;&amp; A[right] == elem) {
                right++;
            }
            if (right == len) {
                break;
            }
            A[left++] = A[right++];
        }
        return left;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Remove-Duplicates-from-Sorted-Array/">[LeetCode 26] Remove Duplicates From Sorted Array</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/09/Remove-Duplicates-from-Sorted-Array/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/09/Remove-Duplicates-from-Sorted-Array/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a sorted array, remove the duplicates in place such that each element appear only <i>once</i> and return the new length.</p>

<p>
Do not allocate extra space for another array, you must do this in place with constant memory.
</p>

<p>
For example,<br>
Given input array A = <code>[1,1,2]</code>,
</p>
<p>
Your function should return length = <code>2</code>, and A is now <code>[1,2]</code>.
</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>This question is easy.</p>

<h3>Solution</h3>

<p>Two pointer operations. A very similar question is <strong>[LeetCode 27] Remove Element</strong>.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public int removeDuplicates(int[] A) {
        if (A == null || A.length == 0) {
            return 0;
        }
        int len = A.length;
        int left = 0;
        int right = 0;
        while (right &lt; len) {
            A[left++] = A[right++];
            // advance right pionter to a new value 
            while (right &lt; len &amp;&amp; A[right - 1] == A[right]) {
                right++;
            }
        }
        return left;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Merge-Two-Sorted-Lists/">[LeetCode 21] Merge Two Sorted Lists</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/09/Merge-Two-Sorted-Lists/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/09/Merge-Two-Sorted-Lists/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/merge-two-sorted-lists/">link</a></p>

<div class="question-content">
            <p></p><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question is easy</strong>. There are difficult ways to solve.</p>

<h3>Solution</h3>

<p>There are 2 ways to solve this problem. First and the easy one is to <strong>do recursion</strong>.</p>

<p>Second solution, also my original solution is to <strong>use a &lsquo;fakeHead&rsquo; to help</strong>. Read <a href="http://www.programcreek.com/2012/12/leetcode-merge-two-sorted-lists-java/">this blog</a>.</p>

<h3>My code</h3>

<p>Recursion:</p>

<pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        } else if (l2 == null) {
            return l1;
        } else {
            if (l1.val &lt; l2.val) {
                l1.next = mergeTwoLists(l1.next, l2);
                return l1;
            } else {
                l2.next = mergeTwoLists(l1, l2.next);
                return l2;
            }
        }
    }
}
</code></pre>

<p>Temporary header + link operations</p>

<pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode pre = new ListNode(0);
        ListNode cur = pre;
        while (l1 != null &amp;&amp; l2 != null) {
            if (l1.val &lt; l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        if (l1 == null) cur.next = l2;
        else cur.next = l1;
        return pre.next;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Generate-Parentheses/">[LeetCode 22] Generate Parentheses</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/09/Generate-Parentheses/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/09/Generate-Parentheses/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/generate-parentheses/">link</a></p>

<div class="question-content">
            <p></p><p>
Given <i>n</i> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
</p>

<p>
For example, given <i>n</i> = 3, a solution set is:
</p>
<p>
<code>"((()))", "(()())", "(())()", "()(())", "()()()"</code>
</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Solution</h3>

<p>Very standard permutation search. You can read more from <a href="http://www.geeksforgeeks.org/print-all-combinations-of-balanced-parentheses/">this link</a>.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public List&lt;String&gt; generateParenthesis(int n) {
        List&lt;String&gt; ans = new ArrayList&lt;String&gt;();
        if (n == 0) {
            return ans;
        }
        helper(ans, "", n, n);
        return ans;
    }

    private void helper(List&lt;String&gt; ans, String path, int left, int right) {
        if (left == 0 &amp;&amp; right == 0) {
            ans.add(path);
            return;
        }
        // add either left or right parenthese
        if (left &gt; 0) {
            helper(ans, path + "(", left - 1, right);
        }
        if (right &gt; left) {
            helper(ans, path + ")", left, right - 1);
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/03/4Sum/">[LeetCode 18] 4Sum</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-03T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/03/4Sum/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/03/4Sum/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/4sum/">link</a></p>

<div class="question-content">
            <p></p><p>Given an array <i>S</i> of <i>n</i> integers, are there elements <i>a</i>, <i>b</i>, <i>c</i>, and <i>d</i> in <i>S</i> such that <i>a</i> + <i>b</i> + <i>c</i> + <i>d</i> = target? Find all unique quadruplets in the array which gives the sum of target.</p>

<p><b>Note:</b><br>
</p><ul>
<li>Elements in a quadruplet (<i>a</i>,<i>b</i>,<i>c</i>,<i>d</i>) must be in non-descending order. (ie, <i>a</i> ≤ <i>b</i> ≤ <i>c</i> ≤ <i>d</i>)</li>
<li>The solution set must not contain duplicate quadruplets.</li>
</ul>
<p></p>

<pre>    For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

    A solution set is:
    (-1,  0, 0, 1)
    (-2, -1, 1, 2)
    (-2,  0, 0, 2)
</pre><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is exactly the same algorithm as 3Sum</strong>. The idea is for every value pair (a, b), find all (c, d) that makes the sum equals to the target.</p>

<p>Note that the final found result (a, b, c, d) is already in sorted order, no need to re-sort.</p>

<h3>Solution</h3>

<p>The solution works in O(n<sup>3</sup>), which is a very common solution. Read <a href="http://www.cnblogs.com/TenosDoIt/p/3649607.html">this blog</a> for a O(n<sup>2</sup>) solution. Read it ONLY if you are interested.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] num, int target) {
        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        if (num == null || num.length &lt; 4) {
            return ans;
        }
        Arrays.sort(num);
        int len = num.length;
        for (int i = 0; i &lt; len - 3; i++) {
            // make sure the first number is distinct 
            if (i != 0 &amp;&amp; num[i - 1] == num[i]) {
                continue;
            }
            for (int j = i + 1; j &lt; len - 2; j++) {
                // make sure the second number is distinct 
                if (j != i + 1 &amp;&amp; num[j - 1] == num[j]) {
                    continue;
                }
                int balance = target - num[i] - num[j];
                int left = j + 1;
                int right = len - 1;
                while (left &lt; right) {
                    int sum = num[left] + num[right];
                    if (sum == balance) {
                        List&lt;Integer&gt; lis = new ArrayList&lt;Integer&gt;();
                        lis.add(num[i]);
                        lis.add(num[j]);
                        lis.add(num[left]);
                        lis.add(num[right]);
                        ans.add(lis);
                    }
                    if (sum &gt;= balance) {
                        // move right pointer left (to a unique value)
                        right--;
                        while (right &gt;= 0 &amp;&amp; num[right] == num[right + 1]) {
                            right--;
                        }
                    }
                    if (sum &lt;= balance) {
                        // move left pointer right (to a unique value)
                        left++;
                        while (left &lt; len &amp;&amp; num[left] == num[left - 1]) {
                            left++;
                        }
                    }
                }
            }
        }
        return ans;
    }
}
</code></pre>

<p>We can also use HashMap to remove duplication. I personally would not recommend doing this, but it gives an interesting viwepoint. Check out <a href="http://www.programcreek.com/2013/02/leetcode-4sum-java/">this code</a>.</p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; fourSum(int[] num, int target) {
    Arrays.sort(num);
    HashSet&lt;ArrayList&lt;Integer&gt;&gt; hashSet = new HashSet&lt;ArrayList&lt;Integer&gt;&gt;();
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    for (int i = 0; i &lt; num.length; i++) {
        for (int j = i + 1; j &lt; num.length; j++) {
            int k = j + 1;
            int l = num.length - 1;
            while (k &lt; l) {
                int sum = num[i] + num[j] + num[k] + num[l];
                if (sum &gt; target) l--;
                else if (sum &lt; target) k++;
                else if (sum == target) {
                    ArrayList&lt;Integer&gt; temp = 
                        new ArrayList&lt;Integer&gt;();
                    temp.add(num[i]);
                    temp.add(num[j]);
                    temp.add(num[k++]);
                    temp.add(num[l--]);
                    if (!hashSet.contains(temp)) {
                        hashSet.add(temp);
                        result.add(temp);
                    }
                }
            }
        }
    }
    return result;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/02/Remove-Nth-Node-From-End-of-List/">[LeetCode 19] Remove Nth Node From End of List</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/02/Remove-Nth-Node-From-End-of-List/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/02/Remove-Nth-Node-From-End-of-List/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/">link</a></p>

<div class="question-content">
            <p></p><p>Given a linked list, remove the <i>n</i><sup>th</sup> node from the end of list and return its head.</p>

<p>
For example,</p>

<pre>   Given linked list: <b>1-&gt;2-&gt;3-&gt;4-&gt;5</b>, and <b><i>n</i> = 2</b>.

   After removing the second node from the end, the linked list becomes <b>1-&gt;2-&gt;3-&gt;5</b>.
</pre>

<p>
<b>Note:</b><br>
Given <i>n</i> will always be valid.<br>
Try to do this in one pass.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>Note the special case: if the head node needs to be removed!</p>

<h3>Solution</h3>

<p>The code explains itself. Just don&rsquo;t forget the special cases.</p>

<h3>My code</h3>

<pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if (head == null) {
            return null;
        }
        ListNode left = head;
        ListNode right = head;
        // important to note that head node can be removed as well!
        // advance right pointer now
        for (int i = 0; i &lt; n; i++) {
            right = right.next;
            if (right == null) {
                right = head;
            }
        }
        // advance left and right pointer together
        while (right.next != null) {
            left = left.next;
            right = right.next;
        }
        // remove the node after left pointer
        // again, the below error check is not necessary
        if (left.next == null) {
            // need to remove the header in this case
            return head.next;
        } else {
            left.next = left.next.next;
            return head;
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/02/Letter-Combinations-of-a-Phone-Number/">[LeetCode 17] Letter Combinations of a Phone Number</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/02/Letter-Combinations-of-a-Phone-Number/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/02/Letter-Combinations-of-a-Phone-Number/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/letter-combinations-of-a-phone-number/">link</a></p>

<div class="question-content">
            <p></p><p>Given a digit string, return all possible letter combinations that the number could represent.
</p>

<p>
A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png"></p>

<pre><b>Input:</b>Digit string "23"
<b>Output:</b> ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
</pre>

<p>
<b>Note:</b><br>
Although the above answer is in lexicographical order, your answer could be in any order you want.
</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>There are 2 considerations associated with this question:</p>

<ol>
<li><p>How to convert an number into a String (i.e. 2->&lsquo;abc&rsquo; etc.)</p></li>
<li><p>How the search works.</p></li>
</ol>


<h4>Convert number to string</h4>

<p>There are 2 way: <strong>math way</strong>, or the <strong>hashmap way</strong>.</p>

<p>My initial idea is to calculate it mathematically:</p>

<pre><code>private String getLetters(int key) {
    if (key &lt;= 1 || key &gt;= 10) return "";
    // key must be in the range of [2,9]
    char first = (char) ('a' + (key - 2) * 3);
    if (key &gt;= 8) first++;
    String letters = "";
    for (int i = 0; i &lt; 4; i++) {
        if (i == 3 &amp;&amp; !(key == 7 || key == 9)) {
            break;
        }
        letters += first++;
    }
    return letters;
}
String letters = getLetters('3' - '0');
</code></pre>

<p>However, most people would use HashMap. It&rsquo;s not the main issue anyway, so using HashMap is fine.</p>

<h3>Solution</h3>

<p>This is very typical &ldquo;Permutation&rdquo; question. Need to memorize clearly.</p>

<p>Refer to <a href="http://www.ninechapter.com//solutions/letter-combinations-of-a-phone-number/">ninechap</a> for the solution and a piece of very standard code.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public List&lt;String&gt; letterCombinations(String digits) {
        List&lt;String&gt; ans = new ArrayList&lt;String&gt;();
        if (digits == null || digits.length() == 0) {
            ans.add("");
            return ans;
        }
        int len = digits.length();
        // this type of DFS question is very standardized
        helper(ans, "", digits, 0, len);
        return ans;
    }

    private void helper(List&lt;String&gt; ans, String path, String digits, int pos, int len) {
        if (pos == len) {
            ans.add(path);
            return;
        }
        // check the char at position 'pos', and find all possible letters to insert
        String possibleLetters = getLetters(digits.charAt(pos));
        for (char letter: possibleLetters.toCharArray()) {
            helper(ans, path + letter, digits, pos + 1, len);
        }
    }

    private String getLetters(char digit) {
        // first convert char to integer
        int index = digit - '0';
        String[] map = new String[] {
            " ",
            "",
            "abc",
            "def",
            "ghi",
            "jkl",
            "mno",
            "pqrs",
            "tuv",
            "wxyz"
        };
        // second, find corresponding string from map
        return map[index];
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/02/3Sum-Closest/">[LeetCode 16] 3Sum Closest</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/02/3Sum-Closest/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/02/3Sum-Closest/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/3sum-closest/">link</a></p>

<div class="question-content">
            <p></p><p>Given an array <i>S</i> of <i>n</i> integers, find three integers in <i>S</i> such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>

<pre>    For example, given array S = {-1 2 1 -4}, and target = 1.

    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</pre><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>This question is a simplified version of <strong>[LeetCode 15] 3Sum</strong>. The required return is an integer instead of a list.</p>

<p>This makes life easier because <strong>we do not need to consider duplications</strong> (think about it, why?).</p>

<h3>Solution</h3>

<p>The code is 3Sum solution without duplication avoidance.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public int threeSumClosest(int[] num, int target) {
        if (num == null || num.length &lt; 3) {
            return 0;
        }
        Arrays.sort(num);
        int len = num.length;
        int ans = num[0] + num[1] + num[2];
        for (int i = 0; i &lt; len; i++) {
            // if (i != 0 &amp;&amp; num[i - 1] == num[i]) {
            //     continue;
            // }
            // similar to 3sum question, but without dup avoidance
            int left = i + 1;
            int right = len - 1;
            while (left &lt; right) {
                int sum = num[i] + num[left] + num[right];
                // if found triplet that sums to target, return!
                if (sum == target) {
                    return target;
                }
                // then update ans variable - if it's closer to target
                if (Math.abs(sum - target) &lt; Math.abs(ans - target)) {
                    ans = sum;
                }
                // now move either left or right pointer
                if (sum &gt;  target) {
                    right--;
                } else {
                    left++;
                }
            }
        }
        return ans;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/02/3Sum/">[LeetCode 15] 3Sum</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/02/3Sum/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/02/3Sum/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/3sum/">link</a></p>

<div class="question-content">
            <p></p><p>Given an array <i>S</i> of <i>n</i> integers, are there elements <i>a</i>, <i>b</i>, <i>c</i> in <i>S</i> such that <i>a</i> + <i>b</i> + <i>c</i> = 0? Find all unique triplets in the array which gives the sum of zero.</p>

<p><b>Note:</b><br>
</p><ul>
<li>Elements in a triplet (<i>a</i>,<i>b</i>,<i>c</i>) must be in non-descending order. (ie, <i>a</i> ≤ <i>b</i> ≤ <i>c</i>)</li>
<li>The solution set must not contain duplicate triplets.</li>
</ul>
<p></p>

<pre>    For example, given array S = {-1 0 1 2 -1 -4},

    A solution set is:
    (-1, 0, 1)
    (-1, -1, 2)
</pre><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>First of all, the array must be sorted first.</p>

<p><strong>This question is solved with O(n<sup>2</sup>) time</strong>. The idea is, for every integer, try to find a 2-integer pair so that the 3 numbers sum to 0. The method to use is <strong>2-pointer scan</strong>.</p>

<h3>Solution</h3>

<p><strong>Very important point of this question</strong>: there might be duplications in the result.</p>

<p>Eg. array = {-5, 2, 2, 3, 3}. When a = -5, we can choose 2, 3 and move pointers both by 1 position. Then we can choose 2, 3 again!</p>

<p>Solution is to increase the pointer to where the value is different. Pay special attention in writing the code. Because there are 3 parts that need duplication avoidance:</p>

<ol>
<li><p><strong>The pivot number that we select, must be distinct each time</strong>. Why? because this is the smallest of the triplet. It must not be same.</p></li>
<li><p>The left pointer and right pointer. They should point to a new value each time.</p></li>
<li><p>Note that when sum is too large, move left pointer, and vice versa. <strong>However when sum is == 0, we move both left and right pointer</strong>.</p></li>
</ol>


<p>Point 3 is the reason why we have 2 conditions in seperate if-block:</p>

<pre><code>if (sum &gt;= 0) {...}

if (sum &lt;= 0) {...}
</code></pre>

<h3>My code</h3>

<pre><code>public class Solution {
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] num) {
        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        if (num == null || num.length &lt; 3) {
            return ans;
        }
        Arrays.sort(num);
        int len = num.length;
        int left, right;
        for (int i = 0; i &lt; len; i++) {
            // duplication avoidance 1
            if (i != 0 &amp;&amp; num[i] == num[i - 1]) {
                continue;
            }
            left = i + 1;
            right = len - 1;
            while (left &lt; right) {
                int sum = num[i] + num[left] + num[right];
                if (sum == 0) {
                    // now one triplet is found, add it to ans list
                    List&lt;Integer&gt; triplet = new ArrayList&lt;Integer&gt;();
                    triplet.add(num[i]);
                    triplet.add(num[left]);
                    triplet.add(num[right]);
                    ans.add(triplet);
                }
                // shrink the range between left and right pointer
                // (until the 2 pointers met)
                if (sum &gt;= 0) {
                    // move right pointer to the left
                    right--;
                    // duplication avoidance 2
                    while (right &gt;= 0 &amp;&amp; num[right] == num[right + 1]) {
                        right--;
                    }
                }
                if (sum &lt;= 0) {
                    // move left pointer to the right
                    left++;
                    // duplication avoidance 3
                    while (left &lt; len &amp;&amp; num[left] == num[left - 1]) {
                        left++;
                    }
                }
            }
        }
        return ans;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/01/Longest-Common-Prefix/">[LeetCode 14] Longest Common Prefix</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-01T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/01/Longest-Common-Prefix/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/01/Longest-Common-Prefix/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/longest-common-prefix/">link</a></p>

<div class="question-content">
            <p></p><p>Write a function to find the longest common prefix string amongst an array of strings.
</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>Straight-forward solution.</strong> Will not go into details.</p>

<p>However, there&rsquo;s another more generalized <a href="http://en.wikipedia.org/wiki/LCP_array"><strong>LCP array</strong></a> which is solved by use of <a href="http://en.wikipedia.org/wiki/Trie">Trie</a>.</p>

<h3>Solution</h3>

<p>The code explains itself.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        int p;
        for (p = 0; p &lt; strs[0].length(); p++) {
            char c = strs[0].charAt(p);
            // check all strings in array strs
            for (int i = 0; i &lt; strs.length; i++) {
                if (p == strs[i].length()) {
                    return strs[i];
                } else if (c != strs[i].charAt(p)) {
                    return strs[i].substring(0, p);
                }
            }
            // if all strings have the same prefix
            // continue checking it
        }
        // first string in array strs is the shortest common prefix
        return strs[0];
    }
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/43">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/41">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/classic/'>classic (3)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (52)</a></li>
<li class='category'><a href='/blog/categories/epic/'>epic (1)</a></li>
<li class='category'><a href='/blog/categories/experience/'>experience (2)</a></li>
<li class='category'><a href='/blog/categories/facebook/'>facebook (6)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (35)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (153)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (85)</a></li>
<li class='category'><a href='/blog/categories/string-search/'>string search (5)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (7)</a></li>
<li class='category'><a href='/blog/categories/top-k/'>top k (5)</a></li>
<li class='category'><a href='/blog/categories/twitter/'>twitter (3)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/12/22/RubyGems-gem-other-terms/">[Ruby]</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/12/18/Binary-Search-Tree-3Sum/">[Facebook] Binary Search Tree 3Sum (Undone)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/12/17/Print-Binary-Tree-Vertically/">[Facebook] Print a Binary Tree in Vertical Order</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/12/08/patient-disease-data-structure/">[Epic] Patient Disease Data Structure</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/12/01/Leetcode-fourth/">[Leetcode] Leetcode Fourth Round</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Charlie Brown -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
