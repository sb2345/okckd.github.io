
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Woodstock Blog</title>
  <meta name="author" content="Charlie Brown">

  
  <meta name="description" content="Question link Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/42">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Woodstock Blog</a></h1>
  
    <h2>What's the good of living if you don't try a few things?</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Generate-Parentheses/">[LeetCode 22] Generate Parentheses</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/valid-parentheses/">link</a></p>

<div class="question-content">
            <p></p><p>
Given <i>n</i> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
</p>

<p>
For example, given <i>n</i> = 3, a solution set is:
</p>
<p>
<code>"((()))", "(()())", "(())()", "()(())", "()()()"</code>
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>Most popular solutions online are using recursive calls</strong>. For example, <a href="http://www.geeksforgeeks.org/print-all-combinations-of-balanced-parentheses/">this blog</a>. I also used this method.</p>

<h3>Solution</h3>

<p>I kept 2 integers: <strong>open</strong> (number of unclosed left parenthesis) and <strong>remain</strong> (number of parenthesis that can be addded to the current string). I optimized my previous code and made it cleaner.</p>

<h3>My code</h3>

<pre><code>public ArrayList&lt;String&gt; generateParenthesis(int n) {
        return helper(new ArrayList&lt;String&gt;(), 0, n, "");
}

private ArrayList&lt;String&gt; helper(ArrayList&lt;String&gt; ans, 
                int open, int remain, String cur) {
        if (open == 0 &amp;&amp; remain == 0) ans.add(cur);
        if (remain &gt; 0) helper(ans, open + 1, remain - 1, cur + "(");
        if (open &gt; 0) helper(ans, open - 1, remain, cur + ")");
        return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/03/4Sum/">[LeetCode 18] 4Sum</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-03T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/4sum/">link</a></p>

<div class="question-content">
            <p></p><p>Given an array <i>S</i> of <i>n</i> integers, are there elements <i>a</i>, <i>b</i>, <i>c</i>, and <i>d</i> in <i>S</i> such that <i>a</i> + <i>b</i> + <i>c</i> + <i>d</i> = target? Find all unique quadruplets in the array which gives the sum of target.</p>

<p><b>Note:</b><br>
</p><ul>
<li>Elements in a quadruplet (<i>a</i>,<i>b</i>,<i>c</i>,<i>d</i>) must be in non-descending order. (ie, <i>a</i> ≤ <i>b</i> ≤ <i>c</i> ≤ <i>d</i>)</li>
<li>The solution set must not contain duplicate quadruplets.</li>
</ul>
<p></p>

<pre>    For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

    A solution set is:
    (-1,  0, 0, 1)
    (-2, -1, 1, 2)
    (-2,  0, 0, 2)
</pre><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">Rather long time</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This solution is using exactly same algorithm as 3Sum</strong>. Basic idea is for every value pair (a, b), find all (c, d) that makes the sum equals to the target.</p>

<p>Note that the final found answer set (a, b, c, d) is already in sorted order, no need  to re-sort.</p>

<h3>Solution</h3>

<p><strong>The code might be a little tricky dealing with duplications</strong>. I simple omit all repeated numbers, and luckily my code passed. There is <a href="http://www.programcreek.com/2013/02/leetcode-4sum-java/">another code</a> removing duplications by using <strong>HashSet.contains()</strong>. I will post his code below, but personally I think my solution is better.</p>

<p>The solution I gave is O(n<sup>3</sup>), which is <strong>a very popular solution from LeetCode blogs</strong>. This is good enough, but in case you&rsquo;re interested, there&rsquo;s a O(n<sup>2</sup>) solution using a HashMap to store all 2-number sums. The coding is difficult, thus would not be discussed here. Check code from <a href="http://www.cnblogs.com/TenosDoIt/p/3649607.html">this blog</a>.</p>

<p><strong>For this question, a O(n<sup>3</sup>) solution is good enough</strong>.</p>

<h3>My code</h3>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; fourSum(int[] numbers, int target) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (numbers == null || numbers.length == 0) {
        return ans;
    }
    Arrays.sort(numbers);
    int len = numbers.length;
    for (int i = 0; i &lt; len - 3; i++) {
        if (i &gt; 0 &amp;&amp; numbers[i - 1] == numbers[i]) {
            continue;
        }
        for (int j = i + 1; j &lt; len - 2; j++) {
            if (j &gt; i + 1 &amp;&amp; numbers[j - 1] == numbers[j]) {
                continue;
            }
            int left = j + 1;
            int right = len - 1;
            while (left &lt; right) {
                int diff = numbers[left] + numbers[right] + numbers[i] + numbers[j] - target;
                if (diff == 0) {
                    ArrayList&lt;Integer&gt; triplet = new ArrayList&lt;Integer&gt;();
                    triplet.add(numbers[i]);
                    triplet.add(numbers[j]);
                    triplet.add(numbers[left]);
                    triplet.add(numbers[right]);
                    ans.add(triplet);
                }
                if (diff &lt;= 0) {
                    left++;
                    while (left &lt; len &amp;&amp; numbers[left - 1] == numbers[left]) {
                        left++;
                    }
                }
                if (diff &gt;= 0) {
                    right--;
                    while (right &gt;= 0 &amp;&amp; numbers[right + 1] == numbers[right]) {
                        right--;
                    }
                }
            }
        }
    }
    return ans;
}
</code></pre>

<p>We can also use HashMap to remove duplication (interesting idea). Check this <a href="http://www.programcreek.com/2013/02/leetcode-4sum-java/">solution</a>.</p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; fourSum(int[] num, int target) {
    Arrays.sort(num);
    HashSet&lt;ArrayList&lt;Integer&gt;&gt; hashSet = new HashSet&lt;ArrayList&lt;Integer&gt;&gt;();
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    for (int i = 0; i &lt; num.length; i++) {
        for (int j = i + 1; j &lt; num.length; j++) {
            int k = j + 1;
            int l = num.length - 1;
            while (k &lt; l) {
                int sum = num[i] + num[j] + num[k] + num[l];
                if (sum &gt; target) l--;
                else if (sum &lt; target) k++;
                else if (sum == target) {
                    ArrayList&lt;Integer&gt; temp = 
                        new ArrayList&lt;Integer&gt;();
                    temp.add(num[i]);
                    temp.add(num[j]);
                    temp.add(num[k++]);
                    temp.add(num[l--]);
                    if (!hashSet.contains(temp)) {
                        hashSet.add(temp);
                        result.add(temp);
                    }
                }
            }
        }
    }
    return result;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/02/Remove-Nth-Node-From-End-of-List/">[LeetCode 19] Remove Nth Node From End of List</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/">link</a></p>

<div class="question-content">
            <p></p><p>Given a linked list, remove the <i>n</i><sup>th</sup> node from the end of list and return its head.</p>

<p>
For example,</p>

<pre>   Given linked list: <b>1-&gt;2-&gt;3-&gt;4-&gt;5</b>, and <b><i>n</i> = 2</b>.

   After removing the second node from the end, the linked list becomes <b>1-&gt;2-&gt;3-&gt;5</b>.
</pre>

<p>
<b>Note:</b><br>
Given <i>n</i> will always be valid.<br>
Try to do this in one pass.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question is easy</strong>. Just keep 2 pointers of a certain distance, and move together.</p>

<h3>Solution</h3>

<p>The code explains itself.</p>

<h3>My code</h3>

<pre><code>public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode p1 = head;
        ListNode p2 = head;
        for (int i=0 ; i&lt;n ; i++){
            p2 = p2.next;
        }
        if (p2 == null){
            return head.next;
        }
        // now p1 and p2 move together
        while(p2.next != null){
            p1 = p1.next;
            p2 = p2.next;
        }
        p1.next = p1.next.next;
        return head;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/02/Letter-Combinations-of-a-Phone-Number/">[LeetCode 17] Letter Combinations of a Phone Number</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/letter-combinations-of-a-phone-number/">link</a></p>

<div class="question-content">
            <p></p><p>Given a digit string, return all possible letter combinations that the number could represent.
</p>

<p>
A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png"></p>

<pre><b>Input:</b>Digit string "23"
<b>Output:</b> ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
</pre>

<p>
<b>Note:</b><br>
Although the above answer is in lexicographical order, your answer could be in any order you want.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">20 minutes</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>Altough this question is not difficult, IT IS VERY IMPORTANT</strong>. The way that recuisive/non-recursive calls are handled are very frequently examed in interviewed.</p>

<p>This question can be split into 2 sub-questions.</p>

<ol>
<li><p><strong>How to convert an number into a String (i.e. 2->&lsquo;abc&rsquo; etc.)</strong> There are 2 way: <strong>math way</strong>, or the <strong>simple way</strong>. I list 2 codes below, the first of which is written by me. The second piece using HashMap is most popular in other people&rsquo;s solutions, for example <a href="http://rafal.io/posts/leetcode-18-letter-combinations-of-a-phone-number.html">this one</a>. Some people also use array of string to achieve the same result.</p></li>
<li><p><strong>How to implement the code</strong>. There might be n digits, so using n nested-loops can solve the problem, but unable to code. There are 2 ways as well: <strong>recursive method</strong>, and <strong>non-recursive method</strong>. Please refer the solutions section.</p></li>
</ol>


<p>Number convert String, Math way:</p>

<pre><code>private String getLetters(int key) {
    if (key &lt;= 1 || key &gt;= 10) return "";
    // key must be in the range of [2,9]
    char first = (char) ('a' + (key - 2) * 3);
    if (key &gt;= 8) first++;
    String letters = "";
    for (int i = 0; i &lt; 4; i++) {
        if (i == 3 &amp;&amp; !(key == 7 || key == 9)) break;
        letters += first++;
    }
    return letters;
}
String letters = getLetters('3' - '0');
</code></pre>

<p>HashMap way(execute time is slightly higher):</p>

<pre><code>static final HashMap&lt;Character, String&gt; map = new HashMap&lt;Character, String&gt;() {
    {
        put('2', "abc");
        put('3', "def");
        put('4', "ghi");
        put('5', "jkl");
        put('6', "mno");
        put('7', "pqrs");
        put('8', "tuv");
        put('9', "wxyz");
    }
};
String letters = map.get('3');
</code></pre>

<h3>Solution</h3>

<p>As mentioned, there are 2 ways to code.</p>

<p><strong>Recursive method</strong> seems easy at first. I split the digits into head (the first digit) and tail (the rest). For example &ldquo;142&rdquo;, the head = 1, tail = 42. Then I use nested loop to concatenate all letters for head, and all answers for tail and get the correct answer. However, <strong>the code uses a lot of List and does not look cool</strong>. The performance however, is the same as the other recursive method.</p>

<p><strong>Now I will explain another (maybe better) recursive method</strong>. Keep an array of char, and a counter. In the beginning, counter = 0, array is empty. Then fill in the first position of the array, and increate counter by 1. Do this recursively until counter reach the last digit (at this point, insert the char array into answer set). <strong>Be very cautious about how the array is passed</strong>. Array is pass by reference, so the array keep getting changed. There shouldn&rsquo;t cause any trouble if your code is correct, but keep in mind that <strong>during recursive call, variables passed by reference is shared by all calls. This might be dangerous unless you handle it well</strong> (like use of counter). Otherwise, simply always create new objects like I did in the first code (2 arraylist are created in the first code, and 0 in the second code).</p>

<p>I printed execution stack for second code, which gives better illustration.</p>

<p>Call letterCombinations(&ldquo;29&rdquo;);</p>

<p>Success time: 0.07 memory: 380224 signal:0</p>

<p>len = 0, one is a
len = 1, one is a w
len = 1, one is a x
len = 1, one is a y
len = 1, one is a z
len = 0, one is b z
len = 1, one is b w
len = 1, one is b x
len = 1, one is b y
len = 1, one is b z
len = 0, one is c z
len = 1, one is c w
len = 1, one is c x
len = 1, one is c y
len = 1, one is c z</p>

<p><strong>Last, and the most important, is the non-recursive method</strong>. This idea is very intereting. 2 list are kept, first is called ans, and second called newAns. Now get all letters for next digit, and concatenate will all current ans using nested loop. Say currently all strings in ans is length 3, then after concatenate, the length because 4, and added to newAns. When all combinations are added to newAns, newAns become a list of string of length 4. Now one digit is finished. <strong>Before proceed to next digit, set ans = newAns, and clear newAns</strong>. Code below.</p>

<h3>My code</h3>

<p>The first recursive method (my code)</p>

<pre><code>public ArrayList&lt;String&gt; letterCombinations(String digits) {
    ArrayList&lt;String&gt; ans = new ArrayList&lt;String&gt;();
    if (digits.length() == 0) {
        ans.add("");
        return ans;
    }
    ArrayList&lt;String&gt; tailAns = this
            .letterCombinations(digits.substring(1));
    String headStr = this.getLetters(digits.charAt(0) - '0');
    for (char head : headStr.toCharArray()) {
        for (String tail : tailAns) 
            ans.add(head + tail);
    }
    return ans;
}

private String getLetters(int key) {
    if (key &lt;= 1 || key &gt;= 10) return "";
    char first = (char) ('a' + (key - 2) * 3);
    if (key &gt;= 8) first++;
    String letters = "";
    for (int i = 0; i &lt; 4; i++) {
        if (i == 3 &amp;&amp; !(key == 7 || key == 9)) break;
        letters += first++;
    }
    return letters;
}
</code></pre>

<p>Second recursive method (learnt and rewritten by me)</p>

<pre><code>public ArrayList&lt;String&gt; letterCombinations(String digits) {
    ArrayList&lt;String&gt; ans = new ArrayList&lt;String&gt;();
    char[] one = new char[digits.length()];
    fill(ans, one, 0, digits);
    return ans;
}

private void fill(ArrayList&lt;String&gt; ans, char[] one, int len, String digits) {
    if (len == one.length) {
        ans.add(String.valueOf(one));
        return;
    }
    String possibleChars = getLetters(digits.charAt(0) - '0');
    for (char c: possibleChars.toCharArray()) {
        one[len] = c;
        fill(ans, one, len+1, digits.substring(1));
    }
}

private String getLetters(int key) {
    if (key &lt;= 1 || key &gt;= 10) return "";
    char first = (char) ('a' + (key - 2) * 3);
    if (key &gt;= 8) first++;
    String letters = "";
    for (int i = 0; i &lt; 4; i++) {
        if (i == 3 &amp;&amp; !(key == 7 || key == 9)) break;
        letters += first++;
    }
    return letters;
}
</code></pre>

<p><strong>The non-recursive method (learnt and rewritten by me)</strong></p>

<p>To demostrate how <strong>HashMap</strong> is used, I changed the convertion method as well.</p>

<pre><code>public ArrayList&lt;String&gt; letterCombinations(String digits) {
        ArrayList&lt;String&gt; ans = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; newAns = new ArrayList&lt;String&gt;();
        ans.add("");
        for (int i = 0; i &lt; digits.length(); i ++) {
            String letters = map.get(digits.charAt(i));
            for (int j = 0; j &lt; letters.length(); j ++) {
                for (String cur: ans) {
                    newAns.add(cur + letters.charAt(j));
                }
            }
            ans = newAns;
            newAns = new ArrayList&lt;String&gt;();
        }
        return ans;
}

static final HashMap&lt;Character, String&gt; map = new HashMap&lt;Character, String&gt;() {
    {
        put('2', "abc");
        put('3', "def");
        put('4', "ghi");
        put('5', "jkl");
        put('6', "mno");
        put('7', "pqrs");
        put('8', "tuv");
        put('9', "wxyz");
    }
};
</code></pre>

<p><strong>Updated June 14th, rewrote the code using template</strong></p>

<p>It could have been better <a href="http://answer.ninechapter.com/solutions/letter-combinations-of-a-phone-number/">writing with StringBuilder</a>, but I think it&rsquo;s minor.</p>

<pre><code>public List&lt;String&gt; letterCombinations(String digits) {
    List&lt;String&gt; ans = new LinkedList&lt;String&gt;();
    if (digits == null) {
        return ans;
    }
    String[] pad = new String[]{
        " ","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    helper(ans, "", pad, digits, 0);
    return ans;
}

private void helper(List&lt;String&gt; ans, String path, String[] pad, String digits, int pos) {
    if (path.length() == digits.length()) {
        ans.add(path);
        return;
    }
    String letters = pad[digits.charAt(pos) - '0'];
    for (int i = 0; i &lt; letters.length(); i++) {
        path += letters.charAt(i) + "";
        helper(ans, path, pad, digits, pos + 1);
        path = path.substring(0, path.length() - 1);
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/02/3Sum-Closest/">[LeetCode 16] 3Sum Closest</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/3sum-closest/">link</a></p>

<div class="question-content">
            <p></p><p>Given an array <i>S</i> of <i>n</i> integers, find three integers in <i>S</i> such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>

<pre>    For example, given array S = {-1 2 1 -4}, and target = 1.

    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</pre><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">20 minutes coding only</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>This is a simplified version of 3Sum. <strong>The method is exactly the same as 3Sum, except the return is integer instead of a list of solutions</strong>. This makes life easier because <strong>we do not need to consider duplications</strong>.</p>

<p>Why? Because in 3Sum, when there is duplicate solution, we need to find them all. But in this question, if a solution is found, the closest value = 0, and is immediately returned.</p>

<h3>Solution</h3>

<p>The code explains itself.</p>

<h3>My code</h3>

<pre><code>public int threeSumClosest(int[] num, int target) {
    if (num.length &lt; 3) return 0;
    Arrays.sort(num);
    int diff = Integer.MAX_VALUE, realSum = -1;
    for (int i = 0; i &lt; num.length - 2; i++) {
        int left = i + 1, right = num.length - 1;
        while (left &lt; right) {
            int sum = num[i] + num[left] + num[right];
            if (sum == target) return target;
            else if (sum &lt; target) left++;
            else right--;
            if (diff &gt; Math.abs(sum - target)) {
                diff = Math.abs(sum - target);
                realSum = sum;
            }
        }
    }
    return realSum;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/02/3Sum/">[LeetCode 15] 3Sum</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/3sum/">link</a></p>

<div class="question-content">
            <p></p><p>Given an array <i>S</i> of <i>n</i> integers, are there elements <i>a</i>, <i>b</i>, <i>c</i> in <i>S</i> such that <i>a</i> + <i>b</i> + <i>c</i> = 0? Find all unique triplets in the array which gives the sum of zero.</p>

<p><b>Note:</b><br>
</p><ul>
<li>Elements in a triplet (<i>a</i>,<i>b</i>,<i>c</i>) must be in non-descending order. (ie, <i>a</i> ≤ <i>b</i> ≤ <i>c</i>)</li>
<li>The solution set must not contain duplicate triplets.</li>
</ul>
<p></p>

<pre>    For example, given array S = {-1 0 1 2 -1 -4},

    A solution set is:
    (-1, 0, 1)
    (-1, -1, 2)
</pre><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">
            <div>
                Difficult
            </div>
        </td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>The array must be sorted first. <strong>Then this question is easily solved with O(n<sup>2</sup>) time.</strong> The idea is, for every integer, a from the array, try to find all combinations of b and c, where b+c = -a. The implementation use <strong>2-pointer scan</strong>.</p>

<p>There might be a problem of duplications. Eg. array = {-5, 2, 2, 3, 3}. When a = -5, we can choose 2, 3 and move pointers both by 1 position. Then we can choose 2, 3 again. We shall increase the pointer to where the value is different, and the problem is solved.</p>

<h3>My code</h3>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(int[] num) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (num.length &lt; 3)
        return ans;
    Arrays.sort(num);
    for (int i = 0; i &lt; num.length - 2; i++) {
        if (i != 0 &amp;&amp; num[i - 1] == num[i])
            continue;
        int target = 0 - num[i];
        int left = i + 1, right = num.length - 1;
        while (left &lt; right) {
            if (num[left] + num[right] &gt; target)
                right--;
            else if (num[left] + num[right] &lt; target)
                left++;
            else {
                ArrayList&lt;Integer&gt; found = new ArrayList&lt;Integer&gt;();
                found.add(num[i]);
                found.add(num[left]);
                found.add(num[right]);
                Collections.sort(found);
                ans.add(found);
                while (left &lt; num.length - 1 &amp;&amp; num[++left] == num[left - 1]) ;
                while (right &gt; i + 1 &amp;&amp; num[--right] == num[right + 1]) ;
            }
        }
    }
    return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/01/Longest-Common-Prefix/">[LeetCode 14] Longest Common Prefix</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-01T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/longest-common-prefix/">link</a></p>

<div class="question-content">
            <p></p><p>Write a function to find the longest common prefix string amongst an array of strings.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="white">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">10 minutes</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question have straight-forward solution.</strong> Every online solution is the same as my method, however, there&rsquo;s another more generalized <a href="http://en.wikipedia.org/wiki/LCP_array"><strong>LCP array</strong></a> which is solved by use of <a href="http://en.wikipedia.org/wiki/Trie">Trie</a>. I&rsquo;m not interested in this topic right now.</p>

<h3>Solution</h3>

<p>The code explains itself.</p>

<h3>My code</h3>

<p>My original solution.</p>

<pre><code>public String longestCommonPrefix(String[] strs) {
    if (strs.length == 0)
        return "";
    int shortest = strs[0].length();
    for (String a : strs)
        shortest = Math.min(shortest, a.length());
    for (int i = 0; i &lt; shortest; i++) {
        for (int j = 1; j &lt; strs.length; j++) {
            // check strs[j].charAt(i)
            if (strs[j].charAt(i) != strs[j - 1].charAt(i)) {
                return strs[0].substring(0, i);
            }
        }
    }
    return strs[0].substring(0, shortest);
}
</code></pre>

<p><strong>Refactored code</strong>. I do not really need &lsquo;shortest&rsquo;. Increase execution time from 468ms to 456 ms.</p>

<p>This is the shortest code for this question, for my best knowledge :)</p>

<pre><code>public String longestCommonPrefix(String[] strs) {
    if (strs.length == 0) return "";
    for (int i = 0; i &lt; strs[0].length(); i++)
        for (int j = 1; j &lt; strs.length; j++)
            if (strs[j].length() == i
                    || strs[j].charAt(i) != strs[0].charAt(i))
                return strs[0].substring(0, i);
    return strs[0];
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/30/Roman-to-Integer/">[LeetCode 13] Roman to Integer</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-30T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/roman-to-integer/">link</a></p>

<div class="question-content">
            <p></p><p>Given a roman numeral, convert it to an integer.</p>

<p>Input is guaranteed to be within the range from 1 to 3999.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>This question is easier than &ldquo;Integer to Roman&rdquo;.</p>

<p><strong>This question is easy, but writing code is not very very easy</strong>. The main idea is to always read 2 char and check. If pre > cur, then OK. If pre &lt; cur, we need to subtract (2 * pre) from the result.</p>

<p>The rest is fine.</p>

<h3>Solution</h3>

<p>The code explains itself.</p>

<h3>My code</h3>

<pre><code>public int romanToInt(String s) {
    int pre = 0;
    int cur = 0;
    int sum = 0;
    if (s.equals("")) return 0;
    for (char t: s.toCharArray()){
        cur = getNum(t);
        if (pre != 0 &amp;&amp; pre &lt; cur){
            sum += cur - (2 * pre);
            pre = 0;
        } else {
            sum += cur;
            pre = cur;
        }
    }
    return sum;
}

private int getNum(char a){
    switch(a){
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
    }
    return 0;
}
</code></pre>

<p>This is another <a href="http://yucoding.blogspot.sg/2013/05/leetcode-question-87-roman-to-interger.html">very interesting solution</a> from online. <strong>It basically just use addition, and solve the problem perfectly!</strong> (The code is C++)</p>

<pre><code>class Solution {
public:
    int romanToInt(string s) {
        // 4:IV, 9:IX, 40:XL, 90:XC, 400:CD, 900:CM,
        // 1:I, 10:X, 100:C, 1000:M
        int res=0;
        char pre = ' ';
        for(int i=0;i&lt;s.size();i++){
            if (s[i]=='M' &amp;&amp; pre!='C') {res+=1000;}
            if (s[i]=='C' &amp;&amp; pre!='X') {res+=100;}
            if (s[i]=='X' &amp;&amp; pre!='I') {res+=10;}

            if (s[i]=='M' &amp;&amp; pre=='C') {res+=800;}
            if (s[i]=='C' &amp;&amp; pre=='X') {res+=80;}
            if (s[i]=='X' &amp;&amp; pre=='I') {res+=8;}

            if (s[i]=='I' ) {res+=1;}

            if (s[i]=='V' &amp;&amp; pre!='I'){res+=5;}
            if (s[i]=='L' &amp;&amp; pre!='X'){res+=50;}
            if (s[i]=='D' &amp;&amp; pre!='C'){res+=500;}

            if (s[i]=='V' &amp;&amp; pre=='I'){res+=3;}
            if (s[i]=='L' &amp;&amp; pre=='X'){res+=30;}
            if (s[i]=='D' &amp;&amp; pre=='C'){res+=300;}

            pre = s[i];
        }
        return res;
    }
};
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/30/Integer-to-Roman/">[LeetCode 12] Integer to Roman</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-30T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/integer-to-roman/">link</a></p>

<div class="question-content">
<p></p><p>Given an integer, convert it to a roman numeral.
</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">35 minutes</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<table>
<thead>
<tr>
<th>Symbol </th>
<th align="center"> Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td align="center">1</td>
</tr>
<tr>
<td>V</td>
<td align="center">5</td>
</tr>
<tr>
<td>X</td>
<td align="center">10</td>
</tr>
<tr>
<td>L</td>
<td align="center">50</td>
</tr>
<tr>
<td>C</td>
<td align="center">100</td>
</tr>
<tr>
<td>D</td>
<td align="center">500</td>
</tr>
<tr>
<td>M</td>
<td align="center">1,000</td>
</tr>
</tbody>
</table>


<p>Though <a href="http://en.wikipedia.org/wiki/Roman_numerals">Roman numerals</a> looks complex, it&rsquo;s actually converted bit by bit. For example 207=>CCVII. We can then construct <strong>the following relationship table</strong>:</p>

<table>
<thead>
<tr>
<th>Base/number</th>
<th align="center">Number(1)</th>
<th align="center">Number(5)</th>
<th align="center">Number(10)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td align="center">I</td>
<td align="center">V</td>
<td align="center">X</td>
</tr>
<tr>
<td>10</td>
<td align="center">X</td>
<td align="center">L</td>
<td align="center">C</td>
</tr>
<tr>
<td>100</td>
<td align="center">C</td>
<td align="center">D</td>
<td align="center">M</td>
</tr>
<tr>
<td>1000</td>
<td align="center">M</td>
<td align="center">n.a.</td>
<td align="center">n.a.</td>
</tr>
</tbody>
</table>


<p>So for each number, just do convert according to the above table.</p>

<blockquote><p>9=>IX</p>

<p>400=>CD.</p></blockquote>

<p>The question states that input is less than 3999, so we have 2 &ldquo;n.a.&rdquo; in the table.</p>

<h3>Solution</h3>

<p><strong>The code itself is really straight-forward</strong>. This time my code is better than last month&rsquo;s, so I post it below. It is followed by someone else&rsquo;s code, which is even better and easy to understand.</p>

<h3>My code</h3>

<pre><code>char[][] roman = { { 'I', 'V', 'X' }, 
           { 'X', 'L', 'C' }, 
           { 'C', 'D', 'M' },
           { 'M', '*', '*' } };

public String intToRoman(int num) {
    String ans = "";
    int base = 1, count = 0, temp = num;
    while (temp &gt; 1) {
        base *= 10;
        count++;
        temp /= 10;
    }
    while (base &gt; 0) {
        int cur = num / base;
        // now convert cur into roman string
        if (cur &gt;= 6 &amp;&amp; cur &lt;= 8) {
            ans += roman[count][1];
            cur = cur % 5;
        }
        if (cur &gt;= 1 &amp;&amp; cur &lt;= 3)
            for (int k = 0; k &lt; cur; k++)
                ans += roman[count][0];
        else if (cur == 5)
            ans += roman[count][1];
        else if (cur == 4)
            ans += roman[count][0] + "" + roman[count][1];
        else if (cur == 9)
            ans += roman[count][0] + "" + roman[count][2];
        num = num % base;
        base /= 10;
        count--;
    }
    return ans;
}
</code></pre>

<p>This is a very <a href="http://stackoverflow.com/a/19759564">simple solution</a> by stackoverflow user bhlangonijr. This method <strong>makes use of Java</strong> <a href="http://goo.gl/e8ryim">TreeMap.floorKey</a></p>

<blockquote><p>TreeMap.floorKey &ndash; Returns the greatest key less than or equal to the given key, or null if there is no such key.</p></blockquote>

<pre><code>public String intToRoman3(int num) {
    TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();
    map.put(1000, "M");
    map.put(900, "CM");
    map.put(500, "D");
    map.put(400, "CD");
    map.put(100, "C");
    map.put(90, "XC");
    map.put(50, "L");
    map.put(40, "XL");
    map.put(10, "X");
    map.put(9, "IX");
    map.put(5, "V");
    map.put(4, "IV");
    map.put(1, "I");
    int l = map.floorKey(num);
    if (num == l) {
        return map.get(num);
    }
    return map.get(l) + intToRoman3(num - l);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/29/ZigZag-Conversion/">[LeetCode 6] ZigZag Conversion</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-29T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/zigzag-conversion/">link</a></p>

<div class="question-content">
<p></p><p>
The string <code>"PAYPALISHIRING"</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
</p><pre>
P   A   H   N
A P L S I I G
Y   I   R
</pre>

And then read line by line: <code>"PAHNAPLSIIGYIR"</code><p></p>

<p>
Write the code that will take a string and make this conversion given a number of rows:

</p><pre>string convert(string text, int nRows);</pre>

<code>convert("PAYPALISHIRING", 3)</code> should return <code>"PAHNAPLSIIGYIR"</code>.
<p></p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">45 minutes</td>
    </tr>
</table>


<h3>Analysis</h3>

<p><strong>This question is easy</strong>. Just follow the basic math function and the solution is achieved.</p>

<p>I coded quickly, but then found that using a String to store result will exceed time limit. I then changed to use <strong>char array</strong> to store result.</p>

<p>Later I found that insead of using String, I can use <strong>StringBuilder</strong> to make the program faster.</p>

<h3>Solution</h3>

<p>Two sets of code mentioned above is shown.</p>

<h3>My code</h3>

<p>My first solution using <strong>StringBuilder to store result</strong>. Passed but not good. (Basically, return &ldquo;&rdquo; at the last line is an bad idea)</p>

<pre><code>public String convert(String s, int nRows) {
    if (nRows &lt;= 1) return s;
    int eachPattern = 2 * nRows - 2;
    int numPatterns = (s.length() - 1) / eachPattern + 1;
    StringBuilder ans = new StringBuilder();
    for (int j = 0; j &lt; nRows; j++) {
        for (int i = 0; i &lt; numPatterns; i++) {
            ans.append(find(s, eachPattern, i, j));
            if (j != 0 &amp;&amp; j != nRows - 1)
                ans.append(find(s, eachPattern, i, 2 * (nRows - 1) - j));
        }
    }
    return ans.toString();
}
private String find(String s, int eachPattern, int i, int j) {
    // find (j)th element from (i)th pattern
    int temp = eachPattern * i + j;
    if (temp &lt; s.length())
        return s.substring(temp, temp + 1);
    return "";
}
</code></pre>

<p>Enhance solution, use <strong>char[] to store result</strong></p>

<pre><code>public String convert(String s, int nRows) {
    if (nRows &lt;= 1) return s;
    int eachPattern = 2 * nRows - 2;
    int numPatterns = (s.length() - 1) / eachPattern + 1;
    char[] ans = new char[s.length()];
    int index = 0;
    for (int j = 0; j &lt; nRows; j++) {
        // j is current row number
        for (int i = 0; i &lt; numPatterns; i++) { 
            // i is current pattern
            char temp = find(s, eachPattern, i, j);
            if (temp == 0) break;
            ans[index++] = temp;
            if (j != 0 &amp;&amp; j != nRows - 1) {
                temp = find(s, eachPattern, i, 2 * (nRows - 1) - j);
                if (temp == 0) break;
                ans[index++] = temp;
            }
        }
    }
    return String.valueOf(ans);
}

private char find(String s, int eachPattern, int i, int j) {
    // find (j)th element from (i)th pattern
    int temp = eachPattern * i + j;
    if (temp &lt; s.length()) return s.charAt(temp);
    return 0;
}
</code></pre>

<p>A much shorter version from <a href="http://blog.csdn.net/linhuanmars/article/details/21145039">a blog</a> (the idea is same)</p>

<pre><code>public String convert(String s, int nRows) {
    if (s == null || s.length() == 0 || nRows &lt;= 0) return "";
    if (nRows == 1) return s;
    StringBuilder res = new StringBuilder();
    int size = 2 * nRows - 2;
    for (int i = 0; i &lt; nRows; i++) {
        for (int j = i; j &lt; s.length(); j += size) {
            res.append(s.charAt(j));
            if (i != 0 &amp;&amp; i != nRows - 1 &amp;&amp; j + size - 2 * i &lt; s.length())
                res.append(s.charAt(j + size - 2 * i));
        }
    }
    return res.toString();
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/43">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/41">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (14)</a></li>
<li class='category'><a href='/blog/categories/classic/'>classic (3)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (51)</a></li>
<li class='category'><a href='/blog/categories/facebook/'>facebook (4)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (34)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (155)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>octopress (1)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (85)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (5)</a></li>
<li class='category'><a href='/blog/categories/thoughts/'>thoughts (7)</a></li>
<li class='category'><a href='/blog/categories/top-k/'>top k (5)</a></li>
<li class='category'><a href='/blog/categories/twitter/'>twitter (3)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/09/15/stack-of-animals/">[CC150v5] 3.7 Stack of Animals</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/15/stack-get-min-value/">[CC150v5] 3.2 Stack Min Value</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/15/linked-list-palindrome/">[CC150v5] 2.7 Linked List Palindrome</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/15/implement-stack/">[CC150v5] Chap 3 Example - Implement Stack</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/15/">[CC150v5] 2.</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Charlie Brown -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
