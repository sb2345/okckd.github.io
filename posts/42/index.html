
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Woodstock Blog</title>
  <meta name="author" content="Charlie Brown">

  
  <meta name="description" content="Question link Given two integers n and k, return all possible combinations of k numbers out of 1 &#8230; n. For example,
If n = 4 and k = 2, a &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/42">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Woodstock Blog</a></h1>
  
    <h2>What's the good of living if you don't try a few things?</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/22/Combinations/">[LeetCode 77] Combinations</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-22T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/22/Combinations/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/22/Combinations/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/combinations/">link</a></p>

<div class="question-content">
            <p></p><p>
Given two integers <i>n</i> and <i>k</i>, return all possible combinations of <i>k</i> numbers out of 1 &#8230; <i>n</i>.
</p>
<p>
For example,<br>
If <i>n</i> = 4 and <i>k</i> = 2, a solution is:
</p>

<pre>[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</pre><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very classic problem</strong>.</p>

<p>The solution is standard, and we must be able to write it without even using our <strong>brain</strong> (only use hands).</p>

<h3>Solution</h3>

<p>Solution 1, recursive DFS calls.</p>

<p>Solution 2, nested loop. Code is shown below.</p>

<h3>Code</h3>

<p><strong>First, my DFS solution</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combine(int n, int k) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (k == 0) return ans;
    helper(ans, new ArrayList&lt;Integer&gt;(), n, k, 0, 0);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans,ArrayList&lt;Integer&gt; list,
                    int n, int k, int curPt, int preNum) {
    if (curPt == k) {
        ans.add(new ArrayList&lt;Integer&gt;(list));
        return;
    }
    for (int i = preNum + 1; i &lt;= n - k + 1 + curPt; i ++) {
        list.add(i);
        helper(ans, list, n, k, curPt + 1, i);
        list.remove(list.size() - 1);
    }
}
</code></pre>

<p><strong>Second, my nested for-loop solution</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combine(int n, int k) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    ans.add(new ArrayList&lt;Integer&gt;());
    if (n == 0 || k == 0 || k &gt; n) return ans;
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; temp = null;
    for (int i = 0; i &lt; k; i ++) {
        temp = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
        for (ArrayList&lt;Integer&gt; a: ans) {
            for (int j = 1; j &lt;= n; j ++) {
                if (a.size() &gt; 0 &amp;&amp; a.get(a.size() - 1) &gt;= j) 
                    continue;
                a.add(j);
                temp.add(new ArrayList&lt;Integer&gt;(a));
                a.remove(a.size() - 1);
            }
        }
        ans = temp;
    }
    return ans;
}
</code></pre>

<p><strong>Updated June 14th, rewrote the code using template</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (n == 0 || k == 0 || n &lt; k) {
        return ans;
    }
    helper(ans, new LinkedList&lt;Integer&gt;(), n, k, 1);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int n, int k, int pos) {
    if (path.size() == k) {
        ans.add(new LinkedList&lt;Integer&gt;(path));
        return;
    }
    for (int i = pos; i &lt;= n; i++) {
        path.add(i);
        helper(ans, path, n, k, i + 1);
        path.remove(path.size() - 1);
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/21/Word-Search/">[LeetCode 79] Word Search</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-21T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/21/Word-Search/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/21/Word-Search/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/word-search/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a 2D board and a word, find if the word exists in the grid.
</p>
<p>
The word can be constructed from letters of sequentially adjacent cell, where &#8220;adjacent&#8221; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
</p>

<p>
For example,<br>
Given <b>board</b> = 
</p><pre>[
  ["ABCE"],
  ["SFCS"],
  ["ADEE"]
]
</pre>

<b>word</b> = <code>"ABCCED"</code>, -&gt; returns <code>true</code>,<br>
<b>word</b> = <code>"SEE"</code>, -&gt; returns <code>true</code>,<br>
<b>word</b> = <code>"ABCB"</code>, -&gt; returns <code>false</code>.<br>
<p></p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Solution</h3>

<p><strong>This is a very classical DFS question</strong>. Writing this solution fast and precise is very importnt.</p>

<p>The solution is recursive DFS search.</p>

<p><strong>The second code posted below comes from <a href="http://needjobasap.blogspot.sg/2014/01/word-search-leetcode.html">this blog</a></strong>. The code is slightly shorter because it checks <strong>visited_array</strong> at the beginning of search() method, instead of for each directions. Other than that, it&rsquo;s basically same solution.</p>

<h3>Code</h3>

<p><strong>First, my code</strong></p>

<pre><code>public boolean exist(char[][] board, String word) {
    if (word.length() == 0) return true;
    int m = board.length, n = board[0].length;
    for (int i = 0; i &lt; m; i ++) {
        for (int j = 0; j &lt; n; j ++) {
            if (board[i][j] == word.charAt(0)) {
                int[][] visited = new int[m][n];
                visited[i][j] = 1;
                boolean ans = find(i, j, board, visited, word.substring(1));
                if (ans) return true;
            }
        }
    }
    return false;
}

private boolean find(int a, int b, char[][] board, int[][] visited, 
                    String word) {
    if (word.length() == 0) return true;
    int m = board.length, n = board[0].length;
    char target = word.charAt(0);
    if (a &gt; 0 &amp;&amp; visited[a-1][b] == 0 &amp;&amp; board[a-1][b] == target) {
        visited[a - 1][b] = 1;
        boolean ans = find(a - 1, b, board, visited, word.substring(1));
        if (ans) return true;
        visited[a - 1][b] = 0;
    } // top
    if (a &lt; m - 1 &amp;&amp; visited[a+1][b] == 0 &amp;&amp; board[a+1][b] == target) {
        visited[a + 1][b] = 1;
        boolean ans = find(a + 1, b, board, visited, word.substring(1));
        if (ans) return true;
        visited[a + 1][b] = 0;
    } // bottom
    if (b &gt; 0 &amp;&amp; visited[a][b-1] == 0 &amp;&amp; board[a][b-1] == target) {
        visited[a][b - 1] = 1;
        boolean ans = find(a, b - 1, board, visited, word.substring(1));
        if (ans) return true;
        visited[a][b - 1] = 0;
    } // left
    if (b &lt; n - 1 &amp;&amp; visited[a][b+1] == 0 &amp;&amp; board[a][b+1] == target) {
        visited[a][b + 1] = 1;
        boolean ans = find(a, b + 1, board, visited, word.substring(1));
        if (ans) return true;
        visited[a][b + 1] = 0;
    } // right
    return false;
}
</code></pre>

<p><strong>Second, code from blog</strong></p>

<pre><code>public boolean exist(char[][] board, String word) {
    int height = board.length;
    int width = board[0].length;
    boolean[][] visited = new boolean[height][width];
    for (int i = 0; i &lt; height; i++) 
        for (int j = 0; j &lt; width; j++) 
            if (search(board, visited, i, j, word, 0)) 
                return true;
    return false;
}

private boolean search(char[][] board, boolean[][] visited, 
        int row, int col, String word, int index) {
    if (word.charAt(index) != board[row][col]) 
        return false;
    if (index == word.length() - 1) 
        return true;

    int height = board.length;
    int width = board[0].length;
    visited[row][col] = true;
    //up
    if (row &gt; 0 &amp;&amp; !visited[row - 1][col] 
            &amp;&amp; search(board, visited, row - 1, col, word, index + 1)) 
        return true;
    //down
    if (row &lt; height - 1 &amp;&amp; !visited[row + 1][col] 
            &amp;&amp; search(board, visited, row + 1, col, word, index + 1)) 
        return true;
    //left
    if (col &gt; 0 &amp;&amp; !visited[row][col - 1] 
            &amp;&amp; search(board, visited, row, col - 1, word, index + 1)) 
        return true;
    //right
    if (col &lt; width - 1 &amp;&amp; !visited[row][col + 1] 
            &amp;&amp; search(board, visited, row, col + 1, word, index + 1)) 
        return true;
    // if we did not find the path we need set this position as unvisited
    visited[row][col] = false;

    return false;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/21/SqrtX/">[LeetCode 69] Sqrt(x)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-21T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/21/SqrtX/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/21/SqrtX/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/sqrtx/">link</a></p>

<div class="question-content">
            <p></p><p>Implement <code>int sqrt(int x)</code>.</p>

<p>Compute and return the square root of <i>x</i>.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a classic question of math and CS</strong>. It&rsquo;s easy, but there are <strong>a few magical solutions</strong> for this problem.</p>

<h3>Solution</h3>

<p><strong>The most standard solution is using binary search</strong>. I have the code for that.</p>

<p><strong><a href="http://en.wikipedia.org/wiki/Newton's_method">Newton&rsquo;s method</a> is a great way to solve this problem</strong>. It uses derivative to keep finding the next better approximation to the root of the value. There is <a href="http://www.2cto.com/kf/201206/137256.html">a great article</a> on this topic talking about Newton&rsquo;s method, and some even faster implementations.</p>

<p>That article is definitely worth reading. I will quote a small propertion of it.</p>

<blockquote cite="http://www.2cto.com/kf/201206/137256.html">
    <p>求出根号a的近似值：首先随便猜一个近似值x，然后不断令x等于x和a/x的平均数，迭代个六七次后x的值就已经相当精确了。
        <br>例如，我想求根号2等于多少。假如我猜测的结果为4，虽然错的离谱，但你可以看到使用牛顿迭代法后这个值很快就趋近于根号2了：
        <br>(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp; + 2/4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) / 2 = 2.25
        <br>(&nbsp;&nbsp;&nbsp;&nbsp; 2.25 + 2/2.25&nbsp;&nbsp;&nbsp;&nbsp; ) / 2 = 1.56944..
        <br>( 1.56944..+ 2/1.56944..) / 2 = 1.42189..
        <br>( 1.42189..+ 2/1.42189..) / 2 = 1.41423..
        <br>&#8230;.
        <img alt="\" src="http://up.2cto.com/2012/0626/20120626085529128.gif" style="width: 376px; height: 288px;">
        <br>这种算法的原理很简单，我们仅仅是不断用(x,f(x))的切线来逼近方程x^2-a=0的根。根号a实际上就是x^2-a=0的一个正实根，这个函数的导数是2x。也就是说，函数上任一点(x,f(x))处的切线斜率是2x。那么，x-f(x)/(2x)就是一个比x更接近的近似值。代入 f(x)=x^2-a得到x-(x^2-a)/(2x)，也就是(x+a/x)/2。</p>
    <p>相关的代码如下：</p>
    <p>float SqrtByNewton(float x)
        <br>{
        <br>&nbsp;float val = x;//最终
        <br>&nbsp;float last;//保存上一个计算的值
        <br>&nbsp;do
        <br>&nbsp;{
        <br>&nbsp;&nbsp;last = val;
        <br>&nbsp;&nbsp;val =(val + x/val) / 2;
        <br>&nbsp;}while(abs(val-last) &gt; eps);
        <br>&nbsp;return val;
        <br>}然后我们再来看下性能测试：
    </p>
    <p>&nbsp;
        <img alt="\" src="http://up.2cto.com/2012/0626/20120626085547902.png" style="width: 375px; height: 180px;">
    </p>
    <p>哇塞，性能提高了很多</p>
</blockquote>


<h3>My code</h3>

<p><strong>Binary search</strong>.</p>

<pre><code>public int sqrt(int x) {
    if (x &lt;= 1)
        return x;
    long left = 1, right = x;
    long mid, square;
    while (right - left &gt; 1) {
        mid = (left + right) / 2;
        square = mid * mid;
        if (square == x)
            return (int) mid;
        else if (square &gt; x)
            right = mid;
        else if (square &lt; x)
            left = mid;
    }
    return (int) left;
}
</code></pre>

<p><strong>Newton&rsquo;s method, code from <a href="http://www.cnblogs.com/AnnieKim/archive/2013/04/18/3028607.html">this blog</a></strong>.</p>

<pre><code>public int sqrt(int x) {
    if (x == 0) return 0;
    double last = 0, res = 1;
    while (res != last) {
        last = res;
        res = (res + x / res) / 2;
    }
    return (int) res;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/21/Sort-Colors/">[LeetCode 75] Sort Colors</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-21T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/21/Sort-Colors/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/21/Sort-Colors/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/sort-colors/">link</a></p>

<div class="question-content">
            <p></p><p>
Given an array with <i>n</i> objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.
</p>

<p>
Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
</p>

<p>
<b>Note:</b><br>
You are not suppose to use the library&#8217;s sort function for this problem.
</p>

<div class="spoilers" >
<p><b>Follow up:</b><br>
A rather straight forward solution is a two-pass algorithm using counting sort.<br>
First, iterate the array counting number of 0&#8217;s, 1&#8217;s, and 2&#8217;s, then overwrite array with total number of 0&#8217;s, then 1&#8217;s and followed by 2&#8217;s.</p>
<p>Could you come up with an one-pass algorithm using only constant space?<br>
</p>
</div><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a extremely interesting question, with very tricky solutions</strong>. But the 3rd piece of code is actually the standard solution (by making use of the idea from <strong>partition array</strong>).</p>

<h3>Code</h3>

<p><strong>First solution came from</strong> <a href="https://oj.leetcode.com/discuss/1827/anyone-with-one-pass-and-constant-space-solution">this blog</a>.</p>

<pre><code>public void sortColors(int[] A) {
    int a = -1, b = -1, c = -1;
    for (int i = 0; i &lt; A.length; i ++) {
        if (A[i] == 0) {
            A[++ c] = 2;
            A[++ b] = 1;
            A[++ a] = 0;
        } else if (A[i] == 1) {
            A[++ c] = 2;
            A[++ b] = 1;
        } else {
            A[++ c] = 2;
        }
    }
}
</code></pre>

<p><strong>Second solution, 2 pointer &amp; swap</strong> which is written <a href="http://fisherlei.blogspot.sg/2013/01/leetcode-sort-colors.html">here</a>.</p>

<pre><code>public void sortColors(int[] A) {
    int len = A.length;
    int i = 0, x = 0, y = len - 1;
    while (i &lt;= y) {
        if (A[i] == 0) 
            swap(A, i ++, x ++);
        else if (A[i] == 2) 
            swap(A, i, y --);
        else i ++;
    }
}

private void swap(int[] A, int a, int b) {
    int temp = A[a];
    A[a] = A[b];
    A[b] = temp;
}
</code></pre>

<p><strong>Updated on July 4th, 2014</strong>: Use of solution of <strong>Partition Array</strong> to partition colors twice:</p>

<ol>
<li>first time move all 0 to left.</li>
<li>second time move all 1 to left, following the 0s.</li>
</ol>


<p>Code :</p>

<pre><code>public void sortColors(int[] A) {
    if (A == null || A.length == 0) {
        return;
    }
    int len = A.length;
    partition(A, 0, len - 1, 0);
    int p = 0;
    while (p &lt; len &amp;&amp; A[p] == 0) {
        p++;
    }
    partition(A, p, len - 1, 1);
}

private void partition(int[] A, int start, int end, int target) {
    // find the target and put it on the left side of the array
    while (start &lt; end) {
        while (start &lt; A.length &amp;&amp; A[start] == target) {
            start++;
        }
        while (end &gt;= 0 &amp;&amp; A[end] != target) {
            end--;
        }
        if (start &gt; end) {
            break;
        } else {
            int temp = A[start];
            A[start] = A[end];
            A[end] = temp;
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/21/Simplify-Path/">[LeetCode 71] Simplify Path</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-21T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/21/Simplify-Path/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/21/Simplify-Path/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/simplify-path/">link</a></p>

<div class="question-content">
            <p></p><p>Given an absolute path for a file (Unix-style), simplify it.</p>

<p>For example,<br>
<b>path</b> = <code>"/home/"</code>, =&gt; <code>"/home"</code><br>
<b>path</b> = <code>"/a/./b/../../c/"</code>, =&gt; <code>"/c"</code><br>
</p>

<div class="spoilers" ><b>Corner Cases:</b>

<p>
</p><ul>
<li>Did you consider the case where <b>path</b> = <code>"/../"</code>?<br>
In this case, you should return <code>"/"</code>.</li>
<li>Another corner case is the path might contain multiple slashes <code>'/'</code> together, such as <code>"/home//foo/"</code>.<br>
In this case, you should ignore redundant slashes and return <code>"/home/foo"</code>.</li>
<p></p>
</ul></div><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very difficult string question</strong>. I read <a href="http://fisherlei.blogspot.sg/2013/01/leetcode-simplify-path.html">this blog</a> and then understands the question. The solution is just straight-forward without any fancy algo/thinkings.</p>

<blockquote cite="http://fisherlei.blogspot.sg/2013/01/leetcode-simplify-path.html">
    <br>
    [解题思路]<br>
    利用栈的特性，如果sub string element<br>
    1. 等于“/”，跳过，直接开始寻找下一个element<br>
    2. 等于“.”，什么都不需要干，直接开始寻找下一个element<br>
    3. 等于“..”，弹出栈顶元素，寻找下一个element<br>
    4. 等于其他，插入当前elemnt为新的栈顶，寻找下一个element<br>
    <br>
    最后，再根据栈的内容，重新拼path。这样可以避免处理连续多个“/”的问题。<br>
    <br>
</blockquote>


<h3>Solution</h3>

<p>Simply make use of stack and read thru all substrings seperated by /.</p>

<h3>Code</h3>

<pre><code>public String simplifyPath(String path) {
    Stack&lt;String&gt; stack = new Stack&lt;String&gt;();
    String[] list = path.split("/");
    for(String cur: list) {
        if (cur.equals("/") || cur.equals(".")
            || cur.equals("")) continue;
        if (cur.equals("..")) {
            if (! stack.isEmpty()) stack.pop();
        } else stack.push(cur);
    }
    String ans = "";
    if (stack.isEmpty()) return "/";
    while (! stack.isEmpty()) {
        ans = "/" + stack.pop() + ans;
    }
    return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/21/Set-Matrix-Zeroes/">[LeetCode 73] Set Matrix Zeroes</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-21T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/21/Set-Matrix-Zeroes/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/21/Set-Matrix-Zeroes/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/set-matrix-zeroes/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a <i>m</i> x <i>n</i> matrix, if an element is 0, set its entire row and column to 0. Do it in place.
</p>

<div class="spoilers"><b>Follow up:</b>

<p>
Did you use extra space?<br>
A straight forward solution using O(<i>m</i><i>n</i>) space is probably a bad idea.<br>
A simple improvement uses O(<i>m</i> + <i>n</i>) space, but still not the best solution.<br>
Could you devise a constant space solution?
</p>
</div><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very borning question</strong>. The O(m+n) space solution is trivial, I will not cover. The constant space solution is <strong>making use of 1st row and 1st columns</strong> of the input array.</p>

<h3>Solution</h3>

<p><strong>The idea is clear enough</strong>, but writing the code is not as easy. <a href="http://www.programcreek.com/2012/12/leetcode-set-matrix-zeroes-java/">This post</a> is a good explanation and code for the solution.</p>

<p><strong>Difficult point</strong>: when there&rsquo;s 0, set 0; but when there is no 0, do not touch on the value (if original it&rsquo;s 3, keep it 3).</p>

<h3>Code</h3>

<pre><code>public void setZeroes(int[][] matrix) {
    int m = matrix.length;
    if (m == 0) return;
    int n = matrix[0].length;
    if (n == 0) return;

    int firstrow = 1, firstcol = 1;
    for (int i = 0; i &lt; m; i ++) 
        if (matrix[i][0] == 0) 
            firstcol = 0;
    for (int i = 0; i &lt; n; i ++) 
        if (matrix[0][i] == 0) 
            firstrow = 0;
    for (int i = 1; i &lt; m; i ++) {
        for (int j = 1; j &lt; n; j ++) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }
    for (int i = 1; i &lt; m; i ++) {
        if (matrix[i][0] == 0)
            for (int j = 1; j &lt; n; j ++) 
                matrix[i][j] = 0;
        if (firstcol == 0) matrix[i][0] = 0;
    }
    for (int i = 1; i &lt; n; i ++) {
        if (matrix[0][i] == 0)
            for (int j = 1; j &lt; m; j ++) 
                matrix[j][i] = 0;
        if (firstrow == 0) matrix[0][i] = 0;
    }
    if(firstrow == 0 || firstcol == 0) 
        matrix[0][0] = 0;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/21/Search-a-2D-Matrix/">[LeetCode 74] Search a 2D Matrix</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-21T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/21/Search-a-2D-Matrix/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/21/Search-a-2D-Matrix/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/search-a-2d-matrix/">link</a></p>

<div class="question-content">
            <p></p><p>Write an efficient algorithm that searches for a value in an <i>m</i> x <i>n</i> matrix. This matrix has the following properties:</p>

<p>
</p><ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<p></p>

<p>
For example,</p>
<p>
Consider the following matrix:
</p>
<pre>[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
</pre>

<p>Given <b>target</b> = <code>3</code>, return <code>true</code>.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Related questions</h3>

<p><strong><a href="/blog/2014/05/21/Search-a-2D-Matrix/">Search a 2D Matrix</a></strong>.</p>

<p><strong><a href="/blog/2014/06/10/Searching-a-2D-Sorted-Matrix/">Searching a 2D Sorted Matrix</a></strong>.</p>

<p><strong><a href="/blog/2014/06/14/Count-negative-in-2D-Sorted-Matrix/">Count negative in a 2D Sorted Matrix</a></strong>.</p>

<h3>Analysis</h3>

<p><strong>This is a binary search question</strong>.</p>

<h3>Solution</h3>

<p>I did not use binary, but use the easier linear search. It still passed.</p>

<h3>Code</h3>

<p><strong>my code revised (2D binary search)</strong></p>

<pre><code>public boolean searchMatrix(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return false;
    }
    int m = matrix.length;
    int n = matrix[0].length;
    // find target vertically from matrix[0] to matrix[m-1]
    int top = 0, bottom = m - 1;
    int mid;
    while (top + 1 &lt; bottom) {
        mid = top + (bottom - top) / 2;
        if (matrix[mid][0] &lt; target) {
            top = mid;
        }
        else {
            bottom = mid;
        }
    }
    // locate the row number
    int row = -1;
    if (matrix[top][0] &lt;= target &amp;&amp; target &lt;= matrix[top][n-1]) {
        row = top;
    }
    else if (matrix[bottom][0] &lt;= target &amp;&amp; target &lt;= matrix[bottom][n-1]) {
        row = bottom;
    }
    else {
        return false;
    }
    // now find target from matrix[row]
    int left = 0, right = n - 1;
    while (left + 1 &lt; right) {
        mid = left + (right - left) / 2;
        if (matrix[row][mid] &lt; target) {
            left = mid;
        }
        else {
            right = mid;
        }
    }
    return (matrix[row][left] == target || matrix[row][right] == target);
}
</code></pre>

<p><strong>A good binary search code <a href="http://www.programcreek.com/2013/01/leetcode-search-a-2d-matrix-java/">here</a> (1D binary search)</strong></p>

<pre><code>public boolean searchMatrix(int[][] matrix, int target) {
    if(matrix==null || matrix.length==0 || matrix[0].length==0) 
        return false;

    int m = matrix.length;
    int n = matrix[0].length;
    int start = 0;
    int end = m*n-1;

    while(start&lt;=end){
        int mid=(start+end)/2;
        int midX=mid/n;
        int midY=mid%n;

        if(matrix[midX][midY]==target) 
            return true;
        if(matrix[midX][midY]&lt;target){
            start=mid+1;
        }else{
            end=mid-1;
        }
    }
    return false;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/21/Plus-One/">[LeetCode 66] Plus One</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-21T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/21/Plus-One/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/21/Plus-One/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/plus-one/">link</a></p>

<div class="question-content">
            <p></p><p>Given a non-negative number represented as an array of digits, plus one to the number.</p>

<p>The digits are stored such that the most significant digit is at the head of the list.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is an easy question</strong>.</p>

<h3>My code</h3>

<pre><code>public int[] plusOne(int[] digits) {
    int n = digits.length - 1;
    while (n != -1 &amp;&amp; digits[n] == 9) {
        n--;
    }
    if (n != -1) {
        // a non-9 number is found. change it. 
        digits[n] ++;
        for (int i = n + 1; i &lt; digits.length; i ++) {
            digits[i] = 0;
        }
        return digits;
    } else {
        int[] newD = new int[digits.length + 1];
        newD[0] = 1;
        for (int i = 1; i &lt; newD.length; i ++) {
            newD[i] = 0;
        }
        return newD;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/21/Minimum-Window-Substring/">[LeetCode 76] Minimum Window Substring</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-21T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/21/Minimum-Window-Substring/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/21/Minimum-Window-Substring/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/minimum-window-substring/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
</p>

<p>
For example,<br>
<b>S</b> = <code>"ADOBECODEBANC"</code><br>
<b>T</b> = <code>"ABC"</code><br>
</p>
<p>
Minimum window is <code>"BANC"</code>.
</p>

<p>
<b>Note:</b><br>
If there is no such window in S that covers all characters in T, return the emtpy string <code>""</code>.
</p>
<p>
If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very difficult string matching question</strong>.</p>

<p>The sliding window solution is very well explained in <a href="http://leetcode.com/2010/11/finding-minimum-window-in-s-which.html">this post</a> (the best solution).</p>

<blockquote cite="http://fisherlei.blogspot.sg/2013/01/leetcode-simplify-path.html">
    <p>To help illustrate this approach, I use a different example: <b>S</b> = “<b>acbbaca</b>” and <b>T</b> = “<b>aba</b>“. The idea is mainly based on the help of two pointers (begin and end position of the window) and two tables (<i>needToFind </i>and <i>hasFound</i>) while traversing <b>S</b>. <i>needToFind</i> stores the total count of a character in <b>T</b> and <i>hasFound</i> stores the total count of a character met so far. We also use a <i>count</i> variable to store the total characters in <b>T</b> that’s met so far (not counting characters where hasFound[<i>x</i>]<i> </i>exceeds needToFind[<i>x</i>]). When count equals <b>T</b>‘s length, we know a valid window is found.</p><p>Each time we advance the end pointer (pointing to an element <i>x</i>), we increment hasFound[<i>x</i>] by one. We also increment <i>count </i>by one if hasFound[<i>x</i>] is less than or equal to needToFind[<i>x</i>]. Why? When the constraint is met (that is, <i>count</i> equals to <b>T</b>‘s size), we immediately advance begin pointer as far right as possible while maintaining the constraint.</p><p>How do we check if it is maintaining the constraint? Assume that begin points to an element <i>x</i>, we check if hasFound[<i>x</i>] is greater than needToFind[<i>x</i>]. If it is, we can decrement hasFound[<i>x</i>] by one and advancing begin pointer without breaking the constraint. On the other hand, if it is not, we stop immediately as advancing begin pointer breaks the window constraint.</p><p>Finally, we check if the minimum window length is less than the current minimum. Update the current minimum if a new minimum is found.</p><p>Essentially, the algorithm finds the first window that satisfies the constraint, then continue maintaining the constraint throughout.</p><p></p><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/_UElib2WLeDE/TOBuvjG6exI/AAAAAAAACYE/uludVXtJ8OY/s1600/sliding.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="83" src="http://2.bp.blogspot.com/_UElib2WLeDE/TOBuvjG6exI/AAAAAAAACYE/uludVXtJ8OY/s400/sliding.gif" width="400"></a></div><div style="text-align: center;"><span style="font-size: x-small;">i) <b>S</b> = “<b>acbbaca</b>” and <b>T</b> = “<b>aba</b>“.<br></span></div><p></p><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/_UElib2WLeDE/TOBvHRLbOAI/AAAAAAAACYI/38QLgUIMePU/s1600/sliding_2.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="79" src="http://4.bp.blogspot.com/_UElib2WLeDE/TOBvHRLbOAI/AAAAAAAACYI/38QLgUIMePU/s400/sliding_2.gif" width="400"></a></div><div style="text-align: center;"><span style="font-size: x-small;">ii) The first minimum window is found. Notice that we cannot advance begin pointer as hasFound[&#8216;a&#8217;] == needToFind[&#8216;a&#8217;] == 2. Advancing would mean breaking the constraint.<br></span></div><p></p><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/_UElib2WLeDE/TOBvLH1aLcI/AAAAAAAACYM/pbJLl7qoduo/s1600/sliding_3.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="79" src="http://3.bp.blogspot.com/_UElib2WLeDE/TOBvLH1aLcI/AAAAAAAACYM/pbJLl7qoduo/s400/sliding_3.gif" width="400"></a></div><div style="text-align: center;"><span style="font-size: x-small;">iii) The second window is found. begin pointer still points to the first element ‘a’. hasFound[&#8216;a&#8217;] (<b>3</b>) is greater than needToFind[&#8216;a&#8217;] (<b>2</b>). We decrement hasFound[&#8216;a&#8217;] by one and advance begin pointer to the right.<br></span></div><p></p><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/_UElib2WLeDE/TOBvOljpz0I/AAAAAAAACYQ/TxuWgWGTOF4/s1600/sliding_4.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="79" src="http://2.bp.blogspot.com/_UElib2WLeDE/TOBvOljpz0I/AAAAAAAACYQ/TxuWgWGTOF4/s400/sliding_4.gif" width="400"></a></div><div style="text-align: center;"><span style="font-size: x-small;">iv) We skip ‘c’ since it is not found in <b>T</b>. Begin pointer now points to ‘b’. hasFound[&#8216;b&#8217;] (<b>2</b>) is greater than needToFind[&#8216;b&#8217;] (<b>1</b>). We decrement hasFound[&#8216;b&#8217;] by one and advance begin pointer to the right.<br></span></div><p></p><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/_UElib2WLeDE/TOBvSOl6RdI/AAAAAAAACYU/R4O1dPXVvBQ/s1600/sliding_5.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="79" src="http://2.bp.blogspot.com/_UElib2WLeDE/TOBvSOl6RdI/AAAAAAAACYU/R4O1dPXVvBQ/s400/sliding_5.gif" width="400"></a></div><div style="text-align: center;"><span style="font-size: x-small;">v) Begin pointer now points to the next ‘b’. hasFound[&#8216;b&#8217;] (1) is equal to needToFind[&#8216;b&#8217;] (1). We stop immediately and this is our newly found minimum window.<br></span></div><p>Both the begin and end pointers can advance at most <i>N</i> steps (where <i>N</i> is <b>S</b>‘s size) in the worst case, adding to a total of 2<i>N</i> times. Therefore, the run time complexity must be in <i>O</i>(<i>N</i>).</p>
</blockquote>


<h3>Solution</h3>

<p>Best code is from <a href="http://answer.ninechapter.com/solutions/minimum-window-substring/">this post</a>.</p>

<p>First of all, keep a HashMap to store all letters and occurrance. Then declare a &lsquo;count&rsquo; variable. This is an important varaible. It helps us to check whether we have successfully achieve at least 1 window. After we found the first window, the &lsquo;count&rsquo; variable shall always equals to total number of letters in &rsquo;T&#8217;.</p>

<p>Now the looping part. Basically we assume that the window end at one point, and we find the correct starting position and calculate corresponding length.</p>

<p>The coding part is very difficult. Try to practise more.</p>

<h3>Code</h3>

<p><strong>Updated on July 7th</strong>, code:</p>

<pre><code>public String minWindow(String S, String T) {
    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();
    HashMap&lt;Character, Integer&gt; map2 = new HashMap&lt;Character, Integer&gt;();
    for (Character ch: T.toCharArray()) {
        if (map.containsKey(ch)) {
            map.put(ch, map.get(ch) + 1);
        } else {
            map.put(ch, 1);
            map2.put(ch, 0);
        }
    }
    int count = 0;
    int start = 0;
    int end = 0;
    String result = "";
    while (end &lt; S.length()) {
        char cur = S.charAt(end);
        if (!map.containsKey(cur)) {
            end++;
            continue;
        }
        map2.put(cur, map2.get(cur) + 1);
        if (map2.get(cur) &lt;= map.get(cur)) {
            count++;
        }

        if (count == T.length()) {
            // locate start point
            while(true) {
                char ll = S.charAt(start);
                if (!map.containsKey(ll)) {
                    start++;
                    continue;
                }
                if (map2.get(ll) &gt; map.get(ll)) {
                    map2.put(ll, map2.get(ll) - 1);
                    start++;
                    continue;
                } else {
                    break;
                }
            }
            if (result.equals("") || result.length() &gt; end - start + 1) {
                result = S.substring(start, end + 1);
            }
        }
        end++;
    }
    return result;
}
</code></pre>

<p><strong>Updated on July 19th</strong>, rewrite the code changing all while-loop to for-loop:</p>

<pre><code>public String minWindow(String S, String T) {
    if (S.length() &lt; T.length()) {
        return "";
    }
    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();
    HashMap&lt;Character, Integer&gt; found = new HashMap&lt;Character, Integer&gt;();
    for (Character ch: T.toCharArray()) {
        if (map.containsKey(ch)) {
            map.put(ch, map.get(ch) + 1);
        } else {
            map.put(ch, 1);
            found.put(ch, 0);
        }
    }

    String window = S;
    int count = 0;
    int start  = 0;

    char[] letters = S.toCharArray();
    for (int i = 0; i &lt; letters.length; i++) {
        char ch  = letters[i];
        if (!map.containsKey(ch)) {
            continue;
        }
        if (found.get(ch) &lt; map.get(ch)) {
            count++;
        }
        found.put(ch, found.get(ch) + 1);
        if (count == T.length()) {
            // update the start pointer
            for (; start &lt;= i; start++) {
                char sChar = letters[start];
                if (!map.containsKey(sChar)) {
                    continue;
                }
                if (found.get(sChar) &lt;= map.get(sChar)) {
                    break;
                } else {
                    found.put(sChar, found.get(sChar) - 1);
                }
            }
            if (window.length() &gt; i - start + 1) {
                window = S.substring(start, i + 1);
            }
        }
    }
    return count == T.length() ? window : "";
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/21/Edit-Distance/">[LeetCode 72] Edit Distance</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-21T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/05/21/Edit-Distance/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/05/21/Edit-Distance/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/edit-distance/">link</a></p>

<div class="question-content">
            <p></p><p>
Given two words <i>word1</i> and <i>word2</i>, find the minimum number of steps required to convert <i>word1</i> to <i>word2</i>. (each operation is counted as 1 step.)
</p>

<p>
You have the following 3 operations permitted on a word:
</p>

<p>
a) Insert a character<br>
b) Delete a character<br>
c) Replace a character<br>
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a difficult DP problem</strong>. A lot of people said in their blog that they spent tons of time on this question.</p>

<h3>Solution</h3>

<p><strong>I posted below a very standard solution</strong>. The unconventional part of this solution is instead of declaring DP array of m*n size, I must declare it (m+1)*(n+1) size, where dp[i][j] denotes the distance of 2 strings that ends with (i)th and (j)th char respectively.</p>

<p>The rest of the code is easy to understand.</p>

<h3>Code</h3>

<p><strong>my code</strong></p>

<pre><code>public int minDistance(String word1, String word2) {
    int m = word1.length();
    int n = word2.length();

    int[][] dp = new int[m+1][n+1];
    for (int i = 0; i &lt;= m; i++) {
        dp[i][0] = i;
    }
    for (int i = 0; i &lt;= n; i++) {
        dp[0][i] = i;
    }
    for (int a = 1; a &lt;= m; a++) {
        char aa = word1.charAt(a-1);
        for (int b = 1; b &lt;= n; b++) {
            char bb = word2.charAt(b-1);
            if (aa == bb) 
                dp[a][b] = dp[a-1][b-1];
            else {
                int t1 = dp[a-1][b-1] + 1;
                int t2 = dp[a][b-1] + 1;
                int t3 = dp[a-1][b] + 1;
                dp[a][b] = Math.min(Math.min(t1, t2), t3);
            }
        }
    }
    return dp[m][n];
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/43">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/41">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (60)</a></li>
<li class='category'><a href='/blog/categories/experience/'>experience (3)</a></li>
<li class='category'><a href='/blog/categories/facebook/'>facebook (9)</a></li>
<li class='category'><a href='/blog/categories/fundamental/'>fundamental (5)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (45)</a></li>
<li class='category'><a href='/blog/categories/java-oop/'>java oop (24)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (153)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (103)</a></li>
<li class='category'><a href='/blog/categories/string-search/'>string search (7)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (7)</a></li>
<li class='category'><a href='/blog/categories/top-k/'>top k (7)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/01/24/distributed-caching-memcached/">[Design] Distributed Caching - Memcached</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/24/design-google-suggest-autocomplete/">[Design] Design Google Suggest (Autocomplete)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/20/top-n-from-sum-2-array/">[Google] Top N Values From Sum of 2 Arrays</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/20/java-vector-arraylist/">[Java OOP] Java Vector and ArrayList</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/20/java-abstract-class-interface/">[Java OOP] Interface and Abstract Classes</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Charlie Brown -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
