
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Woodstock Blog</title>
  <meta name="author" content="Charlie Brown">

  
  <meta name="description" content="Question link Given an array where elements are sorted in ascending order, convert it to a height balanced BST. Stats Frequency 3 Difficulty 2 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/33">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Woodstock Blog</a></h1>
  
    <h2>What's the good of living if you don't try a few things?</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/26/Convert-Sorted-Array-to-Binary-Search-Tree/">[LeetCode 108] Convert Sorted Array to Binary Search Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-26T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">link</a></p>

<div class="question-content">
            <p></p><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>My first understanding of this question is wrong</strong>.</p>

<p>A BST does not necessarily have to fill in left side of the leaf as muc has possible. I was confusing &ldquo;balanced binary tree&rdquo; with &ldquo;left-balanced binary tree&rdquo;.</p>

<blockquote><p><strong>A balanced binary tree</strong> is commonly defined as a binary tree in which the depth of the left and right subtrees of every node differ by 1 or less</p>

<p><strong>A left-balanced binary tree</strong> is a balanced binary tree where the left sub-tree of each node is filled before the right sub-tree</p></blockquote>

<h3>Solution</h3>

<p>Then this question become straight-forward.</p>

<h3>Code</h3>

<pre><code>public TreeNode sortedArrayToBST(int[] num) {
    if (num.length == 0) return null;
    return helper(num, 0, num.length - 1);
}

public TreeNode helper(int[] num, int start, int end) {
    if (start &gt; end) return null;
    int mid = (start + end) / 2;
    TreeNode node = new TreeNode(num[mid]);
    node.left = helper(num, start, mid - 1);
    node.right = helper(num, mid + 1, end);
    return node;
} 
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/26/Balanced-Binary-Tree/">[LeetCode 110] Balanced Binary Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-26T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/balanced-binary-tree/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, determine if it is height-balanced.
</p>

<p>
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <i>every</i> node never differ by more than 1.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a difficult question for me</strong>.</p>

<p>My first code contains many dulicate calls. I have posted it below as an illustration of bad example.</p>

<h3>Solution</h3>

<p>The solution should make use of the return value from the recursion, and avoid duplication calls. The standard solution is posted below.</p>

<h3>Code</h3>

<p><strong>First, my initial solution</strong>. It takes 30ms more than next code.</p>

<pre><code>public boolean isBalanced(TreeNode root) {
    // my old code re-submit, for speed test
    if (root == null) return true;
    if (Math.abs(depth(root.left) - depth(root.right)) &gt; 1) {
        return false;
    }
    if (! isBalanced(root.left)) return false;
    if (! isBalanced(root.right)) return false;
    return true;
}

private int depth(TreeNode node) {
    if (node == null) return 0;
    if (node.left == null) return 1 + depth(node.right);
    if (node.right == null) return 1 + depth(node.left);
    return 1 + Math.max(depth(node.left), depth(node.right));
}
</code></pre>

<p><strong>Second, the standard solution</strong></p>

<pre><code>public boolean isBalanced(TreeNode root) {
    return helper(root) != -1;
}

private int helper(TreeNode node) {
    if (node == null) return 0;
    int a = helper(node.left);
    if (a == -1) return -1;
    int b = helper(node.right);
    if (b == -1) return -1;
    if (Math.abs(a - b) &lt;= 1) 
        return Math.max(a, b) + 1;
    else return -1;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Same-Tree/">[LeetCode 100] Same Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/same-tree/">link</a></p>

<div class="question-content">
            <p></p><p>
Given two binary trees, write a function to check if they are equal or not.
</p>

<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is an easy one</strong></p>

<h3>Code</h3>

<pre><code>public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null &amp;&amp; q == null)
        return true;
    if (p == null || q == null)
        return false;
    if (p.val == q.val)
        return isSameTree(p.left, q.left) 
            &amp;&amp; isSameTree(p.right, q.right);
    return false;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Recover-Binary-Search-Tree/">[LeetCode 99] Recover Binary Search Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/recover-binary-search-tree/">link</a></p>

<div class="question-content">
            <p></p><p>
Two elements of a binary search tree (BST) are swapped by mistake.</p>

<p>Recover the tree without changing its structure.
</p>

<b>Note:</b><br>
A solution using O(<i>n</i>) space is pretty straight forward. Could you devise a constant space solution?
<p></p>

<p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is one of the most difficult questions that I have solved</strong>.</p>

<p>The question can be solved using 2 pointers to point to the 2 misplaced nodes, and swap them. I solved the problem with this approach, and I found a good explanation <a href="http://chaoren.is-programmer.com/posts/42931.html">here</a>.</p>

<blockquote><p>Only two variables (first, second) are enough to record nodes to be exchanged.</p>

<p>If there&rsquo;s only one descending order pair (e.g. 20, 10, 30, 40, 50), use first &amp; second to record it.</p>

<p>If there are two descending order pairs (e.g. 10, 40, 30, 20, 50 or 50, 20, 30, 40, 10), use the smaller number in second pair to update variable &lsquo;second&rsquo;.</p>

<p>In the end, swap first and second.</p></blockquote>

<p>This is a popular solution on the Internet, which <strong>uses O(1) space, plus average case O(lgn) stack space</strong> (because recursion always incur stack usage). So this solution is actually not fulfilling the requirements.</p>

<blockquote><p>中序遍历二叉树的空间复杂度是O(logN) on average case</p></blockquote>

<p><strong>So finally I found a solution with constent space, and it&rsquo;s using Treaded Binary Tree again</strong>! Look below for details.</p>

<h3>Solution</h3>

<p><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/">This</a> is a systematic analysis of <strong>Morris Traversal</strong> based on <strong>Threaded Binary Tree</strong>.</p>

<p><strong>A solution of using Morris Traversal is explained <a href="http://www.cnblogs.com/TenosDoIt/p/3445682.html">here</a></strong>. Don&rsquo;t worry about the tree structure being changed, because it&rsquo;s reverted back after the traversal.</p>

<blockquote><p>算法2：为了满足O(1)空间复杂度，我们就要使用非递归且不使用栈的中序遍历算法，在leetcode另一个题目Binary Tree Inorder Traversal中，我们提到了Morris Traversal中序遍历算法，它既没有递归，也没有使用栈，而是用了线索二叉树的思想，用闲置的右节点指向中序序列中该节点的后缀，遍历后再恢复树的原始指针。其主要算法步骤如下：</p>

<p>重复以下1、2直到当前节点为空。</p></blockquote>

<p><strong><a href="http://fisherlei.blogspot.sg/2012/12/leetcode-recover-binary-search-tree.html">Another person</a></strong> have a very good (maybe better) English version of analysis and code:</p>

<pre><code>1. Initialize current as root 
2. While current is not NULL
   If current does not have left child
      a) Print current’s data
      b) Go to the right, i.e., current = current-&amp;gt;right
   Else
      a) Make current as right child of the rightmost node in current's left subtree
      b) Go to this left child, i.e., current = current-&amp;gt;left
</code></pre>

<h3>Code</h3>

<p><strong>First, my code (2 pointer solution)</strong></p>

<pre><code>TreeNode first = null, second = null;
TreeNode pre = new TreeNode(Integer.MIN_VALUE);

public void recoverTree(TreeNode root) {
    helper(root);
    // now first and second are both found
    int temp = first.val;
    first.val = second.val;
    second.val = temp;
}

private void helper(TreeNode root) {
    if (root == null) return;
    helper(root.left);
    if (pre.val &gt; root.val) {
        if (first == null) {
            first = pre;
            second = root;
        }
        else second = root;
    }
    pre = root;
    helper(root.right);
}
</code></pre>

<p><strong>Second, real O(1) space solution</strong> using Threaded Binary Tree (i.e. Morris Traversal) in C++. I could not memorize this code.</p>

<pre><code>void recoverTree(TreeNode *root) {
       TreeNode *f1=NULL, *f2=NULL;
       TreeNode  *current,*pre, *parent=NULL;

       if(root == NULL)
             return;
       bool found = false;
       current = root;
       while(current != NULL)
       {                
             if(current-&gt;left == NULL)
             {
                    if(parent &amp;&amp; parent-&gt;val &gt; current-&gt;val)
                    {
                           if(!found)
                           {
                                 f1 = parent;
                                 found = true;
                           }
                           f2 = current;
                    }
                    parent = current;
                    current = current-&gt;right;     
             }   
             else
             {
                    /* Find the inorder predecessor of current */
                    pre = current-&gt;left;
                    while(pre-&gt;right != NULL &amp;&amp; pre-&gt;right != current)
                           pre = pre-&gt;right;

                    /* Make current as right child of its inorder predecessor */
                    if(pre-&gt;right == NULL)
                    {
                           pre-&gt;right = current;
                           current = current-&gt;left;
                    }

                    /* Revert the changes made in if part to restore the original
                    tree i.e., fix the right child of predecssor */  
                    else
                    {
                           pre-&gt;right = NULL;
                           if(parent-&gt;val &gt; current-&gt;val)
                           {
                                 if(!found)
                                 {
                                        f1 = parent;       
                                        found = true;
                                 }
                                 f2 = current;
                           }
                           parent = current;
                           current = current-&gt;right;     
                    } /* End of if condition pre-&gt;right == NULL */
             } /* End of if condition current-&gt;left == NULL*/
       } /* End of while */

       if(f1 &amp;&amp; f2)
             swap(f1-&gt;val, f2-&gt;val);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Minimum-Depth-of-Binary-Tree/">[LeetCode 111] Minimum Depth of Binary Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/minimum-depth-of-binary-tree/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, find its minimum depth.</p>

<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>There are various ways to solve this question.</strong></p>

<p>Eg. DFS, BFS, queue and so on.</p>

<h3>Solution</h3>

<p>I have nothing to say with the code.</p>

<h3>Code</h3>

<pre><code>public int minDepth(TreeNode root) {
    if (root == null) return 0;
    return helper(root, Integer.MAX_VALUE, 1);
}

private int helper(TreeNode node, int min, int level) {
    if (node == null || level &gt;= min) 
        return min;
    if (node.left == null &amp;&amp; node.right == null)
        return level;
    min = helper(node.left, min, level + 1);
    min = helper(node.right, min, level + 1);
    return min;
}
</code></pre>

<p><strong>Updated on June 10th, this question is better solved with the Divide &amp; Conquer template</strong>! <a href="http://answer.ninechapter.com/solutions/minimum-depth-of-binary-tree/">link</a></p>

<pre><code>public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return checkLeaf(root);
}

private int checkLeaf(TreeNode node) {
    if (node == null) {
        return Integer.MAX_VALUE;
    }
    if (node.left == null &amp;&amp; node.right == null) {
        return 1;
    }
    int ll = checkLeaf(node.left);
    int rr = checkLeaf(node.right);
    return 1 + Math.min(ll, rr);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Maximum-Depth-of-Binary-Tree/">[LeetCode 104] Maximum Depth of Binary Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/maximum-depth-of-binary-tree/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, find its maximum depth.</p>

<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>There are various ways to solve this question.</strong></p>

<p>Eg. DFS, BFS, queue and so on.</p>

<h3>Solution</h3>

<p>I have nothing to say with the code.</p>

<h3>Code</h3>

<pre><code>public int maxDepth(TreeNode root) {
    return helper(root, 0, 1);
}

private int helper(TreeNode node, int max, int level) {
    if (node == null) return max;
    if (node.left == null &amp;&amp; node.right == null)
        return Math.max(max, level);
    max = helper(node.left, max, level + 1);
    max = helper(node.right, max, level + 1);
    return max;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Binary-Tree-Zigzag-Level-Order-Traversal/">[LeetCode 103] Binary Tree Zigzag Level Order Traversal</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, return the <i>zigzag level order</i> traversal of its nodes&#8217; values. (ie, from left to right, then right to left for the next level and alternate between).</p>

<p>
For example:<br>
Given binary tree <code>{3,9,20,#,#,15,7}</code>,<br>
</p><pre>    3
   / \
  9  20
    /  \
   15   7
</pre>
<p></p>
<p>
return its zigzag level order traversal as:<br>
</p><pre>[
  [3],
  [20,9],
  [15,7]
]
</pre>
<p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question is based on &ldquo;Binary Tree Level Order Traversal&rdquo;</strong>.</p>

<p>Altough this is difficulty level 4, the real difficult part is solving &ldquo;Binary Tree Level Order Traversal&rdquo;. If that question is solved, only slight modification is needed for this question.</p>

<h3>Solution</h3>

<p><strong>Instead of using queue</strong> like in &ldquo;Binary Tree Level Order Traversal&rdquo;, <strong>this question is solved by using Stack</strong>. And it&rsquo;s not hard to see why. The only additional things to note:</p>

<ol>
<li><p>There is no &lsquo;single stack solution&rsquo;, we must use <strong>2 stacks</strong>. (because when push, it&rsquo;s pushed to top).</p></li>
<li><p>Keep a boolean variable to remember rightToLeft or leftToRight.</p></li>
</ol>


<h3>Code</h3>

<p><strong>First, standard BFS solution</strong> using 2 stacks.</p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (root == null) return ans;
    Stack&lt;TreeNode&gt; q = new Stack&lt;TreeNode&gt;();
    q.push(root);
    boolean reverse = true;
    while (! q.isEmpty()) {
        ans.add(new ArrayList&lt;Integer&gt;());
        Stack&lt;TreeNode&gt; qq = new Stack&lt;TreeNode&gt;();
        int curSize = q.size();
        for (int i = 0; i &lt; curSize; i ++) {
            TreeNode node = q.pop();
            ans.get(ans.size() - 1).add(node.val);
            if (reverse) {
                if (node.left != null) qq.push(node.left);
                if (node.right != null) qq.push(node.right);
            }
            else {
                if (node.right != null) qq.push(node.right);
                if (node.left != null) qq.push(node.left);
            }
        }
        q = qq;
        reverse = ! reverse;
    }
    return ans;
}
</code></pre>

<p><strong>Second, DFS solution written by me</strong>, and yes, I love DFS more.</p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    helper(ans, root, 1);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans, TreeNode node, int level) {
    if (node == null) return;
    if (ans.size() &lt; level) {
        ArrayList&lt;Integer&gt; lv = new ArrayList&lt;Integer&gt;();
        lv.add(node.val);
        ans.add(lv);
    }
    else {
        if (level % 2 == 0) 
            ans.get(level - 1).add(0, node.val);
        else
            ans.get(level - 1).add(node.val);
    }
    helper(ans, node.left, level + 1);
    helper(ans, node.right, level + 1);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Binary-Tree-Level-Order-Traversal-II/">[LeetCode 107] Binary Tree Level Order Traversal II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, return the <i>bottom-up level order</i> traversal of its nodes&#8217; values. (ie, from left to right, level by level from leaf to root).</p>

<p>
For example:<br>
Given binary tree <code>{3,9,20,#,#,15,7}</code>,<br>
</p><pre>    3
   / \
  9  20
    /  \
   15   7
</pre>
<p></p>
<p>
return its bottom-up level order traversal as:<br>
</p><pre>[
  [15,7]
  [9,20],
  [3],
]
</pre>
<p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">very easy</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is the same question as previous one</strong>.</p>

<h3>Solution</h3>

<p><strong>There are also 2 solution: BFS and DFS</strong>.</p>

<p>I post BFS code below. Only 2 lines are different: ans.get() and ans.add().</p>

<h3>Code</h3>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (root == null) return ans;
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
    q.add(root);
    while (! q.isEmpty()) {
        ans.add(0, new ArrayList&lt;Integer&gt;());
        int curSize = q.size();
        for (int i = 0; i &lt; curSize; i ++) {
            TreeNode node = q.remove();
            ans.get(0).add(node.val);
            if (node.left != null) q.add(node.left);
            if (node.right != null) q.add(node.right);
        }
    }
    return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Binary-Tree-Level-Order-Traversal/">[LeetCode 102] Binary Tree Level Order Traversal</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/binary-tree-level-order-traversal/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, return the <i>level order</i> traversal of its nodes&#8217; values. (ie, from left to right, level by level).</p>

<p>
For example:<br>
Given binary tree <code>{3,9,20,#,#,15,7}</code>,<br>
</p><pre>    3
   / \
  9  20
    /  \
   15   7
</pre>
<p></p>
<p>
return its level order traversal as:<br>
</p><pre>[
  [3],
  [9,20],
  [15,7]
]
</pre>
<p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a really classic question</strong>.</p>

<p>It is not difficult, however, it&rsquo;s important to understand 2 different ways to solve this problem: <strong>DFS and BFS</strong>.</p>

<p><strong>The different between Inorder, preorder, postorder and Level-order</strong> is explained very well in <a href="http://leetcode.com/2010/09/printing-binary-tree-in-level-order.html">this post</a>.</p>

<blockquote><p>pre-order, in-order, and post-order tree traversal are called Depth First Search (DFS), since they visit the tree by proceeding deeper and deeper until it reaches the leaf nodes.</p>

<p>DFS uses a data structure called Stack and is commonly implemented using recursion. If recursion is not allowed, we can simulate the recursion by using iterative method with the help of stack. For example in the question &ldquo;Binary Search Tree In-Order Traversal&rdquo;, we have a iterative DFS solution using a stack.</p>

<p>The most natural solution for level-order traversal is Breadth First Search (BFS), since it visits the nodes level by level. BFS requires the use of a data structure called Queue.</p></blockquote>

<p><strong>To summarize, Inorder, preorder and postorder is DFS implemented by Stack. Level-order is BFS implemented by Queue</strong>. It is very important to forever make it clear and take it into your grave 60 years later (maybe more, if not less).</p>

<p>One mor thing, <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Stack.html">Stack</a> is a Java class that inherit from <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html">Vector</a>.</p>

<blockquote><p>The Vector class implements a growable array of objects. Like an array, it contains components that can be accessed using an integer index. However, the size of a Vector can grow or shrink as needed to accommodate adding and removing items after the Vector has been created.</p>

<p>ArrayList is roughly equivalent to Vector, except that it is unsynchronized.</p></blockquote>

<p>However, <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Queue.html">Queue</a> is an interface, not a class. What is the most popular Queue implementation in Java? It is not <strong>PriorityQueue</strong>, it&rsquo;s <strong>LinkedList</strong>!</p>

<h3>Solution</h3>

<p><strong>As said, level-order is BFS</strong>. The first code posted below is implemented with a queue. A lot of people used 2 queues, which I don&rsquo;t like.</p>

<p><strong>Second code is DFS</strong>. This is my initial solution, maybe because I&rsquo;m more familiar with DFS.</p>

<h3>Code</h3>

<p><strong>First, BFS code using 1 queue</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (root == null) return ans;
    int level = 0;
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
    q.add(root);
    while (! q.isEmpty()) {
        ans.add(new ArrayList&lt;Integer&gt;());
        int curSize = q.size();
        for (int i = 0; i &lt; curSize; i ++) {
            TreeNode node = q.remove();
            ans.get(level).add(node.val);
            if (node.left != null) q.add(node.left);
            if (node.right != null) q.add(node.right);
        }
        level ++;
    }
    return ans;
}
</code></pre>

<p><strong>First code revised</strong>: I do not really need the variable &lsquo;level&rsquo;.</p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (root == null) return ans;
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
    q.add(root);
    while (! q.isEmpty()) {
        ans.add(new ArrayList&lt;Integer&gt;());
        int curSize = q.size();
        for (int i = 0; i &lt; curSize; i ++) {
            TreeNode node = q.remove();
            ans.get(ans.size() - 1).add(node.val);
            if (node.left != null) q.add(node.left);
            if (node.right != null) q.add(node.right);
        }
    }
    return ans;
}
</code></pre>

<p><strong>Second, DFS code</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (root == null) return ans;
    traverse(ans, root, 0);
    return ans;
}

private void traverse (ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans, TreeNode node, int level) {
    if (node == null) return;
    if (ans.size() &gt;= level + 1) 
        ans.get(level).add(node.val);
    else {
        ArrayList&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;();
        temp.add(node.val);
        ans.add(temp);
    }
    traverse(ans, node.left, level + 1);
    traverse(ans, node.right, level + 1);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/24/Restore-IP-Addresses/">[LeetCode 93] Restore IP Addresses</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-24T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/restore-ip-addresses/">link</a></p>

<div class="question-content">
            <p></p><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>

<p>
For example:<br>
Given <code>"25525511135"</code>,
</p>
<p>
return <code>["255.255.11.135", "255.255.111.35"]</code>. (Order does not matter)
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">40 minutes</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>This is question can be solved by <strong>either DFS or Brute Force</strong>, both are fine.</p>

<h3>Solution</h3>

<p><strong>The DFS solution is obvious, I have the code for it</strong>.</p>

<p>However, there&rsquo;s <a href="http://blog.csdn.net/u011095253/article/details/9158449">another person</a> who wrote much less code while implementing the same solution as mine. I will post his code as a good example to learn.</p>

<p><strong>The brute force solution in this case</strong> does not sound like a bad idea. This is the <strong>most top-rated idea on <a href="https://oj.leetcode.com/discuss/77/restore-ip-addresses">official forum</a></strong> as well.</p>

<blockquote><p> You can get points&#8217; positions by i, j, k. Using these positions, you can divide s into candidate ip-form. Then, you can judge whether the candidate fits ip. To improve the efficiency, you can narrow the scope of i, j, k.</p></blockquote>

<p>So, this BF code is also posted below.</p>

<p>Just one more thing. I tested the <strong>exact same BF code written in C++</strong>. Compared to the <strong>420ms</strong> it took Java to pass OJ test, C++ takes <strong>8ms</strong> only! I was kind of shocked.</p>

<h3>Code</h3>

<p><strong>First, DFS, my code</strong></p>

<p>Note: I could have just insert as string, so that convert() method would not be needed.</p>

<pre><code>public ArrayList&lt;String&gt; restoreIpAddresses(String s) {
    ArrayList&lt;String&gt; ans = new ArrayList&lt;String&gt;();
    helper(ans, new ArrayList&lt;String&gt;(), s, 0);
    return ans;
}

private void helper(ArrayList&lt;String&gt; ans, ArrayList&lt;String&gt; cur, String s, int from) {
    int len = s.length();
    if (from &gt;= len) return;
    if (cur.size() == 3) {
        String lastStr = s.substring(from);
        if (isValidIpNumber(lastStr)) {
            ArrayList&lt;String&gt; oneAns = new ArrayList&lt;String&gt;(cur);
            oneAns.add(lastStr);
            ans.add(convert(oneAns));
        }
    }
    else {
        // cur.size less than 3, so get next num (length = 1, 2 or 3)
        for (int i = 1; i &lt;= 3 &amp;&amp; from + i &lt;= len; i ++) {
            String nextStr = s.substring(from, from + i);
            if (isValidIpNumber(nextStr)) {
                cur.add(nextStr);
                helper(ans, cur, s, from + i);
                cur.remove(cur.size() - 1);
            }
        }
    }
}

private boolean isValidIpNumber(String str) {
    if (str.length() == 0 || str.length() &gt; 3) return false;
    if (str.charAt(0) == '0' &amp;&amp; str.length() != 1) return false;
    int num = Integer.parseInt(str);
    return (0 &lt;= num &amp;&amp; num &lt;= 255);
}

private String convert(ArrayList&lt;String&gt; l) {
    String ans = "";
    for (String a: l)
        ans += "." + a;
    return ans.substring(1);
}
</code></pre>

<p><strong>Second, DFS, shorter version code</strong></p>

<pre><code>public ArrayList&lt;String&gt; restoreIpAddresses(String s) {
    ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;();  
    if (s.length()&lt;4||s.length()&gt;12) return res;  
    dfs(s,"",res,0);  
    return res;  
}  

public void dfs(String s, String tmp, ArrayList&lt;String&gt; res, int count){  
    if (count == 3 &amp;&amp; isValid(s)) {  
        res.add(tmp + s);  
        return;  
    }  
    for(int i=1; i&lt;4 &amp;&amp; i&lt;s.length(); i++){  
        String substr = s.substring(0,i);  
        if (isValid(substr)){  
            dfs(s.substring(i), tmp + substr + '.', res, count+1);  
        }  
    }  
}  

public boolean isValid(String s){  
    if (s.charAt(0)=='0') return s.equals("0");  
    int num = Integer.parseInt(s);  
    return num&lt;=255 &amp;&amp; num&gt;0;  
}  
</code></pre>

<p><strong>Third, BF code using triple nested loop (Java)</strong></p>

<pre><code>public ArrayList&lt;String&gt; restoreIpAddresses(String s) {
    ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;();  
    if (s.length() &gt; 12 || s.length() &lt; 4) return res;
    for (int i = 1; i &lt; 4; i ++) {
        String first = s.substring(0, i);
        if (! isValid(first)) continue;
        for (int j = 1; i + j &lt; s.length() &amp;&amp; j &lt; 4; j ++) {
            String second = s.substring(i, i + j);
            if (! isValid(second)) continue;
            for (int k = 1; i + j + k &lt; s.length() &amp;&amp; k &lt; 4; k ++) {
                String third = s.substring(i + j, i + j + k);
                String fourth = s.substring(i + j + k);
                if (isValid(third) &amp;&amp; isValid(fourth)) 
                    res.add(first + "." + second + "." + third + "." + fourth);
            }
        }
    }
    return res;
}  

public boolean isValid(String s) {
    if (s.length() &gt; 1 &amp;&amp; s.charAt(0) == '0') return false;
    return 0 &lt;= Integer.parseInt(s) &amp;&amp; Integer.parseInt(s) &lt;= 255;  
}
</code></pre>

<p><strong>Fourth, same BF code (C++)</strong></p>

<pre><code>vector&lt;string&gt; restoreIpAddresses(string s) {
    vector&lt;string&gt; res;
    if (s.size() &gt; 12 || s.size() &lt; 4) return res;
    for (int i=1; i&lt;4; i++) {
        string first = s.substr(0, i);
        if (!isValid(first)) continue;
        for (int j=1; i+j &lt; s.size() &amp;&amp; j&lt;4; j++) {
            string second = s.substr(i, j);
            if (!isValid(second)) continue;
            for (int k=1; i+j+k &lt; s.size() &amp;&amp; k&lt;4; k++) {
                string third = s.substr(i+j, k);
                string fourth = s.substr(i+j+k);
                if (isValid(third) &amp;&amp; isValid(fourth)) {
                    string temp = first+"."+second+"."+third+"."+fourth;
                    res.push_back(temp);
                }
            }
        }
    }
    return res;
}

bool isValid(string s) {
    if (s.size() &gt; 1 &amp;&amp; s[0] == '0') return false;
    if (stoi(s) &lt;= 255 &amp;&amp; stoi(s) &gt;= 0) return true;
    else return false;
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/34">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/32">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (10)</a></li>
<li class='category'><a href='/blog/categories/classic/'>classic (3)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (51)</a></li>
<li class='category'><a href='/blog/categories/facebook/'>facebook (4)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (34)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (155)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>octopress (1)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (85)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (5)</a></li>
<li class='category'><a href='/blog/categories/thoughts/'>thoughts (7)</a></li>
<li class='category'><a href='/blog/categories/top-k/'>top k (5)</a></li>
<li class='category'><a href='/blog/categories/twitter/'>twitter (3)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/09/14/kth-last-element-recursive/">[CC150v5] 2.2 Kth Last Element (Recursive)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/14/">[CC150v5] 2.</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/12/DNS-communication-protocol/">[Design] DNS Communication Protocol</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/11/celebrity-problem/">[Question] Celebrity Problem</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/11/barrier-goods-van-and-distance/">[Google] Barrier, Goods Van and Distance</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Charlie Brown -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
