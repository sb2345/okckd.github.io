
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Shuatiblog.com</title>
  <meta name="author" content="CodeMonkey">

  
  <meta name="description" content="Question link Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.shuatiblog.com/posts/59/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Shuatiblog.com" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.shuatiblog.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="blue_light">
            Shuatiblog.com
        </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/13/Combination-Sum-II/">[LeetCode 40] Combination Sum II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-13T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/13/Combination-Sum-II/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/combination-sum-ii/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a collection of candidate numbers (<b><i>C</i></b>) and a target number (<b><i>T</i></b>), find all unique combinations in <b><i>C</i></b> where the candidate numbers sums to <b><i>T</i></b>.
</p>

<p>Each number in <b><i>C</i></b> may only be used <b>once</b> in the combination.
</p>
<p><b>Note:</b><br>
</p><ul>
<li>All numbers (including target) will be positive integers.</li>
<li>Elements in a combination (<i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, … , <i>a</i><sub>k</sub>) must be in non-descending order. (ie, <i>a</i><sub>1</sub> ≤ <i>a</i><sub>2</sub> ≤ … ≤ <i>a</i><sub>k</sub>).</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p></p>

<p>
For example, given candidate set <code>10,1,2,7,6,1,5</code> and target <code>8</code>, <br>
A solution set is: <br>
<code>[1, 7]</code> <br>
<code>[1, 2, 5]</code> <br>
<code>[2, 6]</code> <br>
<code>[1, 1, 6]</code> <br>
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This problem is derived from the &ldquo;Combination Sum&rdquo; problem</strong>.</p>

<p>The solution is the &ldquo;Combination Sum&rdquo; solution plus some duplication avoidance technique.</p>

<h3>Solution</h3>

<p><strong>Main part of this solution is same as &ldquo;Combination Sum&rdquo;</strong>. There is only 2 lines of code that needs to be added/modified.</p>

<p><strong>First change</strong>, When go into the next recursive call, instead of:</p>

<pre><code>helper(ans, cand, path, i, len, target - cand[i]);
</code></pre>

<p>Change it to</p>

<pre><code>helper(ans, cand, path, i + 1, len, target - cand[i]);
</code></pre>

<p><strong>Second change</strong>, inside the for-loop, instead of getting next element right away, we get the element with different value. The additional code is:</p>

<pre><code>if (i &gt; pos &amp;&amp; candidates[i] == candidates[i - 1]) {
    continue;
}
</code></pre>

<h3>My code</h3>

<pre><code>public class Solution {
    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {
        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        if (candidates == null || candidates.length == 0) {
            return ans;
        }
        Arrays.sort(candidates);
        int len = candidates.length;
        helper(ans, candidates, new ArrayList&lt;Integer&gt;(), 0, len, target);
        return ans;
    }

    private void helper(List&lt;List&lt;Integer&gt;&gt; ans, int[] cand, List&lt;Integer&gt; path, int pos, int len, int target) {
        if (target == 0) {
            ans.add(new ArrayList&lt;Integer&gt;(path));
            return;
        } else if (target &lt; 0) {
            return;
        }
        for (int i = pos; i &lt; len; i++) {
            // if 'i' points to a repeated number, skip.
            if (i &gt; pos &amp;&amp; cand[i] == cand[i - 1]) {
                continue;
            }
            // insert cand[i] into path list, and continue search dfs
            path.add(cand[i]);
            helper(ans, cand, path, i + 1, len, target - cand[i]);
            path.remove(path.size() - 1);
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/13/Combination-Sum/">[LeetCode 39] Combination Sum</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-13T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/13/Combination-Sum/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/combination-sum/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a set of candidate numbers (<b><i>C</i></b>) and a target number (<b><i>T</i></b>), find all unique combinations in <b><i>C</i></b> where the candidate numbers sums to <b><i>T</i></b>. 
</p>

<p>The <b>same</b> repeated number may be chosen from <b><i>C</i></b> unlimited number of times.
</p>

<p><b>Note:</b><br>
</p><ul>
<li>All numbers (including target) will be positive integers.</li>
<li>Elements in a combination (<i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, … , <i>a</i><sub>k</sub>) must be in non-descending order. (ie, <i>a</i><sub>1</sub> ≤ <i>a</i><sub>2</sub> ≤ … ≤ <i>a</i><sub>k</sub>).</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p></p>

<p>
For example, given candidate set <code>2,3,6,7</code> and target <code>7</code>, <br>
A solution set is: <br>
<code>[7]</code> <br>
<code>[2, 2, 3]</code> <br>
</p>
<p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is an NP problem</strong>.</p>

<p>It can be solved with basic recursion methods. I refered to <a href="http://blog.csdn.net/linhuanmars/article/details/20828631">this blog</a> for the idea.</p>

<h3>Solution</h3>

<p><strong>Recursively fetch the next element and subtract the value from the target</strong>. In the end, if target happen to be 0, then one solution is found. If target result to be less than 0, return. If larger than 0, continue.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        if (candidates == null || candidates.length == 0) {
            return ans;
        }
        Arrays.sort(candidates);
        int len = candidates.length;
        helper(ans, candidates, new ArrayList&lt;Integer&gt;(), 0, len, target);
        return ans;
    }

    private void helper(List&lt;List&lt;Integer&gt;&gt; ans, int[] cand, List&lt;Integer&gt; path, int pos, int len, int target) {
        if (target == 0) {
            ans.add(new ArrayList&lt;Integer&gt;(path));
            return;
        } else if (target &lt; 0) {
            return;
        }
        for (int i = pos; i &lt; len; i++) {
            // insert cand[i] into path list, and continue search dfs
            path.add(cand[i]);
            helper(ans, cand, path, i, len, target - cand[i]);
            path.remove(path.size() - 1);
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Valid-Sudoku/">[LeetCode 36] Valid Sudoku</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/12/Valid-Sudoku/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/valid-sudoku/">link</a></p>

<div class="question-content">
            <p></p><p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx">Sudoku Puzzles - The Rules</a>.</p>

<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>'.'</code>.</p>

<p>
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"><br>
</p><p style="font-size: 11px">A partially filled sudoku which is valid.</p>
<p></p>

<p><b>Note:</b><br>
A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Solution</h3>

<p><strong>This is not a difficult problem</strong>.</p>

<p>Make use of <strong>three for-loops</strong> and <strong>nine arrays of length 9</strong> (for each loop) to mark the status, then do DFS search.</p>

<p>However, <strong>I also found a very concise solution</strong>. Read below.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public boolean isValidSudoku(char[][] board) {
        if (board == null || board.length == 0) {
            return false;
        }
        int N = board.length;
        for (int i = 0; i &lt; N; i++) {
            boolean[] foo = new boolean[N];
            // validate each row
            for (int j = 0; j &lt; N; j++) {
                if (board[i][j] != '.') {
                    if (foo[board[i][j] - '1']) {
                        return false;
                    }
                    foo[board[i][j] - '1'] = true;
                }
            }
            foo = new boolean[N];
            // validate each column
            for (int j = 0; j &lt; N; j++) {
                if (board[j][i] != '.') {
                    if (foo[board[j][i] - '1']) {
                        return false;
                    }
                    foo[board[j][i] - '1'] = true;
                }
            }
        }
        for (int a = 0; a &lt; 3; a++) {
            for (int b = 0; b &lt; 3; b++) {
                boolean[] foo = new boolean[N];
                for (int c = 0; c &lt; 3; c++) {
                    for (int d = 0; d &lt; 3; d++) {
                        if (board[a * 3 + c][b * 3 + d] != '.') {
                            if (foo[board[a * 3 + c][b * 3 + d] - '1']) {
                                return false;
                            }
                            foo[board[a * 3 + c][b * 3 + d] - '1'] = true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
</code></pre>

<p><strong>The following solution</strong> is from <a href="http://www.cnblogs.com/zhaolizhen/p/Sudoku.html">this blog</a>. It&rsquo;s a very clever and surprisingly concise code.</p>

<pre><code>public boolean isValidSudoku(char[][] board) {
    boolean[][] rows = new boolean[9][9];
    boolean[][] cols = new boolean[9][9];
    boolean[][] blocks = new boolean[9][9];
    for (int i = 0; i &lt; 9; ++i) {
        for (int j = 0; j &lt; 9; ++j) {
            int c = board[i][j] - '1';
            if (board[i][j] == '.') continue;
            if (rows[i][c] || cols[j][c] || blocks[i - i % 3 + j / 3][c])
                return false;
            rows[i][c] = cols[j][c] = blocks[i - i % 3 + j / 3][c] = true;
        }
    }
    return true;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Search-in-Rotated-Sorted-Array/">[LeetCode 33] Search in Rotated Sorted Array</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/12/Search-in-Rotated-Sorted-Array/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/search-in-rotated-sorted-array/">link</a></p>

<div class="question-content">
            <p></p><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>

<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>

<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>

<p>You may assume no duplicate exists in the array.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question is not very difficult</strong>, yet commonly seen in interviews.</p>

<p>Without having any knowledge of pivot, we can check the mid-point value against left value and right value. Read <a href="http://leetcode.com/2010/04/searching-element-in-rotated-array.html">this blog</a> for more.</p>

<h3>Solution</h3>

<p>The code is easy to understand.</p>

<h3>My code</h3>

<p>Pay special attention to different larger/smaller conditions. It&rsquo;s very easy to miss a equal sign or something.</p>

<pre><code>public class Solution {
    public int search(int[] A, int target) {
        if (A == null || A.length == 0) {
            return -1;
        }
        int len = A.length;
        int left = 0; 
        int right = len - 1;
        while (left + 1 &lt; right) {
            int mid = left + (right - left) / 2;
            if (A[mid] == target) {
                return mid;
            } else if (A[left] &lt; A[mid]) {
            // remember to pay attention to (A[left] == target) case
                if (A[left] &lt;= target &amp;&amp; target &lt; A[mid]) {
                    right = mid;
                } else {
                    left = mid;
                }
            } else {
            // remember to pay attention to (A[right] == target) case
                if (A[mid] &lt; target &amp;&amp; target &lt;= A[right]) {
                    left = mid;
                } else {
                    right = mid;
                }
            }
        }
        if (A[left] == target) {
            return left;
        } else if (A[right] == target) {
            return right;
        }
        return -1;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Search-for-a-Range/">[LeetCode 34] Search for a Range</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/12/Search-for-a-Range/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/search-for-a-range/">link</a></p>

<div class="question-content">
            <p></p><p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>

<p>Your algorithm&#8217;s runtime complexity must be in the order of <i>O</i>(log <i>n</i>).</p>

<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>

<p>
For example,<br>
Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>
return <code>[3, 4]</code>.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Solution</h3>

<p><strong>The key to solve this problem is binary search</strong>. Previously my solution is to find the element first, then check left bound and right bound respectively. In worst case, this will take O(n) time. This method, though, will pass OJ, but is not an optimized solution.</p>

<p><strong>First solution is from <a href="http://xixiaogualu.blogspot.sg/2013/09/search-for-range.html">this blog</a></strong>. Using binary search to search twice &ndash; once for left bound, and once for right bound. Code is below.</p>

<p><strong>Second solution is from <a href="http://rleetcode.blogspot.sg/2014/02/search-for-range-java.html">this blog</a></strong>. This idea is still using binary search, also search twice, but a more tricky manner. Instead of searching the number, it searches (number &ndash; 0.5) and (number + 0.5).</p>

<h3>My code</h3>

<p>Solution 1</p>

<pre><code>public class Solution {
    public int[] searchRange(int[] A, int target) {
        int[] ans = new int[] {-1, -1};
        if (A == null || A.length == 0) {
            return ans;
        }
        int len = A.length;
        int left = 0, right = len - 1;
        while (left &lt; right) {
            int mid = left + (right - left) / 2;
            if (A[mid] &gt;= target) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        if (A[left] == target) {
            ans[0] = left;
        } else {
            return ans;
        }
        left = 0;
        right = len - 1;
        while (left &lt; right) {
            int mid = left + (right - left + 1) / 2;
            if (A[mid] &lt;= target) {
                left = mid;
            } else {
                right = mid - 1;
            }
        }
        ans[1] = right;
        return ans;
    }
}
</code></pre>

<p>Solution 2</p>

<pre><code>public int[] searchRange(int[] A, int target) {
    if (A == null) return null;
    int[] result = { -1, -1 };
    int low = binarySearch(A, target - 0.5);
    // Be care for there , low&gt;=A.length must be checked
    if (low &gt;= A.length || A[low] != target) return result;
    result[0] = low;
    result[1] = binarySearch(A, target + 0.5) - 1;
    return result;
}

public int binarySearch(int[] A, double t) {
    int low = 0, high = A.length - 1;
    while (low &lt;= high) {
        int m = (low + high) / 2;
        if (A[m] &lt; t) low = m + 1;
        if (A[m] &gt; t) high = m - 1;
    }
    return low;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Search-Insert-Position/">[LeetCode 35] Search Insert Position</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/12/Search-Insert-Position/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/search-insert-position/">link</a></p>

<div class="question-content">
            <p></p><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>

<p>You may assume no duplicates in the array.</p>

<p>
Here are few examples.<br>
<code>[1,3,5,6]</code>, 5 → 2<br>
<code>[1,3,5,6]</code>, 2 → 1<br>
<code>[1,3,5,6]</code>, 7 → 4<br>
<code>[1,3,5,6]</code>, 0 → 0
</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very basic, yet very difficult question</strong>. It is not easy to get it correct at first attempt.</p>

<p>Read <a href="http://blog.csdn.net/fightforyourdream/article/details/14216321">this blog</a> for more.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public int searchInsert(int[] A, int target) {
        if (A == null || A.length == 0) {
            return 0;
        }
        int len = A.length;
        int left = 0;
        int right = len - 1;
        while (left + 1 &lt; right) {
            int mid = left + (right - left) / 2;
            if (A[mid] &gt;= target) {
                right = mid;
            } else {
                left = mid;
            }
        }
        // now are have a adjacent range [left, right]
        if (target &lt;= A[left]) {
            return left;
        } else if (target &lt;= A[right]) {
            // remember not to miss the == case
            return right;
        } else {
            return right + 1;
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Next-Permutation/">[LeetCode 31] Next Permutation</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/12/Next-Permutation/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/next-permutation/">link</a></p>

<div class="question-content">
            <p></p><p>
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
</p>
<p>
If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).
</p>
<p>
The replacement must be in-place, do not allocate extra memory.
</p>
<p>
Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br>
<code>1,2,3</code> → <code>1,3,2</code><br>
<code>3,2,1</code> → <code>1,2,3</code><br>
<code>1,1,5</code> → <code>1,5,1</code><br>
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<h3>Analysis</h3>

<p>The image below explains the solution very well (for the input number &ldquo;687432&rdquo;).</p>

<p><img class="middle" src="/assets/images/next_permutation.png"></p>

<h3>Solution</h3>

<p>Read <a href="http://blog.csdn.net/havenoidea/article/details/12176737">this blog</a> for a very nice piece of code.</p>

<p>The following code is written by me.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public void nextPermutation(int[] num) {
        if (num == null || num.length &lt;= 1) {
            return;
        }
        int len = num.length;
        int p = len - 2;
        // note that when values are equals, proceed the pointer! 
        // same for line 22
        while (p &gt;= 0 &amp;&amp; num[p] &gt;= num[p + 1]) {
            // move p to left as long as its value is larger than next num
            // we want to find the end of increasing sequence (from end to start)
            p--;
        }
        if (p == -1) {
            // the input is a strictly decreasing sequence
            Arrays.sort(num);
            return;
        }
        // replace number at p with an larger value found in the right of p
        int w = len - 1;
        while (num[w] &lt;= num[p]) {
            w--;
        }
        // ok, now swap number at p and w
        swop(num, p, w);
        // reverse all numbers to the right of p
        reverse(num, p + 1, len - 1);
    }

    private void swop(int[] num, int a, int b) {
        int temp = num[a];
        num[a] = num[b];
        num[b] = temp;
    }

    private void reverse(int[] num, int a, int b) {
        while (a &lt; b) {
            swop(num, a++, b--);
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Longest-Valid-Parentheses/">[LeetCode 32] Longest Valid Parentheses</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/12/Longest-Valid-Parentheses/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/longest-valid-parentheses/">link</a></p>

<div class="question-content">
            <p></p><p>Given a string containing just the characters <code>'('</code> and <code>')'</code>, find the length of the longest valid (well-formed) parentheses substring.
</p>
<p>
For <code>"(()"</code>, the longest valid parentheses substring is <code>"()"</code>, which has length = 2.
</p>
<p>
Another example is <code>")()())"</code>, where the longest valid parentheses substring is <code>"()()"</code>, which has length = 4.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<h3>Solution</h3>

<p><strong>There are 2 ways to solve this problem</strong>, stack and DP.</p>

<p><strong>Stack method 1 is more straight-forward</strong> (code shown below). The idea is to keep a stack of &ldquo;(&rdquo; indexes, and another variable called &ldquo;last&rdquo;. <strong>Note that only &ldquo;)&rdquo; can violates a pattern</strong>. So whenever I see a &ldquo;(&rdquo;, just push to stack. When the pattern is violated by a &ldquo;)&rdquo;, I update &ldquo;last&rdquo;. The code explains itself very well. If not, <a href="http://discuss.leetcode.com/questions/212/longest-valid-parentheses/1488">look here</a></p>

<p><strong>Stack method 2 is more tricky</strong>. This time I will not only push the index of &ldquo;(&rdquo; to stack, but also the index of &ldquo;)&rdquo; when the pattern got violated. It&rsquo;s hard to explain, and hard to think of at first.</p>

<p><strong>The DP solution is not very difficult</strong>. Basically create an array of same length as string s. dp[i] denotes the length of valid parenthese ending with index i. The idea is similar to <a href="http://blog.csdn.net/abcbc/article/details/8826782">this blog</a>, but he used reverse DP, and I use normal DP.</p>

<p>I will explain DP with an example of input &ldquo;<strong>)()()</strong>&rdquo;. For this string, we have <strong>dp[0] = 0, dp[1] = 0, dp[2] = 2, dp[3] = 0</strong>. For dp[4], I check the 3rd position first, and find that dp[4] = 2. Then I also have to add dp[2] into dp[4] to make it complete. The end result is dp[4] = 2 + 2 = 4.</p>

<h3>My code</h3>

<p>Stack method 1 (recommended)</p>

<pre><code>public class Solution {
    public int longestValidParentheses(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        int len = s.length();
        int longest = 0;
        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
        int start = 0;
        for (int i = 0; i &lt; len; i++) {
            char ch = s.charAt(i);
            if (ch == '(') {
                // well, no matter what, '(' is alway a valid part
                // push the index to the stack
                stack.push(i);
            } else if (ch == ')') {
                if (stack.isEmpty()) {
                    // invalid ')', update 'start' variable
                    start = i + 1;
                } else {
                    int pos = stack.pop();
                    if (stack.isEmpty()) {
                        // this is why we need 'start' variable
                        longest = Math.max(longest, i - start + 1);
                    } else {
                        // important: must peek stack again.
                        // eg. (()()  if don't peek again 
                        longest = Math.max(longest, i - stack.peek());
                    }
                }
            }
        }
        return longest;
    }
}
</code></pre>

<p>Stack method 2</p>

<pre><code>public int longestValidParentheses(String s) {
    int res = 0;
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    char[] arr = s.toCharArray();
    for (int i = 0; i &lt; arr.length; i++) {
        if (arr[i] == ')' &amp;&amp; !stack.isEmpty() &amp;&amp; arr[stack.peek()] == '(') {
            stack.pop();
            if (stack.isEmpty()) res = i + 1;
            else res = Math.max(res, i - stack.peek());
        } else stack.push(i);
    }
    return res;
}
</code></pre>

<p>DP</p>

<pre><code>public int longestValidParentheses(String s) {
    int len = s.length();
    if (len &lt;= 1) return 0;
    int max = Integer.MIN_VALUE;
    int[] dp = new int[len];
    for (int i = 1; i &lt; len; i ++) {
        if (s.charAt(i) == '(') dp[i] = 0;
        else {
            int j = i - 1 - dp[i - 1];
            if (j &gt;= 0 &amp;&amp; s.charAt(j) =='(') {
                dp[i] = dp[i - 1] + 2;
                if (j &gt;= 1) dp[i] += dp[j - 1];
            }
            else dp[i] = 0;
        }
        max = Math.max(max, dp[i]);
    }
    return max;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/11/heap-data-structure/">[Fundamental] Heap (Data Structure)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-11T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/11/heap-data-structure/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Definition</h3>

<p><a href="http://en.wikipedia.org/wiki/Heap_%28data_structure%29">A heap</a> is a specialized tree-based data structure that satisfies the heap property:</p>

<blockquote><p>If A is a parent node of B, then the key of node A is ordered with respect to the key of node B with the same ordering applying across the heap.</p></blockquote>

<p>Heaps can then be classified further as either &ldquo;max heap&rdquo; and &ldquo;min heap&rdquo;.</p>

<h3>Details</h3>

<blockquote><p>We take max heap for example. The keys of parent nodes are always greater than or equal to the children node.</p>

<p><strong>The heap is an implementation of priority queue</strong>. In fact, priority queues are often referred to as &ldquo;heaps&rdquo;, regardless of how they may be implemented.</p>

<p>Note that despite the similarity of the name &ldquo;heap&rdquo; to &ldquo;stack&rdquo; and &ldquo;queue&rdquo;, the latter two are <strong>abstract data types</strong>, while a heap is a <strong>specific data structure</strong>, and &ldquo;priority queue&rdquo; is the proper term for the abstract data type.</p></blockquote>

<h4>Insert</h4>

<ol>
<li><p>Add the element to the bottom level of the heap.</p></li>
<li><p>Compare the added element with its parent; if they are in the correct order, stop.</p></li>
<li><p>If not, swap the element with its parent and return to the previous step.</p></li>
</ol>


<p>The number of operations required is dependent on the <strong>number of levels</strong> the new element must rise to satisfy the heap property, thus the insertion operation has a time complexity of O(log n).</p>

<h4>Delete</h4>

<ol>
<li><p>Replace the root of the heap with the last element on the last level.</p></li>
<li><p>Compare the new root with its children; if they are in the correct order, stop.</p></li>
<li><p>If not, swap the element with one of its children and return to the previous step. (Swap with its smaller child in a min-heap and its larger child in a max-heap.)</p></li>
</ol>


<h3>Time complexity</h3>



<table class="tg">
  <tr>
    <th class="tg-s6z2">Heap</th>
    <th class="tg-s6z2">Time</th>
  </tr>
  <tr>
    <td class="tg-031e">Find max</td>
    <td class="tg-s6z2">O(1)</td>
  </tr>
  <tr>
    <td class="tg-031e">Delete</td>
    <td class="tg-s6z2">O(lgn)</td>
  </tr>
  <tr>
    <td class="tg-031e">Insert</td>
    <td class="tg-s6z2">O(lgn)</td>
  </tr>
  <tr>
    <td class="tg-031e">Merge</td>
    <td class="tg-s6z2">O(n)</td>
  </tr>
</table>


<br />


<h4>How about building a heap?</h4>

<p>It&rsquo;s <a href="http://en.wikipedia.org/wiki/Binary_heap#Building_a_heap">O(n)</a>.</p>

<p>Why? You may ask &ndash; &ldquo;why not O(nlgn) like we do successive insert for n time&rdquo;?</p>

<p>Read answers from <a href="http://stackoverflow.com/questions/9755721/build-heap-complexity">stackoverflow</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/11/Reverse-Nodes-in-k-Group/">[LeetCode 25] Reverse Nodes in k-Groups</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-11T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/11/Reverse-Nodes-in-k-Group/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/reverse-nodes-in-k-group/">link</a></p>

<div class="question-content">
<p></p><p>
Given a linked list, reverse the nodes of a linked list <i>k</i> at a time and return its modified list.
</p>

<p>
If the number of nodes is not a multiple of <i>k</i> then left-out nodes in the end should remain as it is.</p>

<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>

<p>Only constant memory is allowed.</p>

<p>
For example,<br>
Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>
</p>

<p>
For <i>k</i> = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code>
</p>

<p>
For <i>k</i> = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code>
</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>The problem is solved in 2 steps</strong>. First, get the next k-group. If remaining items is less than k, terminate the program. Otherwise, reserve this k-group and keep going.</p>

<p>To solve this question is very tricky. <strong>We need to be clear about this: 4 nodes need to be kept track of</strong>: 2 elements before and after the k-group, and 2 elements within the k-group.</p>

<p><strong>The difficult point is while and after reverse the k-group</strong>, how to maintain the &lsquo;pre&rsquo; node and future &lsquo;pre&rsquo; node correctly.</p>

<h3>Solution</h3>

<p>Use Linkedlist Template from NineChap to solve.</p>

<pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (k &lt;= 1 || head == null) {
            return head;
        }
        ListNode nextGroup = head;
        for (int i = 0; i &lt; k; i++) {
            if (nextGroup == null) {
                // there isn't k nodes in this list
                return head;
            }
            nextGroup = nextGroup.next;
        }
        // now we're sure the list have at least k nodes
        // reverse this list (by re-connecting the next pointer k times)
        ListNode newHead = head;
        ListNode tail = null;
        for (int i = 0; i &lt; k; i++) {
            ListNode temp = newHead.next;
            newHead.next = tail;
            tail = newHead;
            newHead = temp;
        }
        // now newHead is pointing to the actual new head
        // temp (which is not accessable here) is same as nextGroup
        // last step, reconnect everything and call recursion method
        head.next = reverseKGroup(nextGroup, k);
        return tail;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="60">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="58">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (77)</a></li>
<li class='category'><a href='/blog/categories/experience/'>experience (4)</a></li>
<li class='category'><a href='/blog/categories/fundamental/'>fundamental (18)</a></li>
<li class='category'><a href='/blog/categories/java-oop/'>java oop (36)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (177)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (16)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (25)</a></li>
<li class='category'><a href='/blog/categories/q-facebook/'>q-facebook (9)</a></li>
<li class='category'><a href='/blog/categories/q-google/'>q-google (63)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (132)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (5)</a></li>
<li class='category'><a href='/blog/categories/z-string-search/'>z-string-search (17)</a></li>
<li class='category'><a href='/blog/categories/z-testing/'>z-testing (2)</a></li>
<li class='category'><a href='/blog/categories/z-top-k/'>z-top-k (6)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/11/18/strategy-pattern/">[Design] Strategy design pattern </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/15/partition-problem/">[Question] Partition Problem (divide array into halves) </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/04/Best-Time-to-Buy-and-Sell-Stock-IV/">[LeetCode 188] Best Time to Buy and Sell Stock IV </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/28/arraylist-implementation/">[Java OOP] Java ArrayList implementation </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/23/static-class-inner-class/">[Java OOP] Static class and Inner class </a>
      </li>
    
  </ul>
</section>





<script type="text/javascript" src="http://srvpub.com/adServe/banners?tid=29011_41781_0&size=120x600" ></script>

<!--
<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"willran168","width":160,"height":600,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>
<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>
&#8211;>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
    Copyright &copy; 2015 - <a href="/about">CodeMonkey</a> -  All posts are my original writing, based uppon my personal view. <a href="/policy">Privacy Policy</a> - 
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
