
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Woodstock Blog</title>
  <meta name="author" content="Woodstock">

  
  <meta name="description" content="Question link Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.shuatiblog.com/posts/60/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.shuatiblog.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="blue_light">
            Woodstock Blog
        </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Longest-Valid-Parentheses/">[LeetCode 32] Longest Valid Parentheses</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/12/Longest-Valid-Parentheses/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/longest-valid-parentheses/">link</a></p>

<div class="question-content">
            <p></p><p>Given a string containing just the characters <code>'('</code> and <code>')'</code>, find the length of the longest valid (well-formed) parentheses substring.
</p>
<p>
For <code>"(()"</code>, the longest valid parentheses substring is <code>"()"</code>, which has length = 2.
</p>
<p>
Another example is <code>")()())"</code>, where the longest valid parentheses substring is <code>"()()"</code>, which has length = 4.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<h3>Solution</h3>

<p><strong>There are 2 ways to solve this problem</strong>, stack and DP.</p>

<p><strong>Stack method 1 is more straight-forward</strong> (code shown below). The idea is to keep a stack of &ldquo;(&rdquo; indexes, and another variable called &ldquo;last&rdquo;. <strong>Note that only &ldquo;)&rdquo; can violates a pattern</strong>. So whenever I see a &ldquo;(&rdquo;, just push to stack. When the pattern is violated by a &ldquo;)&rdquo;, I update &ldquo;last&rdquo;. The code explains itself very well. If not, <a href="http://discuss.leetcode.com/questions/212/longest-valid-parentheses/1488">look here</a></p>

<p><strong>Stack method 2 is more tricky</strong>. This time I will not only push the index of &ldquo;(&rdquo; to stack, but also the index of &ldquo;)&rdquo; when the pattern got violated. It&rsquo;s hard to explain, and hard to think of at first.</p>

<p><strong>The DP solution is not very difficult</strong>. Basically create an array of same length as string s. dp[i] denotes the length of valid parenthese ending with index i. The idea is similar to <a href="http://blog.csdn.net/abcbc/article/details/8826782">this blog</a>, but he used reverse DP, and I use normal DP.</p>

<p>I will explain DP with an example of input &ldquo;<strong>)()()</strong>&rdquo;. For this string, we have <strong>dp[0] = 0, dp[1] = 0, dp[2] = 2, dp[3] = 0</strong>. For dp[4], I check the 3rd position first, and find that dp[4] = 2. Then I also have to add dp[2] into dp[4] to make it complete. The end result is dp[4] = 2 + 2 = 4.</p>

<h3>My code</h3>

<p>Stack method 1 (recommended)</p>

<pre><code>public class Solution {
    public int longestValidParentheses(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        int len = s.length();
        int longest = 0;
        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
        int start = 0;
        for (int i = 0; i &lt; len; i++) {
            char ch = s.charAt(i);
            if (ch == '(') {
                // well, no matter what, '(' is alway a valid part
                // push the index to the stack
                stack.push(i);
            } else if (ch == ')') {
                if (stack.isEmpty()) {
                    // invalid ')', update 'start' variable
                    start = i + 1;
                } else {
                    int pos = stack.pop();
                    if (stack.isEmpty()) {
                        // this is why we need 'start' variable
                        longest = Math.max(longest, i - start + 1);
                    } else {
                        // important: must peek stack again.
                        // eg. (()()  if don't peek again 
                        longest = Math.max(longest, i - stack.peek());
                    }
                }
            }
        }
        return longest;
    }
}
</code></pre>

<p>Stack method 2</p>

<pre><code>public int longestValidParentheses(String s) {
    int res = 0;
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    char[] arr = s.toCharArray();
    for (int i = 0; i &lt; arr.length; i++) {
        if (arr[i] == ')' &amp;&amp; !stack.isEmpty() &amp;&amp; arr[stack.peek()] == '(') {
            stack.pop();
            if (stack.isEmpty()) res = i + 1;
            else res = Math.max(res, i - stack.peek());
        } else stack.push(i);
    }
    return res;
}
</code></pre>

<p>DP</p>

<pre><code>public int longestValidParentheses(String s) {
    int len = s.length();
    if (len &lt;= 1) return 0;
    int max = Integer.MIN_VALUE;
    int[] dp = new int[len];
    for (int i = 1; i &lt; len; i ++) {
        if (s.charAt(i) == '(') dp[i] = 0;
        else {
            int j = i - 1 - dp[i - 1];
            if (j &gt;= 0 &amp;&amp; s.charAt(j) =='(') {
                dp[i] = dp[i - 1] + 2;
                if (j &gt;= 1) dp[i] += dp[j - 1];
            }
            else dp[i] = 0;
        }
        max = Math.max(max, dp[i]);
    }
    return max;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/11/heap-data-structure/">[Fundamental] Heap (Data Structure)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-11T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/11/heap-data-structure/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Definition</h3>

<p><a href="http://en.wikipedia.org/wiki/Heap_%28data_structure%29">A heap</a> is a specialized tree-based data structure that satisfies the heap property:</p>

<blockquote><p>If A is a parent node of B, then the key of node A is ordered with respect to the key of node B with the same ordering applying across the heap.</p></blockquote>

<p>Heaps can then be classified further as either &ldquo;max heap&rdquo; and &ldquo;min heap&rdquo;.</p>

<h3>Details</h3>

<blockquote><p>We take max heap for example. The keys of parent nodes are always greater than or equal to the children node.</p>

<p><strong>The heap is an implementation of priority queue</strong>. In fact, priority queues are often referred to as &ldquo;heaps&rdquo;, regardless of how they may be implemented.</p>

<p>Note that despite the similarity of the name &ldquo;heap&rdquo; to &ldquo;stack&rdquo; and &ldquo;queue&rdquo;, the latter two are <strong>abstract data types</strong>, while a heap is a <strong>specific data structure</strong>, and &ldquo;priority queue&rdquo; is the proper term for the abstract data type.</p></blockquote>

<h4>Insert</h4>

<ol>
<li><p>Add the element to the bottom level of the heap.</p></li>
<li><p>Compare the added element with its parent; if they are in the correct order, stop.</p></li>
<li><p>If not, swap the element with its parent and return to the previous step.</p></li>
</ol>


<p>The number of operations required is dependent on the <strong>number of levels</strong> the new element must rise to satisfy the heap property, thus the insertion operation has a time complexity of O(log n).</p>

<h4>Delete</h4>

<ol>
<li><p>Replace the root of the heap with the last element on the last level.</p></li>
<li><p>Compare the new root with its children; if they are in the correct order, stop.</p></li>
<li><p>If not, swap the element with one of its children and return to the previous step. (Swap with its smaller child in a min-heap and its larger child in a max-heap.)</p></li>
</ol>


<h3>Time complexity</h3>



<table class="tg">
  <tr>
    <th class="tg-s6z2">Heap</th>
    <th class="tg-s6z2">Time</th>
  </tr>
  <tr>
    <td class="tg-031e">Find max</td>
    <td class="tg-s6z2">O(1)</td>
  </tr>
  <tr>
    <td class="tg-031e">Delete</td>
    <td class="tg-s6z2">O(lgn)</td>
  </tr>
  <tr>
    <td class="tg-031e">Insert</td>
    <td class="tg-s6z2">O(lgn)</td>
  </tr>
  <tr>
    <td class="tg-031e">Merge</td>
    <td class="tg-s6z2">O(n)</td>
  </tr>
</table>


<br />


<h4>How about building a heap?</h4>

<p>It&rsquo;s <a href="http://en.wikipedia.org/wiki/Binary_heap#Building_a_heap">O(n)</a>.</p>

<p>Why? You may ask &ndash; &ldquo;why not O(nlgn) like we do successive insert for n time&rdquo;?</p>

<p>Read answers from <a href="http://stackoverflow.com/questions/9755721/build-heap-complexity">stackoverflow</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/11/Reverse-Nodes-in-k-Group/">[LeetCode 25] Reverse Nodes in k-Groups</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-11T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/11/Reverse-Nodes-in-k-Group/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/reverse-nodes-in-k-group/">link</a></p>

<div class="question-content">
<p></p><p>
Given a linked list, reverse the nodes of a linked list <i>k</i> at a time and return its modified list.
</p>

<p>
If the number of nodes is not a multiple of <i>k</i> then left-out nodes in the end should remain as it is.</p>

<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>

<p>Only constant memory is allowed.</p>

<p>
For example,<br>
Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>
</p>

<p>
For <i>k</i> = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code>
</p>

<p>
For <i>k</i> = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code>
</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>The problem is solved in 2 steps</strong>. First, get the next k-group. If remaining items is less than k, terminate the program. Otherwise, reserve this k-group and keep going.</p>

<p>To solve this question is very tricky. <strong>We need to be clear about this: 4 nodes need to be kept track of</strong>: 2 elements before and after the k-group, and 2 elements within the k-group.</p>

<p><strong>The difficult point is while and after reverse the k-group</strong>, how to maintain the &lsquo;pre&rsquo; node and future &lsquo;pre&rsquo; node correctly.</p>

<h3>Solution</h3>

<p>Use Linkedlist Template from NineChap to solve.</p>

<pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (k &lt;= 1 || head == null) {
            return head;
        }
        ListNode nextGroup = head;
        for (int i = 0; i &lt; k; i++) {
            if (nextGroup == null) {
                // there isn't k nodes in this list
                return head;
            }
            nextGroup = nextGroup.next;
        }
        // now we're sure the list have at least k nodes
        // reverse this list (by re-connecting the next pointer k times)
        ListNode newHead = head;
        ListNode tail = null;
        for (int i = 0; i &lt; k; i++) {
            ListNode temp = newHead.next;
            newHead.next = tail;
            tail = newHead;
            newHead = temp;
        }
        // now newHead is pointing to the actual new head
        // temp (which is not accessable here) is same as nextGroup
        // last step, reconnect everything and call recursion method
        head.next = reverseKGroup(nextGroup, k);
        return tail;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/11/Merge-k-Sorted-Lists/">[LeetCode 23] Merge K Sorted Lists</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-11T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/11/Merge-k-Sorted-Lists/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/merge-k-sorted-lists/">link</a></p>

<div class="question-content">
            <p></p><p>
Merge <i>k</i> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>There are two ways to solve this problem.</p>

<ul>
<li>k &ndash; number of lists</li>
<li>n &ndash; length of each list</li>
</ul>


<p><strong>First approach is merge sort</strong>. Using divide and conquer approach, divide the entire input into halves, and then merge 2 list each time. Instead of merging 1 by 1 which the time complexity is O(nk x (k-1)), the 2 lists to be merged is always similar length, thus time complexity is reduced to O(nk x logk).</p>

<p><strong>You may wonder how I calculate time complexity</strong>. See, each round of sort, nk nodes are read and sorted. This happened O(logk) times, where k is the number of lists. Thus totoal time take is O(nk x logk).</p>

<p><strong>Second approach is heap sort</strong>. The idea of this is to always keep a sorted list of the head of each list. When we retrieve items from the heap, it only take O(logk) time to find the next smallest element.</p>

<p>Not sure what is a heap? Read <strong>[Fundamental] Heap (data structure)</strong> before you proceed.</p>

<p>Both method are well explained in <a href="http://blog.csdn.net/linhuanmars/article/details/19899259">this csdn blog</a>. Time complexity analysis is given by <a href="http://n00tc0d3r.blogspot.sg/2013/04/merge-k-sorted-lists.html">nootcoder blog</a>.</p>

<h3>Solution</h3>

<p>Divide and conquer code is lengthy but medium difficulty.</p>

<p>Second solution, however, is not as easy. <strong>Especially when we have to write Comparator on our own</strong>.  A priority queue (heap) is implemented and head of each list is inserted into the heap. Then poll elements out from the heap until heap is empty.</p>

<h3>My code</h3>

<p><strong>Merge sort code, written by me</strong></p>

<pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode mergeKLists(List&lt;ListNode&gt; lists) {
        if (lists == null || lists.size() == 0) {
            return null;
        }
        return mergeHelper(lists, 0, lists.size() - 1);
    }

    private ListNode mergeHelper(List&lt;ListNode&gt; lists, int start, int end) {
        if (start == end) {
            return lists.get(start);
        } 
        int mid = start + (end - start) / 2;
        ListNode firstHalf = mergeHelper(lists, start, mid);
        ListNode secondHalf = mergeHelper(lists, mid + 1, end);
        return mergeTwo(firstHalf, secondHalf);
    }

    private ListNode mergeTwo(ListNode head1, ListNode head2) {
        ListNode dummy = new ListNode(0);
        ListNode p = dummy;
        while (head1 != null &amp;&amp; head2 != null) {
            if (head1.val &lt; head2.val) {
                p.next = head1;
                head1 = head1.next;
                p = p.next;
            } else {
                p.next = head2;
                head2 = head2.next;
                p = p.next;
            }
        }
        if (head1 == null) {
            p.next = head2;
        } else {
            p.next = head1;
        }
        return dummy.next;
    }
}
</code></pre>

<p><strong>Heap sort code, written by me</strong>. <a href="http://answer.ninechapter.com/solutions/merge-k-sorted-lists/">source</a></p>

<pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode mergeKLists(List&lt;ListNode&gt; lists) {
        if (lists == null || lists.size() == 0) {
            return null;
        }
        int size = lists.size();
        // create a heap with Java priority queue, set the initial size
        Queue&lt;ListNode&gt; heap = new PriorityQueue(size, new NodeComparator());
        // add all ListNode into the heap
        for (ListNode node: lists) {
            if (node != null) {
                heap.add(node);
            }
        }
        // start to link nodes from smallest to largest
        ListNode dummy = new ListNode(0);
        ListNode p = dummy;
        while (!heap.isEmpty()) {
            p.next = heap.remove();
            p = p.next;
            if (p.next != null) {
                heap.add(p.next);
            }
        }
        return dummy.next;
    }

    class NodeComparator implements Comparator&lt;ListNode&gt; {
        public int compare(ListNode n1, ListNode n2) {
            return n1.val - n2.val;
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/10/Substring-with-Concatenation-All-Words/">[LeetCode 30] Substring With Concatenation of All Words</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-10T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/10/Substring-with-Concatenation-All-Words/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/substring-with-concatenation-of-all-words/">link</a></p>

<div class="question-content">
            <p></p><p>
You are given a string, <b>S</b>, and a list of words, <b>L</b>, that are all of the same length. Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters.
</p>

<p>
For example, given:<br>
<b>S</b>: <code>"barfoothefoobarman"</code><br>
<b>L</b>: <code>["foo", "bar"]</code>
</p>

<p>
You should return the indices: <code>[0,9]</code>.<br>
(order does not matter).
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>There are 2 ways to solve this question.</p>

<p><strong>The naive approach takes around 1200ms to pass</strong>, and <strong>the KPM-like approach takes around half of that time</strong>. Both methods are explained well in <a href="http://n00tc0d3r.blogspot.sg/2013/06/substring-with-concatenation-of-all.html">this blog</a>.</p>

<p>I will cover only the naive approach.</p>

<h3>Naive approach</h3>

<p><strong>The naive approach uses a HashMap</strong> for 2 reasons. Reason 1 is because there can be duplications in L, and reason 2 is the searching is faster. For information on HashMap, refer to <strong>[Fundamental] Recap on Java HashMap</strong>.</p>

<p><strong>Time complexity of this solution is O((n &ndash; k * m) x m)</strong>, and space is the size of list L, O(m). If m is not very big, the time can be regarded as O(n).</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public List&lt;Integer&gt; findSubstring(String S, String[] L) {
        List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();
        if (L == null || L.length == 0 || S == null || S.length() == 0) {
            return ans;
        }
        int num = L.length;
        int len = L[0].length();
        if (num * len &gt; S.length()) {
            return ans;
        }
        // build a hashset, for simplifying the hashmap generation later on
        HashMap&lt;String, Integer&gt; set = new HashMap&lt;String, Integer&gt;();
        for (String str: L) {
            if (set.containsKey(str)) {
                set.put(str, set.get(str) + 1);
            } else {
                set.put(str, 1);
            }
        }
        // starting from i, check Concatenation of All Words
        for (int i = 0; i &lt;= S.length() - (num * len); i++) {
            // first build a HashMap from the set that we acquired before
            HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(set);
            for (int j = 0; j &lt; num; j++) {
                String str = S.substring(i + j * len, i + (j + 1) * len);
                if (!map.containsKey(str)) {
                    break;
                } else if (map.get(str) &gt; 1) {
                    map.put(str, map.get(str) - 1);
                } else if (map.get(str) == 1) {
                    map.remove(str);
                }
            }
            if (map.isEmpty()) {
                ans.add(i);
            }
        }
        return ans;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/10/Recap-java-hashmap/">[Fundamental] Recap on Java HashMap</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-10T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/10/Recap-java-hashmap/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>The HashMap</h4>

<blockquote cite="http://www.sparknotes.com/cs/searching/hashtables/section1.html">
<div>
<a href="http://www.sparknotes.com/cs/searching/hashtables/section1.html">link</a>
</div>
<p>
A hash table is made up of two parts: an array (the actual table where the data to be searched is stored) and a mapping function, known as a hash function. 
</p>
<p>
The hash function is a mapping from the input space to the integer space that defines the indices of the array. In other words, the hash function provides a way for assigning numbers to the input data such that the data can then be stored at the array index corresponding to the assigned number.
</p>
</blockquote>


<p>For example, if I want to store &lt;&ldquo;Durant&rdquo;>, I pass &ldquo;Durant&rdquo; into the hash function, and get (let&rsquo;s say) number 3. So in the Hash Table, it will store table(3 &ndash;> &ldquo;Durant&rdquo;).</p>

<p>In this way, the <strong>searching of HashMap can almost achieve  O(1) time in best case</strong> (like array access).</p>

<p>However,</p>

<blockquote cite="http://stackoverflow.com/a/9214421">
<div>
<a href="http://stackoverflow.com/a/9214421">link</a>
</div>
<p>
For average case, It really is (as the wikipedia page says) O(1+n/k) where K is the hash table size. If K is large enough, then the result is effectively O(1). But suppose K is 10 and N is 100. In that case each bucket will have on average 10 entries, so the search time is definitely not O(1); it is a linear search through up to 10 entries.
</p>
</blockquote>


<p>In practise, we will just assume search in HashMap always O(1).</p>

<p>Below is a great conclusion.</p>

<blockquote cite="http://stackoverflow.com/a/9214594">
<div>
<a href="http://stackoverflow.com/a/9214594">link</a>
</div>
<p><a href="http://en.wikipedia.org/wiki/Hash_table">Hash tables</a> are <code>O(1)</code> <strong>average and <a href="http://en.wikipedia.org/wiki/Amortized_analysis">amortized</a></strong> case complexity, however is suffers from <code>O(n)</code> <strong>worst case</strong> time complexity. [And I think this is where your confusion is]</p>

<p>Hash tables suffer from <code>O(n)</code> worst time complexity due to two reasons:</p>

<ol>
<li>If too many elements were hashed into the same key: looking inside this key may take <code>O(n)</code> time.</li>
<li>Once a hash table has passed its <a href="http://en.wikipedia.org/wiki/Load_balancing_%28computing%29">load balance</a> - it has to rehash [create a new bigger table, and re-insert each element to the table]. </li>
</ol>

<p>However, it is said to be <code>O(1)</code> average and amortized case because:</p>

<ol>
<li>It is very rare that many items will be hashed to the same key [if you chose a good hash function and you don&#8217;t have too big load balance.</li>
<li>The rehash operation, which is <code>O(n)</code>, can at most happen after <code>n/2</code> ops, which are all assumed <code>O(1)</code>: Thus when you sum the average time per op, you get : <code>(n*O(1) + O(n)) / n) = O(1)</code></li>
</ol>
</blockquote>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/10/Java-bit-operation/">[Fundamental] Java Bit Operation</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-10T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/10/Java-bit-operation/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Bit operators</h3>

<table border="2">
  <tr>
    <th>operator</th>
    <th>what is means</th>
  </tr>
  <tr>
    <td>~</td>
    <td>invert every bit</td>
  </tr>
  <tr>
    <td>&lt;&lt;</td>
    <td>shift left (same as *2)</td>
  </tr>
  <tr>
    <td>&gt;&gt;</td>
    <td>signed shift right</td>
  </tr>
  <tr>
    <td>&gt;&gt;&gt;</td>
    <td>unsigned shift right</td>
  </tr>
  <tr>
    <td>^</td>
    <td>XOR</td>
  </tr>
  <tr>
    <td>|</td>
    <td>OR</td>
  </tr>
</table>


<br />


<p>Note the unsigned right shift operator &ldquo;>>>&rdquo; shifts a <strong>zero into the leftmost position</strong>, while the leftmost position after &ldquo;>>&rdquo; <strong>depends on sign extension</strong>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/10/Implement-strStr/">[LeetCode 28] Implement strStr</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-10T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/10/Implement-strStr/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/implement-strstr/">link</a></p>

<div class="question-content">
<p></p><p>
Implement strStr().
</p>
<p>
Returns a pointer to the first occurrence of needle in haystack, or <b>null</b> if needle is not part of haystack.
</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>There are 2 ways to solve this problem.</p>

<ol>
<li><p><strong>Most common way</strong> is using 2 nested loop</p></li>
<li><p>Also can be solved by <a href="http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">KPM algorithm</a></p></li>
</ol>


<h3>Solution</h3>

<p>Standard solution is posted below. Read <a href="http://www.programcreek.com/2012/12/leetcode-implement-strstr-java/">this post</a> for more.</p>

<p>As for KMP algo, I have to admit I am not able to do it. Plz refer to <a href="http://discuss.leetcode.com/questions/76/implement-strstr">this blog</a> and <a href="http://fisherlei.blogspot.sg/2012/12/leetcode-implement-strstr.html">this blog</a> for more!</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public int strStr(String haystack, String needle) {
        if (haystack == null || needle == null) {
            return -1;
        } else if (haystack.length() &lt; needle.length()) {
            return -1;
        } else if (haystack.length() == 0 &amp;&amp; needle.length() == 0) {
            return 0;
        }
        for (int i = 0; i &lt;= haystack.length() - needle.length(); i++) {
            int j;
            // try to match part of haystack (starting from i) to needle 
            for (j = 0; j &lt; needle.length(); j++) {
                if (haystack.charAt(i + j) != needle.charAt(j)) {
                    break;
                }
            }
            // if part of haystack (starting from i) matches needle 
            if (j == needle.length()) {
                return i;
            }
            // if not match, proceed to next loop
        }
        return -1;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/10/Divide-Two-Integers/">[LeetCode 29] Divide Two Integers</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-10T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/10/Divide-Two-Integers/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/divide-two-integers/">link</a></p>

<div class="question-content">
            <p></p><p>
Divide two integers without using multiplication, division and mod operator.
</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question might be more difficult than you thought</strong>. So do not overlook it because of its seemingly simple description. First of all, please refer to <strong>[Fundamental] Java Bit Operation</strong> for information on bit operators.</p>

<p>And <strong>remember&hellip; overflow can happen</strong>, especially when you dealing with Integer.MAX_VALUE and Integer.MIN_VALUE.</p>

<h3>Solution</h3>

<p>This solution is <strong>a while loop that keeps subtracting (divisor * (2 ^ n)) from dividend</strong>. You can find a good solution from <a href="http://leetcodenotes.wordpress.com/2013/10/19/divide-two-integers/">this blog</a>.</p>

<h3>code</h3>

<pre><code>public class Solution {
    public int divide(int dividend, int divisor) {
        int sign = 1;
        long x = dividend;
        long y = divisor;
        if (x &lt; 0) {
            x = x * -1;
            sign *= -1;
        }
        if (y &lt; 0) {
            y = y * -1;
            sign *= -1;
        }
        return divide(sign, x, y);
    }

    private int divide(int sign, long x, long y) {
        // both x and y are positive numbers
        if (x &lt; y) {
            return 0;
        }
        long quotient = 0;
        long partialQuotient;
        long partialSubtract;
        while (x &gt;= y) {
            // the idea is to subtract a certain times of x from y
            // and save the remainder value back to x
            partialQuotient = 1;
            partialSubtract = y;
            while ((partialSubtract &lt;&lt; 1) &lt;= x) {
                partialQuotient &lt;&lt;= 1; // doubles quotient
                partialSubtract &lt;&lt;= 1; // doubles subtraction
            }
            x -= partialSubtract;
            quotient += partialQuotient;
        }
        long finalQuo = sign * quotient;
        if (finalQuo &lt; Integer.MIN_VALUE || finalQuo &gt; Integer.MAX_VALUE) {
            return Integer.MAX_VALUE;
        } else {
            return (int) finalQuo;
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Valid-Parentheses/">[LeetCode 20] Valid Parentheses</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/09/Valid-Parentheses/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/valid-parentheses/">link</a></p>

<div class="question-content">
            <p></p><p>Given a string containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.</p>

<p>The brackets must close in the correct order, <code>"()"</code> and <code>"()[]{}"</code> are all valid but <code>"(]"</code> and <code>"([)]"</code> are not.</p>
<p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>Either stack or string would work.</p>

<h3>Solution</h3>

<p>The code is easy.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public boolean isValid(String s) {
        if (s == null || s.length() == 0) {
            return false;
        }
        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();
        // process s char by char
        for (char c: s.toCharArray()) {
            if (c == '(' || c == '[' || c == '{') {
                stack.push(c);
            } else {
                if (stack.isEmpty()) {
                    // eg. input = "())))"
                    return false;
                }
                char top = stack.pop();
                if (Math.abs(top - c) &gt; 2) {
                    // parentheses does not match
                    return false;
                }
            }
        }
        // after this, stack should be empty (if parentheses valid)
        return stack.isEmpty();
    }
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="61">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="59">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (79)</a></li>
<li class='category'><a href='/blog/categories/experience/'>experience (4)</a></li>
<li class='category'><a href='/blog/categories/fundamental/'>fundamental (18)</a></li>
<li class='category'><a href='/blog/categories/java-oop/'>java oop (36)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (177)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (16)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (25)</a></li>
<li class='category'><a href='/blog/categories/q-facebook/'>q-facebook (9)</a></li>
<li class='category'><a href='/blog/categories/q-google/'>q-google (63)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (133)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (5)</a></li>
<li class='category'><a href='/blog/categories/z-string-search/'>z-string-search (17)</a></li>
<li class='category'><a href='/blog/categories/z-testing/'>z-testing (2)</a></li>
<li class='category'><a href='/blog/categories/z-top-k/'>z-top-k (6)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/11/22/challenges-writing-crawler/">[Design] Writing a web crawler yourself </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/21/swizzle-sort/">[Question] Swizzle Sort </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/21/generate-maze/">[Design] How to generate Maze </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/18/strategy-pattern/">[Design] Strategy design pattern </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/15/partition-problem/">[Question] Partition Problem (divide array into halves) </a>
      </li>
    
  </ul>
</section>




<!--
<script type="text/javascript" src="http://srvpub.com/adServe/banners?tid=29011_41781_0&size=120x600" ></script>
&#8211;>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
    Copyright &copy; 2015 - <a href="/about">Woodstock</a> -  All posts are my original writing, based uppon my personal view. <a href="/policy">Privacy Policy</a> - 
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
