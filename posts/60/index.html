
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Shuatiblog.com</title>
  <meta name="author" content="CodeMonkey">

  
  <meta name="description" content="Question link Write a function to find the longest common prefix string amongst an array of strings. Stats Frequency 1 Diffficulty 2 Adjusted &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.shuatiblog.com/posts/60/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Shuatiblog.com" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.shuatiblog.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="blue_light">
            Shuatiblog.com
        </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/01/Longest-Common-Prefix/">[LeetCode 14] Longest Common Prefix</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-01T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/01/Longest-Common-Prefix/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/longest-common-prefix/">link</a></p>

<div class="question-content">
            <p></p><p>Write a function to find the longest common prefix string amongst an array of strings.
</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>Straight-forward solution.</strong> Will not go into details.</p>

<p>However, there&rsquo;s another more generalized <a href="http://en.wikipedia.org/wiki/LCP_array"><strong>LCP array</strong></a> which is solved by use of <a href="http://en.wikipedia.org/wiki/Trie">Trie</a>.</p>

<h3>Solution</h3>

<p>The code explains itself.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        int p;
        for (p = 0; p &lt; strs[0].length(); p++) {
            char c = strs[0].charAt(p);
            // check all strings in array strs
            for (int i = 0; i &lt; strs.length; i++) {
                if (p == strs[i].length()) {
                    return strs[i];
                } else if (c != strs[i].charAt(p)) {
                    return strs[i].substring(0, p);
                }
            }
            // if all strings have the same prefix
            // continue checking it
        }
        // first string in array strs is the shortest common prefix
        return strs[0];
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/30/Roman-to-Integer/">[LeetCode 13] Roman to Integer</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-30T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/04/30/Roman-to-Integer/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/roman-to-integer/">link</a></p>

<div class="question-content">
            <p></p><p>Given a roman numeral, convert it to an integer.</p>

<p>Input is guaranteed to be within the range from 1 to 3999.</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>This question is easier than <strong>[LeetCode 12] Integer to Roman</strong>.</p>

<p>The basic idea is to <strong>read 2 char (as pre and cur) and then check</strong>. If pre > cur, then OK, just do the addition. If pre &lt; cur, we need to subtract (2 * pre) from the result.</p>

<p>The code is easy and concise if you have the idea.</p>

<h3>Solution</h3>

<p>The code explains itself.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public int romanToInt(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        int ans = 0;
        int pre = 0;
        int cur = 0;
        for (int i = 0; i &lt; s.length(); i++) {
            cur = getNum(s.charAt(i));
            if (i == 0 || pre &gt;= cur) {
                ans += cur;
            } else {
                ans += cur - (2 * pre);
            }
            pre = cur;
        }
        return ans;
    }

    private int getNum(char a){
        switch(a){
            case 'I': return 1;
            case 'V': return 5;
            case 'X': return 10;
            case 'L': return 50;
            case 'C': return 100;
            case 'D': return 500;
            case 'M': return 1000;
        }
        return 0;
    }
}
</code></pre>

<p>We can also do only adding. Someone posted the code in <a href="http://yucoding.blogspot.sg/2013/05/leetcode-question-87-roman-to-interger.html">here</a>. Read it ONLY if you are interested.</p>

<pre><code>class Solution {
public:
    int romanToInt(string s) {
        // 4:IV, 9:IX, 40:XL, 90:XC, 400:CD, 900:CM,
        // 1:I, 10:X, 100:C, 1000:M
        int res=0;
        char pre = ' ';
        for(int i=0;i&lt;s.size();i++){
            if (s[i]=='M' &amp;&amp; pre!='C') {res+=1000;}
            if (s[i]=='C' &amp;&amp; pre!='X') {res+=100;}
            if (s[i]=='X' &amp;&amp; pre!='I') {res+=10;}

            if (s[i]=='M' &amp;&amp; pre=='C') {res+=800;}
            if (s[i]=='C' &amp;&amp; pre=='X') {res+=80;}
            if (s[i]=='X' &amp;&amp; pre=='I') {res+=8;}

            if (s[i]=='I' ) {res+=1;}

            if (s[i]=='V' &amp;&amp; pre!='I'){res+=5;}
            if (s[i]=='L' &amp;&amp; pre!='X'){res+=50;}
            if (s[i]=='D' &amp;&amp; pre!='C'){res+=500;}

            if (s[i]=='V' &amp;&amp; pre=='I'){res+=3;}
            if (s[i]=='L' &amp;&amp; pre=='X'){res+=30;}
            if (s[i]=='D' &amp;&amp; pre=='C'){res+=300;}

            pre = s[i];
        }
        return res;
    }
};
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/30/Integer-to-Roman/">[LeetCode 12] Integer to Roman</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-30T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/04/30/Integer-to-Roman/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/integer-to-roman/">link</a></p>

<div class="question-content">
<p></p><p>Given an integer, convert it to a roman numeral.
</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<table>
<thead>
<tr>
<th>Symbol </th>
<th align="center"> Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td align="center">1</td>
</tr>
<tr>
<td>V</td>
<td align="center">5</td>
</tr>
<tr>
<td>X</td>
<td align="center">10</td>
</tr>
<tr>
<td>L</td>
<td align="center">50</td>
</tr>
<tr>
<td>C</td>
<td align="center">100</td>
</tr>
<tr>
<td>D</td>
<td align="center">500</td>
</tr>
<tr>
<td>M</td>
<td align="center">1,000</td>
</tr>
</tbody>
</table>


<p>Though <a href="http://en.wikipedia.org/wiki/Roman_numerals">Roman numerals</a> looks complex, it&rsquo;s actually converted bit by bit. For example 207=>CCVII. We can then construct <strong>the following relationship table</strong>:</p>

<table>
<thead>
<tr>
<th>Base/number</th>
<th align="center">Number(1)</th>
<th align="center">Number(5)</th>
<th align="center">Number(10)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td align="center">I</td>
<td align="center">V</td>
<td align="center">X</td>
</tr>
<tr>
<td>10</td>
<td align="center">X</td>
<td align="center">L</td>
<td align="center">C</td>
</tr>
<tr>
<td>100</td>
<td align="center">C</td>
<td align="center">D</td>
<td align="center">M</td>
</tr>
<tr>
<td>1000</td>
<td align="center">M</td>
<td align="center">n.a.</td>
<td align="center">n.a.</td>
</tr>
</tbody>
</table>


<p>So for each number, just do convert according to the above table.</p>

<blockquote><p>9=>IX</p>

<p>400=>CD.</p></blockquote>

<p>The question states that input is less than 3999.</p>

<h3>Analysis</h3>

<p>Before I present my solution, there is a very short code written by stackoverflow user <a href="http://stackoverflow.com/a/19759564">bhlangonijr</a>. This method <strong>makes use of Java <a href="http://goo.gl/e8ryim">TreeMap.floorKey</a></strong>. Read it ONLY if you are interested!</p>

<blockquote><p>TreeMap.floorKey &ndash; Returns the greatest key less than or equal to the given key, or null if there is no such key.</p></blockquote>

<pre><code>public String intToRoman3(int num) {
    TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();
    map.put(1000, "M");
    map.put(900, "CM");
    map.put(500, "D");
    map.put(400, "CD");
    map.put(100, "C");
    map.put(90, "XC");
    map.put(50, "L");
    map.put(40, "XL");
    map.put(10, "X");
    map.put(9, "IX");
    map.put(5, "V");
    map.put(4, "IV");
    map.put(1, "I");
    int l = map.floorKey(num);
    if (num == l) {
        return map.get(num);
    }
    return map.get(l) + intToRoman3(num - l);
}
</code></pre>

<h3>Solution</h3>

<p>I will present 2 solutions below.</p>

<p>First is an iterative solution. It&rsquo;s comparatively shorter, and enjoys beter performance.</p>

<p>Second is my new idea. It has improved readability, but slightly worse performance, because it&rsquo;s recursive.</p>

<h3>My code</h3>

<p>Code 1, iterative.</p>

<pre><code>public class Solution {

    char[][] roman = {
        { 'I', 'V', 'X' }, 
        { 'X', 'L', 'C' }, 
        { 'C', 'D', 'M' },
        { 'M', '*', '*' } 
    };

    public String intToRoman(int num) {
        String ans = "";
        int base = 1, count = 0, temp = num;
        while (temp &gt; 1) {
            base *= 10;
            count++;
            temp /= 10;
        }
        while (base &gt; 0) {
            int cur = num / base;
            // now convert cur into roman string
            if (cur &gt;= 6 &amp;&amp; cur &lt;= 8) {
                ans += roman[count][1];
                cur = cur % 5;
            }
            if (cur &gt;= 1 &amp;&amp; cur &lt;= 3)
                for (int k = 0; k &lt; cur; k++)
                    ans += roman[count][0];
            else if (cur == 5)
                ans += roman[count][1];
            else if (cur == 4)
                ans += roman[count][0] + "" + roman[count][1];
            else if (cur == 9)
                ans += roman[count][0] + "" + roman[count][2];
            num = num % base;
            base /= 10;
            count--;
        }
        return ans;
    }

}
</code></pre>

<p>Code 2, recursive.</p>

<pre><code>public class Solution {

    HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();

    public String intToRoman(int num) {

        map.put(1000, "M");
        map.put(500, "D");
        map.put(100, "C");
        map.put(50, "L");
        map.put(10, "X");
        map.put(5, "V");
        map.put(1, "I");

        String roman = "";
        int base = 1000;
        int digit = 0;
        while (num != 0) {
            digit = num / base;
            num = num % base;
            roman = roman + convert(digit, base);
            base /= 10;
        }
        return roman;
    }

    private String convert(int digit, int base) {
        String ans = "";
        String one = map.get(base);
        String five = map.get(base * 5);
        if (digit == 0) {
            return "";
        } else if (digit &lt;= 3) {
            for (int i = 0; i &lt; digit; i++) {
                ans += one;
            }
        } else if (digit == 4) {
            ans += one;
            ans += convert(5, base);
        } else if (digit == 5) {
            ans += five;
        } else if (digit &lt;= 8) {
            ans += convert(5, base);
            ans += convert(digit - 5, base);
        } else if (digit == 9) {
            ans += one;
            ans += convert(1, base * 10);
        }
        return ans;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/29/ZigZag-Conversion/">[LeetCode 6] ZigZag Conversion</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-29T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/04/29/ZigZag-Conversion/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/zigzag-conversion/">link</a></p>

<div class="question-content">
<p></p><p>
The string <code>"PAYPALISHIRING"</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
</p><pre>
P   A   H   N
A P L S I I G
Y   I   R
</pre>

And then read line by line: <code>"PAHNAPLSIIGYIR"</code><p></p>

<p>
Write the code that will take a string and make this conversion given a number of rows:

</p><pre>string convert(string text, int nRows);</pre>

<code>convert("PAYPALISHIRING", 3)</code> should return <code>"PAHNAPLSIIGYIR"</code>.
<p></p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Solution</h3>

<p><strong>Two ways to work out this problem</strong>.</p>

<p>Solution 1. Insert string s vertically into a 2d array, char by char. After this is finished, make the result string by reading the 2d array horizontally. See code 1 below.</p>

<p>Solution 2. Calculate and find out (in sequence) which char from s should be inserted into the result list. Then build the result list directly. See code 2 below.</p>

<h3>My code</h3>

<p>One. Fill in the whole string, then parse the result.</p>

<pre><code>public class Solution {
    public String convert(String s, int nRows) {
        if (s == null || s.length() == 0 || nRows &lt; 1) {
            return "";
        } else if (nRows == 1) {
            return s;
        }
        int len = s.length();
        int grpSize = nRows * 2 - 2;
        int numGrp = (len - 1) / grpSize + 1;
        String[][] array = new String[nRows][numGrp * 2];
        // fill in string s into array, one group after another
        int p = 0;
        // for each group
        for (int i = 0; i &lt; numGrp; i++) {
            // for each vertical index (left col), fill in one letter from s
            for (int j = 0; j &lt; nRows; j++) {
                // if s is used up, break
                if (p == len) {
                    break;
                }
                array[j][i * 2] = "" + s.charAt(p);
                p++;
            }
            // for each vertical index (right col), fill in one letter from s
            for (int j = nRows - 2; j &gt; 0; j--) {
                // if s is used up, break
                if (p == len) {
                    break;
                }
                array[j][i * 2 + 1] = "" + s.charAt(p);
                p++;
            }
        }
        // now convert array[][] into final string and return answer
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; array.length; i++) {
            for (int j = 0; j &lt; array[0].length; j++) {
                if (array[i][j] == null || array[i][j].length() == 0) {
                    continue;
                } else {
                    sb.append(array[i][j]);
                }
            }
        }
        return sb.toString();
    }
}
</code></pre>

<p>Two. Pick the correct char and form the result string, and fill it in the result string.</p>

<pre><code>public class Solution {
    public String convert(String s, int nRows) {
        if (nRows &lt;= 1)
            return s;
        int eachPattern = 2 * nRows - 2;
        int numPatterns = (s.length() - 1) / eachPattern + 1;
        StringBuilder ans = new StringBuilder();
        for (int j = 0; j &lt; nRows; j++) {
            for (int i = 0; i &lt; numPatterns; i++) {
                ans.append(find(s, eachPattern, i, j));
                if (j != 0 &amp;&amp; j != nRows - 1)
                    ans.append(find(s, eachPattern, i, 2 * (nRows - 1) - j));
            }
        }
        return ans.toString();
    }

    private String find(String s, int eachPattern, int i, int j) {
        // find (j)th element from (i)th pattern
        int temp = eachPattern * i + j;
        if (temp &lt; s.length())
            return s.substring(temp, temp + 1);
        return "";
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/29/String-to-Integer-(atoi)/">[LeetCode 8] String to Integer (Atoi)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-29T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/04/29/String-to-Integer-(atoi)/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/string-to-integer-atoi/">link</a></p>

<div class="question-content">
            <p></p><p>Implement <span style="font-family:monospace">atoi</span> to convert a string to an integer.</p>

<p><b>Hint:</b> Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p>

<p>
<b>Notes:</b> 
It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. </p>

<div class="spoilers"><b>Requirements for atoi:</b>

<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>

<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>

<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>

<p>If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.
</p>
</div><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>This question is not difficult, but hard to get it right. Remember to handle all cases listed below:</p>

<ol>
<li>null or empty string</li>
<li>white spaces</li>
<li>+/&ndash; sign</li>
<li>calculate real value</li>
<li>return int.min or int.max</li>
</ol>


<h3>Solution</h3>

<p><strong>Use one loop to read through, and in the end do some checking</strong>. There is a very good <a href="http://www.programcreek.com/2012/12/leetcode-string-to-integer-atoi/">explanation</a> from online.</p>

<p>This is a standard string question, and try think of some special test cases.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public int atoi(String str) {
        if (str == null || str.length() == 0) {
            return 0;
        }
        int p = 0; 
        int len = str.length();
        // omit as many space as possible
        while (p &lt; len) {
            if (str.charAt(p) != ' ') {
                break;
            }
            p++;
        }
        int sign = 1;
        // check if there is a +/- sign at position p
        // if there is, store its value and advance p
        if (p == len) {
            return 0;
        } else if (str.charAt(p) == '+') {
            p++;
        } else if (str.charAt(p) == '-') {
            sign = -1;
            p++;
        }
        // check if position p have valid number
        if (p == len) {
            return 0;
        } else if (str.charAt(p) &lt; '0' || str.charAt(p) &gt; '9') {
            return 0;
        }
        // now position p is the start of numerical part.
        int q = p;
        while (q &lt; len &amp;&amp; str.charAt(q) &gt;= '0' &amp;&amp; str.charAt(q) &lt;= '9') {
            q++;
        }
        String numPart = str.substring(p, q);
        // first, check if numPart is too long
        if (numPart.length() &gt; 15) {
            if (sign == -1) {
                return Integer.MIN_VALUE;
            } else {
                return Integer.MAX_VALUE;
            }
        }
        // second, convert to numerical format and check value against Integer.MIN and MAX
        long num = sign * Long.parseLong(numPart);
        if (num &gt; Integer.MAX_VALUE) {
            return Integer.MAX_VALUE;
        } else if (num &lt; Integer.MIN_VALUE) {
            return Integer.MIN_VALUE;
        } else {
            return (int) num;
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/29/Regular-Expression-Matching/">[LeetCode 10] Regular Expression Matching</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-29T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/04/29/Regular-Expression-Matching/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/regular-expression-matching/">link</a></p>

<div class="question-content">
<p></p><p>Implement regular expression matching with support for <code>'.'</code> and <code>'*'</code>.</p>

<pre>'.' Matches any single character.
'*' Matches <b>zero or more of the preceding</b> element.

The matching should cover the <b>entire</b> input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true
</pre><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>Very important to note: Do not use DP</strong>. Why? Because eg. &ldquo;a*b&rdquo; will be considered as 2 parts: &ldquo;a*&rdquo; part and &ldquo;b&rdquo; part. Because star is considered to be bundled with previous char, it gives us difficulty in determine the size of the DP array. Of course, we still can do it, but I see nobody have provided a nice DP solution online. Let&rsquo;s just forget about it for now.</p>

<p>The solution I&rsquo;m giving in this post, is to trim String and compare.</p>

<p><strong>We only need to consider 2 cases</strong>:</p>

<p>One, the next char is NOT a star sign. This requires simply char compare.</p>

<p>Two, the next char is a star sign, this will require some effort.</p>

<h3>Solution</h3>

<p>In case of one letter bundled with a star sign, we iterate thru all possible number of repetition of current char (from 0 until large), and check validation one by one.</p>

<p>A final important note, <strong>this question very much looks like DP, but NOT DP</strong>.</p>

<h3>My code</h3>

<p>My code.</p>

<pre><code>public class Solution {
    public boolean isMatch(String s, String p) {
        // eg. s = "aab"  p = "c*a*b"
        return check(s, p, 0, 0);
    }

    private boolean check(String s, String p, int start1, int start2) {
        int len1 = s.length();
        int len2 = p.length();
        if (start1 == len1 &amp;&amp; start2 == len2) {
            return true;
        } else if (start2 == len2) {
            // if p is used up, but still some letters left in s
            return false;
        }
        // check if there is * after start2 in p
        if (start2 == len2 - 1 || p.charAt(start2 + 1) != '*') {
            // if there is no *
            // match only 1 char
            if (start1 == len1) {
                // unable to match single char because s is fully used up
            } else if (p.charAt(start2) != '.' &amp;&amp; s.charAt(start1) != p.charAt(start2)) {
                // if single char could not be matched
                return false;
            } else {
                // if single letter matches
                return check(s, p, start1 + 1, start2 + 1);
            }
        } else {
            // if there is a * following start2
            if (check(s, p, start1, start2 + 2)) {
                // the letter in p represent 0 chars
                return true;
            } else {
                // the letter in p represent 1 or more chars
                // advance start1 until the end of s
                while (start1 &lt; len1) {
                    // check if the char matches
                    if (p.charAt(start2) != '.' &amp;&amp; s.charAt(start1) != p.charAt(start2)) {
                        break;
                    }
                    if (check(s, p, start1 + 1, start2 + 2)) {
                        return true;
                    }
                    start1++;
                }
            }
        }
        return false;
    }
}
</code></pre>

<p>A much shorter version from <a href="http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/">someone else</a> making use of <strong>String.substring()</strong>. I refactored a bit.</p>

<pre><code>public class Solution {
    public boolean isMatch(String s, String p) {
        // s is normal string, and p is regex string
        if (p.length() == 0) {
            return s.length() == 0;
        } else if (p.length() &lt; 2 || p.charAt(1) != '*') {
            // if 2nd char in p is not '*', then match character
            if (s.length() == 0) {
                return false;
            } else if (p.charAt(0) != '.' &amp;&amp; s.charAt(0) != p.charAt(0)) {
                return false;
            } else {
                return isMatch(s.substring(1), p.substring(1));
            }
        } else {
            // if 2nd char in p is '*', then iterate all position repetitions
            char repeatLetter = p.charAt(0);
            for (int i = 0; i &lt;= s.length(); i++) {
                // i is the number of repetition of repeatLetter, start from 0
                if (i &gt; 0 &amp;&amp; repeatLetter != s.charAt(i - 1)
                        &amp;&amp; repeatLetter != '.') {
                    break;
                } else {
                    if (isMatch(s.substring(i), p.substring(2))) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/29/Palindrome-Number/">[LeetCode 9] Palindrome Number</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-29T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/04/29/Palindrome-Number/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/palindrome-number/">link</a></p>

<div class="question-content">
<p></p><p>Determine whether an integer is a palindrome. Do this without extra space.</p>

<div class="spoilers" style="display: block;"><b>Some hints:</b>

<p>Could negative integers be palindromes? (ie, -1)</p>

<p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p>

<p>You could also try reversing an integer. However, if you have solved the problem &#8220;Reverse Integer&#8221;, you know that the reversed integer might overflow. How would you handle such case?</p>

<p>There is a more generic way of solving this problem.</p>

</div><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>This question is easy, and very similar to the &ldquo;Reverse Integer&rdquo; question. <strong>Simpliest solution is to just reverse the integer</strong> and compare with original number.</p>

<p>But again, reversing the integer have chances of <strong>overflow</strong>. How do we work this out?</p>

<h3>Solution</h3>

<p>First, same as previous post <strong>[LeetCode 7] Reverse Integer</strong>, we can use Long type to handle the overflow issues.</p>

<p>Second, <strong>we can also do direct compare</strong> to always compare the head and tail of the number. No numerical type conversion is needed. I came up with idea previously, and code is posted below.</p>

<h3>My code</h3>

<p>Use Long type:</p>

<pre><code>public class Solution {
    public boolean isPalindrome(int x) {
        if (x &lt; 0) {
            return false;
        }
        long rev = 0;
        long original = x;
        while (x != 0) {
            rev = rev * 10 + (x % 10);
            x = x / 10;
        }
        return original == rev;
    }
}
</code></pre>

<p>Compare head and tail:</p>

<pre><code>public boolean isPalindrome(int x) {
    if (x &lt; 0) {
        return false;
    }
    int divide = 1;
    while (x / divide &gt;= 10) {
        divide *= 10;
    }
    int head = 0, tail = 0;
    while (divide &gt; 0) {
        head = x / divide;
        tail = x % 10;
        if (head != tail) {
            return false;
        }
        x = x % divide / 10;
        divide /= 100;
    }
    return true;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/29/Container-With-Most-Water/">[LeetCode 11] Container With Most Water</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-29T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/04/29/Container-With-Most-Water/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/container-with-most-water/">link</a></p>

<div class="question-content">
            <p></p><p>Given <i>n</i> non-negative integers <i>a<sub>1</sub></i>, <i>a<sub>2</sub></i>, &#8230;, <i>a<sub>n</sub></i>, where each represents a point at coordinate (<i>i</i>, <i>a<sub>i</sub></i>). <i>n</i> vertical lines are drawn such that the two endpoints of line <i>i</i> is at (<i>i</i>, <i>a<sub>i</sub></i>) and (<i>i</i>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
</p>
<p>Note: You may not slant the container.
</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>Assume i and j are 2 points in x-axis where i &lt; j. The container volume is decided by the shorter height among the two.</p>

<p>Assume i is lower than j, there will be no i &lt; jj &lt; j that makes the area of (i,jj) greater than area of (i,j). <strong>In other words, all (i,jj) is smaller than (i,j) so there&rsquo;s no need to check them</strong>.</p>

<p>Thus we move i forward by 1. This idea is explained in <a href="http://jane4532.blogspot.sg/2013/05/container-with-most-water-leetcode.html">this post</a>.</p>

<h3>Solution</h3>

<p><strong>Two-pointer scan</strong>. And always move the shorter board index (if we consider it to be a rectangle bucket), as explained in <a href="http://fisherlei.blogspot.sg/2013/01/leetcode-container-with-most-water.html">this post</a>.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public int maxArea(int[] height) {
        if (height == null || height.length &lt;= 1) {
            return 0;
        }
        int left = 0;
        int right = height.length - 1;
        int area = 0;
        // start calculating area and shrinking the distance 
        // between left and right pointer
        while (left &lt; right) {
            area = Math.max(area, (right - left) 
                * Math.min(height[left], height[right]));
            if (height[left] &lt; height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return area;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/28/reverse-integer/">[LeetCode 7] Reverse Integer</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-28T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/04/28/reverse-integer/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/reverse-integer/">link</a></p>

<div class="question-content">
<p></p><p>Reverse digits of an integer.</p>

<p style="font-family:monospace">
<b>Example1:</b> x =  123, return  321<br>
<b>Example2:</b> x = -123, return -321
</p>

<div class="spoilers"><b>Have you thought about this?</b>
<p>Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!</p>
<p>If the integer&#8217;s last digit is 0, what should the output be? ie, cases such as 10, 100.</p>
<p>Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?</p>
<p>Throw an exception? Good, but what if throwing an exception is not an option? You would then have to re-design the function (ie, add an extra parameter).</p>
</div><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>There&rsquo;re 2 points that are tricky.</strong></p>

<p><strong>First, overflow issue</strong>. Look at the following overflow case for Java int:</p>

<pre><code>+300,000,000 * 10 returns -1294967296
+600,000,000 * 10 returns +1705032704
-300,000,000 * 10 returns +1294967296
-600,000,000 * 10 returns -1705032704
note that max integer is 2,147,483,647
</code></pre>

<p>We can observe that if overflow happens, <strong>the result is definitely wrong</strong>. The result can be either positive or negative.</p>

<p>So, from just +/&ndash; sign of the result, we can&rsquo;t identify an overflow (then how to solve this problem??).</p>

<p><strong>Another interesting thing to note: we actually do not need to handle negative sign</strong>. The sign can be preserved during the conversion. Read <a href="http://fisherlei.blogspot.sg/2012/12/leetcode-reverse-integer.html">this post</a> for more.</p>

<p>Without considering overflow, the following code can (almost) work fine:</p>

<pre><code>public int reverse2(int x) {
    int reverse = 0;
    while (x != 0) {
        reverse = reverse * 10 + x % 10;
        x /= 10;
    }
    return reverse;
}
</code></pre>

<h3>Solution</h3>

<p><strong>Two solutions</strong>: 1. use long data type. 2. check if ret > 214748364 or ret &lt; –214748364 before multiplying by 10.</p>

<h3>My code</h3>

<p>First, using long type to avoid overflow.</p>

<pre><code>public class Solution {
    public int reverse(int x) {
        int sign = 1;
        long abs = x;
        long rev = 0;
        if (x &lt; 0) {
            sign = -1;
            abs = 0 - abs;
        }
        // now remove numbers from abs one by one
        // and put these numbers into rev
        while (abs != 0) {
            rev *= 10;
            rev += abs % 10;
            abs /= 10;
        }
        if (rev &gt; Integer.MAX_VALUE) {
            return 0;
        } else {
            return sign * (int) rev;
        }
    }
}
</code></pre>

<p>Second, do boundary check in every step. Suggested by Leetcode official book.</p>

<p>Note that max integer is 2,147,483,647</p>

<pre><code>public class Solution {

    public int reverse(int x) {
        int ret = 0;
        while (x != 0) {
            // handle overflow/underflow
            if (Math.abs(ret) &gt; 214748364) {
                return 0;
            }
            ret = ret * 10 + x % 10;
            x /= 10;
        }
        return ret;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/28/longest-palindrome-substr/">[LeetCode 5] Longest Palindromic Substring</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-28T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/04/28/longest-palindrome-substr/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/longest-palindromic-substring/">link</a></p>

<div class="question-content">
<p></p><p>Given a string <i>S</i>, find the longest palindromic substring in <i>S</i>. You may assume that the maximum length of <i>S</i> is 1000, and there exists one unique longest palindromic substring.</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>There are 2 solutions. One is <strong>DP</strong> which is O(N<sup>2</sup>) time and O(N<sup>2</sup>) space. Another is &ldquo;Search around corner&rdquo;, which uses less space.</p>

<h3>Solution</h3>

<p><strong>DP solution is straight-forward</strong>. Use 2D array to check palindrome intervals and make it as either true or false. Meanwhile, update longest.</p>

<p>O(N<sup>2</sup>) time and O(N<sup>2</sup>) space</p>

<p><strong>Search around corner</strong> is basically iterate through the entire string and assume each char (or char pair) as center of the palindrome. The code isn&rsquo;t difficult once you come up with the idea.</p>

<p>For more, read <a href="http://leetcode.com/2011/11/longest-palindromic-substring-part-i.html">this post</a></p>

<p>O(N<sup>2</sup>) time and O(1) space</p>

<h3>My code</h3>

<p>DP solution</p>

<pre><code>public class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }
        String longest = "";
        int len = s.length();
        // dp[i][j] means substring of s from i to j is palindrome 
        boolean[][] dp = new boolean[len][len];
        // why i decrease from (len-1) to 0, but j increase from i to (len-1)?
        // think about it! 
        for (int i = len - 1; i &gt;= 0; i--) {
            for (int j = i; j &lt; len; j++) {
                if (i == j) {
                    dp[i][j] = true;
                } else if (i + 1 == j) {
                    dp[i][j] = s.charAt(i) == s.charAt(j);
                } else {
                    // important to note: dp[i+1][j-1]
                    // i depends on (i+1), so i from large to small
                    // j is just the opposite, small to large
                    dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; dp[i+1][j-1];
                }
                if (dp[i][j] &amp;&amp; j + 1 - i &gt; longest.length()) {
                    longest = s.substring(i, j + 1);
                }
            }
        }
        return longest;
    }
}
</code></pre>

<p>Search around corner</p>

<pre><code>public class Solution {
    public String longestPalindrome(String s) {
        if (s.length() &lt;= 1)
            return s;
        String largest = s.substring(0, 1);
        for (int i = 0; i &lt; s.length(); i++) {
            String first = this.searchAroundCenter(s, i, i);
            String second = this.searchAroundCenter(s, i, i + 1);
            if (first.length() &lt; second.length())
                first = second;
            if (largest.length() &lt; first.length())
                largest = first;
        }
        return largest;
    }

    private String searchAroundCenter(String s, int a, int b) {
        if (a &lt; 0 || b &gt; s.length() - 1)
            return "";
        while (s.charAt(a) == s.charAt(b)) {
            a--;
            b++;
            if (a &lt; 0 || b &gt; s.length() - 1)
                return s.substring(a + 1, b);
        }
        return s.substring(a + 1, b);
    }
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="61">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="59">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (76)</a></li>
<li class='category'><a href='/blog/categories/experience/'>experience (4)</a></li>
<li class='category'><a href='/blog/categories/fundamental/'>fundamental (14)</a></li>
<li class='category'><a href='/blog/categories/java-oop/'>java oop (30)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (176)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (25)</a></li>
<li class='category'><a href='/blog/categories/q-facebook/'>q-facebook (9)</a></li>
<li class='category'><a href='/blog/categories/q-google/'>q-google (63)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (126)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (5)</a></li>
<li class='category'><a href='/blog/categories/z-string-search/'>z-string-search (17)</a></li>
<li class='category'><a href='/blog/categories/z-testing/'>z-testing (2)</a></li>
<li class='category'><a href='/blog/categories/z-top-k/'>z-top-k (6)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/10/08/segment-tree/">[Fundamental] Segment Tree </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/07/largest-subsquare-with-edge-filled/">[Question] Largest Sub-square with Edges filled </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/07/closest-leaf-binary-tree/">[Question] Find Cloest Leaf in Binary Tree </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/07/all-string-placing-space/">[Amazon] All Strings by Placing Spaces </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/04/seven-bridge/">[Fundamental] The 7 Bridges Problem </a>
      </li>
    
  </ul>
</section>





<script type="text/javascript" src="http://srvpub.com/adServe/banners?tid=29011_41781_0&size=120x600" ></script>

<!--
<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"willran168","width":160,"height":600,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>
<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>
&#8211;>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
    Copyright &copy; 2015 - <a href="/about">CodeMonkey</a> -  All posts are my original writing, based uppon my personal view. <a href="/policy">Privacy Policy</a> - 
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
