
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="Dynamic Programming The fundamental of DP is &lsquo;merorized search&rsquo;. It&rsquo;s easy to implement but bad for memory. And it&rsquo;s &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/15">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/24/NineChap-Dynamic-Programming/">[NineChap 5.1] Dynamic Programming</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-24T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Dynamic Programming</h2>

<p>The fundamental of DP is &lsquo;merorized search&rsquo;. It&rsquo;s easy to implement but bad for memory. And it&rsquo;s generally useless in the industry.</p>

<h3>When to use DP?</h3>

<ol>
<li>Input cannot sort</li>
<li>Find minimum/maximum result</li>
<li>Check the feasibility</li>
<li>Count all possible solutions</li>
</ol>


<p>If question asks you to find all possible solutions, it&rsquo;s gonna be DFS, not DP.</p>

<h3>5 Types of DP</h3>

<ol>
<li>Matrix DP (10%)</li>
<li>Sequence/Two Sequences DP (80%)</li>
<li>Interval DP (5%)</li>
<li>Tree DP (5%)</li>
<li>States Compressing DP (0%)</li>
</ol>


<p>Type 3 to 5 are less important.</p>

<h3>Question List</h3>

<p><strong>Type 1: Matrix DP</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/27/Triangle/">Triangle</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/20/Unique-Paths/">Unique Paths </a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/20/Unique-Paths-II/">Unique Paths II  </a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/20/Minimum-Path-Sum/">Minimum Path Sum </a></strong></p></li>
</ol>


<p><strong>Type 2.1: Sequence Dp</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/21/Climbing-Stairs/">Climbing Stairs </a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/16/Jump-Game/">Jump Game </a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/14/Jump-Game-II/">Jump Game II</a></strong> &ndash; tricky, index handling</p></li>
<li><p><strong><a href="/blog/2014/05/30/Palindrome-Partitioning-II/">Palindrome Partitioning II </a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/02/Word-Break/">Word Break </a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/02/Word-Break-II/">Word Break II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/23/Decode-Ways/">Decode Ways </a></strong> &ndash; tricky, initial state</p></li>
<li><p><strong><a href="/blog/2014/06/24/Longest-Increasing-Subsequence/">Longest Increasing Subsequence</a></strong></p></li>
</ol>


<p><strong>Type 2.2: Two Sequences Dp</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/27/Distinct-Subsequences/">Distinct Subsequences </a></strong> &ndash; difficult, state transition formula</p></li>
<li><p><strong><a href="/blog/2014/05/21/Edit-Distance/">Edit Distance </a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/24/Interleaving-String/">Interleaving String </a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/24/Longest-Common-Subsequence/">Longest Common Subsequence</a></strong></p></li>
</ol>


<p><strong>Type 3: Interval Dp</strong></p>

<p><a href="http://wikioi.com/problem/1048/">Merge Stone</a></p>

<p><strong>Type 4: Tree Dp</strong></p>

<ol>
<li><strong><a href="/blog/2014/05/28/Binary-Tree-Maximum-Path-Sum/">Binary Tree Maximum Path Sum</a></strong></li>
</ol>


<p><strong>Type 5: States Compressing DP</strong></p>

<p>Ignore.</p>

<p>Additional questions</p>

<ol>
<li><p><strong><a href="/blog/2014/05/20/Maximum-Subarray/">Maximum Subarray </a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/30/Coin-Changing-Problem/">Coin Change Problem</a></strong></p></li>
</ol>


<h2>Code</h2>

<h4>Type 1: Matrix DP</h4>

<p><strong>Triangle</strong></p>

<pre><code>public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) {
    if (triangle == null || triangle.size() == 0) {
        return 0;
    }
    int len = triangle.size();
    int[][] dp = new int[len][len];
    for (int i = len - 1; i &gt;= 0; i--) {
        // bottom-up approach (row by row)
        for (int j = 0; j &lt;= i; j++) {
            if (i == len - 1) {
                dp[i][j] = triangle.get(i).get(j);
            } else {
                dp[i][j] = triangle.get(i).get(j)
                        + Math.min(dp[i+1][j], dp[i+1][j+1]);
            }
        }
    }
    return dp[0][0];
}
</code></pre>

<p><strong>Unique Paths</strong></p>

<pre><code>public int uniquePaths(int m, int n) {
    if (m == 0 &amp;&amp; n == 0) {
        return 0;
    }
    int[][] dp = new int[m][n];
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (i == 0 || j == 0) {
                dp[i][j] = 1;
            } else {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
    }
    return dp[m-1][n-1];
}
</code></pre>

<p><strong>Unique Paths II</strong></p>

<pre><code>public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    if (obstacleGrid == null) {
        return 0;
    }
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;
    int[][] dp = new int[m][n];
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (obstacleGrid[i][j] != 0) {
                dp[i][j] = 0;
            } else if (i == 0 &amp;&amp; j == 0) {
                dp[i][j] = 1;
            } else if (i == 0) {
                dp[i][j] = dp[i][j-1];
            } else if (j == 0) {
                dp[i][j] = dp[i-1][j];
            } else {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
    }
    return dp[m-1][n-1];
}
</code></pre>

<p><strong>Minimum Path Sum</strong></p>

<pre><code>public int minPathSum(int[][] grid) {
    if (grid == null) {
        return 0;
    }
    int m = grid.length;
    int n = grid[0].length;
    int[][] dp = new int[m][n];
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (i == 0 &amp;&amp; j == 0) {
                dp[i][j] = grid[i][j];
            } else if (i == 0) {
                dp[i][j] = dp[i][j-1] + grid[i][j];
            } else if (j == 0) {
                dp[i][j] = dp[i-1][j] + grid[i][j];
            } else {
                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[m-1][n-1];
}
</code></pre>

<h4>Type 2.1: Sequence Dp</h4>

<p><strong>Climbing Stairs</strong></p>

<pre><code>public int climbStairs(int n) {
    if (n &lt;= 2) {
        return n;
    }
    int[] dp = new int[n];
    dp[0] = 1;
    dp[1] = 2;
    for (int i = 2; i &lt; n; i++) {
        dp[i] = dp[i - 2] + dp[i - 1];
    }
    return dp[n - 1];
}
</code></pre>

<p><strong>Jump Game</strong></p>

<pre><code>public boolean canJump(int[] A) {
    if (A == null || A.length == 0) 
        return false;
    int reach = 0;
    int len = A.length;
    for (int i = 0; i &lt; len; i++) {
        if (i &gt; reach) 
            break;
        reach = Math.max(reach, i + A[i]);
        if (reach &gt;= len - 1)   
            return true;
    }
    return false;
}
</code></pre>

<p><strong>Jump Game II</strong></p>

<pre><code>public int jump(int[] A) {
    if (A == null || A.length &lt;= 1) 
        return 0;
    int[] dp = new int[A.length];
    int cur = 1;
    for (int i = 0; i &lt; A.length - 1; i++) {
        while (cur &lt;= i + A[i] &amp;&amp; cur &lt; dp.length) {
            dp[cur] = dp[i] + 1;
            cur++;
        }
        if (cur == dp.length) {
            break;
        }
    }
    return dp[A.length - 1];
}
</code></pre>

<p><strong>Palindrome Partitioning II</strong></p>

<pre><code>public int minCut(String s) {
    if (s == null || s.length() &lt;= 1) {
        return 0;
    }
    boolean[][] map = palindromeMap(s);
    int len = s.length();
    int[] dp = new int[len + 1];
    dp[0] = -1;
    for (int i = 1; i &lt;= len; i++) {
        dp[i] = Integer.MAX_VALUE;
        for (int j = 1; j &lt;= i; j++) {
            if (map[i-1][j-1]) {
                dp[i] = Math.min(dp[i], dp[j-1] + 1);
            }
        }
    }
    return dp[len];
}

private boolean[][] palindromeMap(String s) {
    int len = s.length();
    boolean[][] map = new boolean[len][len];
    char[] ss = s.toCharArray();
    for (int i = 0; i &lt; len; i++) {
        for (int j = i; j &gt;= 0; j--) {
            if (i == j) {
                map[i][j] = true;
            } else if (i - j == 1) {
                map[i][j] = ss[i] == ss[j];
            } else {
                map[i][j] = (ss[i] == ss[j]) &amp; map[i - 1][j + 1];
            }
        }
    }
    return map;
}
</code></pre>

<p><strong>Word Break</strong></p>

<pre><code>public boolean wordBreak(String s, Set&lt;String&gt; dict) {
    if (s == null || s.length() == 0) {
        return true;
    }
    int len = s.length();
    boolean[] dp = new boolean[len + 1];
    dp[0] = true;
    for (int i = 1; i &lt;= len; i++) {
        for (int j = 0; j &lt; i; j++) {
            if (!dp[j]) {
                continue;
            }
            if (dict.contains(s.substring(j, i))) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[len];
}
</code></pre>

<p><strong>Word Break II</strong></p>

<p>My code is definitely correct, although it got TLE.</p>

<p>See original post for more.</p>

<p><strong>Decode Ways</strong></p>

<pre><code>public int numDecodings(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    int len = s.length();
    int[] dp = new int[len + 1];
    dp[0] = 1;
    dp[1] = 1; // pay attention to the initial state
    if (!isValidNumber(s.substring(0, 1))) {
        return 0;
    }
    for (int i = 2; i &lt;= len; i++) {
        if (isValidNumber(s.substring(i - 1, i))) {
            dp[i] += dp[i - 1];
        }
        if (isValidNumber(s.substring(i - 2, i))) {
            dp[i] += dp[i - 2];
        }
    }
    return dp[len];
}

private boolean isValidNumber(String input) {
    if (input.length() == 0 || input.length() &gt; 2 || input.charAt(0) == '0') {
        return false;
    }
    int num = Integer.parseInt(input);
    return (1 &lt;= num &amp;&amp; num &lt;= 26);
}
</code></pre>

<p><strong>Longest Increasing Subsequence</strong></p>

<p>There&rsquo;s a new post in &lsquo;Lintcode&rsquo; category.</p>

<h4>Type 2.2: Two Sequences Dp</h4>

<p><strong>Distinct Subsequences</strong></p>

<pre><code>public int numDistinct(String S, String T) {
    int m = S.length(), n = T.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 0; i &lt;= m; i++) {
        for (int j = 0; j &lt;= n; j++) {
            if (j == 0) {
                dp[i][j] = 1;
            } else if (i == 0) {
                dp[i][j] = 0;
            } else {
                dp[i][j] = dp[i - 1][j];
                if (S.charAt(i - 1) == T.charAt(j - 1)) {
                    dp[i][j] += dp[i - 1][j - 1];
                }
            }
        }
    }
    return dp[m][n];
}
</code></pre>

<p><strong>Edit Distance</strong></p>

<pre><code>public int minDistance(String A, String B) {
    if (A == null || B == null)
        return 0;
    int m = A.length(), n = B.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 0; i &lt;= m; i++) {
        for (int j = 0; j &lt;= n; j++) {
            if (i == 0) {
                dp[i][j] = j;
            } else if (j == 0) {
                dp[i][j] = i;
            } else {
                if (A.charAt(i - 1) == B.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j]);
                    dp[i][j] = Math.min(dp[i][j], dp[i][j - 1]);
                    dp[i][j]++;
                }
            }
        }
    }
    return dp[m][n];
}
</code></pre>

<p><strong>Interleaving String</strong></p>

<pre><code>public boolean isInterleave(String s1, String s2, String s3) {
    if (s1 == null || s2 == null) {
        return false;
    }
    int m = s1.length(), n = s2.length();
    if (m + n != s3.length()) {
        return false;
    }
    boolean[][] dp = new boolean[m + 1][n + 1];
    for (int i = 0; i &lt;= m; i++) {
        for (int j = 0; j &lt;= n; j++) {
            if (i == 0) {
                dp[i][j] = s2.substring(0, j).equals(s3.substring(0, j));
                continue;
            } else if (j == 0) {
                dp[i][j] = s1.substring(0, i).equals(s3.substring(0, i));
                continue;
            }
            if (i &gt; 0 &amp;&amp; dp[i - 1][j]
                    &amp;&amp; s1.charAt(i - 1) == s3.charAt(i + j - 1)) {
                dp[i][j] = true;
            }
            if (j &gt; 0 &amp;&amp; dp[i][j - 1]
                    &amp;&amp; s2.charAt(j - 1) == s3.charAt(i + j - 1)) {
                dp[i][j] = true;
            }
        }
    }
    return dp[m][n];
}
</code></pre>

<p><strong>Longest Common Subsequence</strong></p>

<p>There&rsquo;s a new post in &lsquo;Lintcode&rsquo; category.</p>

<h3>Type 3: Interval Dp</h3>

<p><strong>Merge Stone</strong></p>

<blockquote><p>有n堆石子排成一列，每堆石子有一个重量w[i], 每次合并可以合并相邻的两堆石子，一次合并的代价为两堆石子的重量和w[i]+w[i+1]。问安排怎样的合并顺序，能够使得总合并代价达到最小。</p></blockquote>

<p><a href="http://wikioi.com/problem/1048/">link</a></p>

<p>Solution explained:</p>

<blockquote><p>sum[i[用于记录从第1堆到第i堆（包含i）石子的总重量。</p>

<p>dp[i][j]表示从第i堆（包含i）到第j堆（包含j）石子的合并的最小代价。</p>

<p>状态转移方程为：dp[i][j] = minimize{dp[i][k] + dp[k+1][j] + sum[j] &ndash; sum[i-1]}, k从i到j（不包含j）。</p>

<p>len=2表示第一次合并的情况，此时合并的石子为2堆。此时，i从1到n-len+1，j=i+len-1。</p></blockquote>

<p>Quoted from <a href="http://blog.csdn.net/kingzone_2008/article/details/12361327">this blog</a> and the solution is well explained on <a href="http://wikioi.com/solution/list/1048/">wikiio</a>.</p>

<h3>Type 4: Tree Dp</h3>

<p><strong>Binary Tree Maximum Path Sum</strong></p>

<p>This is a difficult question, but I solved it. I feel happy.</p>

<pre><code>private class ResultType {
    int maxPath;
    int depth;

    ResultType(int a, int b) {
        this.maxPath = a;
        this.depth = b;
    }
}

public int maxPathSum(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return helper(root).maxPath;
}

private ResultType helper(TreeNode node) {
    if (node == null) {
        return new ResultType(Integer.MIN_VALUE, 0);
    }
    ResultType ll = helper(node.left);
    ResultType rr = helper(node.right);
    int maxPath = node.val + ll.depth + rr.depth;
    maxPath = Math.max(maxPath, ll.maxPath);
    maxPath = Math.max(maxPath, rr.maxPath);
    int depth = 0;
    depth = Math.max(depth, node.val + Math.max(ll.depth, rr.depth));
    return new ResultType(maxPath, depth);
}
</code></pre>

<h3>Additional questions</h3>

<p><strong>Maximum Subarray</strong></p>

<pre><code>public int maxSubArray(int[] A) {
    if (A == null || A.length == 0) {
        return 0;
    }
    int len = A.length;
    int[] dp = new int[len];
    dp[0] = A[0];
    for (int i = 1; i &lt; len; i++) {
        dp[i] = A[i];
        if (dp[i - 1] &gt; 0)
            dp[i] += dp[i - 1];
    }
    int max = Integer.MIN_VALUE;
    for (Integer i : dp)
        max = Math.max(max, i);
    return max;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/24/Longest-Increasing-Subsequence/">[LintCode] Longest Increasing Subsequence</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-24T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://lintcode.com/en/problem/longest-increasing-subsequence/">link</a></p>

<div style="min-height:100px">
    <p>Given a sequence of integers, find the longest increasing subsequence (LIS).</p>
    <p>You code should return the length of the LIS.</p>
    <div class="m-t-lg m-b-lg">
    <b>Example</b>
    <div>
        <p>For [5, 4, 1, 2, 3], the LIS &nbsp;is [1, 2, 3], return 3</p>
        <p>For [4, 2, 4, 5, 3, 7], the LIS is [4, 4, 5, 7], return 4</p>
    </div>
    </div>
</div>


<h3>Analysis</h3>

<p>This is one of the <strong>2 most popular questions of DP</strong>. This is a sequences Dp. The equation isn&rsquo;t difficult. Time complexity of DP solution is O(n<sup>2</sup>).</p>

<p><strong>There&rsquo;s also a binary search solution</strong> which the time complexity is O(nlgn). It&rsquo;s very complex, and very hard to explain, but I&rsquo;ll try:</p>

<p>Maintain an array called &lsquo;array&rsquo;. A[i] denotes the tail of sequence for LIS = i. Initially A[0] = first element of the input, then keep inserting elements into this array. It&rsquo;s explained in <a href="http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/">this post</a>.</p>

<p>I will give an example for the input: 0, 8, 4, 12, 2</p>

<blockquote><p>Our strategy determined by the following conditions:</p>

<ol>
<li><p>If A[i] is smallest among all end candidates of active lists, we will start new active list of length 1.</p></li>
<li><p>If A[i] is largest among all end candidates of active lists, we will clone the largest active list, and extend it by A[i].</p></li>
<li><p>If A[i] is in between, we will find a list with largest end element that is smaller than A[i]. Clone and extend this list by A[i]. We will discard all other lists of same length as that of this modified list.</p></li>
</ol>


<p>A[0] = 0. Case 1. There are no active lists, create one.</p>

<p>array = 0</p>

<p>A[1] = 8. Case 2. Clone and extend.</p>

<p>array = 0, 8</p>

<p>A[2] = 4. Case 3. Clone, extend and discard.</p>

<p>array = 0, 4</p>

<p>A[3] = 12. Case 2. Clone and extend.</p>

<p>array = 0, 4, 12</p>

<p>A[4] = 2. Case 3. Clone, extend and discard.</p>

<p>array = 0, 2, 12</p>

<p>So the LIS is (0, 2, 12) of length 3.</p></blockquote>

<h3>Code</h3>

<p><strong>DP solution, by me</strong></p>

<pre><code>public int longestIncreasingSubsequence(int[] nums) {
    // write your code here
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int len = nums.length;
    int[] dp = new int[len];
    dp[0] = 1;
    for (int i = 1; i &lt; len; i++) {
        dp[i] = 1;
        for (int j = 0; j &lt; i; j++) {
            if (nums[j] &lt;= nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    int lis = 1;
    for (Integer seq : dp) {
        lis = Math.max(lis, seq);
    }
    return lis;
}
</code></pre>

<p><strong>Binary search solution</strong>, C++ code from <a href="http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/">this post</a>. I don&rsquo;t think I am able code this solution.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

using namespace std;

#define ARRAY_SIZE(A) sizeof(A)/sizeof(A[0])
// Binary search (note boundaries in the caller)
// A[] is ceilIndex in the caller
int CeilIndex(int A[], int l, int r, int key) {
    int m;

    while( r - l &gt; 1 ) {
        m = l + (r - l)/2;
        (A[m] &gt;= key ? r : l) = m; // ternary expression returns an l-value
    }

    return r;
}

int LongestIncreasingSubsequenceLength(int A[], int size) {
    // Add boundary case, when array size is one

    int *tailTable   = new int[size];
    int len; // always points empty slot

    memset(tailTable, 0, sizeof(tailTable[0])*size);

    tailTable[0] = A[0];
    len = 1;
    for( int i = 1; i &lt; size; i++ ) {
        if( A[i] &lt; tailTable[0] )
            // new smallest value
            tailTable[0] = A[i];
        else if( A[i] &gt; tailTable[len-1] )
            // A[i] wants to extend largest subsequence
            tailTable[len++] = A[i];
        else
            // A[i] wants to be current end candidate of an existing subsequence
            // It will replace ceil value in tailTable
            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i];
    }

    delete[] tailTable;

    return len;
}

int main() {
    int A[] = { 2, 5, 3, 7, 11, 8, 10, 13, 6 };
    int n = ARRAY_SIZE(A);

    printf("Length of Longest Increasing Subsequence is %d\n",
            LongestIncreasingSubsequenceLength(A, n));

    return 0;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/24/Longest-Common-Subsequence/">[LintCode] Longest Common Subsequence</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-24T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://lintcode.com/en/problem/longest-common-subsequence/">link</a></p>

<div style="min-height:100px">
    <p>Given two strings, find the longest comment subsequence (LCS).</p>
    <p>Your code should return the length of LCS.</p>
    <div class="m-t-lg m-b-lg">
    <b>Example</b>
    <div>
        <p>For &#8220;ABCD&#8221; and &#8220;EDCA&#8221;, the LCS is &#8220;A&#8221; (or D or C), return 1</p>
        <p>For &#8220;ABCD&#8221; and &#8220;EACB&#8221;, the LCS is &#8220;AC&#8221;, return 2</p>
    </div>
    </div>
</div>


<h3>Analysis</h3>

<p>This is one of the <strong>2 most popular questions of DP</strong>.</p>

<p>This is a two-sequences Dp. The equation is not difficult to build. (consider only the last element of the DP array when building the state transition equation)</p>

<h3>Code</h3>

<pre><code>public int longestCommonSubsequence(String A, String B) {
    // write your code here
    if (A == null || B == null) {
        return 0;
    }
    int m = A.length(), n = B.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 1; i &lt;= m; i++) {
        for (int j = 1; j &lt;= n; j++) {
            if (A.charAt(i - 1) == B.charAt(j - 1)) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/23/Cache-algorithms/">[Design] Cache Algorithms</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-23T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Cache Algorithms</h3>

<h4>Equation</h4>

<p>of memory reference time is:</p>

<p>T = m * T(m) + T(h) + E</p>

<blockquote><p>m: miss ratio = 1 &ndash; hit ratio</p>

<p>T(m): time for main memory access</p>

<p>T(h): latency (when there&rsquo;s a hit)</p>

<p>E: secondary effects liek queuing effects etc.</p></blockquote>

<h4>hit ratio</h4>

<p>how often a searched-for item is actually found in the cache</p>

<h4>latency</h4>

<p>how long after requesting a desired item the cache can return that item (when there is a hit).</p>

<h3>Replacement policy</h3>

<h4>Bélády&rsquo;s Algorithm (Optimal Algorithm)</h4>

<p>The optimal algorithm, not implementable in practise.</p>

<h4>LFU</h4>

<p>Least Frequently Used, slow and not very adaptive.</p>

<h4>LRU</h4>

<p>Fast and adaptive, but hard to implement.</p>

<p>It can be implemented with either a counter or a stack/doubleLinkedList.</p>

<p>Web browser use this.</p>

<h4>LRU2 and 2Qs</h4>

<p><strong>LRU2</strong> &ndash; Only add entries to the cache the second time they are accessed.</p>

<p><strong>Two Queues</strong> &ndash; Add entries to an normal LRU cache. If accessed again, move it to second, larger, LRU cache.</p>

<h4>MRU (most recent used)</h4>

<p>Some claim that MRU cache algorithms have more hits than LRU due to their tendency to retain older data.</p>

<h4>FIFO</h4>

<p>Low-overhead, fast but not adaptive.</p>

<h4>Second-chance</h4>

<p>Modified version of FIFO. Relatively better than FIFO at little cost.</p>

<p>Initially, a reference bit is set. Instead of removing old entries, it clears reference bit first, and insert that entry at the back of the queue. An entry is only cleared if the reference bit is not set. This is like a circular queue.</p>

<p>If all the pages have been referenced, second chance degenerates into pure FIFO. Why? Let&rsquo;s say all entries reference are set, the pointer will go around the entire list and clear all references, and in the end come back to the starting point. Then, it&rsquo;s like a FIFO. For more, see the <a href="http://javalandscape.blogspot.sg/2009/01/cachingcaching-algorithms-and-caching.html">link</a>.</p>

<h4>Clock</h4>

<p>Modified version of second-hand. Better than second hand. Instead of pushing to the back, it keep a &ldquo;hand&rdquo; pointer in the circular list. <a href="http://javalandscape.blogspot.sg/2009/01/cachingcaching-algorithms-and-caching.html">link</a></p>

<p>When cache miss occurs and no empty place exists, then I consult the R (referenced) bit at the hand&rsquo;s location to know what I should do. If R is 0, then I will place the new entry at the &ldquo;hand&rdquo; position, otherwise I will clear the R bit. Then, I will increment the hand (iterator) and repeat the process until an entry is replaced.</p>

<h4>Simple time-based</h4>

<p>Fast, but not adaptive. Entries remain in cache for a specific amount of time.</p>

<h4>Extended time-based expiration</h4>

<p>Only clear cache at certain points in time (say every 5 minutes).</p>

<h3>Conclusion</h3>

<p>Each replacement strategy is a <strong>compromise between hit rate and latency</strong>.</p>

<h4>One more thing</h4>

<p>What is Distributed cache?</p>

<p><a href="http://en.wikipedia.org/wiki/Distributed_cache">Distributed cache</a> is an extension of the traditional concept of cache used in a single locale.</p>

<p>A distributed cache may <strong>span multiple servers</strong> so that it can grow in size and in transactional capacity. It is mainly used to store <strong>application data residing in database and web session data</strong>.</p>

<p>The idea of distributed caching has become feasible now because main memory has become very cheap and network cards have become very fast, with 1 Gbit now standard everywhere and 10 Gbit gaining traction.</p>

<p>Also, a distributed cache works well on <strong>lower cost machines usually employed for web servers</strong> as opposed to <strong>database servers</strong> which require expensive hardware.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/18/Two-egg-100-floor-question/">[Brain Teaser] 2 Eggs 100 Floors Puzzle</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-18T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.programmerinterview.com/index.php/puzzles/2-eggs-100-floors-puzzle/">link</a></p>

<blockquote><p>You are given 2 eggs.</p>

<p>You have access to a 100-storey building.</p>

<p>Eggs can be very hard or very fragile means it may break if dropped from the first floor or may not even break if dropped from 100 th floor.Both eggs are identical.</p>

<p>You need to figure out the highest floor of a 100-storey building an egg can be dropped without breaking.</p>

<p>Now the question is how many drops you need to make. You are allowed to break 2 eggs in the process</p></blockquote>

<h3>Analysis</h3>

<p>Most obvious solutoin is drop in 10th, 20th, 30th &hellip; floor. But this solution would result in <strong>19 drops in worst case</strong>. We should try to reduce the worst case scenario by making all possible scenarios take the same number of drops!</p>

<p>The best solution is:</p>

<blockquote><p>What if we tried to reduce the number of drops that would be required with the linear search (with the 2nd egg) after we get to one of the higher floors? This way we <strong>counteract the fact that getting to the higher floor took so many drops</strong>, and if we use less drops for the linear search we are <strong>balancing out the worst case</strong>.</p></blockquote>

<p>According to the <a href="http://www.programmerinterview.com/index.php/puzzles/2-eggs-100-floors-puzzle/">solution</a>, we form a series:</p>

<blockquote><p>x + (x-1) + (x-2) + (x-3) + &hellip; + 1 = 100</p>

<p>x(x+1)/2 = 100</p>

<p>x = 14</p></blockquote>

<h3>Final Result</h3>

<p>We would drop in this way:</p>

<table width="50">
<thead><tr><th>&nbsp;Drop&nbsp;</th><th>&nbsp;Floor&nbsp;</th></tr></thead>
<tbody><tr align="center"><td>#1</td><td>14</td></tr>
<tr align="center"><td>#2</td><td>27</td></tr>
<tr align="center"><td>#3</td><td>39</td></tr>
<tr align="center"><td>#4</td><td>50</td></tr>
<tr align="center"><td>#5</td><td>60</td></tr>
<tr align="center"><td>#6</td><td>69</td></tr>
<tr align="center"><td>#7</td><td>77</td></tr>
<tr align="center"><td>#8</td><td>84</td></tr>
<tr align="center"><td>#9</td><td>90</td></tr>
<tr align="center"><td>#10</td><td>95</td></tr>
<tr align="center"><td>#11</td><td>99</td></tr>
<tr align="center"><td>#12</td><td>100</td></tr>
</tbody>
</table>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/18/Number-sum-sequence/">[Question] Number Sum Sequence</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-18T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://bbs.csdn.net/topics/390332954">link</a></p>

<blockquote><p>定义一个数字有以下的特征, 它可以被分成几个部分,而前面的部分相加起来的和是后面的部分.举例来说</p>

<p>1235813,       1+2=3; 2+3=5;3+5=8; 5+8=13;</p>

<p>112112224,     112+112=224;</p>

<p>1981100,       19+81=100;</p>

<p>122436,        12+24=36;</p>

<p>1299111210,    12+99=111,99+111=210;</p>

<p>要求写出一个函数,输入一个数字,判断这个数字是不是要求的这个数。</p></blockquote>

<h3>Analysis</h3>

<p><strong>This is a difficult DFS search question</strong>. Basic idea from <a href="http://bbs.csdn.net/topics/390332954">this blog</a>:</p>

<blockquote><p>取前i位为a1,第i+1到j位为a2,检测n是否由a1和a2生成的序列组成。</p>

<p>时间复杂度为O(n<sup>3</sup>)（或O(n<sup>2</sup>)).</p></blockquote>

<h3>Code</h3>

<p>The code is surprisingly very short.</p>

<p>I have yet to prove whether this code works.</p>

<pre><code>def isLegal(n, i, j):
    """取前i位为a1,第i+1到j位为a2,检测n是否由a1和a2生成的序列组成。"""
    nextDigit = j
    a1 = int(n[:i])
    a2 = int(n[i:j])
    while nextDigit&lt;len(n): # n还有数字可用
        a2, a1 = a1+a2, a2
        s2 = str(a2)
        if n.startswith(s2, nextDigit): #从n的第nextDigit位开始，与s2比较
            nextDigit += len(s2)
        else:
            return False
    return True

def test(n):
    for i in range(1, len(n)-1):
        for j in range(i+1, len(n)-1):
            if isLegal(n, i, j):
                return True
    return False
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/18/NineChap-Linked-List-additional/">[NineChap 4.2] Linked List Additional</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-18T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Question list</h2>

<ol>
<li><p><strong><a href="/blog/2014/06/17/Union-and-intersection-of-linked-list/">Union and Intersection of two Linked Lists</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/30/Insertion-Sort-List/">Insertion Sort List</a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="/blog/2014/05/28/Flatten-Binary-Tree-to-Linked-List/">Flatten Binary Tree to Linked List</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/26/Convert-Sorted-List-to-Binary-Search-Tree/">Convert Sorted List to Binary Search Tree</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/19/Rotate-List/">Rotate List</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/02/Remove-Nth-Node-From-End-of-List/">Remove Nth Node From End of List</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/03/LRU-Cache/">LRU Cache </a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/11/Reverse-Nodes-in-k-Group/">Reverse Nodes in k-Groups</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/09/Swap-Nodes-in-Pairs/">Swap Nodes in Pairs</a></strong></p></li>
</ol>


<h2>Code</h2>

<p><strong>Union and Intersection of two Linked Lists</strong></p>

<p>Think about the idea only.</p>

<p><strong>Insertion Sort List</strong></p>

<pre><code>public ListNode insertionSortList(ListNode head) {
    if (head == null) {
        return null;
    }
    ListNode dummy = new ListNode(0);
    ListNode cur = head;
    while (cur != null) {
        // insert cur into correct pos
        ListNode pos = dummy;
        while (pos.next != null &amp;&amp; pos.next.val &lt; cur.val) {
            pos = pos.next;
        }
        ListNode temp = cur.next;
        cur.next = pos.next;
        pos.next = cur;
        cur = temp;
    }
    return dummy.next;
}
</code></pre>

<p><strong>Flatten Binary Tree to Linked List</strong></p>

<p>I forgot to set &ldquo;root.left = null&rdquo; again, which result in long-time debugging. This is a very common and very silly mistake that I really should avoid.</p>

<pre><code>public void flatten(TreeNode root) {
    root = helper(root);
}

private TreeNode helper(TreeNode node) {
    if (node == null) {
        return null;
    } else if (node.left == null &amp;&amp; node.right == null) {
        return node;
    } else if (node.left == null) {
        return helper(node.right);
    } else if (node.right == null) {
        node.right = node.left;
        node.left = null;
        return helper(node.right);
    } else {
        TreeNode tempRight = node.right;
        node.right = node.left;
        node.left = null;
        TreeNode leftTail = helper(node.right);
        leftTail.right = tempRight;
        return helper(tempRight);
    }
}
</code></pre>

<p><strong>Convert Sorted List to Binary Search Tree</strong></p>

<p>This is the Mock Interview question. My solution is:</p>

<pre><code>public TreeNode sortedListToBST(ListNode listHead) {
    if (listHead == null) {
        return null;
    }
    if (listHead.next == null) {
        return new TreeNode(listHead.val);
    }
    ListNode listFirstHalf = listHead;
    ListNode listPreMid = findMiddle(listHead);
    ListNode listSecondHalf = null;
    if (listPreMid.next != null) {
        listSecondHalf = listPreMid.next.next;
    }
    TreeNode head = new TreeNode(listPreMid.next.val);
    listPreMid.next = null;
    head.left = sortedListToBST(listFirstHalf);
    head.right = sortedListToBST(listSecondHalf);
    return head;
}

private ListNode findMiddle(ListNode listHead) {
    if (listHead == null) {
        return null;
    }
    ListNode slow = listHead;
    ListNode fast = listHead.next;
    while (fast != null &amp;&amp; fast.next != null&amp;&amp; fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}
</code></pre>

<p>This is not a good answer, cuz I have to findMid in each recursion.</p>

<p>The best solution is, use a global variable and 2 numbers to simplify this process. Code:</p>

<pre><code>ListNode cur = null;

public TreeNode sortedListToBST(ListNode head) {
    if (head == null) {
        return null;
    }
    cur = head;
    int k = 0;
    ListNode p = head;
    while (p != null) {
        k++;
        p = p.next;
    }
    return build(0, k - 1);
}

private TreeNode build(int start, int end) {
    if (start &gt; end) {
        return null;
    }
    int mid = start + (end - start) / 2;
    TreeNode leftBranch = build(start, mid - 1);
    TreeNode head = new TreeNode(cur.val);
    cur = cur.next;
    head.left = leftBranch;
    head.right = build(mid + 1, end);
    return head;
}
</code></pre>

<p><strong>Rotate List</strong></p>

<p>Naive solution:</p>

<pre><code>public ListNode rotateRight(ListNode head, int n) {
    if (head == null) {
        return null;
    }
    ListNode p = head;
    for (int i = 0; i &lt; n; i++) {
        if (p.next == null) {
            p = head;
        } else {
            p = p.next;
        }
    }
    ListNode q = head;
    while (p.next != null) {
        p = p.next;
        q = q.next;
    }
    p.next = head;
    ListNode newHead = q.next;
    q.next = null;
    return newHead;
}
</code></pre>

<p>Make a circular list:</p>

<pre><code>public ListNode rotateRight(ListNode head, int n) {
    if (head == null) {
        return null;
    }
    ListNode p = head;
    int k = 1;
    while (p.next != null) {
        k++;
        p = p.next;
    }
    p.next = head;
    int steps = k - (n % k);
    for (int i = 0; i &lt; steps; i++) {
        p = p.next;
    }
    head = p.next;
    p.next = null;
    return head;
}
</code></pre>

<p><strong>Remove Nth Node From End of List</strong></p>

<pre><code>public ListNode removeNthFromEnd(ListNode head, int n) {
    if (head == null || n == 0) {
        return null;
    }
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode right = dummy;
    for (int i = 0; i &lt; n; i++) {
        right = right.next;
    }
    ListNode left = dummy;
    while (right.next != null) {
        left = left.next;
        right = right.next;
    }
    left.next = left.next.next;
    return dummy.next;
}
</code></pre>

<p><strong>LRU Cache</strong></p>

<p>I solved it in the original post.</p>

<p><strong>Reverse Nodes in k-Groups</strong></p>

<pre><code>public ListNode reverseKGroup(ListNode head, int k) {
    ListNode p = head;
    int count = 0;
    while (p != null) {
        p = p.next;
        count++;
    }
    return helper(head, k, count);
}

public ListNode helper(ListNode head, int k, int count) {
    if (head == null || k &lt; 1 || count &lt; k) {
        return head;
    }
    ListNode result = null;
    ListNode cur = head;
    for (int i = 0; i &lt; k; i++) {
        if (cur == null) break;
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
    }
    head.next = helper(cur, k, count - k);
    return result;
}
</code></pre>

<p><strong>Swap Nodes in Pairs</strong></p>

<pre><code>public ListNode swapPairs(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode result = head.next;
    ListNode temp = head.next.next;
    result.next = head;
    head.next = swapPairs(temp);
    return result;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/17/Union-and-intersection-of-linked-list/">[Question] Union and Intersection of Two Linked Lists</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-17T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/union-and-intersection-of-two-linked-lists/">link</a></p>

<blockquote><p>Given two Linked Lists, create union and intersection lists that contain union and intersection of the elements present in the given lists. Order of elments in output lists doesn’t matter.</p>

<p>Example:</p>

<p>Input: &ldquo;10->15->4->20&rdquo; and &ldquo;8->4->2->10&rdquo;</p>

<p>Intersection: 4->10</p>

<p>Union: 2->8->20->4->15->10</p></blockquote>

<h3>Analysis</h3>

<p>There are 2 solutions.</p>

<p>First solution is to do mergesort, then do a linear search. Time complexity is O(mlgm + nlgn).</p>

<p>Second solution is using hashing. On time <a href="http://www.geeksforgeeks.org/union-and-intersection-of-two-linked-lists/">complexity</a>:</p>

<blockquote><p>Time complexity of this method depends on the hashing technique used and the distribution of elements in input lists. In practical, this approach may turn out to be better than above method.</p></blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/17/Time-complexity-calculation/">[Design] Time Complexity Calculation (Master Theorem)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-17T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Master theorem</h3>

<p>In the analysis of algorithms, the <a href="http://en.wikipedia.org/wiki/Master_theorem">master theorem</a> provides a cookbook solution in asymptotic terms (using Big O notation) for recurrence relations that occur in many divide and conquer algorithms. It was introduced and popularized by <strong>Introduction to Algorithms</strong>.</p>

<h3>Examples with common algorithms</h3>



<table class="tg">
  <tr>
    <th class="tg-031e">Algorithm</th>
    <th class="tg-031e">Recurrence</th>
    <th class="tg-031e">Big-Oh Solution</th>
  </tr>
  <tr>
    <td class="tg-031e">Binary Search</td>
    <td class="tg-031e">T(n) = T(n/2) + O(1)</td>
    <td class="tg-031e">O(log n)</td>
  </tr>
  <tr>
    <td class="tg-031e">tree traversal</td>
    <td class="tg-031e">T(n) = 2 T(n/2) + O(1)</td>
    <td class="tg-031e">O(n)</td>
  </tr>
  <tr>
    <td class="tg-031e">Mergesort</td>
    <td class="tg-031e">T(n) = 2 T(n/2) + O(n)</td>
    <td class="tg-031e">O(n log n)</td>
  </tr>
</table>


<p><a href="http://www.cs.duke.edu/~ola/ap/recurrence.html">source</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/17/Reverse-linkedlist-recursively/">[LeetCode Plus] Reverse Linked List Iteratively and Recursively</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-17T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://leetcode.com/2010/04/reversing-linked-list-iteratively-and.html">link</a></p>

<blockquote><p>Implement the reversal of a singly linked list iteratively and recursively.</p></blockquote>

<h3>Iteratively</h3>

<p>First, the iterative solution is very common, and is listed as <strong>one of the &ldquo;5 fundamental operations of linked list&rdquo;</strong> in the NineChap4 post. I will quote below.</p>

<blockquote><p>First variant: Reverse from a particular node to the end</p></blockquote>

<pre><code>public ListNode reverse(ListNode start) {
    ListNode result = null;
    ListNode cur = start;
    while (cur != null) {
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
    }
    return result;
}
</code></pre>

<blockquote><p>Second variant: Reverse from a node until another node</p></blockquote>

<pre><code>public ListNode reverseRange(ListNode start, int len) {
    ListNode result = null;
    ListNode cur = start;
    while (len &gt; 0) {
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
        len--;
    }
    start.next = cur;
    return result;
}
</code></pre>

<h3>Recursively</h3>

<p>A good code from <a href="http://stackoverflow.com/a/354937">here</a>.</p>

<pre><code>public ListNode Reverse(ListNode list) {
    if (list == null) return null; 
    if (list.next == null) return list; 
    ListNode secondElem = list.next;
    list.next = null;
    ListNode reverseRest = Reverse(secondElem);
    secondElem.next = list;
    return reverseRest;
}
</code></pre>

<p>Alternatively, the code can be written in a &lsquo;show-off&rsquo; practice.</p>

<pre><code>public ListNode Reverse(ListNode list) {
    if (list == null) return null;
    if (list.next == null) return list;
    ListNode reverseRest = Reverse(list.next);
    list.next.next = list;
    list.next = null;
    return reverseRest;
}
</code></pre>

<p>Test cases urgently needed.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/16">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/14">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150/'>cc150 (3)</a></li>
<li class='category'><a href='/blog/categories/collection/'>collection (5)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (37)</a></li>
<li class='category'><a href='/blog/categories/facebook/'>facebook (2)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (20)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (154)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (76)</a></li>
<li class='category'><a href='/blog/categories/thoughts/'>thoughts (4)</a></li>
<li class='category'><a href='/blog/categories/twitter/'>twitter (1)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/08/17/Numbers-Concatenation-Max/">[Question] Numbers Concatenation to Get Max Value</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/17/Number-of-tree-given-preorder-postorder/">[Question] Number of Valid Trees Given Preorder and Postorder</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/17/Expression-evaluation/">[Twitter] Arithmetic Expression Evaluation</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/16/orthogonal-traverse-map/">[Google] Orthogonal Traverse the Map (`)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/16/Excel-decimal-conversion/">[Question] Excel Decimal Conversion</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
