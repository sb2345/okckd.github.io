
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="Question link Given n, generate all structurally unique BST&#8217;s (binary search trees) that store values 1&#8230;n. For example,
Given n = 3, your &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/18">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/26/Unique-Binary-Search-Trees-II/">[LeetCode 95] Unique Binary Search Trees II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-26T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/unique-binary-search-trees-ii/">link</a></p>

<div class="question-content">
            <p></p><p>Given <i>n</i>, generate all structurally unique <b>BST&#8217;s</b> (binary search trees) that store values 1&#8230;<i>n</i>.</p>

<p>
For example,<br>
Given <i>n</i> = 3, your program should return all 5 unique BST&#8217;s shown below.

</p><pre>   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</pre>
<p></p>
<p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a question with standard solution</strong>.</p>

<p>It looks like difficult, but actually the code is very short.</p>

<h3>Solution</h3>

<p>This is my previous solution. Everyone in blogs are having same solution. I mean, every single one of  them, <a href="http://gongxuns.blogspot.sg/2013/01/leetcodeunique-binary-search-trees-ii.html">one example</a>.</p>

<h3>Code</h3>

<pre><code>public ArrayList&lt;TreeNode&gt; generateTrees(int n) {
    return construct(0, n);
}

ArrayList&lt;TreeNode&gt; construct(int base, int n) {
    ArrayList&lt;TreeNode&gt; ans = new ArrayList&lt;TreeNode&gt;();
    if (n == 0) ans.add(null);
    for (int cur = 1; cur &lt;= n; cur++) 
        for (TreeNode l : construct(base, cur - 1)) 
            for (TreeNode r : construct(base + cur, n - cur)) {
                TreeNode root = new TreeNode(base + cur);
                root.left = l;
                root.right = r;
                ans.add(root);
            }
    return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/26/Unique-Binary-Search-Trees/">[LeetCode 96] Unique Binary Search Trees</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-26T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/unique-binary-search-trees/">link</a></p>

<div class="question-content">
            <p></p><p>Given <i>n</i>, how many structurally unique <b>BST&#8217;s</b> (binary search trees) that store values 1&#8230;<i>n</i>?</p>

<p>
For example,<br>
Given <i>n</i> = 3, there are a total of 5 unique BST&#8217;s.

</p><pre>   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</pre>
<p></p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This seems like an easy recursion question</strong>, however it will result in many repeated recursion calls.</p>

<p>To avoid repeated recursion, use <strong>Dynamic Programming</strong>.</p>

<h3>Solution</h3>

<p>First code below is my solution. It is <strong>a standard recursion solution</strong>, but it&rsquo;s not good. The run time is 30ms more than next code.</p>

<p>Second code is <strong>DP solution</strong>, where the previous answers are saved and used forfuture calculation. This is the best solution for this question, and I learnt it from <a href="https://github.com/shengmin/coding-problem/blob/master/leetcode/unique-binary-search-trees/Solution.java">this blog</a>.</p>

<h3>Code</h3>

<p><strong>First code</strong></p>

<pre><code>public int numTrees(int n) {
    if (n &lt;= 1) return 1;

    int total = 0;
    if (n % 2 == 0){
        for (int i = 0; i &lt;= n / 2 - 1; i ++ ){
            // i is all the possible number of nodes on the left
            total += 2 * numTrees(i) * numTrees(n-i-1);
        }
    } else {
        for (int i = 0; i &lt;= (n-1) / 2 - 1; i ++ ){
            // i is all the possible number of nodes on the left
            total += 2 * numTrees(i) * numTrees(n-i-1);
        }
        total += Math.pow(numTrees((n-1)/2), 2);
    }
    return total;
}
</code></pre>

<p><strong>Second code</strong></p>

<pre><code>public int numTrees(int n) {
    int[] table = new int[n + 1];
    table[0] = 1;
    table[1] = 1;
    for (int i = 2; i &lt;= n; i++) {
        int sum = 0;
        for (int j = 1; j &lt;= i; j++) {
            int left = j - 1;
            int right = i - j;
            sum += table[left] * table[right];
        }
        table[i] = sum;
    }
    return table[n];
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/26/Symmetric-Tree/">[LeetCode 101] Symmetric Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-26T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/symmetric-tree/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>

<p>
For example, this binary tree is symmetric:
</p><pre>    1
   / \
  2   2
 / \ / \
3  4 4  3
</pre>
<p></p>
<p>
But the following is not:<br>
</p><pre>    1
   / \
  2   2
   \   \
   3    3
</pre>
<p></p>

<p>
<b>Note:</b><br>
Bonus points if you could solve it both recursively and iteratively.
</p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">2 ways to solve</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is an easy one</strong>.</p>

<h3>Solution</h3>

<p>I solved it using recursion.</p>

<p>The non-recursion solution is using 2 stacks (or queues). I did not write it, but the code is posted as well, copied from <a href="https://oj.leetcode.com/discuss/456/recusive-solution-symmetric-optimal-solution-inordertraversal">this post</a>.</p>

<h3>Code</h3>

<p><strong>First, recursion</strong></p>

<pre><code>public boolean isSymmetric(TreeNode root) {
    if (root == null) return true;
    return check(root.left, root.right);
}

private boolean check(TreeNode left, TreeNode right) {
    if (left == null &amp;&amp; right == null) return true;
    if (left == null || right == null) return false;
    if (left.val != right.val) return false;
    return check(left.left, right.right) &amp; check(left.right, right.left);
}
</code></pre>

<p><strong>Second, non-recursion</strong></p>

<pre><code>public boolean isSymmetric(TreeNode root) {
    if (root == null) return true;
    Stack&lt;TreeNode&gt; s1 = new Stack&lt;TreeNode&gt;();
    Stack&lt;TreeNode&gt; s2 = new Stack&lt;TreeNode&gt;();
    s1.push(root.left);
    s2.push(root.right);
    while (!s1.empty() &amp;&amp; !s2.empty()) {
        TreeNode n1 = s1.pop();
        TreeNode n2 = s2.pop();
        if (n1 == null &amp;&amp; n2 == null) continue;
        if (n1 == null || n2 == null) return false;
        if (n1.val != n2.val) return false;
        s1.push(n1.left);
        s2.push(n2.right);
        s1.push(n1.right);
        s2.push(n2.left);
    }
    return true;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/26/Convert-Sorted-List-to-Binary-Search-Tree/">[LeetCode 109] Convert Sorted List to Binary Search Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-26T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">link</a></p>

<div class="question-content">
            <p></p><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very interesting question, with a very tricky solution</strong>. Because <strong>LinkedList does not have radom access</strong>, it is impossible for us to solve it in like we did in last question.</p>

<p><strong>The traditional top-down approach</strong> is heavily relied on index operation, and we can&rsquo;t do that. That is why we solve this question with <strong>bottom-up approach</strong>. Which is to say, we insert TreeNodes following LinkedList&rsquo;s order.</p>

<p>I know it&rsquo;s hard to understand. I found a <a href="http://leetcode.com/2010/11/convert-binary-search-tree-bst-to.html">explanation</a>, but it&rsquo;s not clear also. The fastest way is to just read the code or write it by hand.</p>

<h3>Solution</h3>

<p><strong>The key of this solution is a public pointer which traverse thru the list</strong>. Each time the pointer procceed, a new TreeNode is added into the final answer. <strong>How to keep track of parent TreeNodes</strong>? That&rsquo;s the tricky part. we tree structure is generated before the insertion, altough the values have not been filled in yet.</p>

<p>It&rsquo;s like doing a DFS in-order traverse thru the tree, and fill in values one by one. In order to know how the tree would look like, prior knowledge of the size of the LinkedList is necessary.</p>

<p>That&rsquo;s the solution. I&rsquo;ve never seen a solution like this before, so it&rsquo;s very important to learn it and memorize it by heart.</p>

<h3>Code</h3>

<p><strong>standard solution</strong></p>

<pre><code>ListNode cur = null;

public TreeNode sortedListToBST(ListNode head) {
    cur = head;
    int k = 0;
    ListNode temp = head;
    while (temp != null) {
        temp = temp.next;
        k ++;
    }
    return helper(0, k - 1);
}

private TreeNode helper(int left, int right) {
    if (left &gt; right) return null;
    int mid = left + (right - left) / 2;
    TreeNode head = new TreeNode(-1);
    head.left  = helper(left, mid - 1);
    head.val = cur.val;
    cur = cur.next;
    head.right = helper(mid + 1, right);
    return head;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/26/Convert-Sorted-Array-to-Binary-Search-Tree/">[LeetCode 108] Convert Sorted Array to Binary Search Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-26T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">link</a></p>

<div class="question-content">
            <p></p><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>My first understanding of this question is wrong</strong>.</p>

<p>A BST does not necessarily have to fill in left side of the leaf as muc has possible. I was confusing &ldquo;balanced binary tree&rdquo; with &ldquo;left-balanced binary tree&rdquo;.</p>

<blockquote><p><strong>A balanced binary tree</strong> is commonly defined as a binary tree in which the depth of the left and right subtrees of every node differ by 1 or less</p>

<p><strong>A left-balanced binary tree</strong> is a balanced binary tree where the left sub-tree of each node is filled before the right sub-tree</p></blockquote>

<h3>Solution</h3>

<p>Then this question become straight-forward.</p>

<h3>Code</h3>

<pre><code>public TreeNode sortedArrayToBST(int[] num) {
    if (num.length == 0) return null;
    return helper(num, 0, num.length - 1);
}

public TreeNode helper(int[] num, int start, int end) {
    if (start &gt; end) return null;
    int mid = (start + end) / 2;
    TreeNode node = new TreeNode(num[mid]);
    node.left = helper(num, start, mid - 1);
    node.right = helper(num, mid + 1, end);
    return node;
} 
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/26/Balanced-Binary-Tree/">[LeetCode 110] Balanced Binary Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-26T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/balanced-binary-tree/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, determine if it is height-balanced.
</p>

<p>
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <i>every</i> node never differ by more than 1.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a difficult question for me</strong>.</p>

<p>My first code contains many dulicate calls. I have posted it below as an illustration of bad example.</p>

<h3>Solution</h3>

<p>The solution should make use of the return value from the recursion, and avoid duplication calls. The standard solution is posted below.</p>

<h3>Code</h3>

<p><strong>First, my initial solution</strong>. It takes 30ms more than next code.</p>

<pre><code>public boolean isBalanced(TreeNode root) {
    // my old code re-submit, for speed test
    if (root == null) return true;
    if (Math.abs(depth(root.left) - depth(root.right)) &gt; 1) {
        return false;
    }
    if (! isBalanced(root.left)) return false;
    if (! isBalanced(root.right)) return false;
    return true;
}

private int depth(TreeNode node) {
    if (node == null) return 0;
    if (node.left == null) return 1 + depth(node.right);
    if (node.right == null) return 1 + depth(node.left);
    return 1 + Math.max(depth(node.left), depth(node.right));
}
</code></pre>

<p><strong>Second, the standard solution</strong></p>

<pre><code>public boolean isBalanced(TreeNode root) {
    return helper(root) != -1;
}

private int helper(TreeNode node) {
    if (node == null) return 0;
    int a = helper(node.left);
    if (a == -1) return -1;
    int b = helper(node.right);
    if (b == -1) return -1;
    if (Math.abs(a - b) &lt;= 1) 
        return Math.max(a, b) + 1;
    else return -1;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Same-Tree/">[LeetCode 100] Same Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/same-tree/">link</a></p>

<div class="question-content">
            <p></p><p>
Given two binary trees, write a function to check if they are equal or not.
</p>

<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is an easy one</strong></p>

<h3>Code</h3>

<pre><code>public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null &amp;&amp; q == null)
        return true;
    if (p == null || q == null)
        return false;
    if (p.val == q.val)
        return isSameTree(p.left, q.left) 
            &amp;&amp; isSameTree(p.right, q.right);
    return false;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Recover-Binary-Search-Tree/">[LeetCode 99] Recover Binary Search Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/recover-binary-search-tree/">link</a></p>

<div class="question-content">
            <p></p><p>
Two elements of a binary search tree (BST) are swapped by mistake.</p>

<p>Recover the tree without changing its structure.
</p>

<b>Note:</b><br>
A solution using O(<i>n</i>) space is pretty straight forward. Could you devise a constant space solution?
<p></p>

<p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is one of the most difficult questions that I have solved</strong>.</p>

<p>The question can be solved using 2 pointers to point to the 2 misplaced nodes, and swap them. I solved the problem with this approach, and I found a good explanation <a href="http://chaoren.is-programmer.com/posts/42931.html">here</a>.</p>

<blockquote><p>Only two variables (first, second) are enough to record nodes to be exchanged.</p>

<p>If there&rsquo;s only one descending order pair (e.g. 20, 10, 30, 40, 50), use first &amp; second to record it.</p>

<p>If there are two descending order pairs (e.g. 10, 40, 30, 20, 50 or 50, 20, 30, 40, 10), use the smaller number in second pair to update variable &lsquo;second&rsquo;.</p>

<p>In the end, swap first and second.</p></blockquote>

<p>This is a popular solution on the Internet, which <strong>uses O(1) space, plus average case O(lgn) stack space</strong> (because recursion always incur stack usage). So this solution is actually not fulfilling the requirements.</p>

<blockquote><p>中序遍历二叉树的空间复杂度是O(logN) on average case</p></blockquote>

<p><strong>So finally I found a solution with constent space, and it&rsquo;s using Treaded Binary Tree again</strong>! Look below for details.</p>

<h3>Solution</h3>

<p><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/">This</a> is a systematic analysis of <strong>Morris Traversal</strong> based on <strong>Threaded Binary Tree</strong>.</p>

<p><strong>A solution of using Morris Traversal is explained <a href="http://www.cnblogs.com/TenosDoIt/p/3445682.html">here</a></strong>. Don&rsquo;t worry about the tree structure being changed, because it&rsquo;s reverted back after the traversal.</p>

<blockquote><p>算法2：为了满足O(1)空间复杂度，我们就要使用非递归且不使用栈的中序遍历算法，在leetcode另一个题目Binary Tree Inorder Traversal中，我们提到了Morris Traversal中序遍历算法，它既没有递归，也没有使用栈，而是用了线索二叉树的思想，用闲置的右节点指向中序序列中该节点的后缀，遍历后再恢复树的原始指针。其主要算法步骤如下：</p>

<p>重复以下1、2直到当前节点为空。</p></blockquote>

<p><strong><a href="http://fisherlei.blogspot.sg/2012/12/leetcode-recover-binary-search-tree.html">Another person</a></strong> have a very good (maybe better) English version of analysis and code:</p>

<pre><code>1. Initialize current as root 
2. While current is not NULL
   If current does not have left child
      a) Print current’s data
      b) Go to the right, i.e., current = current-&amp;gt;right
   Else
      a) Make current as right child of the rightmost node in current's left subtree
      b) Go to this left child, i.e., current = current-&amp;gt;left
</code></pre>

<h3>Code</h3>

<p><strong>First, my code (2 pointer solution)</strong></p>

<pre><code>TreeNode first = null, second = null;
TreeNode pre = new TreeNode(Integer.MIN_VALUE);

public void recoverTree(TreeNode root) {
    helper(root);
    // now first and second are both found
    int temp = first.val;
    first.val = second.val;
    second.val = temp;
}

private void helper(TreeNode root) {
    if (root == null) return;
    helper(root.left);
    if (pre.val &gt; root.val) {
        if (first == null) {
            first = pre;
            second = root;
        }
        else second = root;
    }
    pre = root;
    helper(root.right);
}
</code></pre>

<p><strong>Second, real O(1) space solution</strong> using Threaded Binary Tree (i.e. Morris Traversal) in C++. I could not memorize this code.</p>

<pre><code>void recoverTree(TreeNode *root) {
       TreeNode *f1=NULL, *f2=NULL;
       TreeNode  *current,*pre, *parent=NULL;

       if(root == NULL)
             return;
       bool found = false;
       current = root;
       while(current != NULL)
       {                
             if(current-&gt;left == NULL)
             {
                    if(parent &amp;&amp; parent-&gt;val &gt; current-&gt;val)
                    {
                           if(!found)
                           {
                                 f1 = parent;
                                 found = true;
                           }
                           f2 = current;
                    }
                    parent = current;
                    current = current-&gt;right;     
             }   
             else
             {
                    /* Find the inorder predecessor of current */
                    pre = current-&gt;left;
                    while(pre-&gt;right != NULL &amp;&amp; pre-&gt;right != current)
                           pre = pre-&gt;right;

                    /* Make current as right child of its inorder predecessor */
                    if(pre-&gt;right == NULL)
                    {
                           pre-&gt;right = current;
                           current = current-&gt;left;
                    }

                    /* Revert the changes made in if part to restore the original
                    tree i.e., fix the right child of predecssor */  
                    else
                    {
                           pre-&gt;right = NULL;
                           if(parent-&gt;val &gt; current-&gt;val)
                           {
                                 if(!found)
                                 {
                                        f1 = parent;       
                                        found = true;
                                 }
                                 f2 = current;
                           }
                           parent = current;
                           current = current-&gt;right;     
                    } /* End of if condition pre-&gt;right == NULL */
             } /* End of if condition current-&gt;left == NULL*/
       } /* End of while */

       if(f1 &amp;&amp; f2)
             swap(f1-&gt;val, f2-&gt;val);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Minimum-Depth-of-Binary-Tree/">[LeetCode 111] Minimum Depth of Binary Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/minimum-depth-of-binary-tree/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, find its minimum depth.</p>

<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>There are various ways to solve this question.</strong></p>

<p>Eg. DFS, BFS, queue and so on.</p>

<h3>Solution</h3>

<p>I have nothing to say with the code.</p>

<h3>Code</h3>

<pre><code>public int minDepth(TreeNode root) {
    if (root == null) return 0;
    return helper(root, Integer.MAX_VALUE, 1);
}

private int helper(TreeNode node, int min, int level) {
    if (node == null || level &gt;= min) 
        return min;
    if (node.left == null &amp;&amp; node.right == null)
        return level;
    min = helper(node.left, min, level + 1);
    min = helper(node.right, min, level + 1);
    return min;
}
</code></pre>

<p><strong>Updated on June 10th, this question is better solved with the Divide &amp; Conquer template</strong>! <a href="http://answer.ninechapter.com/solutions/minimum-depth-of-binary-tree/">link</a></p>

<pre><code>public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return checkLeaf(root);
}

private int checkLeaf(TreeNode node) {
    if (node == null) {
        return Integer.MAX_VALUE;
    }
    if (node.left == null &amp;&amp; node.right == null) {
        return 1;
    }
    int ll = checkLeaf(node.left);
    int rr = checkLeaf(node.right);
    return 1 + Math.min(ll, rr);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Maximum-Depth-of-Binary-Tree/">[LeetCode 104] Maximum Depth of Binary Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/maximum-depth-of-binary-tree/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, find its maximum depth.</p>

<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>There are various ways to solve this question.</strong></p>

<p>Eg. DFS, BFS, queue and so on.</p>

<h3>Solution</h3>

<p>I have nothing to say with the code.</p>

<h3>Code</h3>

<pre><code>public int maxDepth(TreeNode root) {
    return helper(root, 0, 1);
}

private int helper(TreeNode node, int max, int level) {
    if (node == null) return max;
    if (node.left == null &amp;&amp; node.right == null)
        return Math.max(max, level);
    max = helper(node.left, max, level + 1);
    max = helper(node.right, max, level + 1);
    return max;
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/19">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/17">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/08/03/Multilayered-architecture/">[General] Multilayered Architecture</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/03/Design-Solar-System/">[Google] Design Solar System</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/03/Data-Structure-3-Keys/">[Google] Data Structure for 3 Keys</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/03/">[General] Multilayered Architecture</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/02/Winner-tic-tac-toe/">[Google] Winner of Tic-tac-toe</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
