
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="First Word Tree Traversal is a classic category of question, however solving it in non-recursive way is not very easy. Question List Inorder, &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/17">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Collection-Tree-Traversal/">[Collection] a Collection of Tree Traversal Questions</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>First Word</h3>

<p>Tree Traversal is a classic category of question, however solving it in non-recursive way is not very easy.</p>

<h3>Question List</h3>

<p>Inorder, preorder and postorder</p>

<ol>
<li><p><strong><a href="/blog/2014/05/24/Binary-Tree-Inorder-Traversal/">Binary Tree Inorder Traversal</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/24/Binary-Tree-Inorder-Traversal/">Binary Tree Preorder Traversal</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/24/Binary-Tree-Inorder-Traversal/">Binary Tree Postorder Traversal</a></strong></p></li>
</ol>


<p>Level-order</p>

<ol>
<li><p><strong><a href="/blog/2014/05/25/Binary-Tree-Level-Order-Traversal/">Binary Tree Level Order Traversal</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/25/Binary-Tree-Level-Order-Traversal-II/">Binary Tree Level Order Traversal II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/25/Binary-Tree-Zigzag-Level-Order-Traversal/">Binary Tree Zigzag Level Order Traversal</a></strong></p></li>
</ol>


<p>Traversal-related questions</p>

<ol>
<li><p><strong><a href="/blog/2014/05/27/Construct-Binary-Tree-from-Preorder-and-Inorder/">Construct Binary Tree from Preorder and Inorder</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/27/Construct-Binary-Tree-from-Inorder-and-Postorder/">Construct Binary Tree from Inorder and Postorder</a></strong></p></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Binary-Tree-Zigzag-Level-Order-Traversal/">[LeetCode 103] Binary Tree Zigzag Level Order Traversal</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, return the <i>zigzag level order</i> traversal of its nodes&#8217; values. (ie, from left to right, then right to left for the next level and alternate between).</p>

<p>
For example:<br>
Given binary tree <code>{3,9,20,#,#,15,7}</code>,<br>
</p><pre>    3
   / \
  9  20
    /  \
   15   7
</pre>
<p></p>
<p>
return its zigzag level order traversal as:<br>
</p><pre>[
  [3],
  [20,9],
  [15,7]
]
</pre>
<p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question is based on &ldquo;Binary Tree Level Order Traversal&rdquo;</strong>.</p>

<p>Altough this is difficulty level 4, the real difficult part is solving &ldquo;Binary Tree Level Order Traversal&rdquo;. If that question is solved, only slight modification is needed for this question.</p>

<h3>Solution</h3>

<p><strong>Instead of using queue</strong> like in &ldquo;Binary Tree Level Order Traversal&rdquo;, <strong>this question is solved by using Stack</strong>. And it&rsquo;s not hard to see why. The only additional things to note:</p>

<ol>
<li><p>There is no &lsquo;single stack solution&rsquo;, we must use <strong>2 stacks</strong>. (because when push, it&rsquo;s pushed to top).</p></li>
<li><p>Keep a boolean variable to remember rightToLeft or leftToRight.</p></li>
</ol>


<h3>Code</h3>

<p><strong>First, standard BFS solution</strong> using 2 stacks.</p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (root == null) return ans;
    Stack&lt;TreeNode&gt; q = new Stack&lt;TreeNode&gt;();
    q.push(root);
    boolean reverse = true;
    while (! q.isEmpty()) {
        ans.add(new ArrayList&lt;Integer&gt;());
        Stack&lt;TreeNode&gt; qq = new Stack&lt;TreeNode&gt;();
        int curSize = q.size();
        for (int i = 0; i &lt; curSize; i ++) {
            TreeNode node = q.pop();
            ans.get(ans.size() - 1).add(node.val);
            if (reverse) {
                if (node.left != null) qq.push(node.left);
                if (node.right != null) qq.push(node.right);
            }
            else {
                if (node.right != null) qq.push(node.right);
                if (node.left != null) qq.push(node.left);
            }
        }
        q = qq;
        reverse = ! reverse;
    }
    return ans;
}
</code></pre>

<p><strong>Second, DFS solution written by me</strong>, and yes, I love DFS more.</p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    helper(ans, root, 1);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans, TreeNode node, int level) {
    if (node == null) return;
    if (ans.size() &lt; level) {
        ArrayList&lt;Integer&gt; lv = new ArrayList&lt;Integer&gt;();
        lv.add(node.val);
        ans.add(lv);
    }
    else {
        if (level % 2 == 0) 
            ans.get(level - 1).add(0, node.val);
        else
            ans.get(level - 1).add(node.val);
    }
    helper(ans, node.left, level + 1);
    helper(ans, node.right, level + 1);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Binary-Tree-Level-Order-Traversal-II/">[LeetCode 107] Binary Tree Level Order Traversal II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, return the <i>bottom-up level order</i> traversal of its nodes&#8217; values. (ie, from left to right, level by level from leaf to root).</p>

<p>
For example:<br>
Given binary tree <code>{3,9,20,#,#,15,7}</code>,<br>
</p><pre>    3
   / \
  9  20
    /  \
   15   7
</pre>
<p></p>
<p>
return its bottom-up level order traversal as:<br>
</p><pre>[
  [15,7]
  [9,20],
  [3],
]
</pre>
<p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">very easy</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is the same question as previous one</strong>.</p>

<h3>Solution</h3>

<p><strong>There are also 2 solution: BFS and DFS</strong>.</p>

<p>I post BFS code below. Only 2 lines are different: ans.get() and ans.add().</p>

<h3>Code</h3>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (root == null) return ans;
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
    q.add(root);
    while (! q.isEmpty()) {
        ans.add(0, new ArrayList&lt;Integer&gt;());
        int curSize = q.size();
        for (int i = 0; i &lt; curSize; i ++) {
            TreeNode node = q.remove();
            ans.get(0).add(node.val);
            if (node.left != null) q.add(node.left);
            if (node.right != null) q.add(node.right);
        }
    }
    return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Binary-Tree-Level-Order-Traversal/">[LeetCode 102] Binary Tree Level Order Traversal</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/binary-tree-level-order-traversal/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, return the <i>level order</i> traversal of its nodes&#8217; values. (ie, from left to right, level by level).</p>

<p>
For example:<br>
Given binary tree <code>{3,9,20,#,#,15,7}</code>,<br>
</p><pre>    3
   / \
  9  20
    /  \
   15   7
</pre>
<p></p>
<p>
return its level order traversal as:<br>
</p><pre>[
  [3],
  [9,20],
  [15,7]
]
</pre>
<p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a really classic question</strong>.</p>

<p>It is not difficult, however, it&rsquo;s important to understand 2 different ways to solve this problem: <strong>DFS and BFS</strong>.</p>

<p><strong>The different between Inorder, preorder, postorder and Level-order</strong> is explained very well in <a href="http://leetcode.com/2010/09/printing-binary-tree-in-level-order.html">this post</a>.</p>

<blockquote><p>pre-order, in-order, and post-order tree traversal are called Depth First Search (DFS), since they visit the tree by proceeding deeper and deeper until it reaches the leaf nodes.</p>

<p>DFS uses a data structure called Stack and is commonly implemented using recursion. If recursion is not allowed, we can simulate the recursion by using iterative method with the help of stack. For example in the question &ldquo;Binary Search Tree In-Order Traversal&rdquo;, we have a iterative DFS solution using a stack.</p>

<p>The most natural solution for level-order traversal is Breadth First Search (BFS), since it visits the nodes level by level. BFS requires the use of a data structure called Queue.</p></blockquote>

<p><strong>To summarize, Inorder, preorder and postorder is DFS implemented by Stack. Level-order is BFS implemented by Queue</strong>. It is very important to forever make it clear and take it into your grave 60 years later (maybe more, if not less).</p>

<p>One mor thing, <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Stack.html">Stack</a> is a Java class that inherit from <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html">Vector</a>.</p>

<blockquote><p>The Vector class implements a growable array of objects. Like an array, it contains components that can be accessed using an integer index. However, the size of a Vector can grow or shrink as needed to accommodate adding and removing items after the Vector has been created.</p>

<p>ArrayList is roughly equivalent to Vector, except that it is unsynchronized.</p></blockquote>

<p>However, <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Queue.html">Queue</a> is an interface, not a class. What is the most popular Queue implementation in Java? It is not <strong>PriorityQueue</strong>, it&rsquo;s <strong>LinkedList</strong>!</p>

<h3>Solution</h3>

<p><strong>As said, level-order is BFS</strong>. The first code posted below is implemented with a queue. A lot of people used 2 queues, which I don&rsquo;t like.</p>

<p><strong>Second code is DFS</strong>. This is my initial solution, maybe because I&rsquo;m more familiar with DFS.</p>

<h3>Code</h3>

<p><strong>First, BFS code using 1 queue</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (root == null) return ans;
    int level = 0;
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
    q.add(root);
    while (! q.isEmpty()) {
        ans.add(new ArrayList&lt;Integer&gt;());
        int curSize = q.size();
        for (int i = 0; i &lt; curSize; i ++) {
            TreeNode node = q.remove();
            ans.get(level).add(node.val);
            if (node.left != null) q.add(node.left);
            if (node.right != null) q.add(node.right);
        }
        level ++;
    }
    return ans;
}
</code></pre>

<p><strong>First code revised</strong>: I do not really need the variable &lsquo;level&rsquo;.</p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (root == null) return ans;
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
    q.add(root);
    while (! q.isEmpty()) {
        ans.add(new ArrayList&lt;Integer&gt;());
        int curSize = q.size();
        for (int i = 0; i &lt; curSize; i ++) {
            TreeNode node = q.remove();
            ans.get(ans.size() - 1).add(node.val);
            if (node.left != null) q.add(node.left);
            if (node.right != null) q.add(node.right);
        }
    }
    return ans;
}
</code></pre>

<p><strong>Second, DFS code</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (root == null) return ans;
    traverse(ans, root, 0);
    return ans;
}

private void traverse (ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans, TreeNode node, int level) {
    if (node == null) return;
    if (ans.size() &gt;= level + 1) 
        ans.get(level).add(node.val);
    else {
        ArrayList&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;();
        temp.add(node.val);
        ans.add(temp);
    }
    traverse(ans, node.left, level + 1);
    traverse(ans, node.right, level + 1);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/24/Restore-IP-Addresses/">[LeetCode 93] Restore IP Addresses</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-24T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/restore-ip-addresses/">link</a></p>

<div class="question-content">
            <p></p><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>

<p>
For example:<br>
Given <code>"25525511135"</code>,
</p>
<p>
return <code>["255.255.11.135", "255.255.111.35"]</code>. (Order does not matter)
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">40 minutes</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>This is question can be solved by <strong>either DFS or Brute Force</strong>, both are fine.</p>

<h3>Solution</h3>

<p><strong>The DFS solution is obvious, I have the code for it</strong>.</p>

<p>However, there&rsquo;s <a href="http://blog.csdn.net/u011095253/article/details/9158449">another person</a> who wrote much less code while implementing the same solution as mine. I will post his code as a good example to learn.</p>

<p><strong>The brute force solution in this case</strong> does not sound like a bad idea. This is the <strong>most top-rated idea on <a href="https://oj.leetcode.com/discuss/77/restore-ip-addresses">official forum</a></strong> as well.</p>

<blockquote><p> You can get points&#8217; positions by i, j, k. Using these positions, you can divide s into candidate ip-form. Then, you can judge whether the candidate fits ip. To improve the efficiency, you can narrow the scope of i, j, k.</p></blockquote>

<p>So, this BF code is also posted below.</p>

<p>Just one more thing. I tested the <strong>exact same BF code written in C++</strong>. Compared to the <strong>420ms</strong> it took Java to pass OJ test, C++ takes <strong>8ms</strong> only! I was kind of shocked.</p>

<h3>Code</h3>

<p><strong>First, DFS, my code</strong></p>

<p>Note: I could have just insert as string, so that convert() method would not be needed.</p>

<pre><code>public ArrayList&lt;String&gt; restoreIpAddresses(String s) {
    ArrayList&lt;String&gt; ans = new ArrayList&lt;String&gt;();
    helper(ans, new ArrayList&lt;String&gt;(), s, 0);
    return ans;
}

private void helper(ArrayList&lt;String&gt; ans, ArrayList&lt;String&gt; cur, String s, int from) {
    int len = s.length();
    if (from &gt;= len) return;
    if (cur.size() == 3) {
        String lastStr = s.substring(from);
        if (isValidIpNumber(lastStr)) {
            ArrayList&lt;String&gt; oneAns = new ArrayList&lt;String&gt;(cur);
            oneAns.add(lastStr);
            ans.add(convert(oneAns));
        }
    }
    else {
        // cur.size less than 3, so get next num (length = 1, 2 or 3)
        for (int i = 1; i &lt;= 3 &amp;&amp; from + i &lt;= len; i ++) {
            String nextStr = s.substring(from, from + i);
            if (isValidIpNumber(nextStr)) {
                cur.add(nextStr);
                helper(ans, cur, s, from + i);
                cur.remove(cur.size() - 1);
            }
        }
    }
}

private boolean isValidIpNumber(String str) {
    if (str.length() == 0 || str.length() &gt; 3) return false;
    if (str.charAt(0) == '0' &amp;&amp; str.length() != 1) return false;
    int num = Integer.parseInt(str);
    return (0 &lt;= num &amp;&amp; num &lt;= 255);
}

private String convert(ArrayList&lt;String&gt; l) {
    String ans = "";
    for (String a: l)
        ans += "." + a;
    return ans.substring(1);
}
</code></pre>

<p><strong>Second, DFS, shorter version code</strong></p>

<pre><code>public ArrayList&lt;String&gt; restoreIpAddresses(String s) {
    ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;();  
    if (s.length()&lt;4||s.length()&gt;12) return res;  
    dfs(s,"",res,0);  
    return res;  
}  

public void dfs(String s, String tmp, ArrayList&lt;String&gt; res, int count){  
    if (count == 3 &amp;&amp; isValid(s)) {  
        res.add(tmp + s);  
        return;  
    }  
    for(int i=1; i&lt;4 &amp;&amp; i&lt;s.length(); i++){  
        String substr = s.substring(0,i);  
        if (isValid(substr)){  
            dfs(s.substring(i), tmp + substr + '.', res, count+1);  
        }  
    }  
}  

public boolean isValid(String s){  
    if (s.charAt(0)=='0') return s.equals("0");  
    int num = Integer.parseInt(s);  
    return num&lt;=255 &amp;&amp; num&gt;0;  
}  
</code></pre>

<p><strong>Third, BF code using triple nested loop (Java)</strong></p>

<pre><code>public ArrayList&lt;String&gt; restoreIpAddresses(String s) {
    ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;();  
    if (s.length() &gt; 12 || s.length() &lt; 4) return res;
    for (int i = 1; i &lt; 4; i ++) {
        String first = s.substring(0, i);
        if (! isValid(first)) continue;
        for (int j = 1; i + j &lt; s.length() &amp;&amp; j &lt; 4; j ++) {
            String second = s.substring(i, i + j);
            if (! isValid(second)) continue;
            for (int k = 1; i + j + k &lt; s.length() &amp;&amp; k &lt; 4; k ++) {
                String third = s.substring(i + j, i + j + k);
                String fourth = s.substring(i + j + k);
                if (isValid(third) &amp;&amp; isValid(fourth)) 
                    res.add(first + "." + second + "." + third + "." + fourth);
            }
        }
    }
    return res;
}  

public boolean isValid(String s) {
    if (s.length() &gt; 1 &amp;&amp; s.charAt(0) == '0') return false;
    return 0 &lt;= Integer.parseInt(s) &amp;&amp; Integer.parseInt(s) &lt;= 255;  
}
</code></pre>

<p><strong>Fourth, same BF code (C++)</strong></p>

<pre><code>vector&lt;string&gt; restoreIpAddresses(string s) {
    vector&lt;string&gt; res;
    if (s.size() &gt; 12 || s.size() &lt; 4) return res;
    for (int i=1; i&lt;4; i++) {
        string first = s.substr(0, i);
        if (!isValid(first)) continue;
        for (int j=1; i+j &lt; s.size() &amp;&amp; j&lt;4; j++) {
            string second = s.substr(i, j);
            if (!isValid(second)) continue;
            for (int k=1; i+j+k &lt; s.size() &amp;&amp; k&lt;4; k++) {
                string third = s.substr(i+j, k);
                string fourth = s.substr(i+j+k);
                if (isValid(third) &amp;&amp; isValid(fourth)) {
                    string temp = first+"."+second+"."+third+"."+fourth;
                    res.push_back(temp);
                }
            }
        }
    }
    return res;
}

bool isValid(string s) {
    if (s.size() &gt; 1 &amp;&amp; s[0] == '0') return false;
    if (stoi(s) &lt;= 255 &amp;&amp; stoi(s) &gt;= 0) return true;
    else return false;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/24/Maximal-Rectangle/">[LeetCode 85] Maximal Rectangle</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-24T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/maximal-rectangle/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a 2D binary matrix filled with 0&#8217;s and 1&#8217;s, find the largest rectangle containing all ones and return its area.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very difficult question</strong>. It is similar and also related to &ldquo;<strong>Largest Rectangle in Histogram</strong>&rdquo;.</p>

<p>Two solutions are available for this question.</p>

<p><strong>First solution is O(n<sup>2</sup>)</strong>. This makes use of solution of &ldquo;<strong>Largest Rectangle in Histogram</strong>&rdquo;, which is to say, we are finding the max rectangle for each row (as base) in the matrix.</p>

<p>This solution is very easy to write once you realize this connection &ndash; I guess not many people would. That&rsquo;s why I have the next solution.</p>

<p><strong>Second solution is a clever Brute Force, time complexity is O(n<sup>3</sup>)</strong>. The fundamental idea is to make a 2-D array storing the number of &lsquo;1&rsquo;s occured before current node (inclusive). After this is done, there&rsquo;re 2 different ways to implement. Read code 2 and code 3.</p>

<h3>Solution</h3>

<p>FIrst code is easy.</p>

<p>Second code is the idea from <a href="http://blog.csdn.net/fightforyourdream/article/details/17711893">this blog</a>. For every node in the 2-D array, checks all possible rectangles ending at this node (which mean check all the way up/left).</p>

<p>Third code from <a href="http://leetcodenotes.wordpress.com/2013/10/19/leetcode-maximal-rectangle-0101%E7%BB%84%E6%88%90%E7%9A%84%E7%9F%A9%E9%98%B5%EF%BC%8C%E6%B1%82%E9%87%8C%E9%9D%A2%E5%85%A8%E6%98%AF1%E7%9A%84%E7%9F%A9%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2/">this blog</a>. It is similar to second, but it&rsquo;s checking all rectangles that shared same width as current line. So it&rsquo;s checking up then down, both direction. Read the code and it&rsquo;s easy to understand.</p>

<h3>Code</h3>

<p><strong>First, solution making use of &ldquo;Largest rectangle&rdquo;</strong></p>

<pre><code>public int maximalRectangle(char[][] matrix) {
    if (matrix.length == 0 || matrix[0].length == 0) return 0;
    int[][] m = new int[matrix.length][matrix[0].length];
    for (int i = 0; i &lt; matrix.length; i ++) {
        for (int j = 0; j &lt; matrix[i].length; j ++) {
            if (i == 0 || matrix[i][j] == '0') 
                m[i][j] = matrix[i][j] - '0';
            else 
                m[i][j] = m[i-1][j] + 1;
        }
    }
    int max = 0;
    for (int i = 0; i &lt; m.length; i ++) {
        max = Math.max(max, largestRectangleArea(m[i]));
    }
    return max;
}

// the following code is the solution for "Largest Rectangle in Histogram"
public int largestRectangleArea(int[] height) {
    int len = height.length;
    if (len == 0) return 0;
    int max = Integer.MIN_VALUE;
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    for (int i = 0; i &lt; len; i ++) {
        if (stack.isEmpty() || height[stack.peek()] &lt;= height[i]) stack.push(i);
        else {
            int temp = stack.pop();
            // here I must do a check of stack.isEmpty(), 
            // And do nto use (i-height[temp]) instead use (i-stack.peek()-1])
            max = Math.max(max, height[temp] * 
                (stack.isEmpty() ? i : (i - stack.peek() - 1)));
            i --;
        }
    }
    while (! stack.isEmpty()) {
            int temp = stack.pop();
            max = Math.max(max, height[temp] * 
                (stack.isEmpty() ? len : (len - stack.peek() - 1)));
    }
    return max;
}
</code></pre>

<p><strong>Second </strong></p>

<pre><code>public int maximalRectangle(char[][] matrix) {
    int rows = matrix.length;  
    if (rows == 0) return 0;  
    int cols = matrix[0].length;  
    int [][] hOnes = new int[rows][cols];
    int max = 0;
    for (int i=0; i&lt;rows; i++)
        for(int j=0; j&lt;cols; j++) 
            if(matrix[i][j] == '1')
                if(j == 0) hOnes[i][j] = 1;
                else hOnes[i][j] = hOnes[i][j-1] + 1;
    for (int i=0; i&lt;rows; i++)
        for (int j=0; j&lt;cols; j++){  
            if (hOnes[i][j] != 0){  
                int minI = i;
                int minRowWidth = hOnes[i][j];
                while (minI &gt;= 0){
                    minRowWidth = Math.min(minRowWidth, hOnes[minI][j]);  
                    int area = minRowWidth * (i-minI+1);  
                    max = Math.max(max, area);  
                    minI--;  
                }
            }
        }
    return max;  
}
</code></pre>

<p><strong>Third</strong></p>

<pre><code>public int maximalRectangle(char[][] matrix) {
    if (matrix.length == 0) return 0;
    int res = 0;
    int m = matrix.length, n = matrix[0].length;
    int[][] d = new int[m][n];
    for (int i = 0; i &lt; m; i++) {
        d[i][0] = matrix[i][0] - '0';
        for (int j = 1; j &lt; n; j++) 
            d[i][j] = matrix[i][j] == '1' ? d[i][j - 1] + 1 : 0;
    }
    for (int i = 0; i &lt; m; i++) 
        for (int j = 0; j &lt; n; j++) 
            res = Math.max(res, expand(d, i, j));
    return res;
}

private int expand(int[][] d, int I, int J) {
    int height = 0, width = d[I][J];
    //go up
    for (int i = I - 1; i &gt;= 0; i--)
        if (d[i][J] &gt;= width) height++;
        else break;
    //go down
    for (int i = I; i &lt; d.length; i++) 
        if (d[i][J] &gt;= width) height++;
        else break;
    return width * height;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/24/Interleaving-String/">[LeetCode 97] Interleaving String</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-24T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/interleaving-string/">link</a></p>

<div class="question-content">
            <p></p><p>
Given <i>s1</i>, <i>s2</i>, <i>s3</i>, find whether <i>s3</i> is formed by the interleaving of <i>s1</i> and <i>s2</i>.
</p>

<p>
For example,<br>
Given:<br>
<i>s1</i> = <code>"aabcc"</code>,<br>
<i>s2</i> = <code>"dbbca"</code>,
</p>
<p>
When <i>s3</i> = <code>"aadbbcbcac"</code>, return true.<br>
When <i>s3</i> = <code>"aadbbbaccc"</code>, return false.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a DP question</strong>.</p>

<p>At first look it might look like very easily solved by DFS. It it, but TLE exception.</p>

<p>So, I learnt the idea from <a href="http://blog.csdn.net/u011095253/article/details/9248073">this blog</a>. It&rsquo;s easy to realize this is a <strong>very standard DP question</strong>.</p>

<h3>Solution</h3>

<p>Declare a 2-D array for DP, and dp(i)(j) denotes whether it&rsquo;s possible to construct s3 (of length i+j) by using s1 (of length i) and s2 (of length j).</p>

<p>Only thing needs to mention is the size of dp is (m+1)*(n+1), because i = [0, m] and j = [0, n].</p>

<h3>Code</h3>

<p><strong>DP solution</strong></p>

<pre><code>public boolean isInterleave(String s1, String s2, String s3) {
    int len1 = s1.length();
    int len2 = s2.length();
    int len3 = s3.length();
    if (len1 + len2 != len3) return false;
    boolean[][] dp = new boolean[len1 + 1][len2 + 1];
    dp[0][0] = true;
    for (int i = 1; i &lt;= len2; i ++)
        dp[0][i] = dp[0][i - 1] &amp; s2.charAt(i-1) == s3.charAt(i-1);
    for (int i = 1; i &lt;= len1; i ++)
        dp[i][0] = dp[i-1][0] &amp; s1.charAt(i-1) == s3.charAt(i-1);
    for (int i = 1; i &lt;= len1; i ++) {
        for (int j = 1; j &lt;= len2; j ++) {
            if (s1.charAt(i-1) == s3.charAt(i+j-1) &amp;&amp; dp[i-1][j])
                dp[i][j] = true;
            if (s2.charAt(j-1) == s3.charAt(i+j-1) &amp;&amp; dp[i][j-1])
                dp[i][j] = true;
        }
    }
    return dp[len1][len2];
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/24/Binary-Tree-Inorder-Traversal/">[LeetCode 94] Binary Tree Inorder Traversal</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-24T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/binary-tree-inorder-traversal/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, return the <i>inorder</i> traversal of its nodes&#8217; values.</p>

<p>
For example:<br>
Given binary tree <code>{1,#,2,3}</code>,<br>
</p><pre>   1
    \
     2
    /
   3
</pre>
<p></p>
<p>
return <code>[1,3,2]</code>.
</p>

<p><b>Note:</b> Recursive solution is trivial, could you do it iteratively?</p>

<p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a classic AND EXTREMELY IMPORTANT question</strong>. I solved it at first attempt, but forget about it and couldn&rsquo;t solve on 2nd time.</p>

<p>About DFS, it is always implemented with a stack, no matter recursion is used or not. See <a href="http://leetcode.com/2010/09/printing-binary-tree-in-level-order.html">here</a></p>

<blockquote><p>DFS uses a data structure called Stack and is commonly implemented using recursion (since function calls are pushed and popped off the memory stack). If recursion is not allowed, we can simulate the recursion by using iterative method with the help of stack.</p></blockquote>

<p><strong>A not-very-intuitive solution is Morris Traversal</strong>. The idea behind this is <a href="http://en.wikipedia.org/wiki/Threaded_binary_tree">Threaded binary tree</a>. I don&rsquo;t like this method, so I will skip.</p>

<p>The idea written below (2nd code) is very interesting, and was never seen before. Should keep it in mind.</p>

<h3>Solution</h3>

<p><strong>The most classic and standard solution for this question</strong> is explained well in <a href="http://leetcode.com/2010/04/binary-search-tree-in-order-traversal.html">this blog</a>.</p>

<blockquote><p>First, the current pointer is initialized to the root. Keep traversing to its left child while pushing visited nodes onto the stack. When you reach a NULL node (ie, you&rsquo;ve reached a leaf node), you would pop off an element from the stack and set it to current. Now is the time to print current&rsquo;s value. Then, current is set to its right child and repeat the process again. When the stack is empty, this means you&rsquo;re done printing.</p></blockquote>

<h3>Code</h3>

<p><strong>First, my previous code, very good solution</strong>.</p>

<pre><code>public ArrayList&lt;Integer&gt; inorderTraversal(TreeNode root) {
    Stack&lt;TreeNode&gt; stk = new Stack&lt;TreeNode&gt;();
    stk.push(root);
    ArrayList&lt;Integer&gt; ls = new ArrayList&lt;Integer&gt;();

    if(root == null)
        return ls;
    while(stk.size() &gt; 0){
        TreeNode cur = stk.peek();
        if (cur == null){
            stk.pop();
            if (stk.size() == 0) return ls;
            TreeNode temp = stk.pop(); 
            ls.add(temp.val);
            stk.push(temp.right);
            // why do I need a temp variable at this step?
            // this isn't good enough, change it in the future
        } else if (cur.left != null){
            stk.push(cur.left);
        } else {
            ls.add(cur.val);
            stk.pop();
            stk.push(cur.right);
        }
    }
    return ls;
}
// Program Logic:
// If cur is null
//    Remove cur
//    Print next stack node
//    Push next stack node's right
// Else if cur got left
//    Push cur.left
// Else if cur not got left
//    Print cur
//    Remove cur
//    Push cur.right
// End if
</code></pre>

<p><strong>Second, standard solution, which is a simplified version of above code</strong></p>

<pre><code>public ArrayList&lt;Integer&gt; inorderTraversal(TreeNode root) {
    ArrayList&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();
    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
    TreeNode p = root;
    while (p != null || ! stack.isEmpty()) {
        if (p != null) {
            stack.push(p);
            p = p.left;
        }
        else if (! stack.isEmpty()) {
            TreeNode temp = stack.pop();
            ans.add(temp.val);
            p = temp.right;
        }
    }
    return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/23/Scramble-String/">[LeetCode 87] Scramble String</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-23T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/scramble-string/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a string <i>s1</i>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.
</p>
<p>
Below is one possible representation of <i>s1</i> = <code>"great"</code>:
</p>
<pre>    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
</pre>
<p>
To scramble the string, we may choose any non-leaf node and swap its two children.
</p>
<p>
For example, if we choose the node <code>"gr"</code> and swap its two children, it produces a scrambled string <code>"rgeat"</code>.
</p>
<pre>    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
</pre>
<p>
We say that <code>"rgeat"</code> is a scrambled string of <code>"great"</code>.
</p>
<p>
Similarly, if we continue to swap the children of nodes <code>"eat"</code> and <code>"at"</code>, it produces a scrambled string <code>"rgtae"</code>.
</p>
<pre>    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
</pre>
<p>
We say that <code>"rgtae"</code> is a scrambled string of <code>"great"</code>.
</p>
<p>
Given two strings <i>s1</i> and <i>s2</i> of the same length, determine if <i>s2</i> is a scrambled string of <i>s1</i>.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>This is problem can be solved by <strong>either DFS or DP.</strong></p>

<p><strong><a href="http://zhaohongze.com/wordpress/2013/12/12/leetcode-scramble-string/">This blog</a> have a very good analysis of the DFS approach</strong>.</p>

<blockquote>
<p>Note that the binary tree can be constructed arbitrarily. So the general idea to tackle this problem is to enumerate every possible binary trees using DFS to see if two strings are scrambled strings. We can accelerate this process by adding a very efficient pruning.<br>
Given two strings, s1, s2. First check if they have same letters and same length, denote as len.<br>
For any l (1 &lt;= l &lt;= len): partition s1 into s11 = s1[0 : l), s12 = s1[l : len). We have two ways to partition s1:</p>
<ol>
<li>s21 = s2[0 : 1), s22 = s2[l : len). In this case, check s11 and s21 have same letters and are scrambled strings. And check s12 and s22 have same letters and are scrambled strings</li>
<li>s21 = s2[0 : len – l), s22 = s2[len – l : len). In this case, check s11 and s22 have same letters and are scrambled strings. Then check s12 and s21 have same letters and are scrambled strings </li>
</ol>
</blockquote>


<p><strong><a href="http://blog.sina.com.cn/s/blog_b9285de20101gy6n.html">This blog</a> have a very good DP analysis</strong>.</p>

<blockquote>
<span style="font-family: Arial; vertical-align: baseline; white-space: pre-wrap;">
dp[i][j][k] 代表了s1从i开始，s2从j开始，长度为k的两个substring是否为scramble
string。</span><br>
<span style="font-family: Arial; vertical-align: baseline; white-space: pre-wrap;">
有三种情况需要考虑：</span><br>
<span style="font-family: Arial; vertical-align: baseline; white-space: pre-wrap;">
1. 如果两个substring相等的话，则为true</span><br>
<span style="font-family: Arial; vertical-align: baseline; white-space: pre-wrap;">
2. 如果两个substring中间某一个点，左边的substrings为scramble string，
同时右边的substrings也为scramble string，则为true</span><br>
<span style="font-family: Arial; vertical-align: baseline; white-space: pre-wrap;">
3. 如果两个substring中间某一个点，s1左边的substring和s2右边的substring为scramble
string, 同时s1右边substring和s2左边的substring也为scramble
string，则为true</span><br>
</blockquote>


<p>For more explanation, <a href="http://yihuad.blogspot.sg/2013/10/scramble-string-leetcode.html">this blog</a> and <a href="http://www.blogjava.net/sandy/archive/2013/05/22/399605.html">this blog</a> and <a href="http://blog.csdn.net/linhuanmars/article/details/24506703">this blog</a> have discussed about it.</p>

<h3>Code</h3>

<p><strong>my code</strong></p>

<pre><code>public boolean isScramble(String s1, String s2) {
    if (! sameLetters(s1, s2)) return false;
    if (s1.equals(s2)) return true;
    for (int i = 1; i &lt; s1.length(); i ++) {
        String left1 = s1.substring(0,  i);
        String right1 = s1.substring(i, s1.length());
        String left2 = s2.substring(0,  i);
        String right2 = s2.substring(i, s2.length());
        if (isScramble(left1, left2) &amp;&amp; isScramble(right1, right2))
            return true;
        left2 = s2.substring(0, s2.length() - i);
        right2 = s2.substring(s2.length() - i, s2.length());
        if (isScramble(left1, right2) &amp;&amp; isScramble(right1, left2))
            return true;
    }
    return false;
}

private boolean sameLetters(String a, String b) {
    if (a.length() != b.length()) return false;
    int[] count = new int[26];
    for (Character aa: a.toCharArray()) 
        count[aa - 'a'] ++;
    for (Character bb: b.toCharArray()) 
        if (count[bb - 'a'] -- &lt;= 0) 
            return false;
    return true;
}
</code></pre>

<p><strong>Updated on July 5th, 2014</strong>: written again with less substring operations and more variables inside the method:</p>

<pre><code>public boolean isScramble(String s1, String s2) {
    if (s1 == null || s2 == null || s1.length() != s2.length()) {
        return false;
    }
    int len = s1.length();
    return helper(s1, 0, len - 1, s2, 0, len - 1);
}

private boolean helper(String s1, int a1, int b1, String s2, int a2, int b2) {
    if (a1 - b1 != a2 - b2) 
        return false;
    // check s1[a1, b1] and s2[a2, b2] have same set of letters
    int[] count = new int[26];
    for (int i = a1; i &lt;= b1; i++) 
        count[s1.charAt(i) - 'a'] ++;
    for (int i = a2; i &lt;= b2; i++) 
        if (count[s2.charAt(i) - 'a'] -- &lt;= 0) 
            return false;
    // check s1[a1, b1] and s2[a2, b2] is scramble or not
    if (a1 == b1) {
        return (s1.charAt(a1) == s2.charAt(a2));
    }
    for (int i = 0; i &lt; b1 - a1; i++) {
        boolean check = helper(s1, a1, a1 + i, s2, a2, a2 + i) 
                    &amp;&amp; helper(s1, a1 + i + 1, b1, s2, a2 + i + 1, b2);
        if (check) return true;
        check = helper(s1, a1, a1 + i, s2, b2 - i, b2) 
                    &amp;&amp; helper(s1, a1 + i + 1, b1, s2, a2, b2 - i - 1);
        if (check) return true;
    }
    return false;
}
</code></pre>

<p><strong>DP code</strong>, not written by me</p>

<pre><code>public boolean isScramble(String s1, String s2) {
    int n = s1.length();
    boolean[][][] dp = new boolean[n][n][n + 1];
    for (int i = n - 1; i &gt;= 0; i--)
        for (int j = n - 1; j &gt;= 0; j--)
            for (int k = 1; k &lt;= n - Math.max(i, j); k++) {
                if (s1.substring(i, i + k).equals(s2.substring(j, j + k)))
                    dp[i][j][k] = true;
                else {
                    for (int l = 1; l &lt; k; l++) {
                        if (dp[i][j][l] &amp;&amp; dp[i + l][j + l][k - l] 
                            || dp[i][j + k - l][l] &amp;&amp; dp[i + l][j][k - l]) {
                            dp[i][j][k] = true;
                            break;
                        }
                    }
                }
            }
    return dp[0][0][n];
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/23/Reverse-Linked-List-II/">[LeetCode 92] Reverse Linked List II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-23T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/reverse-linked-list-ii/">link</a></p>

<div class="question-content">
            <p></p><p>
Reverse a linked list from position <i>m</i> to <i>n</i>. Do it in-place and in one-pass.
</p>

<p>
For example:<br>
Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, <i>m</i> = 2 and <i>n</i> = 4,
</p>
<p>
return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.
</p>
<p>
<b>Note:</b><br>
Given <i>m</i>, <i>n</i> satisfy the following condition:<br>
1 ≤ <i>m</i> ≤ <i>n</i> ≤ length of list.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">18 minutes</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very standard interview question of LinkedList</strong>.</p>

<h3>Solution</h3>

<p><strong>Keep 2 pointers, one of which points to preReversePosition, another one points to finalTailOfTheReversedPart</strong>. Each time, I will get next element and insert it between the 2 pointers mentioned above. See below image for details:</p>

<p><img class="left" src="/assets/images/reverse-linked-list-ii.png"></p>

<p>The coding isn&rsquo;t easy, there can be a lot of details being omitted. Just think of it in this way: in the above picture, 123 is broken away from 45678. Each time, get next element from 45678, and insert it right after 2. Do this 2 times, so that 4,5 are moved. In the end, make 3 point to 6, and solution done.</p>

<h3>Code</h3>

<p><strong>First, my code</strong></p>

<pre><code>public ListNode reverseBetween(ListNode head, int m, int n) {
    ListNode preHead = new ListNode(0);
    preHead.next = head;
    ListNode before = preHead;
    for (int i = 1; i &lt; m; i ++)
        before = before.next;
    ListNode rTail = before.next;
    ListNode cur = before.next.next;
    for (int i = 0; i &lt; n - m; i ++) {
        ListNode temp = cur.next;
        cur.next = before.next;
        before.next = cur;
        cur = temp;
    }
    rTail.next = cur;
    return preHead.next;
}
</code></pre>

<p><strong>Second, </strong></p>

<p>A lot of people have similar solutions, so I won&rsquo;t post any of their code. Reading it won&rsquo;t help, write it yourself is actually important.</p>

<p>A lot of people have complained about this problem not easy to write.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/18">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/16">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/07/29/Which-is-faster/">[Question] Which Loop Is Faster</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/29/Find-Min-Max-in-Array/">[Question] Find Min & Max in an Array Using Minimum Comparisons</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/29/Construct-BST-from-preorder/">[Question] Construct a BST From Preorder Traversal</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/28/Matching-Nuts-And-Bolts/">[Question] Matching Nuts and Bolts</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/28/Check-Number-Exists/">[Question] Check if Number Exists</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
