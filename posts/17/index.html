
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="Question link Sort a linked list in O(n log n) time using constant space complexity. Stats Adjusted Difficulty 4 Time to use &#8212;&#8212;&#8211; &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/17">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/02/Sort-List/">[LeetCode 148] Sort List</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/sort-list/">link</a></p>

<div class="question-content bg-color bg-img font-color">
            <p class="font-color"></p><p class="font-color">Sort a linked list in <i>O</i>(<i>n</i> log <i>n</i>) time using constant space complexity.</p><p class="font-color"></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a difficult question</strong>.</p>

<p>To sort with O(nlgn) time, we must use either quick sort or <strong>merge sort</strong>.</p>

<h3>Solution</h3>

<p>This is a standard merge sort algorithm. The details can be found <a href="http://www.programcreek.com/2012/11/leetcode-solution-merge-sort-linkedlist-in-java/">here</a>.</p>

<p>I am being lazy here, I reused the code from &ldquo;Merge Two Sorted Lists&rdquo;. Surprisingly it worked! Just remember, we must set the last node of first half to point to null.</p>

<h3>Code</h3>

<pre><code>public ListNode sortList(ListNode head) {
    if (head == null || head.next == null) 
        return head;
    int len = 0;
    ListNode temp = head;
    while (temp != null) {
        temp = temp.next;
        len ++;
    }
    temp = head;
    for (int i = 1; i &lt; len / 2; i ++)
        temp = temp.next;
    ListNode firstHalf = head, secondHalf = temp.next;
    temp.next = null;
    return mergeTwoLists(sortList(firstHalf), 
                         sortList(secondHalf));
}

// The following code is copied from
// Question - Merge Two Sorted Lists
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode pre = new ListNode(Integer.MIN_VALUE);
    ListNode cur = pre;
    while (l1 != null &amp;&amp; l2 != null) {
        if (l1.val &lt; l2.val) {
            cur.next = l1;
            l1 = l1.next;
        } else {
            cur.next = l2;
            l2 = l2.next;
        }
        cur = cur.next;
    }
    if (l1 == null) cur.next = l2;
    else cur.next = l1;
    return pre.next;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/02/Linked-List-Cycle-II/">[LeetCode 142] Linked List Cycle II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/linked-list-cycle-ii/">link</a></p>

<div class="question-content bg-color bg-img font-color">
            <p class="font-color"></p><p class="font-color">
Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.
</p>

<p class="font-color">
Follow up:<br>
Can you solve it without using extra space?
</p><p class="font-color"></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is an famous question, historically know as the <a href="http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare">Tortoise and hare</a></strong>.</p>

<h3>Solution</h3>

<p><a href="http://fisherlei.blogspot.sg/2013/11/leetcode-linked-list-cycle-ii-solution.html">This blog</a> has a great solution.</p>

<blockquote cite="">
    <p class="font-color">现在有两个指针，第一个指针，每走一次走一步，第二个指针每走一次走两步，如果他们走了t次之后相遇在K点</p>
    <p class="font-color">那么&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指针一&nbsp; 走的路是&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = X + nY + K&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①</p>
    <p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指针二&nbsp; 走的路是&nbsp;&nbsp;&nbsp;&nbsp; 2t = X + mY+ K&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m,n为未知数</p>
    <p class="font-color">把等式一代入到等式二中, 有</p>
    <p class="font-color">2X + 2nY + 2K = X + mY + K</p>
    <p class="font-color">=&gt;&nbsp;&nbsp; X+K&nbsp; =&nbsp; (m-2n)Y&nbsp;&nbsp;&nbsp; ③</p>
    <p class="font-color">这就清晰了，X和K的关系是基于Y互补的。等于说，两个指针相遇以后，再往下走X步就回到Cycle的起点了。这就可以有O(n)的实现了。</p>
</blockquote>


<p><img class="middle" src="/assets/images/Linked-List-Cycle-II.png"></p>

<h3>Code</h3>

<pre><code>public ListNode detectCycle(ListNode head) {
    if (head == null || head.next == null) 
        return null;
    ListNode first = head.next, second = first.next;
    ListNode found = null;
    while (first != null &amp;&amp; second != null) {
        if (first == second) {
            found = first;
            break;
        }
        first = first.next;
        second = second.next;
        if (second == null) break;
        second = second.next;
    }
    if (found == null) return null;
    first = head;
    while (first != second) {
        first = first.next;
        second = second.next;
    }
    return first;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/02/Linked-List-Cycle/">[LeetCode 141] Linked List Cycle</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/linked-list-cycle/">link</a></p>

<div class="question-content bg-color bg-img font-color">
            <p class="font-color"></p><p class="font-color">
Given a linked list, determine if it has a cycle in it.
</p>

<p class="font-color">
Follow up:<br>
Can you solve it without using extra space?
</p><p class="font-color"></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is an famous question, historically know as the <a href="http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare">Tortoise and hare</a></strong>.</p>

<h3>Solution</h3>

<p><a href="http://www.programcreek.com/2012/12/leetcode-linked-list-cycle/">This blog</a> has a great solution.</p>

<blockquote><p>Use fast and low pointer. The advantage about fast/slow pointers is that when a circle is located, the fast one will catch the slow one for sure.</p></blockquote>

<h3>Code</h3>

<pre><code>public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) 
        return false;
    ListNode first = head.next, second = first.next;
    while (first != null &amp;&amp; second != null) {
        if (first == second) return true;
        first = first.next;
        second = second.next;
        if (second == null) return false;
        second = second.next;
    }
    return false;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/02/Copy-List-with-Random-Pointer/">[LeetCode 138] Copy List With Random Pointer</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/copy-list-with-random-pointer/">link</a></p>

<div class="question-content bg-color bg-img font-color">
            <p class="font-color"></p><p class="font-color">
A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.
</p>

<p class="font-color">
Return a deep copy of the list.
</p><p class="font-color"></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">20 minutes</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is not a difficult question</strong>, however I mark it as difficulty level &ldquo;4&rdquo; because there are 2 solution, the second of which is hard to think of.</p>

<h3>Solution</h3>

<p><strong>Solution 1 which is my initial idea is using HashMap</strong> to store mappings from original nodes to copied nodes. This solution become exactly same as another question &ldquo;Clone Graph&rdquo;, only easier. It works fine.</p>

<p>However such solution uses O(n) extra space. Can we do it with less space?</p>

<p><strong>Solution 2 is a in-place method</strong> which directly creates the copied list. It is well explained in <a href="http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/">here</a>:</p>

<blockquote><ol>
<li>Create a copy of first node and insert it between Node 1 &amp; Node 2 in original list. Then create a copy of second node and insert it between Node 2 &amp; Node 3&hellip; Continue in this fashion</li>
<li>Set random link of the copied nodes (by referring to <strong>original.random.next</strong>)</li>
<li>Restore the original and copied lists (and return answer)</li>
</ol>
</blockquote>

<p>This solution (although uses 3 while-loops) is O(n) and O(1) extra space.</p>

<h3>Code</h3>

<p><strong>First, my solution using HashMap</strong></p>

<pre><code>public RandomListNode copyRandomList(RandomListNode head) {
    if (head == null) return null;
    RandomListNode newHead = new RandomListNode(head.label);
    HashMap&lt;RandomListNode, RandomListNode&gt; map = 
            new HashMap&lt;RandomListNode, RandomListNode&gt;();
    map.put(head, newHead);
    RandomListNode orin = head, cp = newHead;
    while (orin != null) {
        if (orin.next != null) {
            if (!map.containsKey(orin.next))
                map.put(orin.next, new RandomListNode(orin.next.label));
            cp.next = map.get(orin.next);
        }
        if (orin.random != null) {
            if (!map.containsKey(orin.random))
                map.put(orin.random, new RandomListNode(orin.random.label));
            cp.random = map.get(orin.random);
        }
        orin = orin.next;
        cp = cp.next;
    }
    return newHead;
}
</code></pre>

<p><strong>Second, constent space solution</strong></p>

<pre><code>public RandomListNode copyRandomList(RandomListNode head)  {
    if (head == null)  {
        return null;
    }
    // copy each node and append right after original node
    RandomListNode p = head;
    while (p != null)  {
        RandomListNode cp = new RandomListNode(p.label);
        cp.next = p.next;
        p.next = cp;
        p = p.next.next;
    }
    // now set random pointer of all copied nodes
    p = head;
    while (p != null)  {
        if (p.random != null)  {
            p.next.random = p.random.next;
        }
        p = p.next.next;
    }
    // now restore original list, and connected all copied nodes
    RandomListNode ans = head.next;
    RandomListNode m = head, n = head.next;
    while (m != null)  {
        if (n.next == null)  {
            m.next = null;
            m = null;
        }
        else  {
            m.next = n.next;
            n.next = n.next.next;
            m = m.next;
            n = n.next;
        }
    }
    return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/02/Binary-Tree-Preorder-Traversal/">[LeetCode 144] Binary Tree Preorder Traversal</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/binary-tree-preorder-traversal/">link</a></p>

<div class="question-content bg-color bg-img font-color">
            <p class="font-color"></p><p class="font-color">Given a binary tree, return the <i>preorder</i> traversal of its nodes&#8217; values.</p>

<p class="font-color">
For example:<br>
Given binary tree <code>{1,#,2,3}</code>,<br>
</p><pre>   1
    \
     2
    /
   3
</pre>
<p class="font-color"></p>
<p class="font-color">
return <code>[1,2,3]</code>.
</p>

<p class="font-color"><b>Note:</b> Recursive solution is trivial, could you do it iteratively?</p><p class="font-color"></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is the easiest question of this series</strong>.</p>

<p>In-order and post-order are not easy at all!</p>

<h3>Code</h3>

<pre><code>public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; ans = new LinkedList&lt;Integer&gt;();
    if (root == null) return ans;
    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode cur = stack.pop();
        ans.add(cur.val);
        // should it do reversely, right?
        if (cur.right != null) stack.push(cur.right);
        if (cur.left != null) stack.push(cur.left);
    }
    return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/01/thoughts-on-leetcode-3/">Some Thoughts on LeetCode Questions III</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-01T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>First word</h3>

<p>It&rsquo;s been around 2 month since I started doing Leetcode OJ, and a little more than a month since my first blog.</p>

<p><strong>As of May 31st, 2014 Saturday</strong>, I have solved <strong>147/151 questions</strong> on LeetCode, plus <strong>135 blog posts</strong>.</p>

<p>Unsolved questions are:</p>

<ol>
<li>Median of Two Sorted Arrays</li>
<li>Word Ladder II</li>
<li>Word Break II</li>
<li>LRU Cache</li>
</ol>


<p>And while doing this, I also have a 9-to-5 job to feed myself.</p>

<h3>Thoughts</h3>

<p>I think this is a fruitful two months for me, from where I have struggled, compromised, grown, went sleepless, went crazy, went on fire and went exhausted from time to time, until I finally realize that I am beginning to see a bit of silver lining. But the more that I learn, the better that I understand how much more I am still lacking.</p>

<p>I always thought this is gonna be a journey that takes me from one point to another, but <strong>No</strong>. It&rsquo;s not that simple. In the end, this might just be an infinitely long and tortuous journey that eventually take me to nowhere. But on the other hand, I never have believed in my entire life, that there&rsquo;s something in this world that I can&rsquo;t do. Sometimes hard work pays off, and sometimes good luck does. I always have both. And that gives me no reason to shrink.</p>

<h3>Silver Lining</h3>

<p>I suddenly remembered a great movie &ldquo;<strong>Silver Lining Playbook</strong>&rdquo; featuring Pat and Tiffany&rsquo;s difficult journey to happiness.</p>

<blockquote><p>Pat: This is what I learned at the hospital. You have to do everything you can, you have to work your hardest, and if you do, you have a shot at a silver lining.</p>

<p>Tiffany: Listen, I haven&rsquo;t dated since before my marriage so I don&rsquo;t really remember how this works. I saw the way you were looking at me, Pat. You felt it, I felt it, don&rsquo;t lie. We&rsquo;re not liars like they are. I live in the addition around back, which is completely separate from my parents&#8217; house, so there&rsquo;s no chance of them walking in on us. I hate the fact that you wore a football jersey to dinner because I hate football, but you can fuck me if you turn the lights off, okay?</p>

<p>Tiffany: Humanity is just nasty and there&rsquo;s no silver lining.</p>

<p>Tiffany: You know, for a while, I thought you were the best thing that ever happened to me. But now I&rsquo;m starting to think you&rsquo;re the worst.</p>

<p>Pat: The only way you can beat my crazy was by doing something crazy yourself. Thank you. I love you. I knew it the minute I met you. I&rsquo;m sorry it took so long for me to catch up. I just got stuck.</p></blockquote>

<p>I wish silvering lining will open up for me in the near future.</p>

<p>And Happy Dragon Boat Festival, I just realize that.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/01/Single-Number-II/">[LeetCode 137] Single Number II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-01T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/single-number-ii/">link</a></p>

<div class="question-content bg-color bg-img font-color">
            <p class="font-color"></p><p class="font-color">
Given an array of integers, every element appears <i>three</i> times except for one. Find that single one.
</p>

<p class="font-color">
<b>Note:</b><br>
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
</p><p class="font-color"></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>$
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is an extremely difficult question</strong>. There are 2 solutions (both are bit manipulation).</p>

<h3>Solution</h3>

<p><strong>First solution comes from <a href="https://oj.leetcode.com/discuss/857/constant-space-solution">this forum</a></strong>.</p>

<blockquote><p>A straightforward implementation is to use an array of size 32 to keep track of the total count of ith bit.</p></blockquote>

<p>A more detailed <a href="http://leetcodesolutions.blogspot.sg/2013/10/single-number-ii.html">explanation</a>:</p>

<blockquote cite="http://leetcodesolutions.blogspot.sg/2013/10/single-number-ii.html">
    <div >
        <span style="font-family: Times, Times New Roman, serif;" class="font-color">For eg : A = [ 2, 3, 3, 3]</span>
    </div>
    <div >
        <span style="font-family: Times, Times New Roman, serif;" class="font-color">We count the number of 1s for each bit position. Then find <i>mod 3 </i>of each of them. The bit positions having <i>mod 3 </i>&nbsp;equal to one are the bits that are set due to the number occurring once.</span>
    </div>
    <div >
        <span style="font-family: Times, Times New Roman, serif;" class="font-color">Writing the Binary Representation of the numbers.</span>
    </div>
    <div >
        <span style="font-family: Times, Times New Roman, serif;" class="font-color">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 0 1 0</span>
    </div>
    <div >
        <span style="font-family: Times, Times New Roman, serif;" class="font-color">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 0 1 1</span>
    </div>
    <div >
        <span style="font-family: Times, Times New Roman, serif;" class="font-color">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 0 1 1</span>
    </div>
    <div >
        <span style="font-family: Times, Times New Roman, serif;" class="font-color">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 0 1 1</span>
    </div>
    <div >
        <span style="font-family: Times, Times New Roman, serif;" class="font-color">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#8212;&#8212;&#8212;&#8212;&#8212;-</span>
    </div>
    <div >
        <span style="font-family: Times, Times New Roman, serif;" class="font-color">We count the number of 1s for each bit -&gt; &nbsp;0 0 4 3</span>
    </div>
    <div >
        <span style="font-family: Times, Times New Roman, serif;" class="font-color">Taking modulo 3 we get &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 0 1 0</span>
    </div>
    <div >
        <span style="font-family: Times, Times New Roman, serif;" class="font-color">and that&#8217;s our answer. -&gt; 2</span>
    </div>

</blockquote>


<p><strong>Second solution is different, and very hard to read/write</strong>. I will not cover this solution. An analysis is found <a href="http://zhaohongze.com/wordpress/2013/12/04/leetcode-single-number-ii/">here</a>:</p>

<blockquote><p>The basic idea is use two integer, <strong>ones and twos</strong>. <strong>Ones</strong> is used to record the bits only exist once in current iterated number. <strong>Twos</strong> is used to record the bits only exist twice in all number. If a bit exists up to three times, we should clear it in both ones and twos.</p></blockquote>

<h3>Code</h3>

<p><strong>my code</strong></p>

<pre><code>public int singleNumber(int[] A) {
    int result = 0;
    for (int i = 0; i &lt; 32; i++) {
        int count = 0;
        for (Integer in: A) {
            count += (in &amp; (1 &lt;&lt; i)) == 0 ? 0 : 1;
        }
        if (count % 3 != 0) {
            result = result | (1 &lt;&lt; i);
        }
    }
    return result;
}
</code></pre>

<p><strong>a different solution</strong></p>

<pre><code>public int singleNumber(int[] A) {
    int ones = 0, twos = 0;
    for (int i = 0; i &lt; A.length; i++) {
        twos = twos | (ones &amp; A[i]);
        ones = ones ^ A[i];

        int common_mask = ~(ones &amp; twos);
        ones &amp;= common_mask;
        twos &amp;= common_mask;
    }
    return ones;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/01/Single-Number/">[LeetCode 136] Single Number</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-01T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/single-number/">link</a></p>

<div class="question-content bg-color bg-img font-color">
            <p class="font-color"></p><p class="font-color">Given an array of integers, every element appears <i>twice</i> except for one. Find that single one.</p>

<p class="font-color">
<b>Note:</b><br>
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
</p><p class="font-color"></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>First solutions is bit manipulation</strong>.</p>

<blockquote><p>If two numbers are the same, then XOR result is 0.</p></blockquote>

<p>And for negative integers:</p>

<blockquote><p>A negative number is a <a href="http://en.wikipedia.org/wiki/Bit_field">bit field</a> just like a positive number. XOR doesn&rsquo;t care</p></blockquote>

<p>Follow-up question, what if the input is not an array in interger, but a bunch of Strings? <a href="http://stackoverflow.com/a/35271">This guy</a> have the answer.</p>

<blockquote><p>There are ways of XORing strings by XORing the individual chars &ndash; you would just have to have a temporary variable as large as the largest string.</p>

<p>What wouldn&rsquo;t work is trying to XOR a linked list or some other complicated data structure.</p></blockquote>

<p>Which is to say, a string is just like an array of chars (integers). For every char (integer), just apply the same method and we shall have the answer.</p>

<p><strong>Second solution is HashSet</strong>, but must use more space. Code is posted below as well.</p>

<p>Someone also sort then find, but this takes more time.</p>

<h3>Code</h3>

<p><strong>First, XOR solution</strong></p>

<pre><code>public int singleNumber(int[] A) {
    int num = A[0];
    for (int i = 1; i &lt; A.length; i ++)
        num = num ^ A[i];
    return num;
}
</code></pre>

<p><strong>Second, HashSet solution</strong></p>

<p>The last line &ldquo;return -1&rdquo; is only for compiling purposes, and will not be executed.</p>

<pre><code>public int singleNumber(int[] A) {
    HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
    for (int i = 0; i &lt; A.length; i ++) {
        if (set.contains(A[i]))
            set.remove(A[i]);
        else
            set.add(A[i]);
    }
    for (Integer a: set)
        return a;
    return -1;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/31/Gas-Station/">[LeetCode 134] Gas Station</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-31T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/gas-station/">link</a></p>

<div class="question-content">
            <p class="font-color"></p><p class="font-color">
There are <i>N</i> gas stations along a circular route, where the amount of gas at station <i>i</i> is <code>gas[i]</code>.
</p>

<p class="font-color">
You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <i>i</i> to its next station (<i>i</i>+1). You begin the journey with an empty tank at one of the gas stations.
</p>

<p class="font-color">
Return the starting gas station&#8217;s index if you can travel around the circuit once, otherwise return -1.
</p>

<p class="font-color">
<b>Note:</b><br>
The solution is guaranteed to be unique.
</p><p class="font-color"></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a tough question, which requires a lot of math-related thinking</strong>.</p>

<p><strong>My solution is IMHO very simple and easy</strong>. I first do a cumulation of gas from beginning to the end, and find the lowest cumulative value of the  gas tank (of course can be negative). That point is where I start the journey, which is to say, I will validate the path from that point, and then return the result.</p>

<p><strong>This idea is not seen on Internet</strong>, although it is just 2 loops thru the list, and time complexity is also O(n). Anyway, there&rsquo;s a great solution which most people uses.</p>

<p><strong>There&rsquo;s a great <a href="https://oj.leetcode.com/discuss/4159/share-some-of-my-ideas">post</a> that gives 2 valid conclusions</strong>:</p>

<blockquote><ol>
<li>If car starts at A and can not reach B (let&rsquo;s say B is the first station that A can not reach), then any station between A and B can not reach B.</li>
<li>If the total number of gas is bigger than the total number of cost. There must be a valid solution.</li>
</ol>
</blockquote>

<p>From here, a great solution can be found.</p>

<h3>Solution</h3>

<p><strong>A very detailed explanation and code is found from <a href="http://leetcodenotes.wordpress.com/2013/11/21/leetcode-gas-station-%E8%BD%AC%E5%9C%88%E7%9A%84%E5%8A%A0%E6%B2%B9%E7%AB%99%E7%9C%8B%E8%83%BD%E4%B8%8D%E8%83%BD%E8%B5%B0%E4%B8%80%E5%9C%88/">this blog</a></strong>.</p>

<blockquote><ol>
<li>从i开始，j是当前station的指针，sum += gas[j] – cost[j] （从j站加了油，再算上从i开始走到j剩的油，走到j+1站还能剩下多少油）</li>
<li>如果sum &lt; 0，说明从i开始是不行的。那能不能从i..j中间的某个位置开始呢？假设能从k (i &lt;=k&lt;=j)走，那么i..j &lt; 0，若k..j >=0，说明i..k – 1更是&lt;0，那从k处就早该断开了，根本轮不到j。</li>
<li>所以一旦sum&lt;0，i就赋成j + 1，sum归零。</li>
</ol>
</blockquote>

<p>And note that if i is moved to j, there is no need to check (0..old_i) again, because this range must be reachable (write code again for beter understanding).</p>

<p>Coding this solution <strong>is not easy</strong>! I failed to do it.</p>

<h3>Code</h3>

<p><strong>First, my solution</strong></p>

<pre><code>public int canCompleteCircuit(int[] gas, int[] cost) {
    int len = gas.length;
    if (len == 0) return -1;
    int start = -1, min = Integer.MAX_VALUE, total = 0;
    for (int i = 0; i &lt; len; i ++) {
        total += getDiff(gas, cost, i);
        if (total &lt; min) {
            min = total;
            start = i;
        }
    }
    start = (start + 1) % len;
    // now traverse the route from start 
    total = 0;
    for (int i = 0; i &lt; len; i ++) {
        total += getDiff(gas, cost, (start + i) % len);
        if (total &lt; 0) return -1; 
    }
    return start;
}

private int getDiff(int[] gas, int[] cost, int i) {
    return gas[i] - cost[i];
}
</code></pre>

<p><strong>Second, best solution</strong></p>

<pre><code>public int canCompleteCircuit(int[] gas, int[] cost) {
    int i = 0, j = 0;
    int sum = 0;
    int total = 0;
    while (j &lt; gas.length) {
        int diff = gas[j] - cost[j];
        if (sum + diff &lt; 0) {
            i = j + 1;
            sum = 0;
        } else {
            sum += diff;
        }
        j++;
        total += diff;
    }
    return total &gt;= 0 ? i : -1;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/31/Candy/">[LeetCode 135] Candy</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-31T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/candy/">link</a></p>

<div class="question-content">
            <p></p><p>
There are <i>N</i> children standing in a line. Each child is assigned a rating value. 
</p>
<p>
You are giving candies to these children subjected to the following requirements:
</p>
<ul>
<li>Each child must have at least one candy.</li>
<li>Children with a higher rating get more candies than their neighbors.</li>
</ul>
<p>
What is the minimum candies you must give?
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a difficult question</strong>.</p>

<p>Directly doing it will result in a lot of trace-backs. The following picture gives a clear idea of what the problem is:</p>

<p><img class="middle" src="/assets/images/candy.png"></p>

<p>When traversing from low to high (upward sloping), just increase candy, that&rsquo;s fine. But when sloping down, we would have no idea what value to set until we reach the min point. <strong><a href="http://fisherlei.blogspot.sg/2013/11/leetcode-candy-solution.html">Fish Lei</a> have a good solution of &ldquo;trace-back algorithm&rdquo;</strong> to re-adjust the values by traversing back to the top again.</p>

<p>However, I personally think the 2nd solution is way more splendid, that I will not cover 1st solution in detail.</p>

<h3>Solution</h3>

<p><strong>The 2nd solution is very similar to &ldquo;Trapping Rain Water&rdquo;</strong>. <a href="http://zhaohongze.com/wordpress/2013/12/10/leetcode-candy/">This blog</a> is the best explanation I found from Internet.</p>

<blockquote><ol>
<li>For the first time, scan from left to right. If current rating is larger than the left one, give one more candy to current child than the left one.</li>
<li>For the second time, scan from right to left. If current rating is larger than the right one, give one more candy to current child than the right one.</li>
</ol>


<p>We consider the policy as two folds, left policy and right policy. Left policy means a child has more candies than his left one if his rating is higher than his left one. The first scan ensures that the distribution meets left policy. The second scan ensures that the distribution meets right policy. However, it will not violate left policy.</p></blockquote>

<h3>Code</h3>

<p><strong>2nd solution</strong></p>

<pre><code>public int candy(int[] ratings) {
    int len = ratings.length;
    if (len &lt;= 1) return len;
    int[] candy = new int[len];
    candy[0] = candy[len-1] = 1;
    for (int i = 1; i &lt; len; i ++) {
        if (ratings[i] &gt; ratings[i-1])
            candy[i] = candy[i-1] + 1;
        else candy[i] = 1;
    }
    for (int i = len-2; i &gt;= 0; i --) {
        if (ratings[i] &gt; ratings[i+1])
            candy[i] = Math.max(candy[i], candy[i+1] + 1);
    }
    int sum = 0;
    for (int i = 0; i &lt; len; i ++) sum += candy[i];
    return sum;
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/18">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/16">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150/'>cc150 (2)</a></li>
<li class='category'><a href='/blog/categories/collection/'>collection (5)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (25)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (16)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (154)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (68)</a></li>
<li class='category'><a href='/blog/categories/thoughts/'>thoughts (4)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/08/08/Thread-pool-pattern/">[Design] Thread Pool Pattern</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/08/Producer-consumer-problem/">[Design] Producer Consumer Problem</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/08/Max-sum-non-consecutive/">[Question] Max Sum of Non-Consecutive Elements</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/08/Decimal-to-Hex/">[Question] Decimal to Hexadecimal</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/07/Million-phone-numbers/">[Google] Million Phone Numbers</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
