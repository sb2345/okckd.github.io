
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="Question link Given a binary tree, flatten it to a linked list in-place. For example,
Given 1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/22">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/28/Flatten-Binary-Tree-to-Linked-List/">[LeetCode 114] Flatten Binary Tree to Linked List</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a binary tree, flatten it to a linked list in-place.
</p>

<p>
For example,<br>
Given
</p><pre>         1
        / \
       2   5
      / \   \
     3   4   6
</pre>
<p></p>

The flattened tree should look like:<br>
<pre>   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
</pre>

<div class="spoilers" ><b>Hints:</b>
<p>If you notice carefully in the flattened tree, each node&#8217;s right child points to the next node of a pre-order traversal.</p>
</div><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very difficult question</strong>, and there are many solutions.</p>

<h3>Solution</h3>

<p><strong>Analysis of all solutions (except first one) is found in <a href="http://n00tc0d3r.blogspot.sg/2013/03/flatten-binary-tree-to-linked-list-in.html">this great article</a></strong>.</p>

<p><strong>Solution 1 is my code</strong>, I am make use of a &lsquo;pre&rsquo; pointer in this recursive method. This idea is actually quite good, but is never seen in any other people&rsquo;s blogs.</p>

<p><strong>Solution 2 is the most standard recursive solution</strong>. It passes in a node, flatten it and return the last node after it&rsquo;s flattened. So we can flatten root node&rsquo;s left and right node respectively, and then connect it.</p>

<blockquote cite="http://n00tc0d3r.blogspot.sg/2013/03/flatten-binary-tree-to-linked-list-in.html">
To flatten a binary tree, according to the given example, is to recursively insert the left subtree to the right subtree and append the original right subtree to the end of the left subtree, i.e.<br>
<pre>     root                        root
     /  \            -&gt;            \
  left  right                      left
                                     \
                                    right
</pre>
Since we need to append the original right-tree to the end of the left subtree, we let the recursion function return the last node after flatten.
</blockquote>


<p>I missed &ldquo;root.left = null&rdquo; while coding, and it resulted in long long time debugging. I think this is a very silly mistake.</p>

<p><strong>Solution 3 is making use of a stack</strong>. I have to say, although I can figure how it works, I am still blur about the thinking process of this entire idea. Which is to say, I can&rsquo;t keep it in mind even after learning it.</p>

<p>I shall try write this code in the future.</p>

<blockquote>
We can also solve the problem without recursion.<br>
<br>
To do that, we can use a stack to store all right subtrees when we prune them temporarily, and append each of them back after we go through the corresponding left subtree.<br>
<br>
Basically, given a non-empty tree,<br>
<ul>
<li>if it has left subtree, store the right subtree (if not null) to stack, move the left subtree to right;</li>
<li>if not, append back a subtree from stack to the current node&#8217;s right;</li>
<li>continue to the right node until finish.</li>
</ul>
</blockquote>


<p><strong>Solution 4 is what I believe the best solution</strong>. It simple uses while loop to put all nodes in the correct position, without recursion or stack.</p>

<blockquote><p>Each time when we prune a right subtree, we use while-loop to find the right-most leaf of the current left subtree, and append the subtree there.</p></blockquote>

<p><strong>Analysis of all solutions (except first one) is found in <a href="http://n00tc0d3r.blogspot.sg/2013/03/flatten-binary-tree-to-linked-list-in.html">this great article</a></strong>.</p>

<h3>Code</h3>

<p><strong>First, my solution</strong>, a kind of recursive solution</p>

<pre><code>public void flatten(TreeNode root) {
    helper(new TreeNode(1234), root);
}

private TreeNode helper(TreeNode pre, TreeNode node) { 
    // pre cannot be null, this function return the last node of the flatten list
    if (node == null) return pre;
    pre.left = null;
    pre.right = node;
    TreeNode a = node.left;
    TreeNode b = node.right;
    TreeNode temp = helper(node, a);
    return helper(temp, b);
}
</code></pre>

<p><strong>Second, standard recursive solution</strong></p>

<pre><code>public void flatten(TreeNode root) {
    helper(root);
}

private TreeNode helper(TreeNode root) {
    if (root == null) return null;
    TreeNode oldRight = root.right;
    if (root.left != null) {
        root.right = root.left;
        // I missed this line of code: 
        root.left = null;
        root = helper(root.right);
    }
    if (oldRight != null) {
        root.right = oldRight;
        root = helper(root.right);
    }
    // return value is the last element of the flatten tree
    return root;
}
</code></pre>

<p><strong>Third, stack non-recursive solution</strong></p>

<pre><code>public void flatten(TreeNode root) {
    TreeNode cur = root;
    Stack&lt;TreeNode&gt; rtrees = new Stack&lt;TreeNode&gt;();
    while (cur != null) {
        while (cur.left != null) {
            if (cur.right != null)
                rtrees.push(cur.right);
            cur.right = cur.left;
            cur.left = null;
            cur = cur.right;
        }
        if (cur != null &amp;&amp; cur.right == null &amp;&amp; !rtrees.isEmpty()) {
            cur.right = rtrees.pop();
        }
        cur = cur.right;
    }
}
</code></pre>

<p><strong>Fourth, non-stack non-recursive solution</strong></p>

<pre><code>public void flatten(TreeNode root) {
    TreeNode cur = root;
    while (cur != null) {
        if (cur.left != null) {
            if (cur.right != null) { // if we need to prune a right subtree
                TreeNode next = cur.left;
                while (next.right != null)
                    next = next.right;
                next.right = cur.right;
            }
            cur.right = cur.left;
            cur.left = null;
        }
        cur = cur.right;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/28/Binary-Tree-Maximum-Path-Sum/">[LeetCode 124] Binary Tree Maximum Path Sum</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/binary-tree-maximum-path-sum/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a binary tree, find the maximum path sum.
</p>

<p>
The path may start and end at any node in the tree.
</p>

<p>
For example:<br>
Given the below binary tree,
</p><pre>       1
      / \
     2   3
</pre>
<p></p>
<p>
Return <code>6</code>.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a difficult DFS question</strong>.</p>

<p>The basic idea is:</p>

<blockquote><p>When we are in a root node, how we decided to include current node in the maximum path sum? We need to calculate the depth in both subtree. In the meantime, we need to set a variable &ldquo;max&rdquo; to store the max path sum we found during the recursion.</p>

<p>Pay attention that when a subtree sum to negative value, we discard this subtree.</p>

<p>Otherwise, max path sum including current node is <strong>leftSum + cur.val + rightSum</strong></p>

<p>Max depth of current node is <strong>(maximum value of leftSum and rightSum) + cur.val</strong></p></blockquote>

<h3>Solution</h3>

<p>There are 2 points that may incur problems during coding, they are:</p>

<ol>
<li><p>The recursive solution is calculating the &lsquo;max height&rsquo; while checking &lsquo;its own max path sum&rsquo;. It&rsquo;s a bit hard to explain. Basic idea is doing 2 things at same time, while traversing (are one result is returned, another is stored in a public variable, at least for code 1 below).</p></li>
<li><p>Note that &lsquo;max height&rsquo; of a child branch can be nagative. In this case, WE MUST SET IT TO 0.</p></li>
</ol>


<p>The first point is a concept seen in previous questions, but I forgot which. The second point is important, because I missed this and got failed a few times without any clue.</p>

<h3>Code</h3>

<p><strong>First, recursive solution</strong></p>

<pre><code>int max = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) {
    maxHeight(root);
    return max;
}

private int maxHeight(TreeNode node) {
    if (node == null) return 0;
    int l = Math.max(0, maxHeight(node.left));
    int r = Math.max(0, maxHeight(node.right));
    max = Math.max(max, l + r + node.val);
    return node.val + Math.max(l, r);
}
</code></pre>

<p><strong>Second, previous code refactored</strong>.</p>

<p>I removed the global variable, and instead pass an array as reference in the recursion. In this way the &lsquo;shared&rsquo; array achieve same functionality as a global variable.</p>

<pre><code>public int maxPathSum(TreeNode root) {
    int[] shared = {Integer.MIN_VALUE};
    maxHeight(root, shared);
    return shared[0];
}

private int maxHeight(TreeNode node, int[] shared) {
    if (node == null) return 0;
    int l = Math.max(0, maxHeight(node.left, shared));
    int r = Math.max(0, maxHeight(node.right, shared));
    shared[0] = Math.max(shared[0], l + r + node.val);
    return node.val + Math.max(l, r);
}
</code></pre>

<p><strong>Updated on June 10th, it&rsquo;s a terrible practise to use global variable</strong>. The <a href="http://answer.ninechapter.com/solutions/binary-tree-maximum-path-sum/">new solution</a> suggested by Mr. Huang uses a new ResultType Class to solve the problem.</p>

<pre><code>private class ResultType {
    int singlePath, maxPath;
    ResultType(int singlePath, int maxPath) {
        this.singlePath = singlePath;
        this.maxPath = maxPath;
    }
}

public int maxPathSum(TreeNode root) {
    ResultType result = helper(root);
    return result.maxPath;
}

private ResultType helper(TreeNode node) {
    // null case
    if (node == null) {
        return new ResultType(0, Integer.MIN_VALUE);
    }
    // divide
    ResultType ll = helper(node.left);
    ResultType rr = helper(node.right);
    // conquer
    int curSinglePath = Math.max(0, node.val + 
            Math.max(ll.singlePath, rr.singlePath));
    int childMaxPath = Math.max(ll.maxPath, rr.maxPath);
    int curMaxPath = Math.max(childMaxPath, node.val + 
            ll.singlePath + rr.singlePath);
    // done
    return new ResultType(curSinglePath, curMaxPath);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/28/Best-Time-to-Buy-and-Sell-Stock-III/">[LeetCode 123] Best Time to Buy and Sell Stock III</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">link</a></p>

<div class="question-content">
            <p></p><p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>

<p>Design an algorithm to find the maximum profit. You may complete at most <i>two</i> transactions.</p>

<p><b>Note:</b><br>
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is much harder to solve then previous 2 question combined</strong>.</p>

<h3>Solution</h3>

<p><strong>Almost all solutions online are same</strong>, I think <a href="http://rleetcode.blogspot.sg/2014/02/best-time-to-buy-and-sell-stock-iii-java.html">this blog</a> explains it best.</p>

<blockquote><p>we can just dived the whole prices array at every point, try to calculate max profit from left and from right respectively&hellip;</p>

<p>However, there are many repeat calculations. So we can apply DP to record max profits for each left side and right side. then add them together at each point.</p></blockquote>

<p>A detailed illustration with examples can be found <a href="http://yucoding.blogspot.sg/2012/12/leetcode-question-10-best-time-to-buy.html">here</a>.</p>

<p>However, the coding part is slightly difficult at least for me. <strong>I made a terrible mistake with the variable &lsquo;leftMin&rsquo; and &lsquo;rightMax&rsquo;</strong>. I declared it as <strong>&lsquo;rightMin&rsquo;</strong> instead, and then the program logic is wrong. We should avoid this kind of mistakes.</p>

<h3>Code</h3>

<pre><code>public int maxProfit(int[] prices) {
    int len = prices.length;
    if (len == 0) return 0;
    int leftMin = Integer.MAX_VALUE, rightMax = Integer.MIN_VALUE;
    int leftPro[] = new int[len], rightPro[] = new int[len];
    for (int j = 0; j &lt;= len - 1; j ++) {
        leftMin = Math.min(leftMin, prices[j]);
        if (j == 0) leftPro[0] = 0;
        else leftPro[j] = Math.max(leftPro[j-1], prices[j] - leftMin);
    }
    for (int k = len - 1; k &gt;= 0; k --) {
        rightMax = Math.max(rightMax, prices[k]);
        if (k == len - 1) rightPro[len-1] = 0;
        else rightPro[k] = Math.max(rightPro[k+1], rightMax - prices[k]);
    }
    int totalPro = 0;
    for (int i = 0; i &lt; len; i ++) {
        totalPro = Math.max(totalPro, leftPro[i] + rightPro[i]);
    }
    return totalPro;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/28/Best-Time-to-Buy-and-Sell-Stock-II/">[LeetCode 122] Best Time to Buy and Sell Stock II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">link</a></p>

<div class="question-content">
            <p></p><p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>

<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Solution</h3>

<p><strong>This solution is best explained <a href="http://jane4532.blogspot.sg/2013/07/best-time-to-buy-and-sell-stock.html">here</a></strong>.</p>

<blockquote><p>就从左到右轮一遍，遇到递增的都给加起来呗。</p></blockquote>

<h3>Code</h3>

<pre><code>public int maxProfit(int[] prices) {
    int len = prices.length;
    if (len &lt;= 1) return 0;
    int profit = 0;
    for (int i = 1; i &lt; len; i ++) 
        profit += Math.max(0, prices[i] - prices[i-1]);
    return profit;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/28/Best-Time-to-Buy-and-Sell-Stock/">[LeetCode 121] Best Time to Buy and Sell Stock</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/">link</a></p>

<div class="question-content">
            <p></p><p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>

<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a question from a MIT course</strong>, <a href="http://courses.csail.mit.edu/iap/interview/materials.php">Hacking a Google Interview</a>.</p>

<p>I did not solve it, but it&rsquo;s actually very simple to do.</p>

<h3>Solution</h3>

<p>The solution is explained <a href="http://leetcode.com/2010/11/best-time-to-buy-and-sell-stock.html">here</a>:</p>

<blockquote><p>To solve this problem efficiently, you would need to track the minimum value’s index. As you traverse, update the minimum value’s index when a new minimum is met. Then, compare the difference of the current element with the minimum value. Save the buy and sell time when the difference exceeds our maximum difference (also update the maximum difference).</p>

<p>Time is O(N)</p></blockquote>

<h3>Code</h3>

<pre><code>public int maxProfit(int[] prices) {
    int len = prices.length;
    if (len &lt;= 1) return 0;
    int min = prices[0];
    int max = Integer.MIN_VALUE;
    for (int i = 1; i &lt; len; i ++) {
        max = Math.max(max, prices[i] - min);
        min = Math.min(min, prices[i]);
    }
    return Math.max(max, 0);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/27/Triangle/">[LeetCode 120] Triangle</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-27T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/triangle/">link</a></p>

<div class="question-content">
            <p></p><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>

<p>
For example, given the following triangle<br>
</p><pre>[
     [<font color="red">2</font>],
    [<font color="red">3</font>,4],
   [6,<font color="red">5</font>,7],
  [4,<font color="red">1</font>,8,3]
]
</pre>
<p></p>
<p>
The minimum path sum from top to bottom is <code>11</code> (i.e., <font color="red">2</font> + <font color="red">3</font> + <font color="red">5</font> + <font color="red">1</font> = 11).
</p>

<p>
<b>Note:</b><br>
Bonus point if you are able to do this using only <i>O</i>(<i>n</i>) extra space, where <i>n</i> is the total number of rows in the triangle.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a math question</strong>.</p>

<h3>Solution</h3>

<p>It&rsquo;s an easy question. Instead of normal DP transition function, this one is <strong>so-called bottom-up approach</strong>.</p>

<h3>Code</h3>

<pre><code>public int minimumTotal(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; triangle) {
    int len = triangle.size();
    if (len == 0) return 0;
    int[] m = new int[len];
    m[0] = triangle.get(0).get(0);
    for (int i = 1; i &lt; len; i ++) {
        ArrayList&lt;Integer&gt; cur = triangle.get(i);
        for (int j = i; j &gt;= 0; j --) {
            if (j == i) m[j] = m[j-1] + cur.get(j);
            else if (j == 0) m[j] = m[0] + cur.get(0);
            else m[j] = Math.min(m[j-1], m[j]) + cur.get(j);
        }
    }
    int min = Integer.MAX_VALUE;
    for (Integer k: m)
        min = Math.min(min, k);
    return min;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/27/Populating-Next-Right-Pointers-in-Each-Node-II/">[LeetCode 117] Populating Next Right Pointers in Each Node II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-27T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">link</a></p>

<div class="question-content">
            <p></p><p>Follow up for problem &#8221;<i>Populating Next Right Pointers in Each Node</i>&#8221;.</p>
<p>What if the given tree could be any binary tree? Would your previous solution still work?</p>
<p>
<b>Note:</b>
</p><ul><li>You may only use constant extra space.</li></ul>
<p></p>
<p>
For example,<br>
Given the following binary tree,<br>
</p><pre>         1
       /  \
      2    3
     / \    \
    4   5    7
</pre>
<p></p>
<p>
After calling your function, the tree should look like:<br>
</p><pre>         1 -&gt; NULL
       /  \
      2 -&gt; 3 -&gt; NULL
     / \    \
    4-&gt; 5 -&gt; 7 -&gt; NULL
</pre>
<p></p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a difficult question</strong>.</p>

<p>We can of course do a BFS, but that&rsquo;s too simple, and it&rsquo;s not related to previous question, thus <strong>Queue</strong> is not the answer we&rsquo;re looking for.</p>

<p><strong>There are 2 ways to solve this problem, recursively and iteratively</strong>. The 2 solutions are quite different, I will explain 1 by 1.</p>

<h3>Solution</h3>

<p><strong>First solution is non-recursion, which is from <a href="http://rleetcode.blogspot.sg/2014/03/follow-up-for-problem-populating-next.html">this blog</a></strong>. First we declare a pointer &lsquo;cur&rsquo; that points to a node. We assume the &lsquo;next-links&rsquo; are already built in current level, and our job is to generate the &lsquo;next-links&rsquo; for the next level.</p>

<p>In order to do that, we need another 2 pointers in the next level (one head and one tail) to keep track of the position till where we have finished building the links. So &lsquo;cur&rsquo; keep traversing thru current level, until it reaches the end. Then, we move &lsquo;cur&rsquo; to the head of next level, and continue the process.</p>

<p>The coding part is not difficult, <strong>which is not the case for next solution</strong>.</p>

<p><strong>Second solution is recursive, and it is written in <a href="http://fisherlei.blogspot.sg/2012/12/leetcode-populating-next-right-pointers_29.html">this blog</a></strong>. Same as previous solution, we assume that current level have all &lsquo;next-links&rsquo; ready, and we will build these links for next level.</p>

<p>The way of getting next link for child nodes is a bit different, but I guess that&rsquo;s fine. The difficult part is <strong>during recursive call, I NEED TO CALL THE RECURSION METHOD FOR RIGHT CHILD FIRST, THEN LEFT CHILD</strong>. The reason is, the links from left child to right child is going to be used in the recursion call. If we do left first, we will have problem getting <strong>current.left.next</strong> (which in this case, will be null). I spent a terribly long time debugging this error, and finally found a great explanation <a href="https://oj.leetcode.com/discuss/1942/anyone-helps-to-find-bug-for-my-code">here</a>.</p>

<blockquote><p>in your code: connect(root->left); connect(root->right);</p>

<p>which means you first recurs left sub-tree, then right subtree. The problem is the right subtree&rsquo;s next pointers are not processed. So in your example, 9->next should be 1, however, when you traverse the left sub tree, 9&rsquo;s next pointer is still NULL. Your code will think 9 is the end of the third level, so the fourth level&rsquo;s 0 will have its next to be NULL.</p></blockquote>

<h3>Code</h3>

<p><strong>First, my initial solution making use of queue</strong>. It is around 50ms slower than the other solutions.</p>

<pre><code>public void connect(TreeLinkNode root) {
    if (root == null) return;
    LinkedList&lt;TreeLinkNode&gt; list = new LinkedList&lt;TreeLinkNode&gt;();
    list.add(root);
    while (! list.isEmpty()) {
        LinkedList&lt;TreeLinkNode&gt; newList = new LinkedList&lt;TreeLinkNode&gt;();
        while (! list.isEmpty()) {
            TreeLinkNode node = list.remove();
            if (! list.isEmpty()) node.next = list.get(0);
            if (node.left != null) newList.add(node.left);
            if (node.right != null) newList.add(node.right);
        }
        list = newList;
    }
}
</code></pre>

<p><strong>Second, non-recursion solution</strong></p>

<pre><code>public void connect(TreeLinkNode root) {
    TreeLinkNode nextLevelHead = null;
    TreeLinkNode nextLevelTail = null;
    TreeLinkNode cur = root;
    while (cur != null) {
        if (cur.left != null) {
            if (nextLevelHead == null) {
                nextLevelHead = cur.left;
                nextLevelTail = cur.left;
            }
            else {
                nextLevelTail.next = cur.left;
                nextLevelTail = cur.left;
            }
        }
        if (cur.right != null) {
            if (nextLevelHead == null) {
                nextLevelHead = cur.right;
                nextLevelTail = cur.right;
            }
            else {
                nextLevelTail.next = cur.right;
                nextLevelTail = cur.right;
            }
        }
        cur = cur.next;
        if (cur == null) {
            cur = nextLevelHead;
            nextLevelHead = null;
            nextLevelTail = null;
        }
    }
}
</code></pre>

<p><strong>Third, recursive solution</strong></p>

<pre><code>public void connect(TreeLinkNode root) {
    if (root == null) return;
    // now find root.next's valid child
    TreeLinkNode n = root.next, nextLevelNext = null;
    while (n != null &amp;&amp; nextLevelNext == null) {
        if (n.left != null) {
            nextLevelNext = n.left;
            break;
        }
        if (n.right != null) {
            nextLevelNext = n.right;
            break;
        }
        n = n.next;
    }
    // now nextLevelNext is fetched
    if (root.right != null) 
        root.right.next = nextLevelNext;
    if (root.left != null) 
        root.left.next = root.right == null ? nextLevelNext : root.right;
    // recursion call
    connect(root.right);
    connect(root.left);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/27/Populating-Next-Right-Pointers-in-Each-Node/">[LeetCode 116] Populating Next Right Pointers in Each Node</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-27T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a binary tree
</p><pre>    struct TreeLinkNode {
      TreeLinkNode *left;
      TreeLinkNode *right;
      TreeLinkNode *next;
    }
</pre>
<p></p>

<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>

<p>Initially, all next pointers are set to <code>NULL</code>.</p>

<p>
<b>Note:</b>
</p><ul>
<li>You may only use constant extra space.</li>
<li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li>
</ul>
<p></p>

<p>
For example,<br>
Given the following perfect binary tree,<br>
</p><pre>         1
       /  \
      2    3
     / \  / \
    4  5  6  7
</pre>
<p></p>
<p>
After calling your function, the tree should look like:<br>
</p><pre>         1 -&gt; NULL
       /  \
      2 -&gt; 3 -&gt; NULL
     / \  / \
    4-&gt;5-&gt;6-&gt;7 -&gt; NULL
</pre>
<p></p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>Although this question is not hard, it needs a bit thinking</strong>.</p>

<p>The important point is, how to effectively make use of the &lsquo;next link&rsquo; generated before, to help us solve this problem.</p>

<h3>Solution</h3>

<p><strong>My solution is actually very good</strong>. It pass current node and next node into a method, and then generate links for current node&rsquo;s children.</p>

<p><strong>There is a even <a href="http://leetcode.com/2010/03/first-on-site-technical-interview.html">better solution</a></strong>, which directly make use of the &lsquo;next link&rsquo; generated already. In fact, it&rsquo;s same as my solution, except it uses one less variable. Great idea it is!</p>

<h3>Code</h3>

<p><strong>First, my solution</strong></p>

<pre><code>public void connect(TreeLinkNode root) {
    link(root, null);
}

private void link(TreeLinkNode node, TreeLinkNode rr){
    if (node == null || node.left == null) return;
    node.left.next = node.right;
    if (rr == null) node.right.next = null;
    else node.right.next = rr.left;

    link(node.left, node.left.next);
    link(node.right, node.right.next);
}
</code></pre>

<p><strong>Second, better solution</strong></p>

<pre><code>public void connect(TreeLinkNode root) {
    if (root == null || root.left == null || root.right == null) 
        return;
    root.left.next = root.right;
    root.right.next = root.next == null ? null : root.next.left;
    connect(root.left);
    connect(root.right);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/27/Path-Sum-II/">[LeetCode 113] Path Sum II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-27T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/path-sum-ii/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a binary tree and a sum, find all root-to-leaf paths where each path&#8217;s sum equals the given sum.
</p>

For example:<br>
Given the below binary tree and <code>sum = 22</code>,
<pre>              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
</pre>

<p>
return<br>
</p><pre>[
   [5,4,11,2],
   [5,8,4,5]
]
</pre>
<p></p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a standard question</strong></p>

<h3>Solution</h3>

<p>My code is simple DFS. However, the coding part is not easy. Note that value can be negative, and think about when to add result into list.</p>

<p>Just write it by hand and get an idea of it.</p>

<h3>Code</h3>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    helper(root, sum, new ArrayList&lt;Integer&gt;(), ans);
    return ans;
}

private void helper(TreeNode node, int total, ArrayList&lt;Integer&gt; list, 
                    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans) {
    if (node == null) return;
    list.add(node.val);
    if (node.val == total &amp;&amp; node.left == null &amp;&amp; node.right == null)
        ans.add(new ArrayList(list));
    helper(node.left, total - node.val, list, ans);
    helper(node.right, total - node.val, list, ans);
    list.remove(list.size() - 1);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/27/Path-Sum/">[LeetCode 112] Path Sum</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-27T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/path-sum/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
</p>

For example:<br>
Given the below binary tree and <code>sum = 22</code>,
<pre>              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
</pre>

<p>
return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question can be solved with either DFS or BFS</strong>.</p>

<h3>Solution</h3>

<p>My code is <strong>DFS recursion</strong>.</p>

<p>I found another BFS non-recursive solution <a href="http://www.programcreek.com/2013/01/leetcode-path-sum/">here</a>, but I did not post this code, because this question is too simple.</p>

<p><strong>One more thing, the last line of code has a \|\| operation</strong>. Isn&rsquo;t it duplicate execution? I mean if answer is found in root.left, no need to check root.right.</p>

<p>Actually it&rsquo;s not duplication. The <a href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op2.html">official doc</a> explains it:</p>

<blockquote><p>The &amp;&amp; and \|\| operators perform Conditional-AND and Conditional-OR operations on two boolean expressions. These operators exhibit &ldquo;short-circuiting&rdquo; behavior, which means that the second operand is evaluated only if needed.</p></blockquote>

<h3>Code</h3>

<pre><code>public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null) return false;
    if (root.left == null &amp;&amp; root.right == null) 
        return (sum == root.val);
    return hasPathSum(root.left, sum - root.val) 
        || hasPathSum(root.right, sum - root.val);
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/23">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/21">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150/'>cc150 (3)</a></li>
<li class='category'><a href='/blog/categories/collection/'>collection (5)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (37)</a></li>
<li class='category'><a href='/blog/categories/facebook/'>facebook (2)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (20)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (155)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (76)</a></li>
<li class='category'><a href='/blog/categories/thoughts/'>thoughts (4)</a></li>
<li class='category'><a href='/blog/categories/twitter/'>twitter (1)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/08/18/Leetcode-second-third/">[Leetcode] Leetcode Second Round (3)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/17/Numbers-Concatenation-Max/">[Question] Numbers Concatenation to Get Max Value</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/17/Number-of-tree-given-preorder-postorder/">[Question] Number of Valid Trees Given Preorder and Postorder</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/17/Expression-evaluation/">[Twitter] Arithmetic Expression Evaluation</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/16/orthogonal-traverse-map/">[Google] Orthogonal Traverse the Map (`)</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
