
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Woodstock Blog</title>
  <meta name="author" content="Charlie Brown">

  
  <meta name="description" content="Question link Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.
An example is the root-to-leaf &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/24">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Woodstock Blog</a></h1>
  
    <h2>What's the good of living if you don't try a few things?</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/29/Sum-Root-to-Leaf-Numbers/">[LeetCode 129] Sum Root to Leaf Numbers</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-29T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/sum-root-to-leaf-numbers/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p>

<p>Find the total sum of all root-to-leaf numbers.</p>

<p>For example,
</p><pre>    1
   / \
  2   3
</pre>
<p></p>
<p>
The root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.<br>
The root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.
</p>
<p>
Return the sum = 12 + 13 = <code>25</code>.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">10 minutes</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is DFS standard question</strong>.</p>

<h3>Solution</h3>

<p>I posted 2 pieces of my code, and 1 best code (from <a href="http://blog.sina.com.cn/s/blog_b9285de20101iv6l.html">this blog</a>).</p>

<h3>Code</h3>

<p><strong>First, my solution using List</strong>.</p>

<pre><code>int sum = 0;

public int sumNumbers(TreeNode root) {
    dfs(root, new LinkedList&lt;Integer&gt;());
    return sum;
}

private void dfs(TreeNode node, LinkedList&lt;Integer&gt; list) {
    if (node == null) return;
    if (node.left == null &amp;&amp; node.right == null) {
        int num = 0;
        for (int i = 0; i &lt; list.size(); i ++) 
            num = num * 10 + list.get(i);
        sum += num * 10 + node.val;
        return;
    }
    // if node is not null, not a leaf
    list.add(node.val);
    dfs(node.left, list);
    dfs(node.right, list);
    list.remove(list.size() - 1);
}
</code></pre>

<p><strong>Second, previous code refactored, without using list</strong>, because it&rsquo;s not necessary to know the previous path.</p>

<pre><code>int sum = 0;
public int sumNumbers(TreeNode root) {
    dfs(root, 0);
    return sum;
}

private void dfs(TreeNode node, int preVal) {
    if (node == null) return;
    int curVal = preVal * 10 + node.val;
    if (node.left == null &amp;&amp; node.right == null) {
        int num = 0;
        sum += curVal;
        return;
    }
    // if node is not null, not a leaf
    dfs(node.left, curVal);
    dfs(node.right, curVal);
}
</code></pre>

<p><strong>Third, best solution</strong></p>

<pre><code>public int sumNumbers(TreeNode root) {
    return dfs(root,0);
}

int dfs(TreeNode root, int sum){
    if(root==null) return 0;
    sum=sum*10+root.val;
    if(root.left==null &amp;&amp; root.right==null) return sum;
    return dfs(root.left,sum) + dfs(root.right,sum);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/29/Palindrome-Partitioning/">[LeetCode 131] Palindrome Partitioning</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-29T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/palindrome-partitioning/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a string <i>s</i>, partition <i>s</i> such that every substring of the partition is a palindrome.
</p>
<p>
Return all possible palindrome partitioning of <i>s</i>.
</p>
<p>
For example, given <i>s</i> = <code>"aab"</code>,<br>

Return
</p><pre>  [
    ["aa","b"],
    ["a","a","b"]
  ]
</pre>
<p></p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is an extremely classic question</strong>.</p>

<p>It&rsquo;s not very hard to solve, although it looked impossible at first.</p>

<h3>Solution</h3>

<p><strong>The solution is DFS</strong>.</p>

<p>It&rsquo;s very standard DFS code, I will not go into coding details. This type of &ldquo;return all possible path&rdquo; question is always related to DFS, keep this in mind!</p>

<p>The code is borrowing ideas from <a href="http://blog.sina.com.cn/s/blog_b9285de20101jbtl.html">peking2&rsquo;s blog</a>. He also had an <strong>analysis on this series of questions</strong>:</p>

<blockquote><p>我觉得一般有三种变形，解法各有不同。</p>

<ol>
<li>最后结果是一个整数，比如Palindrome Partitioning II。这个用DP来解</li>
<li>最后求一个结果，比如最小切法。这个用DP＋backtrack来解</li>
<li>求所有的结果。这个一般用DFS来解。</li>
</ol>
</blockquote>

<p>This question is the 3rd case. <a href="http://fisherlei.blogspot.sg/2013/03/leetcode-palindrome-partitioning.html">Fish Lei</a> also said the same.</p>

<blockquote><p>这种需要输出所有结果的基本上都是DFS的解法</p></blockquote>

<h3>Code</h3>

<pre><code>public ArrayList&lt;ArrayList&lt;String&gt;&gt; partition(String s) {
    // int len = s.length();
    ArrayList&lt;ArrayList&lt;String&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;String&gt;&gt;();
    helper(ans, new ArrayList&lt;String&gt;(), s, 0);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;String&gt;&gt; ans, ArrayList&lt;String&gt; cur, 
        String s, int start) {
    int len = s.length();
    if (start == len) {
        ans.add(new ArrayList&lt;String&gt;(cur));
        return;
    }
    for (int i = start + 1; i &lt;= len; i ++) {
        String sub = s.substring(start, i);
        if (isPal(sub)) {
            cur.add(sub);
            helper(ans, cur, s, i);
            cur.remove(cur.size() - 1);
        }
    }
}

private boolean isPal(String str) {
    int left = 0, right = str.length() - 1;
    while (left &lt; right) {
        if (str.charAt(left) != str.charAt(right)) 
            return false;
        left++;
        right--;
    }
    return true;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/29/Longest-Consecutive-Sequence/">[LeetCode 128] Longest Consecutive Sequence</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-29T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/longest-consecutive-sequence/">link</a></p>

<div class="question-content">
            <p></p><p>
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
</p>
<p>
For example,<br>
Given <code>[100, 4, 200, 1, 3, 2]</code>,<br>
The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Return its length: <code>4</code>.
</p>
<p>
Your algorithm should run in O(<i>n</i>) complexity.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">just coding is easy</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>I did not solve this question</strong>. We are going to make use of <strong>HashSet</strong>.</p>

<p>Information on HashSet from <a href="http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html">official document</a>:</p>

<blockquote><p><strong>java.util.HashSet</strong></p>

<p>This class <strong>implements the Set interface</strong>, backed by a <strong>hash table</strong> (actually a HashMap instance). It makes no guarantees as to the <strong>iteration order</strong> of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the <strong>null element</strong>.</p>

<p>This class offers <strong>constant time performance</strong> for the basic operations (add, remove, contains and size), assuming the hash function disperses the elements properly among the buckets. Iterating over this set requires time proportional to the sum of the HashSet instance&rsquo;s size (the number of elements) plus the &ldquo;capacity&rdquo; of the backing HashMap instance (the number of buckets). Thus, it&rsquo;s very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.</p>

<p>Note that this implementation is <strong>not synchronized</strong>. If multiple threads access a hash set concurrently, and at least one of the threads modifies the set, it must be synchronized externally.</p></blockquote>

<p><strong>To summarize it, HashSet</strong>:</p>

<ol>
<li><p>implements Set interface</p></li>
<li><p>implemented by using a hash table</p></li>
<li><p>un-ordered</p></li>
<li><p>add, remove and contains methods have constant time O(1)</p></li>
<li><p>can have null element</p></li>
<li><p>not sync</p></li>
</ol>


<h3>Solution</h3>

<p><strong>Well explained in <a href="http://stackoverflow.com/a/7453295">this site</a></strong>.</p>

<blockquote><p>Dump everything to a hash set.</p>

<p>Now go through the hashset. For each element, look up the set for all values neighboring the current value. Keep track of the largest sequence you can find, while removing the elements found from the set. Save the count for comparison.</p>

<p>Repeat this until the hashset is empty.</p>

<p>Assuming lookup, insertion and deletion are O(1) time, this algorithm would be O(N) time.</p></blockquote>

<p><strong>Updated on July 4th, 2014</strong>: Look at the 2nd for-loop. Here if I do &lsquo;for (Integer in: set)&rsquo; to iterate all numbers, I will get &ldquo;java.util.ConcurrentModificationException &rdquo;. This is because we are iterating while modifying. <strong>The most tricky part of this solution is iteration thru the array</strong>, instead of the set. Take note of that!</p>

<h3>Code</h3>

<pre><code>public int longestConsecutive(int[] num) {
    int longest = 1;
    HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
    for (Integer in: num) set.add(in);
    for (Integer in: num) {
        int left = in - 1, right = in + 1;
        while (set.contains(left)) {
            set.remove(left);
            left --;
        }
        while (set.contains(right)) {
            set.remove(right);
            right ++;
        }
        longest = Math.max(longest, right - left - 1);
    }
    return longest;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/29/DFS-BFS-space-efficiency/">[Design] DFS, BFS and Space Efficiency</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-29T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>First Word</h3>

<p>This post talks about BFS, DFS and space efficiency.</p>

<h3>Analysis</h3>

<p><strong>For BFS</strong> it&rsquo;s easy to understand. It is implemented with a queue. <strong>Space usage is O(width)</strong></p>

<p><strong>For DFS</strong>, there are 2 types: true DFS and pseudo-DFS. True DFS space usage is <strong>O(depth)</strong>, while psudo-DFS is <strong>O(depth x <a href="http://en.wikipedia.org/wiki/Branching_factor">branching factor</a>)</strong>.</p>

<blockquote><p><strong>branching factor</strong> is the number of children at each node, the outdegree.</p></blockquote>

<p>Pseudo-DFS is implemented by <strong>simply take the BFS implementation and replace the Queue with Stack</strong>. But true-DFS is a very different algorithm where the <strong>stack is use for backtracking only</strong>. <a href="http://stackoverflow.com/a/20429574">This</a> is a great article talking about this topic.</p>

<blockquote><p>the true classic DFS cannot be obtained from BFS by such queue-to-stack replacement. The classic DFS is a completely different algorithm with significantly different inner structure. True DFS is a genuinely recursive algorithm that uses stack for backtracking purposes, not for storing the vertex discovery &ldquo;front&rdquo; (as is the case in BFS)</p></blockquote>

<p><strong>The following quoted texts are also worth-reading</strong>.</p>

<blockquote><p>Something worth noting &ndash; Pseudo-DFS should give you O(depth * branching factor) space, as opposed to O(depth) for proper DFS, which is still better than O(width).</p>

<p>The defining characteristic that separates true DFS and what you call pseudo DFS is how they use the stack. True DFS use it to store backtracking information in contrast to pseudo DFS which used the stack to store the vertex discovery front.</p></blockquote>

<h3>Examples</h3>

<p><strong>Given a perfect binary search tree of 4 levels</strong>. BFS would require 8 space, while DFS requires only 4 space. The branching factor is 2, so true and pseudo DFS use same amount of space.</p>

<p><strong>Given a star graph</strong>: a single central vertex surrounded by 1000 peripheral vertices, with each connected to the central vertex. If we run BFS on this graph, the queue size will immediately jump to 1000. The same thing happens for pseudo-DFS. But classic DFS algorithm will need stack depth of only 1 (!) to traverse this entire graph.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/28/Valid-Palindrome/">[LeetCode 125] Valid Palindrome</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/valid-palindrome/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
</p>

<p>
For example,<br>
<code>"A man, a plan, a canal: Panama"</code> is a palindrome.<br>
<code>"race a car"</code> is <i>not</i> a palindrome.
</p>

<p>
<b>Note:</b><br>
Have you consider that the string might be empty? This is a good question to ask during an interview.</p>
<p>
For the purpose of this problem, we define empty string as valid palindrome.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>Wow, it&rsquo;s frequency 5!</p>

<p><strong>This is a very classic and easy question</strong>.</p>

<h3>Code</h3>

<pre><code>public boolean isPalindrome(String s) {
    int len = s.length();
    s = s.toLowerCase();
    int left = 0, right = len - 1;
    while (left &lt; right) {
        while (left &lt; len &amp;&amp; !isAlphanumeric(s.charAt(left)))
            left ++;
        while (right &gt;= 0 &amp;&amp; ! isAlphanumeric(s.charAt(right)))
            right --;
        if (left == len &amp;&amp; right == -1) return true;
        if (left == len || right == -1) return false;
        if (s.charAt(left) != s.charAt(right)) 
            return false;
        left ++;
        right --;
    }
    return true;
}

private boolean isAlphanumeric(char c) {
    return ('a' &lt;= c &amp;&amp; c &lt;= 'z') 
        || ('0' &lt;= c &amp;&amp; c &lt;= '9');
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/28/Flatten-Binary-Tree-to-Linked-List/">[LeetCode 114] Flatten Binary Tree to Linked List</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a binary tree, flatten it to a linked list in-place.
</p>

<p>
For example,<br>
Given
</p><pre>         1
        / \
       2   5
      / \   \
     3   4   6
</pre>
<p></p>

The flattened tree should look like:<br>
<pre>   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
</pre>

<div class="spoilers" ><b>Hints:</b>
<p>If you notice carefully in the flattened tree, each node&#8217;s right child points to the next node of a pre-order traversal.</p>
</div><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very difficult question</strong>, and there are many solutions.</p>

<h3>Solution</h3>

<p><strong>Analysis of all solutions (except first one) is found in <a href="http://n00tc0d3r.blogspot.sg/2013/03/flatten-binary-tree-to-linked-list-in.html">this great article</a></strong>.</p>

<p><strong>Solution 1 is my code</strong>, I am make use of a &lsquo;pre&rsquo; pointer in this recursive method. This idea is actually quite good, but is never seen in any other people&rsquo;s blogs.</p>

<p><strong>Solution 2 is the most standard recursive solution</strong>. It passes in a node, flatten it and return the last node after it&rsquo;s flattened. So we can flatten root node&rsquo;s left and right node respectively, and then connect it.</p>

<blockquote cite="http://n00tc0d3r.blogspot.sg/2013/03/flatten-binary-tree-to-linked-list-in.html">
To flatten a binary tree, according to the given example, is to recursively insert the left subtree to the right subtree and append the original right subtree to the end of the left subtree, i.e.<br>
<pre>     root                        root
     /  \            -&gt;            \
  left  right                      left
                                     \
                                    right
</pre>
Since we need to append the original right-tree to the end of the left subtree, we let the recursion function return the last node after flatten.
</blockquote>


<p>I missed &ldquo;root.left = null&rdquo; while coding, and it resulted in long long time debugging. I think this is a very silly mistake.</p>

<p><strong>Solution 3 is making use of a stack</strong>. I have to say, although I can figure how it works, I am still blur about the thinking process of this entire idea. Which is to say, I can&rsquo;t keep it in mind even after learning it.</p>

<p>I shall try write this code in the future.</p>

<blockquote>
We can also solve the problem without recursion.<br>
<br>
To do that, we can use a stack to store all right subtrees when we prune them temporarily, and append each of them back after we go through the corresponding left subtree.<br>
<br>
Basically, given a non-empty tree,<br>
<ul>
<li>if it has left subtree, store the right subtree (if not null) to stack, move the left subtree to right;</li>
<li>if not, append back a subtree from stack to the current node&#8217;s right;</li>
<li>continue to the right node until finish.</li>
</ul>
</blockquote>


<p><strong>Solution 4 is what I believe the best solution</strong>. It simple uses while loop to put all nodes in the correct position, without recursion or stack.</p>

<blockquote><p>Each time when we prune a right subtree, we use while-loop to find the right-most leaf of the current left subtree, and append the subtree there.</p></blockquote>

<p><strong>Analysis of all solutions (except first one) is found in <a href="http://n00tc0d3r.blogspot.sg/2013/03/flatten-binary-tree-to-linked-list-in.html">this great article</a></strong>.</p>

<h3>Code</h3>

<p><strong>First, my solution</strong>, a kind of recursive solution</p>

<pre><code>public void flatten(TreeNode root) {
    helper(new TreeNode(1234), root);
}

private TreeNode helper(TreeNode pre, TreeNode node) { 
    // pre cannot be null, this function return the last node of the flatten list
    if (node == null) return pre;
    pre.left = null;
    pre.right = node;
    TreeNode a = node.left;
    TreeNode b = node.right;
    TreeNode temp = helper(node, a);
    return helper(temp, b);
}
</code></pre>

<p><strong>Second, standard recursive solution</strong></p>

<pre><code>public void flatten(TreeNode root) {
    helper(root);
}

private TreeNode helper(TreeNode root) {
    if (root == null) return null;
    TreeNode oldRight = root.right;
    if (root.left != null) {
        root.right = root.left;
        // I missed this line of code: 
        root.left = null;
        root = helper(root.right);
    }
    if (oldRight != null) {
        root.right = oldRight;
        root = helper(root.right);
    }
    // return value is the last element of the flatten tree
    return root;
}
</code></pre>

<p><strong>Third, stack non-recursive solution</strong></p>

<pre><code>public void flatten(TreeNode root) {
    TreeNode cur = root;
    Stack&lt;TreeNode&gt; rtrees = new Stack&lt;TreeNode&gt;();
    while (cur != null) {
        while (cur.left != null) {
            if (cur.right != null)
                rtrees.push(cur.right);
            cur.right = cur.left;
            cur.left = null;
            cur = cur.right;
        }
        if (cur != null &amp;&amp; cur.right == null &amp;&amp; !rtrees.isEmpty()) {
            cur.right = rtrees.pop();
        }
        cur = cur.right;
    }
}
</code></pre>

<p><strong>Fourth, non-stack non-recursive solution</strong></p>

<pre><code>public void flatten(TreeNode root) {
    TreeNode cur = root;
    while (cur != null) {
        if (cur.left != null) {
            if (cur.right != null) { // if we need to prune a right subtree
                TreeNode next = cur.left;
                while (next.right != null)
                    next = next.right;
                next.right = cur.right;
            }
            cur.right = cur.left;
            cur.left = null;
        }
        cur = cur.right;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/28/Binary-Tree-Maximum-Path-Sum/">[LeetCode 124] Binary Tree Maximum Path Sum</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/binary-tree-maximum-path-sum/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a binary tree, find the maximum path sum.
</p>

<p>
The path may start and end at any node in the tree.
</p>

<p>
For example:<br>
Given the below binary tree,
</p><pre>       1
      / \
     2   3
</pre>
<p></p>
<p>
Return <code>6</code>.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a difficult DFS question</strong>.</p>

<p>The basic idea is:</p>

<blockquote><p>When we are in a root node, how we decided to include current node in the maximum path sum? We need to calculate the depth in both subtree. In the meantime, we need to set a variable &ldquo;max&rdquo; to store the max path sum we found during the recursion.</p>

<p>Pay attention that when a subtree sum to negative value, we discard this subtree.</p>

<p>Otherwise, max path sum including current node is <strong>leftSum + cur.val + rightSum</strong></p>

<p>Max depth of current node is <strong>(maximum value of leftSum and rightSum) + cur.val</strong></p></blockquote>

<h3>Solution</h3>

<p>There are 2 points that may incur problems during coding, they are:</p>

<ol>
<li><p>The recursive solution is calculating the &lsquo;max height&rsquo; while checking &lsquo;its own max path sum&rsquo;. It&rsquo;s a bit hard to explain. Basic idea is doing 2 things at same time, while traversing (are one result is returned, another is stored in a public variable, at least for code 1 below).</p></li>
<li><p>Note that &lsquo;max height&rsquo; of a child branch can be nagative. In this case, WE MUST SET IT TO 0.</p></li>
</ol>


<p>The first point is a concept seen in previous questions, but I forgot which. The second point is important, because I missed this and got failed a few times without any clue.</p>

<h3>Code</h3>

<p><strong>First, recursive solution</strong></p>

<pre><code>int max = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) {
    maxHeight(root);
    return max;
}

private int maxHeight(TreeNode node) {
    if (node == null) return 0;
    int l = Math.max(0, maxHeight(node.left));
    int r = Math.max(0, maxHeight(node.right));
    max = Math.max(max, l + r + node.val);
    return node.val + Math.max(l, r);
}
</code></pre>

<p><strong>Second, previous code refactored</strong>.</p>

<p>I removed the global variable, and instead pass an array as reference in the recursion. In this way the &lsquo;shared&rsquo; array achieve same functionality as a global variable.</p>

<pre><code>public int maxPathSum(TreeNode root) {
    int[] shared = {Integer.MIN_VALUE};
    maxHeight(root, shared);
    return shared[0];
}

private int maxHeight(TreeNode node, int[] shared) {
    if (node == null) return 0;
    int l = Math.max(0, maxHeight(node.left, shared));
    int r = Math.max(0, maxHeight(node.right, shared));
    shared[0] = Math.max(shared[0], l + r + node.val);
    return node.val + Math.max(l, r);
}
</code></pre>

<p><strong>Updated on June 10th, it&rsquo;s a terrible practise to use global variable</strong>. The <a href="http://answer.ninechapter.com/solutions/binary-tree-maximum-path-sum/">new solution</a> suggested by Mr. Huang uses a new ResultType Class to solve the problem.</p>

<pre><code>private class ResultType {
    int singlePath, maxPath;
    ResultType(int singlePath, int maxPath) {
        this.singlePath = singlePath;
        this.maxPath = maxPath;
    }
}

public int maxPathSum(TreeNode root) {
    ResultType result = helper(root);
    return result.maxPath;
}

private ResultType helper(TreeNode node) {
    // null case
    if (node == null) {
        return new ResultType(0, Integer.MIN_VALUE);
    }
    // divide
    ResultType ll = helper(node.left);
    ResultType rr = helper(node.right);
    // conquer
    int curSinglePath = Math.max(0, node.val + 
            Math.max(ll.singlePath, rr.singlePath));
    int childMaxPath = Math.max(ll.maxPath, rr.maxPath);
    int curMaxPath = Math.max(childMaxPath, node.val + 
            ll.singlePath + rr.singlePath);
    // done
    return new ResultType(curSinglePath, curMaxPath);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/28/Best-Time-to-Buy-and-Sell-Stock-III/">[LeetCode 123] Best Time to Buy and Sell Stock III</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">link</a></p>

<div class="question-content">
            <p></p><p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>

<p>Design an algorithm to find the maximum profit. You may complete at most <i>two</i> transactions.</p>

<p><b>Note:</b><br>
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is much harder to solve then previous 2 question combined</strong>.</p>

<h3>Solution</h3>

<p><strong>Almost all solutions online are same</strong>, I think <a href="http://rleetcode.blogspot.sg/2014/02/best-time-to-buy-and-sell-stock-iii-java.html">this blog</a> explains it best.</p>

<blockquote><p>we can just dived the whole prices array at every point, try to calculate max profit from left and from right respectively&hellip;</p>

<p>However, there are many repeat calculations. So we can apply DP to record max profits for each left side and right side. then add them together at each point.</p></blockquote>

<p>A detailed illustration with examples can be found <a href="http://yucoding.blogspot.sg/2012/12/leetcode-question-10-best-time-to-buy.html">here</a>.</p>

<p>However, the coding part is slightly difficult at least for me. <strong>I made a terrible mistake with the variable &lsquo;leftMin&rsquo; and &lsquo;rightMax&rsquo;</strong>. I declared it as <strong>&lsquo;rightMin&rsquo;</strong> instead, and then the program logic is wrong. We should avoid this kind of mistakes.</p>

<h3>Code</h3>

<pre><code>public int maxProfit(int[] prices) {
    int len = prices.length;
    if (len == 0) return 0;
    int leftMin = Integer.MAX_VALUE, rightMax = Integer.MIN_VALUE;
    int leftPro[] = new int[len], rightPro[] = new int[len];
    for (int j = 0; j &lt;= len - 1; j ++) {
        leftMin = Math.min(leftMin, prices[j]);
        if (j == 0) leftPro[0] = 0;
        else leftPro[j] = Math.max(leftPro[j-1], prices[j] - leftMin);
    }
    for (int k = len - 1; k &gt;= 0; k --) {
        rightMax = Math.max(rightMax, prices[k]);
        if (k == len - 1) rightPro[len-1] = 0;
        else rightPro[k] = Math.max(rightPro[k+1], rightMax - prices[k]);
    }
    int totalPro = 0;
    for (int i = 0; i &lt; len; i ++) {
        totalPro = Math.max(totalPro, leftPro[i] + rightPro[i]);
    }
    return totalPro;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/28/Best-Time-to-Buy-and-Sell-Stock-II/">[LeetCode 122] Best Time to Buy and Sell Stock II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">link</a></p>

<div class="question-content">
            <p></p><p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>

<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Solution</h3>

<p><strong>This solution is best explained <a href="http://jane4532.blogspot.sg/2013/07/best-time-to-buy-and-sell-stock.html">here</a></strong>.</p>

<blockquote><p>就从左到右轮一遍，遇到递增的都给加起来呗。</p></blockquote>

<h3>Code</h3>

<pre><code>public int maxProfit(int[] prices) {
    int len = prices.length;
    if (len &lt;= 1) return 0;
    int profit = 0;
    for (int i = 1; i &lt; len; i ++) 
        profit += Math.max(0, prices[i] - prices[i-1]);
    return profit;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/28/Best-Time-to-Buy-and-Sell-Stock/">[LeetCode 121] Best Time to Buy and Sell Stock</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/">link</a></p>

<div class="question-content">
            <p></p><p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>

<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a question from a MIT course</strong>, <a href="http://courses.csail.mit.edu/iap/interview/materials.php">Hacking a Google Interview</a>.</p>

<p>I did not solve it, but it&rsquo;s actually very simple to do.</p>

<h3>Solution</h3>

<p>The solution is explained <a href="http://leetcode.com/2010/11/best-time-to-buy-and-sell-stock.html">here</a>:</p>

<blockquote><p>To solve this problem efficiently, you would need to track the minimum value’s index. As you traverse, update the minimum value’s index when a new minimum is met. Then, compare the difference of the current element with the minimum value. Save the buy and sell time when the difference exceeds our maximum difference (also update the maximum difference).</p>

<p>Time is O(N)</p></blockquote>

<h3>Code</h3>

<pre><code>public int maxProfit(int[] prices) {
    int len = prices.length;
    if (len &lt;= 1) return 0;
    int min = prices[0];
    int max = Integer.MIN_VALUE;
    for (int i = 1; i &lt; len; i ++) {
        max = Math.max(max, prices[i] - min);
        min = Math.min(min, prices[i]);
    }
    return Math.max(max, 0);
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/25">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/23">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/classic/'>classic (3)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (52)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (35)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (152)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>octopress (1)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (85)</a></li>
<li class='category'><a href='/blog/categories/string-search/'>string search (3)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (5)</a></li>
<li class='category'><a href='/blog/categories/top-k/'>top k (4)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/09/16/google-guess-password/">[Google] Guess Password</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/12/DNS-communication-protocol/">[Design] DNS Communication Protocol</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/11/barrier-goods-van-and-distance/">[Google] Barrier, Goods Van and Distance</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/11/arithmetic-progression-triplet/">[Google] Arithmetic Progression Triplet</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/11/arithmetic-progression-longest/">[Google] Arithmetic Progression Longest</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Charlie Brown -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
