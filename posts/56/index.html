
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Shuatiblog.com</title>
  <meta name="author" content="CodeMonkey">

  
  <meta name="description" content="Question link Given an unsorted integer array, find the first missing positive integer. For example,
Given [1,2,0] return 3,
and [3,4,-1,1] return 2 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.shuatiblog.com/posts/56/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Shuatiblog.com" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.shuatiblog.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="blue_light">
            Shuatiblog.com
        </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/14/First-Missing-Positive/">[LeetCode 41] First Missing Positive</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-14T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/14/First-Missing-Positive/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/first-missing-positive/">link</a></p>

<div class="question-content">
            <p></p><p>
Given an unsorted integer array, find the first missing positive integer.
</p>

<p>
For example,<br>
Given <code>[1,2,0]</code> return <code>3</code>,<br>
and <code>[3,4,-1,1]</code> return <code>2</code>.
</p>

<p>
Your algorithm should run in <i>O</i>(<i>n</i>) time and uses constant space.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very difficult question</strong>!</p>

<p>The tricky part of this question is the limit in space/time. If we sort and check, the space is constent, but time is increased.</p>

<p>The key is to <strong>make use of the position index of the array</strong>.</p>

<h3>Solution</h3>

<p><strong>Make sure that (i)th item of the array stores value (i+1)</strong>. The image below and the quoted text from <a href="http://tianrunhe.wordpress.com/2012/07/15/finding-the-1st-missing-positive-int-in-an-array-first-missing-positive/">this blog</a> are very good explanations.</p>

<p><img class="middle" src="/assets/images/first_missing_pos.jpg"></p>

<blockquote><p>The idea is simple. What is the most desired array we want to see? Something like [1,2,3] then we know 4 is missing, or [1, 8, 3, 4] then we know 2 is missing. In other word, “all the numbers are in their correct positions”.</p>

<p>What are correct positions? For any i, A[i] = i+1. So our goal is to rearrange those numbers (in place) to their correct positions.</p>

<p>We then need to decide how to arrange them. Let’s take the [3, 4, -1, 1] as an example. The 1st number, 3, we know it should stay in position 2. So we swap A[0] = 3 with A[2]. We then get [-1, 4, 3, 1]. We can’t do anything about -1 so we leave it there. The 2nd number, 4, we know it should sit in A[3]. So we swap A[1] = 4 with A[3]. We then get [-1, 1, 3, 4]. Now 1 should stay in A[0], so we keep swapping and we get [1, -1, 3, 4]. Notice now every positive number is staying in their correct position (A[0]=1, A[2]=3 and A[3]=4). We then need one more scan to find out 2 is missing.</p></blockquote>

<h3>My code</h3>

<pre><code>public class Solution {
    public int firstMissingPositive(int[] A) {
        if (A == null || A.length == 0) {
            return 1;
        }
        int len = A.length;
        int p = 0;
        while (p &lt; len) {
            if (A[p] == p + 1) {
                // the number is in its correct position~
                p++;
                continue;
            } else if (A[p] &lt;= 0 || A[p] &gt; len) {
                // the number is out of range, leave it alone then.
                p++;
                continue;
            } else if (A[p] == A[A[p] - 1]) {
                // this is an important case!!! I missed it just now~
                p++;
                continue; 
            }
            swop(A, p, A[p] - 1);
        }
        // now check and find the first number that is not in correct position
        p = 0;
        while (p &lt; len) {
            if (A[p] != p + 1) {
                return p + 1;
            }
            p++;
        }
        return p + 1;
    }

    private void swop(int[] A, int x, int y) {
        int temp = A[x];
        A[x] = A[y];
        A[y] = temp;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/13/Count-And-Say/">[LeetCode 38] Count and Say</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-13T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/13/Count-And-Say/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/count-and-say/">link</a></p>

<div class="question-content">
<p></p><p>The count-and-say sequence is the sequence of integers beginning as follows:<br>
<code>1, 11, 21, 1211, 111221, ...</code>
</p>

<p>
<code>1</code> is read off as <code>"one 1"</code> or <code>11</code>.<br>
<code>11</code> is read off as <code>"two 1s"</code> or <code>21</code>.<br>
<code>21</code> is read off as <code>"one 2</code>, then <code>one 1"</code> or <code>1211</code>.<br>
</p>

<p>
Given an integer <i>n</i>, generate the <i>n</i><sup>th</sup> sequence.
</p>

<p>
Note: The sequence of integers will be represented as a string.
</p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Solution</h3>

<p><strong>This is a implementation question, not difficult</strong>.</p>

<h3>My code</h3>

<p>code 1</p>

<pre><code>public class Solution {
    public String countAndSay(int n) {
        String num = "1";
        for (int i = 1; i &lt; n; i++) {
            num = say(num);
        }
        return num;
    }

    private String say(String input) {
        // 21 -&gt; 1211
        int len = input.length();
        String output = "";
        int left = 0;
        int right = 0;
        while (right &lt; len) {
            left = right;
            // forward right until right pointer to a different value
            // compared to that pointed by left pointer
            while (right &lt; len &amp;&amp; input.charAt(left) == input.charAt(right)) {
                right++;
            }
            output += String.valueOf(right - left);
            output += input.charAt(left);
        }
        return output;
    }
}
</code></pre>

<p>code 2</p>

<pre><code>public String countAndSay(int n) {
    String s = "1";
    for (int i = 2; i &lt;= n; i ++) {
        char[] nums = s.toCharArray();
        String newS = "";
        int len = nums.length, left = 0, right = 0;
        while (right &lt; len) {
            while (right &lt; len &amp;&amp; nums[left] == nums[right]) right ++;
            newS += (right - left) + "" + nums[left];
            left = right;
        }
        s = newS;
    }
    return s;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/13/Combination-Sum-II/">[LeetCode 40] Combination Sum II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-13T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/13/Combination-Sum-II/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/combination-sum-ii/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a collection of candidate numbers (<b><i>C</i></b>) and a target number (<b><i>T</i></b>), find all unique combinations in <b><i>C</i></b> where the candidate numbers sums to <b><i>T</i></b>.
</p>

<p>Each number in <b><i>C</i></b> may only be used <b>once</b> in the combination.
</p>
<p><b>Note:</b><br>
</p><ul>
<li>All numbers (including target) will be positive integers.</li>
<li>Elements in a combination (<i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, … , <i>a</i><sub>k</sub>) must be in non-descending order. (ie, <i>a</i><sub>1</sub> ≤ <i>a</i><sub>2</sub> ≤ … ≤ <i>a</i><sub>k</sub>).</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p></p>

<p>
For example, given candidate set <code>10,1,2,7,6,1,5</code> and target <code>8</code>, <br>
A solution set is: <br>
<code>[1, 7]</code> <br>
<code>[1, 2, 5]</code> <br>
<code>[2, 6]</code> <br>
<code>[1, 1, 6]</code> <br>
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This problem is derived from the &ldquo;Combination Sum&rdquo; problem</strong>.</p>

<p>The solution is the &ldquo;Combination Sum&rdquo; solution plus some duplication avoidance technique.</p>

<h3>Solution</h3>

<p><strong>Main part of this solution is same as &ldquo;Combination Sum&rdquo;</strong>. There is only 2 lines of code that needs to be added/modified.</p>

<p><strong>First change</strong>, When go into the next recursive call, instead of:</p>

<pre><code>helper(ans, cand, path, i, len, target - cand[i]);
</code></pre>

<p>Change it to</p>

<pre><code>helper(ans, cand, path, i + 1, len, target - cand[i]);
</code></pre>

<p><strong>Second change</strong>, inside the for-loop, instead of getting next element right away, we get the element with different value. The additional code is:</p>

<pre><code>if (i &gt; pos &amp;&amp; candidates[i] == candidates[i - 1]) {
    continue;
}
</code></pre>

<h3>My code</h3>

<pre><code>public class Solution {
    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {
        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        if (candidates == null || candidates.length == 0) {
            return ans;
        }
        Arrays.sort(candidates);
        int len = candidates.length;
        helper(ans, candidates, new ArrayList&lt;Integer&gt;(), 0, len, target);
        return ans;
    }

    private void helper(List&lt;List&lt;Integer&gt;&gt; ans, int[] cand, List&lt;Integer&gt; path, int pos, int len, int target) {
        if (target == 0) {
            ans.add(new ArrayList&lt;Integer&gt;(path));
            return;
        } else if (target &lt; 0) {
            return;
        }
        for (int i = pos; i &lt; len; i++) {
            // if 'i' points to a repeated number, skip.
            if (i &gt; pos &amp;&amp; cand[i] == cand[i - 1]) {
                continue;
            }
            // insert cand[i] into path list, and continue search dfs
            path.add(cand[i]);
            helper(ans, cand, path, i + 1, len, target - cand[i]);
            path.remove(path.size() - 1);
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/13/Combination-Sum/">[LeetCode 39] Combination Sum</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-13T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/13/Combination-Sum/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/combination-sum/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a set of candidate numbers (<b><i>C</i></b>) and a target number (<b><i>T</i></b>), find all unique combinations in <b><i>C</i></b> where the candidate numbers sums to <b><i>T</i></b>. 
</p>

<p>The <b>same</b> repeated number may be chosen from <b><i>C</i></b> unlimited number of times.
</p>

<p><b>Note:</b><br>
</p><ul>
<li>All numbers (including target) will be positive integers.</li>
<li>Elements in a combination (<i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, … , <i>a</i><sub>k</sub>) must be in non-descending order. (ie, <i>a</i><sub>1</sub> ≤ <i>a</i><sub>2</sub> ≤ … ≤ <i>a</i><sub>k</sub>).</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p></p>

<p>
For example, given candidate set <code>2,3,6,7</code> and target <code>7</code>, <br>
A solution set is: <br>
<code>[7]</code> <br>
<code>[2, 2, 3]</code> <br>
</p>
<p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is an NP problem</strong>.</p>

<p>It can be solved with basic recursion methods. I refered to <a href="http://blog.csdn.net/linhuanmars/article/details/20828631">this blog</a> for the idea.</p>

<h3>Solution</h3>

<p><strong>Recursively fetch the next element and subtract the value from the target</strong>. In the end, if target happen to be 0, then one solution is found. If target result to be less than 0, return. If larger than 0, continue.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        if (candidates == null || candidates.length == 0) {
            return ans;
        }
        Arrays.sort(candidates);
        int len = candidates.length;
        helper(ans, candidates, new ArrayList&lt;Integer&gt;(), 0, len, target);
        return ans;
    }

    private void helper(List&lt;List&lt;Integer&gt;&gt; ans, int[] cand, List&lt;Integer&gt; path, int pos, int len, int target) {
        if (target == 0) {
            ans.add(new ArrayList&lt;Integer&gt;(path));
            return;
        } else if (target &lt; 0) {
            return;
        }
        for (int i = pos; i &lt; len; i++) {
            // insert cand[i] into path list, and continue search dfs
            path.add(cand[i]);
            helper(ans, cand, path, i, len, target - cand[i]);
            path.remove(path.size() - 1);
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Valid-Sudoku/">[LeetCode 36] Valid Sudoku</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/12/Valid-Sudoku/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/valid-sudoku/">link</a></p>

<div class="question-content">
            <p></p><p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx">Sudoku Puzzles - The Rules</a>.</p>

<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>'.'</code>.</p>

<p>
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"><br>
</p><p style="font-size: 11px">A partially filled sudoku which is valid.</p>
<p></p>

<p><b>Note:</b><br>
A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Solution</h3>

<p><strong>This is not a difficult problem</strong>.</p>

<p>Make use of <strong>three for-loops</strong> and <strong>nine arrays of length 9</strong> (for each loop) to mark the status, then do DFS search.</p>

<p>However, <strong>I also found a very concise solution</strong>. Read below.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public boolean isValidSudoku(char[][] board) {
        if (board == null || board.length == 0) {
            return false;
        }
        int N = board.length;
        for (int i = 0; i &lt; N; i++) {
            boolean[] foo = new boolean[N];
            // validate each row
            for (int j = 0; j &lt; N; j++) {
                if (board[i][j] != '.') {
                    if (foo[board[i][j] - '1']) {
                        return false;
                    }
                    foo[board[i][j] - '1'] = true;
                }
            }
            foo = new boolean[N];
            // validate each column
            for (int j = 0; j &lt; N; j++) {
                if (board[j][i] != '.') {
                    if (foo[board[j][i] - '1']) {
                        return false;
                    }
                    foo[board[j][i] - '1'] = true;
                }
            }
        }
        for (int a = 0; a &lt; 3; a++) {
            for (int b = 0; b &lt; 3; b++) {
                boolean[] foo = new boolean[N];
                for (int c = 0; c &lt; 3; c++) {
                    for (int d = 0; d &lt; 3; d++) {
                        if (board[a * 3 + c][b * 3 + d] != '.') {
                            if (foo[board[a * 3 + c][b * 3 + d] - '1']) {
                                return false;
                            }
                            foo[board[a * 3 + c][b * 3 + d] - '1'] = true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
</code></pre>

<p><strong>The following solution</strong> is from <a href="http://www.cnblogs.com/zhaolizhen/p/Sudoku.html">this blog</a>. It&rsquo;s a very clever and surprisingly concise code.</p>

<pre><code>public boolean isValidSudoku(char[][] board) {
    boolean[][] rows = new boolean[9][9];
    boolean[][] cols = new boolean[9][9];
    boolean[][] blocks = new boolean[9][9];
    for (int i = 0; i &lt; 9; ++i) {
        for (int j = 0; j &lt; 9; ++j) {
            int c = board[i][j] - '1';
            if (board[i][j] == '.') continue;
            if (rows[i][c] || cols[j][c] || blocks[i - i % 3 + j / 3][c])
                return false;
            rows[i][c] = cols[j][c] = blocks[i - i % 3 + j / 3][c] = true;
        }
    }
    return true;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Search-in-Rotated-Sorted-Array/">[LeetCode 33] Search in Rotated Sorted Array</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/12/Search-in-Rotated-Sorted-Array/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/search-in-rotated-sorted-array/">link</a></p>

<div class="question-content">
            <p></p><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>

<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>

<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>

<p>You may assume no duplicate exists in the array.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question is not very difficult</strong>, yet commonly seen in interviews.</p>

<p>Without having any knowledge of pivot, we can check the mid-point value against left value and right value. Read <a href="http://leetcode.com/2010/04/searching-element-in-rotated-array.html">this blog</a> for more.</p>

<h3>Solution</h3>

<p>The code is easy to understand.</p>

<h3>My code</h3>

<p>Pay special attention to different larger/smaller conditions. It&rsquo;s very easy to miss a equal sign or something.</p>

<pre><code>public class Solution {
    public int search(int[] A, int target) {
        if (A == null || A.length == 0) {
            return -1;
        }
        int len = A.length;
        int left = 0; 
        int right = len - 1;
        while (left + 1 &lt; right) {
            int mid = left + (right - left) / 2;
            if (A[mid] == target) {
                return mid;
            } else if (A[left] &lt; A[mid]) {
            // remember to pay attention to (A[left] == target) case
                if (A[left] &lt;= target &amp;&amp; target &lt; A[mid]) {
                    right = mid;
                } else {
                    left = mid;
                }
            } else {
            // remember to pay attention to (A[right] == target) case
                if (A[mid] &lt; target &amp;&amp; target &lt;= A[right]) {
                    left = mid;
                } else {
                    right = mid;
                }
            }
        }
        if (A[left] == target) {
            return left;
        } else if (A[right] == target) {
            return right;
        }
        return -1;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Search-for-a-Range/">[LeetCode 34] Search for a Range</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/12/Search-for-a-Range/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/search-for-a-range/">link</a></p>

<div class="question-content">
            <p></p><p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>

<p>Your algorithm&#8217;s runtime complexity must be in the order of <i>O</i>(log <i>n</i>).</p>

<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>

<p>
For example,<br>
Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>
return <code>[3, 4]</code>.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Solution</h3>

<p><strong>The key to solve this problem is binary search</strong>. Previously my solution is to find the element first, then check left bound and right bound respectively. In worst case, this will take O(n) time. This method, though, will pass OJ, but is not an optimized solution.</p>

<p><strong>First solution is from <a href="http://xixiaogualu.blogspot.sg/2013/09/search-for-range.html">this blog</a></strong>. Using binary search to search twice &ndash; once for left bound, and once for right bound. Code is below.</p>

<p><strong>Second solution is from <a href="http://rleetcode.blogspot.sg/2014/02/search-for-range-java.html">this blog</a></strong>. This idea is still using binary search, also search twice, but a more tricky manner. Instead of searching the number, it searches (number &ndash; 0.5) and (number + 0.5).</p>

<h3>My code</h3>

<p>Solution 1</p>

<pre><code>public class Solution {
    public int[] searchRange(int[] A, int target) {
        int[] ans = new int[] {-1, -1};
        if (A == null || A.length == 0) {
            return ans;
        }
        int len = A.length;
        int left = 0, right = len - 1;
        while (left &lt; right) {
            int mid = left + (right - left) / 2;
            if (A[mid] &gt;= target) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        if (A[left] == target) {
            ans[0] = left;
        } else {
            return ans;
        }
        left = 0;
        right = len - 1;
        while (left &lt; right) {
            int mid = left + (right - left + 1) / 2;
            if (A[mid] &lt;= target) {
                left = mid;
            } else {
                right = mid - 1;
            }
        }
        ans[1] = right;
        return ans;
    }
}
</code></pre>

<p>Solution 2</p>

<pre><code>public int[] searchRange(int[] A, int target) {
    if (A == null) return null;
    int[] result = { -1, -1 };
    int low = binarySearch(A, target - 0.5);
    // Be care for there , low&gt;=A.length must be checked
    if (low &gt;= A.length || A[low] != target) return result;
    result[0] = low;
    result[1] = binarySearch(A, target + 0.5) - 1;
    return result;
}

public int binarySearch(int[] A, double t) {
    int low = 0, high = A.length - 1;
    while (low &lt;= high) {
        int m = (low + high) / 2;
        if (A[m] &lt; t) low = m + 1;
        if (A[m] &gt; t) high = m - 1;
    }
    return low;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Search-Insert-Position/">[LeetCode 35] Search Insert Position</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/12/Search-Insert-Position/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/search-insert-position/">link</a></p>

<div class="question-content">
            <p></p><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>

<p>You may assume no duplicates in the array.</p>

<p>
Here are few examples.<br>
<code>[1,3,5,6]</code>, 5 → 2<br>
<code>[1,3,5,6]</code>, 2 → 1<br>
<code>[1,3,5,6]</code>, 7 → 4<br>
<code>[1,3,5,6]</code>, 0 → 0
</p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very basic, yet very difficult question</strong>. It is not easy to get it correct at first attempt.</p>

<p>Read <a href="http://blog.csdn.net/fightforyourdream/article/details/14216321">this blog</a> for more.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public int searchInsert(int[] A, int target) {
        if (A == null || A.length == 0) {
            return 0;
        }
        int len = A.length;
        int left = 0;
        int right = len - 1;
        while (left + 1 &lt; right) {
            int mid = left + (right - left) / 2;
            if (A[mid] &gt;= target) {
                right = mid;
            } else {
                left = mid;
            }
        }
        // now are have a adjacent range [left, right]
        if (target &lt;= A[left]) {
            return left;
        } else if (target &lt;= A[right]) {
            // remember not to miss the == case
            return right;
        } else {
            return right + 1;
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Next-Permutation/">[LeetCode 31] Next Permutation</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/12/Next-Permutation/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/next-permutation/">link</a></p>

<div class="question-content">
            <p></p><p>
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
</p>
<p>
If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).
</p>
<p>
The replacement must be in-place, do not allocate extra memory.
</p>
<p>
Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br>
<code>1,2,3</code> → <code>1,3,2</code><br>
<code>3,2,1</code> → <code>1,2,3</code><br>
<code>1,1,5</code> → <code>1,5,1</code><br>
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<h3>Analysis</h3>

<p>The image below explains the solution very well (for the input number &ldquo;687432&rdquo;).</p>

<p><img class="middle" src="/assets/images/next_permutation.png"></p>

<h3>Solution</h3>

<p>Read <a href="http://blog.csdn.net/havenoidea/article/details/12176737">this blog</a> for a very nice piece of code.</p>

<p>The following code is written by me.</p>

<h3>My code</h3>

<pre><code>public class Solution {
    public void nextPermutation(int[] num) {
        if (num == null || num.length &lt;= 1) {
            return;
        }
        int len = num.length;
        int p = len - 2;
        // note that when values are equals, proceed the pointer! 
        // same for line 22
        while (p &gt;= 0 &amp;&amp; num[p] &gt;= num[p + 1]) {
            // move p to left as long as its value is larger than next num
            // we want to find the end of increasing sequence (from end to start)
            p--;
        }
        if (p == -1) {
            // the input is a strictly decreasing sequence
            Arrays.sort(num);
            return;
        }
        // replace number at p with an larger value found in the right of p
        int w = len - 1;
        while (num[w] &lt;= num[p]) {
            w--;
        }
        // ok, now swap number at p and w
        swop(num, p, w);
        // reverse all numbers to the right of p
        reverse(num, p + 1, len - 1);
    }

    private void swop(int[] num, int a, int b) {
        int temp = num[a];
        num[a] = num[b];
        num[b] = temp;
    }

    private void reverse(int[] num, int a, int b) {
        while (a &lt; b) {
            swop(num, a++, b--);
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/12/Longest-Valid-Parentheses/">[LeetCode 32] Longest Valid Parentheses</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-12T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/12/Longest-Valid-Parentheses/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/longest-valid-parentheses/">link</a></p>

<div class="question-content">
            <p></p><p>Given a string containing just the characters <code>'('</code> and <code>')'</code>, find the length of the longest valid (well-formed) parentheses substring.
</p>
<p>
For <code>"(()"</code>, the longest valid parentheses substring is <code>"()"</code>, which has length = 2.
</p>
<p>
Another example is <code>")()())"</code>, where the longest valid parentheses substring is <code>"()()"</code>, which has length = 4.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<h3>Solution</h3>

<p><strong>There are 2 ways to solve this problem</strong>, stack and DP.</p>

<p><strong>Stack method 1 is more straight-forward</strong> (code shown below). The idea is to keep a stack of &ldquo;(&rdquo; indexes, and another variable called &ldquo;last&rdquo;. <strong>Note that only &ldquo;)&rdquo; can violates a pattern</strong>. So whenever I see a &ldquo;(&rdquo;, just push to stack. When the pattern is violated by a &ldquo;)&rdquo;, I update &ldquo;last&rdquo;. The code explains itself very well. If not, <a href="http://discuss.leetcode.com/questions/212/longest-valid-parentheses/1488">look here</a></p>

<p><strong>Stack method 2 is more tricky</strong>. This time I will not only push the index of &ldquo;(&rdquo; to stack, but also the index of &ldquo;)&rdquo; when the pattern got violated. It&rsquo;s hard to explain, and hard to think of at first.</p>

<p><strong>The DP solution is not very difficult</strong>. Basically create an array of same length as string s. dp[i] denotes the length of valid parenthese ending with index i. The idea is similar to <a href="http://blog.csdn.net/abcbc/article/details/8826782">this blog</a>, but he used reverse DP, and I use normal DP.</p>

<p>I will explain DP with an example of input &ldquo;<strong>)()()</strong>&rdquo;. For this string, we have <strong>dp[0] = 0, dp[1] = 0, dp[2] = 2, dp[3] = 0</strong>. For dp[4], I check the 3rd position first, and find that dp[4] = 2. Then I also have to add dp[2] into dp[4] to make it complete. The end result is dp[4] = 2 + 2 = 4.</p>

<h3>My code</h3>

<p>Stack method 1 (recommended)</p>

<pre><code>public class Solution {
    public int longestValidParentheses(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        int len = s.length();
        int longest = 0;
        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
        int start = 0;
        for (int i = 0; i &lt; len; i++) {
            char ch = s.charAt(i);
            if (ch == '(') {
                // well, no matter what, '(' is alway a valid part
                // push the index to the stack
                stack.push(i);
            } else if (ch == ')') {
                if (stack.isEmpty()) {
                    // invalid ')', update 'start' variable
                    start = i + 1;
                } else {
                    int pos = stack.pop();
                    if (stack.isEmpty()) {
                        // this is why we need 'start' variable
                        longest = Math.max(longest, i - start + 1);
                    } else {
                        // important: must peek stack again.
                        // eg. (()()  if don't peek again 
                        longest = Math.max(longest, i - stack.peek());
                    }
                }
            }
        }
        return longest;
    }
}
</code></pre>

<p>Stack method 2</p>

<pre><code>public int longestValidParentheses(String s) {
    int res = 0;
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    char[] arr = s.toCharArray();
    for (int i = 0; i &lt; arr.length; i++) {
        if (arr[i] == ')' &amp;&amp; !stack.isEmpty() &amp;&amp; arr[stack.peek()] == '(') {
            stack.pop();
            if (stack.isEmpty()) res = i + 1;
            else res = Math.max(res, i - stack.peek());
        } else stack.push(i);
    }
    return res;
}
</code></pre>

<p>DP</p>

<pre><code>public int longestValidParentheses(String s) {
    int len = s.length();
    if (len &lt;= 1) return 0;
    int max = Integer.MIN_VALUE;
    int[] dp = new int[len];
    for (int i = 1; i &lt; len; i ++) {
        if (s.charAt(i) == '(') dp[i] = 0;
        else {
            int j = i - 1 - dp[i - 1];
            if (j &gt;= 0 &amp;&amp; s.charAt(j) =='(') {
                dp[i] = dp[i - 1] + 2;
                if (j &gt;= 1) dp[i] += dp[j - 1];
            }
            else dp[i] = 0;
        }
        max = Math.max(max, dp[i]);
    }
    return max;
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="57">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="55">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (76)</a></li>
<li class='category'><a href='/blog/categories/experience/'>experience (4)</a></li>
<li class='category'><a href='/blog/categories/fundamental/'>fundamental (11)</a></li>
<li class='category'><a href='/blog/categories/java-oop/'>java oop (30)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (176)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (20)</a></li>
<li class='category'><a href='/blog/categories/q-facebook/'>q-facebook (9)</a></li>
<li class='category'><a href='/blog/categories/q-google/'>q-google (62)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (124)</a></li>
<li class='category'><a href='/blog/categories/string-search/'>string search (17)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (7)</a></li>
<li class='category'><a href='/blog/categories/top-k/'>top k (7)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/08/30/how-google-search-works/">[Design] How Google search works </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/30/design-class-4/">[NineChap Sys] System Design Class 4: Crawler & Search Engine </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/28/design-class-3/">[NineChap Sys] System Design Class 3: Web Service </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/26/design-class-2/">[NineChap Sys] System Design Class 2: Database </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/24/three-property-object/">[Java OOP] Three Properties of Class/Object </a>
      </li>
    
  </ul>
</section>




<!--
<script type="text/javascript" src="http://srvpub.com/adServe/banners?tid=29011_41781_0&size=120x600" ></script>
&#8211;>

<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"willran168","width":160,"height":600,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>
<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
    Copyright &copy; 2015 - <a href="/about">CodeMonkey</a> -  All posts are my original writing, based uppon my personal view. <a href="/policy">Privacy Policy</a> - 
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
