
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Shuatiblog.com</title>
  <meta name="author" content="CodeMonkey">

  
  <meta name="description" content="Question link How to find the majority elelment in an array in O(n)? Note: The majority element is the element that occurs more than half of the size &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.shuatiblog.com/posts/41/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Shuatiblog.com" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.shuatiblog.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="blue_light">
            Shuatiblog.com
        </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/28/Majority-Number/">[LintCode] Majority Number</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/06/28/Majority-Number/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.lintcode.com/en/problem/majority-number/">link</a></p>

<blockquote><p>How to find the majority elelment in an array in O(n)?</p>

<p>Note: The majority element is the element that occurs more than half of the size of the array</p>

<p>Example: For [1, 1, 1, 1, 2, 2, 2], return 1</p></blockquote>

<h3>Analysis</h3>

<p>This question is called <strong><a href="http://www.cs.utexas.edu/~moore/best-ideas/mjrty/example.html">Moore’s Voting Algorithm</a></strong> (or Majority Vote Algorithm).</p>

<p>Psudo-code from <a href="http://www.geeksforgeeks.org/majority-element/">GFG</a>:</p>

<pre><code>findCandidate(a[], size)
1.  Initialize index and count of majority element
     maj_index = 0, count = 1
2.  Loop for i = 1 to size – 1
    (a)If a[maj_index] == a[i]
        count++
    (b)Else
        count--;
    (c)If count == 0
        maj_index = i;
        count = 1
3.  Return a[maj_index]
</code></pre>

<p>Sometimess majority element does not exist, so you might want to do another iteration to double check.</p>

<p>If the check shows invalid, then there&rsquo;s no majoirty element.</p>

<h3>Code</h3>

<pre><code>public int majorityNumber(ArrayList&lt;Integer&gt; nums) {
    // write your code
    if (nums == null || nums.size() == 0) {
        return 0;
    }
    int num = nums.get(0);
    int count = 1;
    for (int i = 1; i &lt; nums.size(); i++) {
        if (count == 0) {
            num = nums.get(i);
            count = 1;
        } else if (nums.get(i) == num) {
            count++;
        } else {
            count--;
        }
    }
    return num;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/27/Topology-sorting/">[Question] Topology Sort (Undone)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-27T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/06/27/Topology-sorting/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://en.wikipedia.org/wiki/Topological_sorting">link</a></p>

<blockquote><p>Topological ordering of a directed graph is a linear ordering of its vertices such that <strong>for every directed edge uv from vertex u to vertex v, u comes before v in the ordering</strong>.</p>

<p>A topological ordering is possible if and only if the graph has no directed cycles, that is, if it is a <strong>directed acyclic graph (DAG)</strong>.</p></blockquote>

<h3>Analysis</h3>

<p>Canonical application of toposort is to schedule tasks with dependency (project management etc.) It&rsquo;s also used for computing formulas, logic synthesis, order of compilation (&lsquo;make&rsquo; command) and data serialization.</p>

<p><img class="middle" src="/assets/images/topology_sort_example.png"></p>

<h3>Solution</h3>

<p>The usual algorithms have <strong>linear run-time</strong>, i.e. O(V + E).</p>

<blockquote><p>First step is to find a list of &ldquo;start nodes&rdquo; which have no incoming edges. Then insert them into a set S and delete it. At least one such node must exist in an <strong>directed acyclic graph</strong>. From a university <a href="https://courses.cs.washington.edu/courses/cse326/03wi/lectures/RaoLect20.pdf">lecture</a>.</p></blockquote>

<p>From Wiki:</p>

<pre><code>L ← Empty list that will contain the sorted elements
S ← Set of all nodes with no incoming edges
while S is non-empty do
    remove a node n from S
    add n to tail of L
    for each node m with an edge e from n to m do
        remove edge e from the graph
        if m has no other incoming edges then
            insert m into S
if graph has edges then
    return error (graph has at least one cycle)
else 
    return L (a topologically sorted order)
</code></pre>

<p>If the graph is a DAG, <strong>a solution will be contained in the list L</strong> (the solution is not necessarily unique). Otherwise, the graph must have at least one cycle and therefore <strong>a topological sorting is impossible</strong>.</p>

<h3>Code</h3>

<p>The solution comes from <a href="http://codereview.stackexchange.com/questions/44689/topological-sort-in-java">here</a>.</p>

<p><img class="middle" src="/assets/images/topology_sort.png" width="250" height="250"></p>

<pre><code>public class Graph {
    private int vertices;
    private Set&lt;Node&gt; nodes = new HashSet&lt;Node&gt;();

    public Graph(int vertices) {
        this.vertices = vertices;
    }

    public void addVertex(Node node) {
        this.nodes.add(node);
    }

    public Set&lt;Node&gt; topologicalSort() {
        Queue&lt;Node&gt; q = new LinkedList&lt;Node&gt;();
        Set&lt;Node&gt; topoSort = new LinkedHashSet&lt;Node&gt;();
        int vertexProcessesCtr = 0;
        for (Node m : this.nodes) {
            vertexProcessesCtr = addToQueue(m, topoSort, vertexProcessesCtr, q);
        }
        while (!q.isEmpty()) {
            Node m = q.poll();
            for (Node child : m.getAdjacenctNode()) {
                int indeq = child.getInDegree() - 1;
                child.setInDegree(indeq);
                vertexProcessesCtr = addToQueue(child, topoSort,
                        vertexProcessesCtr, q);
            }
        }
        if (vertexProcessesCtr &gt; this.vertices) {
            System.out.println();
        }
        return topoSort;
    }

    private int addToQueue(Node node, Set&lt;Node&gt; topoSort, int vertexProcess,
            Queue&lt;Node&gt; q) {
        if (node.getInDegree() == 0) {
            q.add(node);
            topoSort.add(node);
            return vertexProcess + 1;
        }
        return vertexProcess;
    }

    public static void main(String[] args) {
        Graph g = new Graph(8);

        Node TEN = new Node("10");
        Node ELEVEN = new Node("11");
        Node TWO = new Node("2");
        Node THREE = new Node("3");
        Node FIVE = new Node("5");
        Node SEVEN = new Node("7");
        Node EIGHT = new Node("8");
        Node NINE = new Node("9");

        SEVEN.AdjacenctNode.add(ELEVEN);
        ELEVEN.inDegree++;
        SEVEN.AdjacenctNode.add(EIGHT);
        EIGHT.inDegree++;
        FIVE.AdjacenctNode.add(ELEVEN);
        ELEVEN.inDegree++;
        THREE.AdjacenctNode.add(EIGHT);
        EIGHT.inDegree++;
        THREE.AdjacenctNode.add(TEN);
        TEN.inDegree++;
        ELEVEN.AdjacenctNode.add(TEN);
        TEN.inDegree++;
        ELEVEN.AdjacenctNode.add(TWO);
        TWO.inDegree++;
        ELEVEN.AdjacenctNode.add(NINE);
        NINE.inDegree++;
        EIGHT.AdjacenctNode.add(NINE);
        NINE.inDegree++;

        g.nodes.add(TWO);
        g.nodes.add(THREE);
        g.nodes.add(FIVE);
        g.nodes.add(SEVEN);
        g.nodes.add(EIGHT);
        g.nodes.add(NINE);

        System.out.println("Now calling the topologial sorts");
        Set&lt;Node&gt; result = g.topologicalSort();
        for (Node node : result) {
            System.out.println(node.data + " ");
        }
    }
}

class Node {
    public String data;
    public int dist;
    public int inDegree;
    LinkedList&lt;Node&gt; AdjacenctNode = new LinkedList&lt;Node&gt;();

    public void addAdjNode(final Node Child) {
        AdjacenctNode.add(Child);
        Child.inDegree++;
    }

    public Node(String data) {
        super();
        this.data = data;
    }

    public int getInDegree() {
        return inDegree;
    }

    public void setInDegree(int inDegree) {
        this.inDegree = inDegree;
    }

    public LinkedList&lt;Node&gt; getAdjacenctNode() {
        return AdjacenctNode;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/27/Previous-Permutation/">[LintCode] Previous Permutation</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-27T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/06/27/Previous-Permutation/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.lintcode.com/en/problem/previous-permuation/">link</a></p>

<div style="min-height:100px">
<p>Given a list of integers, which denote a permutation.</p>

<p>Find the previous permutation in ascending order.</p>
    
<div class="m-t-lg m-b-lg">
      <b>Note</b>
      <div><p>The list may contains duplicate integers.</p>
      </div>
</div>
    
<div class="m-t-lg m-b-lg">
      <b>Example</b>
      <div><p>For <strong><span style="color:#B22222;">[1,3,2,3]</span></strong>, the previous permutation is <span style="color:#B22222;"><strong>[1,2,3,3]</strong></span></p>

<p>For <span style="color:#B22222;"><strong>[1,2,3,4]</strong></span>, the previous permutation is <span style="color:#B22222;"><strong>[4,3,2,1]</strong></span></p>
    </div>
</div>
</div>


<h3>Analysis</h3>

<p>This is almost the same question as &ldquo;Next Permutation&rdquo;.</p>

<ol>
<li>Find</li>
<li>Swap</li>
<li>Replace</li>
</ol>


<h3>Code</h3>

<pre><code>public ArrayList&lt;Integer&gt; previousPermuation(ArrayList&lt;Integer&gt; nums) {
    // write your code
    if (nums == null || nums.size() == 0) {
        return null;
    }
    int len = nums.size();
    int p = len - 2;
    // 1. find 1st increasing position from the back
    while (p &gt;= 0 &amp;&amp; nums.get(p) &lt;= nums.get(p + 1)) {
        p--;
    }
    // 2. swap p with the first smaller value from the back
    if (p != -1) {
        int q = len - 1;
        while (nums.get(q) &gt;= nums.get(p)) {
            q--;
        }
        swap(nums, p, q);
    }
    // swap array in range of (p+1, end)
    int left = p + 1;
    int right = len - 1;
    while (left &lt; right) {
        swap(nums, left++, right--);
    }
    return nums;
}

private void swap(ArrayList&lt;Integer&gt; num, int p, int q) {
    int temp = num.get(p);
    num.set(p, num.get(q));
    num.set(q, temp);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/26/NineChap-Graph/">[NineChap 6] Graph and Search</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-26T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/06/26/NineChap-Graph/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Graph</h2>

<p>For graph, there are only 2 high-frequency questions, which is &lsquo;clone graph&rsquo; and &lsquo;topology sorting&rsquo;.</p>

<h3>Question list</h3>

<ol>
<li><p><strong><a href="/blog/2014/05/30/Clone-Graph/">Clone Graph</a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="/blog/2014/06/27/Topology-sorting/">Topology Sorting</a></strong></p></li>
</ol>


<h2>Search</h2>

<p>Search have either DFS or BFS.</p>

<p>First, we will cover permutations and combinations using DFS. In this section we solve the famous N-queens question.</p>

<p>Then, there&rsquo;s a few BFS questions. Graph traversal is BFS, and Word ladder is also a classic BFS question.</p>

<h3>Question list</h3>

<ol>
<li><p><strong><a href="/blog/2014/05/22/Subsets/">Subsets</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/22/Subsets-II/">Subsets II</a></strong></p>

<p> difficult</p></li>
<li><p><strong><a href="/blog/2014/05/14/Permutations/">Permutations</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/14/Permutations-II/">Permutations II</a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="/blog/2014/05/16/N-Queens/">N-Queens</a></strong></p>

<p> how to use hashmap (and some space) to make it faster? 3 hashmaps to store the row, the (x,y) diff and sum. This will make isValid() method O(1).</p></li>
<li><p><strong><a href="/blog/2014/05/16/N-Queens-II/">N-Queens II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/12/Next-Permutation/">Next Permutation</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/27/Previous-Permutation/">Previous Permutation</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/29/Palindrome-Partitioning/">Palindrome Partitioning</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/30/Palindrome-Partitioning-II/">Palindrome Partitioning II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/13/Combination-Sum/">Combination Sum</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/13/Combination-Sum/">Combination Sum II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/29/Word-Ladder/">Word Ladder</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/30/Word-Ladder-II/">Word Ladder II</a></strong></p></li>
</ol>


<h3>Additional questions</h3>

<ol>
<li><p><strong><a href="/blog/2014/05/24/Restore-IP-Addresses/">Restore IP Addresses</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/22/Combinations/">Combinations</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/02/Letter-Combinations-of-a-Phone-Number/">Letter Combinations of a Phone Number</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/19/Permutation-Sequence/">Permutation Sequence</a></strong></p></li>
</ol>


<h2>Code</h2>

<h3>Graph</h3>

<p><strong>Clone Graph</strong></p>

<pre><code>public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if (node == null) return null;
    HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = 
            new HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt;();
    Queue&lt;UndirectedGraphNode&gt; queue = new LinkedList&lt;UndirectedGraphNode&gt;();
    map.put(node, new UndirectedGraphNode(node.label));
    queue.add(node);
    while (!queue.isEmpty()) {
        UndirectedGraphNode cur = queue.remove();
        UndirectedGraphNode copy = map.get(cur);
        // here the 'copy' must exist. why? because all neighbors 
        // has been added to the map when they're pushed to queue.
        // so 'cur' must have a corresponding copy in the hashmap. 
        for (UndirectedGraphNode neib: cur.neighbors) {
            if (!map.containsKey(neib)) {
                queue.add(neib);
                map.put(neib, new UndirectedGraphNode(neib.label));
            }
            copy.neighbors.add(map.get(neib));
        }
    }
    return map.get(node);
}
</code></pre>

<p><strong>Topology Sorting</strong></p>

<p>A new post is written for it.</p>

<h3>Search</h3>

<p><strong>Subsets</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; subsets(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (num == null || num.length == 0) {
        return ans;
    }
    Arrays.sort(num);
    helper(ans, new LinkedList&lt;Integer&gt;(), num, 0);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num, int pos) {
    ans.add(new LinkedList&lt;Integer&gt;(path));
    for (int i = pos; i &lt; num.length; i++) {
        path.add(num[i]);
        helper(ans, path, num, i + 1);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Subsets II</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (num == null || num.length == 0) {
        return ans;
    }
    Arrays.sort(num);
    helper(ans, new LinkedList&lt;Integer&gt;(), num, 0);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num, int pos) {
    ans.add(new LinkedList&lt;Integer&gt;(path));
    for (int i = pos; i &lt; num.length; i++) {
        if (i &gt; pos &amp;&amp; num[i - 1] == num[i]) {
            continue;
        }
        path.add(num[i]);
        helper(ans, path, num, i + 1);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Permutations</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (num == null || num.length == 0) {
        return ans;
    }
    helper(ans, new LinkedList&lt;Integer&gt;(), num);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num){
    if (path.size() == num.length) {
        ans.add(new LinkedList&lt;Integer&gt;(path));
    }
    for (int i = 0; i &lt; num.length; i++) {
        if (path.contains(num[i])) {
            continue;
        }
        path.add(num[i]);
        helper(ans, path, num);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Permutations II</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (num == null || num.length == 0) {
        return ans;
    }
    Arrays.sort(num);
    helper(ans, new LinkedList&lt;Integer&gt;(), num, new int[num.length]);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num, int[] visited){
    if (path.size() == num.length) {
        ans.add(new LinkedList&lt;Integer&gt;(path));
        return;
    }
    for (int i = 0; i &lt; num.length; i++) {
        if (visited[i] == 1) {
            continue;
        }
        if (i &gt; 0 &amp;&amp; visited[i - 1] == 1 &amp;&amp; visited[i] == 0 &amp;&amp; num[i - 1] == num[i]) {
            // if current number is same as previous, then don't visit current
            continue;
        }
        path.add(num[i]);
        visited[i] = 1;

        helper(ans, path, num, visited);

        path.remove(path.size() - 1);
        visited[i] = 0;
    }
}
</code></pre>

<p><strong>N-Queens</strong></p>

<p>一次通关！高兴。</p>

<pre><code>public List&lt;String[]&gt; solveNQueens(int n) {
    List&lt;String[]&gt; ans = new LinkedList&lt;String[]&gt;();
    if (n &lt;= 0) {
        return ans;
    }
    helper(ans, new int[n], n, 0);
    return ans;
}

private void helper(List&lt;String[]&gt; ans, int[] path, int n, int pos) {
    if (pos &gt;= n) {
        ans.add(convert(path, n));
        return;
    }
    for (int i = 0; i &lt; n; i++) {
        path[pos] = i;
        if (!isValid(path, pos)) {
            continue;
        }
        helper(ans, path, n, pos + 1);
    }
}

private String[] convert(int[] path, int n) {
    String[] ans = new String[n];
    for (int j = 0; j &lt; n; j++) {
        ans[j] = "";
        for (int i = 0; i &lt; n; i++) {
            ans[j] += (j == path[i]) ? 'Q' : '.';
        }
    }
    return ans;
}

private boolean isValid(int[] path, int pos) {
    for (int i = 0; i &lt; pos; i++) {
        // check path[i] and path[pos]
        if (path[i] == path[pos]) {
            return false;
        }
        if (path[i] - path[pos] == pos - i) {
            return false;
        }
        if (path[pos] - path[i] == pos - i) {
            return false;
        }
    }
    return true;
}
</code></pre>

<p><strong>N-Queens II</strong></p>

<pre><code>int total;

public int totalNQueens(int n) {
    if (n &lt;= 0) {
        return 0;
    }
    helper(new int[n], n, 0);
    return total;
}

private void helper(int[] path, int n, int pos) {
    if (pos &gt;= n) {
        total++;
        return;
    }
    for (int i = 0; i &lt; n; i++) {
        path[pos] = i;
        if (!isValid(path, pos)) {
            continue;
        }
        helper(path, n, pos + 1);
    }
}

private boolean isValid(int[] path, int pos) {
    for (int i = 0; i &lt; pos; i++) {
        // check path[i] and path[pos]
        if (path[i] == path[pos]) {
            return false;
        }
        if (path[i] - path[pos] == pos - i) {
            return false;
        }
        if (path[pos] - path[i] == pos - i) {
            return false;
        }
    }
    return true;
}
</code></pre>

<p><strong>Next Permutation</strong></p>

<pre><code>public void nextPermutation(int[] num) {
    if (num == null || num.length &lt;= 1) {
        return;
    }
    int len = num.length;
    int p = len - 2;
    while (p &gt;= 0 &amp;&amp; num[p] &gt;= num[p + 1]) {
        p--;
    }
    if (p &lt; 0) {
        Arrays.sort(num);
    } else {
        int k = len - 1;
        while (k &gt;= 0 &amp;&amp; num[k] &lt;= num[p]) {
            k--;
        }
        swap(num, p, k);
        reverse(num, p + 1, len - 1);
    }
}

private void swap(int[] num, int p, int k) {
    num[p] = num[p] + num[k];
    num[k] = num[p] - num[k];
    num[p] = num[p] - num[k];
}

private void reverse(int[] num, int s, int d) {
    while (s &lt; d) {
        swap(num, s++, d--);
    }
}
</code></pre>

<p><strong>Previous Permutation</strong></p>

<p>Plz look at the new post.</p>

<p><strong>Palindrome Partitioning</strong></p>

<p>一次通关 again！very 高兴。</p>

<pre><code>public ArrayList&lt;ArrayList&lt;String&gt;&gt; partition(String s) {
    ArrayList&lt;ArrayList&lt;String&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;String&gt;&gt;();
    if (s == null || s.length() == 0) {
        return ans;
    }
    boolean[][] map = palinMap(s);
    helper(ans, new ArrayList&lt;String&gt;(), s, map, 0);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;String&gt;&gt; ans, ArrayList&lt;String&gt; path, String s, boolean[][] map, int pos) {
    int len = s.length();
    if (pos == len) {
        ans.add(new ArrayList&lt;String&gt;(path));
        return;
    }
    for (int i = pos; i &lt; len; i++) {
        if (!map[pos][i]) {
            continue;
        }
        path.add(s.substring(pos, i + 1));
        helper(ans, path, s, map, i + 1);
        path.remove(path.size() - 1);
    }
}

private boolean[][] palinMap(String s) {
    int len = s.length();
    boolean[][] map = new boolean[len][len];
    for (int i = len - 1; i &gt;= 0; i--) {
        for (int j = 0; j &lt; len; j++) {
            if (i &gt; j) {
                continue;
            } else if (i == j) {
                map[i][j] = true;
            } else if (j - i == 1) {
                map[i][j] = s.charAt(i) == s.charAt(j);
            } else {
                map[i][j] = map[i + 1][j - 1] &amp; 
                        s.charAt(i) == s.charAt(j);
            }
        }
    }
    return map;
}
</code></pre>

<p><strong>Palindrome Partitioning II</strong></p>

<p>This is DP, not Graph &amp; Search.</p>

<p><strong>Combination Sum</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (candidates == null || candidates.length == 0) {
        return ans;
    }
    Arrays.sort(candidates);
    helper(ans, new ArrayList&lt;Integer&gt;(), candidates, target, 0);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans, ArrayList&lt;Integer&gt; path, 
        int[] candidates, int target, int pos) {
    if (target == 0) {
        ans.add(new ArrayList&lt;Integer&gt;(path));
        return;
    } else if (target &lt; 0) {
        return;
    }
    for (int i = pos; i &lt; candidates.length; i++) {
        if (target &lt; candidates[i]) {
            continue;
        }
        path.add(candidates[i]);
        helper(ans, path, candidates, target - candidates[i], i);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Combination Sum II</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (candidates == null || candidates.length == 0) {
        return ans;
    }
    Arrays.sort(candidates);
    helper(ans, new ArrayList&lt;Integer&gt;(), candidates, target, 0);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans, ArrayList&lt;Integer&gt; path, 
        int[] candidates, int target, int pos) {
    if (target == 0) {
        ans.add(new ArrayList&lt;Integer&gt;(path));
        return;
    } else if (target &lt; 0) {
        return;
    }
    for (int i = pos; i &lt; candidates.length; i++) {
        if (target &lt; candidates[i]) {
            continue;
        }
        if (i &gt; pos &amp;&amp; candidates[i - 1] == candidates[i]) {
            continue;
        }
        path.add(candidates[i]);
        helper(ans, path, candidates, target - candidates[i], i + 1);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Word Ladder</strong></p>

<p>Note that this is a <strong>BFS question, not DFS</strong>. I made it wrong and it took me a long time.</p>

<pre><code>public int ladderLength(String start, String end, Set&lt;String&gt; dict) {
    Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();
    queue.add(start);
    int length = 1;

    while (!queue.isEmpty()) {
        int currentSize = queue.size();
        for (int k = 0; k &lt; currentSize; k++) {
            String word = queue.remove();
            // insert all adjacent strings of word
            if (word.equals(end)) {
                return length;
            }
            for (int i = 0; i &lt; word.length(); i++) {
                char[] letters = word.toCharArray();
                char originalLetter = letters[i];
                for (char c = 'a'; c &lt;= 'z'; c++) {
                    if (c == originalLetter) continue;
                    letters[i] = c;
                    String newLetters = String.valueOf(letters);
                    if (dict.contains(newLetters)) {
                        queue.add(newLetters);
                        dict.remove(newLetters);
                    }
                }
                letters[i] = originalLetter;
            }
        }
        length++;
    }
    return 0;
}
</code></pre>

<p><strong>Word Ladder II</strong></p>

<p>unsolvable</p>

<h3>Additional questions</h3>

<p><strong>Restore IP Addresses</strong></p>

<pre><code>public List&lt;String&gt; restoreIpAddresses(String s) {
    List&lt;String&gt; ans = new ArrayList&lt;String&gt;();
    if (s == null || s.length() == 0) {
        return ans;
    }
    helper(ans, new ArrayList&lt;String&gt;(), s, 0);
    return ans;
}

private void helper(List&lt;String&gt; ans, List&lt;String&gt; path, String s, int pos) {
    if (path.size() == 4) {
        if (pos == s.length()) {
            ans.add(convert(path));
        }
        return;
    }
    for (int i = pos + 1; i &lt;= s.length() &amp;&amp; i &lt;= pos + 3; i++) {
        String nextNum = s.substring(pos, i);
        if (!isValid(nextNum)) {
            continue;
        }
        path.add(nextNum);
        helper(ans, path, s, i);
        path.remove(path.size() - 1);
    }
}

private boolean isValid(String str) {
    if (str.length() == 1) {
        return true;
    } else if (str.charAt(0) == '0') {
        return false;
    } else {
        int num = Integer.parseInt(str);
        return 0 &lt;= num &amp;&amp; num &lt;= 255;
    }
}

private String convert(List&lt;String&gt; path) {
    String str = "";
    for (String s: path) {
        str += "." + s;
    }
    return str.substring(1);
}
</code></pre>

<p><strong>Combinations</strong></p>

<p>skip</p>

<p><strong>Letter Combinations of a Phone Number</strong></p>

<p>skip</p>

<p><strong>Permutation Sequence</strong></p>

<pre><code>public String getPermutation(int n, int k) {
    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
    int fact = 1;
    for (int i = 1; i &lt;= n; i++) {
        list.add(i);
        fact *= i;
    }
    String ans = "";
    for (int i = n; i &gt; 0; i--) {
        fact = fact / i;
        int rank = (k - 1) / fact;
        k = (k - 1) % fact + 1;

        int curNum = list.remove(rank);
        ans += String.valueOf(curNum);
    }
    return ans;
}
</code></pre>

<h2>Conclusion</h2>

<h4>DFS (O(2<sup>n</sup>), O(n!))</h4>

<ol>
<li>Find all possible solutions</li>
<li>Permutations / Subsets</li>
</ol>


<h4>BFS (O(m), O(n))</h4>

<ol>
<li>Graph traversal</li>
<li>Find shortest path in a simple graph</li>
</ol>


<p><strong>Two most canonical BFS questions</strong>:</p>

<ol>
<li>Graph traversal and toposort</li>
<li>Word Ladder</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/26/Khan-academy-8-brain-teasers/">[Brain Teaser] Khan Academy 8 Brain Teasers</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-26T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/06/26/Khan-academy-8-brain-teasers/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question List</h3>

<p><a href="http://tigerandy.blog.163.com/blog/static/976385201301485058608/">link</a></p>

<p><a href="https://www.khanacademy.org/math/recreational-math/puzzles/brain-teasers/v/liar-truthteller-brain-teaser">link2</a></p>

<ol>
<li>Liar truth-teller (skip)</li>
<li>Toggler brain teaser</li>
<li>Alien abduction</li>
<li>Blue forehead room</li>
<li>Forehead numbers</li>
<li>Light bulb switching</li>
<li>Path counting (skip)</li>
<li>3D path counting</li>
</ol>


<h3>Toggler brain teaser</h3>

<p>“你前面站了5个人，他们中间只有一个人讲真话……”</p>

<p>这个问题比上个问题难就难在，你只知道他们五个中有一个只讲真话，但其余四个，他们有时候讲真话，有时候讲假话，只有一点可以确定，这四个人将真话和假话有个规律：如果这次讲了真话，下次就会讲假话，如果这次讲假话，下次就讲真话。你的任务是，把五个人中那个只讲真话的人找出来。</p>

<p>你可以问两个问题，两个问题可以向同一个人发问，也可以分别问两个人。</p>

<p>你该问什么问题？</p>

<p>小提示：你可以这样安排两个问题承担的任务：首先你可以先问一个问题，不管得到的答案是什么，你都能从中知道下一个问题你将得到的答案是真是假。</p>

<p>求职者的最佳答案：</p>

<p>随便找一个人，首先问：“你是那个只讲真话的吗？”如果答案是肯定的，你再问这个人：“谁是只讲真话的？”；如果第一个问题你得到的答案是否定的，你就再问对方“谁不是只讲真话的？”</p>

<p>正如这个问题给出的提示，第一个问题的价值在于，如果你得到的答案是“我是”，那么你问的人要么是那个只讲真话的，要么是那个这一轮讲假话的“半真话半假话”者，不管是谁，他下一轮一定会说真话。所以你可以继续问这个人：“谁是只讲真话的？”对方的答案就是正确答案。</p>

<p><img class="middle" src="/assets/images/brain-teaser-toggler.png"></p>

<p>如果对第一个问题你得到的答案是“我不是”，那么回答者不可能是只讲真话的那个人，只能是一个此轮讲真话的“半真话半假话”者。此人下一轮将会说假话，所以你应该问他：“谁不是只讲真话的？”同样他告诉你的，只能是那个只讲真话的。</p>

<h3>Alien abduction</h3>

<p>“外星人打算将地球用来种蘑菇，并且已经抓了十个人类……”</p>

<p>外星人用这十个人代表地球60亿人口，将通过外星人的方式来测试这十个人，决定地球是不是有资格加入跨星际委员会，如果没有，就把地球变成一个蘑菇农场。</p>

<p>明天，这十个人将被关在一间漆黑的屋子里前后排成一队，外星人将给每个人戴一顶帽子，帽子为紫色或者绿色，然后外星人会将灯打开，这十个人每个人都无法看见自己头上的帽子是什么颜色，但可以看见排在你前面的每个人头上帽子的颜色。</p>

<p>帽子的颜色是随机的，可能全是紫的，也可能全是绿的，或者是任意的组合。</p>

<p>外星人会从后往前问每一个人:“你头上的帽子是什么颜色？”如果这个人答对了，这个人就安然无事，他所代表的地球上6亿人口也将获救。否则，这个人将被爆头，外星人将把他所代表的6亿人口变成蘑菇的肥料。每个人的答案屋子里所有人都可以听到。</p>

<p>现在，人类的命运在你手上，你可以设计一个方案，使这十个人提前制定一个计划，这个计划必须拯救尽可能多的人。</p>

<p>提示：有个方案可以让你拯救其中至少九个人。</p>

<p>求职者的最佳答案：</p>

<p>第十个人计算排在前面的所有人的绿帽子是奇数还是偶数并向前面的人发出一个信号，这样排在前面人就可以再通过排在更前面的所有人的绿帽子的奇偶数是否变化来判断自己帽子的颜色，因为如果绿帽子奇偶发生变化，那自己就是那个导致变化的“绿帽子”，如果没变化，自己就是“紫帽子”。</p>

<p>因为所有的人除了回答外星人的问题不能说话，所以第十个人的“信号”只能包含在自己的答案里，比如如果排在前面的九个人有奇数顶绿帽子，这个人类就告诉外星人自己的帽子是“绿色”，如果是偶数，就猜自己的帽子是“紫色”。这样等于给他前面的人一个暗号，排在他前面的这个人，可以通过计算自己前面的所有人的绿帽子的奇偶变化来判断自己的帽子是绿还是紫。</p>

<p>排在最后的那个人为了大众利益没有选择，根据前面的人的帽子情况告诉外星人自己是“绿帽子”还是“紫帽子”，他的答案有1/2的几率正确，但他前面的人一定都能答对。</p>

<p>还没懂？比如第十个人看到前面有奇数个绿帽子，他就告诉外星人自己的是绿色，这是他前面的人就知道他的意思是前面九个人中有奇数个绿帽子，这是第九个人再数前面八个人的，如果前面八个人中也有奇数个，那自己就是紫色帽子。第九个人告诉外星人自己是紫色帽子，第八个人就知道绿帽子没有减少还是奇数个，再数数前面七个人绿帽子数的奇偶，就可以判断自己帽子的颜色；反之，如果第九个人告诉外星人自己是绿色帽子，那第八个人就应该知道绿色帽子减少了一个由奇数变成了偶数，再看看前面所有的绿帽子情况作出判断。这样一个接一个，只要每个人都认真听后面的人的答案并在心里计算所剩绿帽子的奇偶变化，前面九个人都能获救。</p>

<p>当然，你也可以计算紫色帽子的奇偶。</p>

<h3>Blue forehead room</h3>

<p>“100个完美的逻辑学家坐在一个房间里……”</p>

<p>这是一个电视真人秀节目，节目里100个拥有完美无瑕逻辑思维能力的人围成一圈坐在一个房间里。在进入房间前，这100个人被告知，100个人中至少有一个人的额头是蓝色的。你可以看见别人额头的颜色，但无法看到自己的，你需要对自己额头是不是蓝色进行猜测，在房间的灯被关掉时，如果你推测出你的额头是蓝色的，你需要站起来离开房间。</p>

<p>然后房间的灯被再次打开，那些认为自己额头是蓝色的人已经不在屋内。接下来灯会再次被关掉，剩下的人中推测自己额头是蓝色的离开房间，如此重复。</p>

<p>问题来了，假设这100个人的额头都是蓝色的，将会发生什么情况？注意，这100个人都有完美无瑕的逻辑推理能力，他们会根据其他人的额头颜色对自己进行合理的推理和猜测。</p>

<p>提示：想想看，如果100个人不全是蓝色额头，又会发生什么情况？</p>

<p>求职者的最佳答案：</p>

<p>将会出现的情况是：灯关了又开，开了又关，重复到第一百次时，所有人都同时离开。</p>

<p>这是为什么呢？想想看，每个人都看见其他99个人额头是蓝色的，灯关掉后再打开，发现这99个蓝色额头的同伴都没有离开，然后灯再次关掉后打开，如此重复100遍后，所有人同时离开了房间。</p>

<p>这么理解吧，假设只有一个人的额头是蓝色的，由于这100个人事先被告知至少有一个人额头是蓝色，所以这个人如果看到其他99个人额头都不是蓝色，立马就知道自己是蓝色，所以灯一关掉，这个人就会离开房间。</p>

<p>如果有两个人额头是蓝色呢？</p>

<p>其中一个蓝色额头的人会想：我的额头可能是蓝色也可能不是蓝色，现在其他99个人中有一个蓝色额头的人，如果我不是蓝色，那么就只有这一个人是，那么他看到我们都不是蓝色额头就能推断出他是，那么灯一关他就会离开，我先等一下，灯再打开如果他已经走了，那就证明我的额头不是蓝色的。</p>

<p>反之，如果我的额头是蓝色的，那个蓝色额头的人的想法会和我刚才的想法一样先等一等，第一次关灯他不会离开，这样如果灯开了那个蓝色额头的人还在，就证明我的额头也是蓝色的。这样第二次关灯我们俩会一起离开。</p>

<p>以此类推，如果有三个人额头是蓝色，你看到另外两个人额头是蓝色，应该推算出如果自己的额头不是蓝色的话，那么灯第二次关的时候他们俩会同时离开，如果他们俩没有同时离开，那就证明我的额头是蓝色的，我应该在第三次关灯的时候离开。结果是，三个蓝色额头的人在第三次关灯的时候同时离开。</p>

<p>把上述逻辑重复一百遍，你就得到了最上面的正确答案。</p>

<h3>Forehead numbers</h3>

<p>“逻辑学家们围成一圈坐着，他们的额头上面画有数字……”</p>

<p>又来一个逻辑学家围成一圈的问题，这次是这样的，三个拥有完美逻辑推理能力的人围成一圈坐在一个房间里，每个人的额头上都画着一个大于0的数字，三个人的数字各不相同，每个人都看得见其他两个人的数字，看不见自己的。</p>

<p>这三个数字的情况是，其中一个数字是其他两个数字的和，已知的情况还有，其中一个逻辑学家的数字是20，一个是30。</p>

<p>游戏组织者从这三个逻辑学家后面走过，并问三个人各自额头上的数字是什么。但第一轮每个逻辑学家都回答他们无法推测自己的数字是什么。游戏组织者只好进行第二轮的发问，这是为什么？你能据此猜出三个逻辑学家的数字吗？</p>

<p>求职者的最佳答案：</p>

<p>结果由第三个逻辑学家的答案而定。他们三个的数字分别是20，30和50。</p>

<p>假设第二个和第三个逻辑学家额头上的数字是20和30，这时候如果第一个逻辑学家的数字是10，那么第二个逻辑学家看到其他两个人一个是10，一个是30，会想：“我要么是20，要么是40。”</p>

<p>第三个逻辑学家看到其他两个人一个是10，一个是20，会想：“我要么是30，要么是10，但我不会是10，因为每个数字都不一样，所以我应该是30。”</p>

<p>这样第三个逻辑学家就会猜出自己的数字是30了，但他没有，第一轮谁也没有准确推测出自己的数字，这说明我们的前提不正确，第一个逻辑学家的数字不是10，那么他只能是50。</p>

<h3>Light bulb switching</h3>

<p>“你面前有一百个灯泡，排成一排……”</p>

<p>一百个灯泡排成一排，第一轮你把他们全都打开亮着，然后第二轮，你每隔一个灯泡关掉一个，这样所有排在偶数的灯泡都被关掉了。</p>

<p>然后第三轮，你每隔两个灯泡，将开着的灯泡关掉，关掉的灯泡打开（也就是说将所有排在3的倍数的灯泡的开关状态改变）。</p>

<p>以此类推，你将所有排在4的倍数的灯泡的开关状态改变，然后将排在5的倍数的灯泡开关状态改变……</p>

<p>第100轮的时候，还有几盏灯泡亮着？</p>

<p>提示：如果你是第n轮（n大于1小于100），排在n的倍数位置的灯泡的开关状态就发生转变。</p>

<p>反过来，比如第8个灯泡，当你在8的因子轮（即第1，2，4和8轮）的时候，它就会改变开关状态。所以对于第m个灯泡，如果m有奇数个因子，你的开关状态就发生奇数次变化。</p>

<p>求职者的最佳答案：</p>

<p>10盏灯泡亮着，这10盏灯泡排位数都是平方数。</p>

<p>根据提示已经可以看出，这个问题的实质就是找出有多少个灯泡的排位数拥有奇数个因子。每拥有一个因子，到这个因子数的那一轮时，这个灯泡就会被转换开关状态。</p>

<p>比如第1轮，因为所有100个数字都有因数1，所以全部被打开；第2轮，只有那些拥有2这个因子、能被2整除的数字的灯泡转换状态被关掉；第3轮，只有那些拥有3这个因子、能被3整除的数字的灯泡被转换状态。以此类推，如果灯泡排位数拥有奇数个因子，意味着它被打开和关上奇数次，那它就最终还是被打开的状态，如果灯泡排位数拥有偶数个因子，那它最终就是被关上的状态。</p>

<p>比如第1个灯泡有奇数个因子，第2个有偶数个（1，2），第3个有偶数个（1，3）第4个有奇数个（1，2，4），所以 第4个灯泡最后还是亮着的。</p>

<p>最终计算得出，所有排位数为平方数的灯泡最终还是亮着的，因为这些数都拥有奇数个因子，1，4，9，16……</p>

<p>在100以内，共有10个平方数，分别是1，4，9，16，25，36，49，64，81，100。这10个排位数的灯泡，最终都还是亮着。</p>

<h3>3D path counting (most difficult)</h3>

<p>“你有一个立方体，立方体的边长是3……”</p>

<p>这个问题比前面那个从左上格子走到右下格子的问题难，因为那毕竟是个平面问题。如图所示，这次的任务是从立方体的背面左上的小立方体走到完全相对的正面右下小立方体。</p>

<p>你可以往上移，也可以往下移，还可以往前移。You can movetoward the front, you can move down, or you can move upward。</p>

<p>问题还是，你共有几种走法？</p>

<p>求职者的最佳答案：</p>

<p>90种，思路是将这个立方体分成“三层”。</p>

<p>上面平面图的那道题的思路就是个最好的提示。你可以将这个立方体分成“三层”，粉红色代表最上面那层，紫色代表中间那层，橘红色代表下面那层。</p>

<p>现在，我们把问题变成了：从左边、右边和上边到达目标小立方体的走法共有多少（如图所示，即到达紫色中间层最右下脚方块以及橘红色最右下脚左边以及上边相邻方块的方法）？假设从起点小立方体到达终点小立方体左边相邻小立方体共有m种方法，到达右边相邻小立方体共有n种方法，到达上边相邻小立方体有r 种方法，那我们需要求出来的，就是n+m+r。</p>

<p>按照前面那道平面题的思路和方法，你就可以一点一点计算出来我们的正确答案。</p>

<table class="tg">
  <tr>
    <th class="tg-031e">1</th>
    <th class="tg-031e">1</th>
    <th class="tg-031e">1</th>
  </tr>
  <tr>
    <td class="tg-031e">1</td>
    <td class="tg-031e">2</td>
    <td class="tg-031e">3</td>
  </tr>
  <tr>
    <td class="tg-031e">1</td>
    <td class="tg-031e">3</td>
    <td class="tg-031e">6</td>
  </tr>
</table>


<p>Layer 1</p>




<table class="tg">
  <tr>
    <th class="tg-031e">1</th>
    <th class="tg-031e">2</th>
    <th class="tg-031e">3</th>
  </tr>
  <tr>
    <td class="tg-031e">2</td>
    <td class="tg-031e">6</td>
    <td class="tg-031e">12</td>
  </tr>
  <tr>
    <td class="tg-031e">3</td>
    <td class="tg-031e">12</td>
    <td class="tg-031e">30</td>
  </tr>
</table>


<p>Layer 2</p>




<table class="tg">
  <tr>
    <th class="tg-031e">1</th>
    <th class="tg-031e">3</th>
    <th class="tg-031e">6</th>
  </tr>
  <tr>
    <td class="tg-031e">3</td>
    <td class="tg-031e">12</td>
    <td class="tg-031e">30</td>
  </tr>
  <tr>
    <td class="tg-031e">6</td>
    <td class="tg-031e">30</td>
    <td class="tg-031e">90</td>
  </tr>
</table>


<p>Layer 3</p>






<p><strong>A better and more elegant mathamatics solution is available <a href="http://math.stackexchange.com/a/317320">here</a></strong></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/24/NineChap-Dynamic-Programming/">[NineChap 5.1] Dynamic Programming</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-24T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/06/24/NineChap-Dynamic-Programming/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Dynamic Programming</h2>

<p>The fundamental of DP is &lsquo;merorized search&rsquo;. It&rsquo;s easy to implement but bad for memory. And it&rsquo;s generally useless in the industry.</p>

<h3>When to use DP?</h3>

<ol>
<li>Input cannot sort</li>
<li>Find minimum/maximum result</li>
<li>Check the feasibility</li>
<li>Count all possible solutions</li>
</ol>


<p>If question asks you to find all possible solutions, it&rsquo;s gonna be DFS, not DP.</p>

<h3>5 Types of DP</h3>

<ol>
<li>Matrix DP (10%)</li>
<li>Sequence/Two Sequences DP (80%)</li>
<li>Interval DP (5%)</li>
<li>Tree DP (5%)</li>
<li>States Compressing DP (0%)</li>
</ol>


<p>Type 3 to 5 are less important.</p>

<h3>Question List</h3>

<p><strong>Type 1: Matrix DP</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/27/Triangle/">Triangle</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/20/Unique-Paths/">Unique Paths </a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/20/Unique-Paths-II/">Unique Paths II  </a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/20/Minimum-Path-Sum/">Minimum Path Sum </a></strong></p></li>
</ol>


<p><strong>Type 2.1: Sequence Dp</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/21/Climbing-Stairs/">Climbing Stairs </a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/16/Jump-Game/">Jump Game </a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/14/Jump-Game-II/">Jump Game II</a></strong> &ndash; tricky, index handling</p></li>
<li><p><strong><a href="/blog/2014/05/30/Palindrome-Partitioning-II/">Palindrome Partitioning II </a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/02/Word-Break/">Word Break </a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/02/Word-Break-II/">Word Break II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/23/Decode-Ways/">Decode Ways </a></strong> &ndash; tricky, initial state</p></li>
<li><p><strong><a href="/blog/2014/06/24/Longest-Increasing-Subsequence/">Longest Increasing Subsequence</a></strong></p></li>
</ol>


<p><strong>Type 2.2: Two Sequences Dp</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/27/Distinct-Subsequences/">Distinct Subsequences </a></strong> &ndash; difficult, state transition formula</p></li>
<li><p><strong><a href="/blog/2014/05/21/Edit-Distance/">Edit Distance </a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/24/Interleaving-String/">Interleaving String </a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/24/Longest-Common-Subsequence/">Longest Common Subsequence</a></strong></p></li>
</ol>


<p><strong>Type 3: Interval Dp</strong></p>

<p><a href="http://wikioi.com/problem/1048/">Merge Stone</a></p>

<p><strong>Type 4: Tree Dp</strong></p>

<ol>
<li><strong><a href="/blog/2014/05/28/Binary-Tree-Maximum-Path-Sum/">Binary Tree Maximum Path Sum</a></strong></li>
</ol>


<p><strong>Type 5: States Compressing DP</strong></p>

<p>Ignore.</p>

<p>Additional questions</p>

<ol>
<li><p><strong><a href="/blog/2014/05/20/Maximum-Subarray/">Maximum Subarray </a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/30/Coin-Changing-Problem/">Coin Change Problem</a></strong></p></li>
</ol>


<h2>Code</h2>

<h4>Type 1: Matrix DP</h4>

<p><strong>Triangle</strong></p>

<pre><code>public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) {
    if (triangle == null || triangle.size() == 0) {
        return 0;
    }
    int len = triangle.size();
    int[][] dp = new int[len][len];
    for (int i = len - 1; i &gt;= 0; i--) {
        // bottom-up approach (row by row)
        for (int j = 0; j &lt;= i; j++) {
            if (i == len - 1) {
                dp[i][j] = triangle.get(i).get(j);
            } else {
                dp[i][j] = triangle.get(i).get(j)
                        + Math.min(dp[i+1][j], dp[i+1][j+1]);
            }
        }
    }
    return dp[0][0];
}
</code></pre>

<p><strong>Unique Paths</strong></p>

<pre><code>public int uniquePaths(int m, int n) {
    if (m == 0 &amp;&amp; n == 0) {
        return 0;
    }
    int[][] dp = new int[m][n];
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (i == 0 || j == 0) {
                dp[i][j] = 1;
            } else {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
    }
    return dp[m-1][n-1];
}
</code></pre>

<p><strong>Unique Paths II</strong></p>

<pre><code>public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    if (obstacleGrid == null) {
        return 0;
    }
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;
    int[][] dp = new int[m][n];
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (obstacleGrid[i][j] != 0) {
                dp[i][j] = 0;
            } else if (i == 0 &amp;&amp; j == 0) {
                dp[i][j] = 1;
            } else if (i == 0) {
                dp[i][j] = dp[i][j-1];
            } else if (j == 0) {
                dp[i][j] = dp[i-1][j];
            } else {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
    }
    return dp[m-1][n-1];
}
</code></pre>

<p><strong>Minimum Path Sum</strong></p>

<pre><code>public int minPathSum(int[][] grid) {
    if (grid == null) {
        return 0;
    }
    int m = grid.length;
    int n = grid[0].length;
    int[][] dp = new int[m][n];
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (i == 0 &amp;&amp; j == 0) {
                dp[i][j] = grid[i][j];
            } else if (i == 0) {
                dp[i][j] = dp[i][j-1] + grid[i][j];
            } else if (j == 0) {
                dp[i][j] = dp[i-1][j] + grid[i][j];
            } else {
                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[m-1][n-1];
}
</code></pre>

<h4>Type 2.1: Sequence Dp</h4>

<p><strong>Climbing Stairs</strong></p>

<pre><code>public int climbStairs(int n) {
    if (n &lt;= 2) {
        return n;
    }
    int[] dp = new int[n];
    dp[0] = 1;
    dp[1] = 2;
    for (int i = 2; i &lt; n; i++) {
        dp[i] = dp[i - 2] + dp[i - 1];
    }
    return dp[n - 1];
}
</code></pre>

<p><strong>Jump Game</strong></p>

<pre><code>public boolean canJump(int[] A) {
    if (A == null || A.length == 0) 
        return false;
    int reach = 0;
    int len = A.length;
    for (int i = 0; i &lt; len; i++) {
        if (i &gt; reach) 
            break;
        reach = Math.max(reach, i + A[i]);
        if (reach &gt;= len - 1)   
            return true;
    }
    return false;
}
</code></pre>

<p><strong>Jump Game II</strong></p>

<pre><code>public int jump(int[] A) {
    if (A == null || A.length &lt;= 1) 
        return 0;
    int[] dp = new int[A.length];
    int cur = 1;
    for (int i = 0; i &lt; A.length - 1; i++) {
        while (cur &lt;= i + A[i] &amp;&amp; cur &lt; dp.length) {
            dp[cur] = dp[i] + 1;
            cur++;
        }
        if (cur == dp.length) {
            break;
        }
    }
    return dp[A.length - 1];
}
</code></pre>

<p><strong>Palindrome Partitioning II</strong></p>

<pre><code>public int minCut(String s) {
    if (s == null || s.length() &lt;= 1) {
        return 0;
    }
    boolean[][] map = palindromeMap(s);
    int len = s.length();
    int[] dp = new int[len + 1];
    dp[0] = -1;
    for (int i = 1; i &lt;= len; i++) {
        dp[i] = Integer.MAX_VALUE;
        for (int j = 1; j &lt;= i; j++) {
            if (map[i-1][j-1]) {
                dp[i] = Math.min(dp[i], dp[j-1] + 1);
            }
        }
    }
    return dp[len];
}

private boolean[][] palindromeMap(String s) {
    int len = s.length();
    boolean[][] map = new boolean[len][len];
    char[] ss = s.toCharArray();
    for (int i = 0; i &lt; len; i++) {
        for (int j = i; j &gt;= 0; j--) {
            if (i == j) {
                map[i][j] = true;
            } else if (i - j == 1) {
                map[i][j] = ss[i] == ss[j];
            } else {
                map[i][j] = (ss[i] == ss[j]) &amp; map[i - 1][j + 1];
            }
        }
    }
    return map;
}
</code></pre>

<p><strong>Word Break</strong></p>

<pre><code>public boolean wordBreak(String s, Set&lt;String&gt; dict) {
    if (s == null || s.length() == 0) {
        return true;
    }
    int len = s.length();
    boolean[] dp = new boolean[len + 1];
    dp[0] = true;
    for (int i = 1; i &lt;= len; i++) {
        for (int j = 0; j &lt; i; j++) {
            if (!dp[j]) {
                continue;
            }
            if (dict.contains(s.substring(j, i))) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[len];
}
</code></pre>

<p><strong>Word Break II</strong></p>

<p>My code is definitely correct, although it got TLE.</p>

<p>See original post for more.</p>

<p><strong>Decode Ways</strong></p>

<pre><code>public int numDecodings(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    int len = s.length();
    int[] dp = new int[len + 1];
    dp[0] = 1;
    dp[1] = 1; // pay attention to the initial state
    if (!isValidNumber(s.substring(0, 1))) {
        return 0;
    }
    for (int i = 2; i &lt;= len; i++) {
        if (isValidNumber(s.substring(i - 1, i))) {
            dp[i] += dp[i - 1];
        }
        if (isValidNumber(s.substring(i - 2, i))) {
            dp[i] += dp[i - 2];
        }
    }
    return dp[len];
}

private boolean isValidNumber(String input) {
    if (input.length() == 0 || input.length() &gt; 2 || input.charAt(0) == '0') {
        return false;
    }
    int num = Integer.parseInt(input);
    return (1 &lt;= num &amp;&amp; num &lt;= 26);
}
</code></pre>

<p><strong>Longest Increasing Subsequence</strong></p>

<p>There&rsquo;s a new post in &lsquo;Lintcode&rsquo; category.</p>

<h4>Type 2.2: Two Sequences Dp</h4>

<p><strong>Distinct Subsequences</strong></p>

<pre><code>public int numDistinct(String S, String T) {
    int m = S.length(), n = T.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 0; i &lt;= m; i++) {
        for (int j = 0; j &lt;= n; j++) {
            if (j == 0) {
                dp[i][j] = 1;
            } else if (i == 0) {
                dp[i][j] = 0;
            } else {
                dp[i][j] = dp[i - 1][j];
                if (S.charAt(i - 1) == T.charAt(j - 1)) {
                    dp[i][j] += dp[i - 1][j - 1];
                }
            }
        }
    }
    return dp[m][n];
}
</code></pre>

<p><strong>Edit Distance</strong></p>

<pre><code>public int minDistance(String A, String B) {
    if (A == null || B == null)
        return 0;
    int m = A.length(), n = B.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 0; i &lt;= m; i++) {
        for (int j = 0; j &lt;= n; j++) {
            if (i == 0) {
                dp[i][j] = j;
            } else if (j == 0) {
                dp[i][j] = i;
            } else {
                if (A.charAt(i - 1) == B.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j]);
                    dp[i][j] = Math.min(dp[i][j], dp[i][j - 1]);
                    dp[i][j]++;
                }
            }
        }
    }
    return dp[m][n];
}
</code></pre>

<p><strong>Interleaving String</strong></p>

<pre><code>public boolean isInterleave(String s1, String s2, String s3) {
    if (s1 == null || s2 == null) {
        return false;
    }
    int m = s1.length(), n = s2.length();
    if (m + n != s3.length()) {
        return false;
    }
    boolean[][] dp = new boolean[m + 1][n + 1];
    for (int i = 0; i &lt;= m; i++) {
        for (int j = 0; j &lt;= n; j++) {
            if (i == 0) {
                dp[i][j] = s2.substring(0, j).equals(s3.substring(0, j));
                continue;
            } else if (j == 0) {
                dp[i][j] = s1.substring(0, i).equals(s3.substring(0, i));
                continue;
            }
            if (i &gt; 0 &amp;&amp; dp[i - 1][j]
                    &amp;&amp; s1.charAt(i - 1) == s3.charAt(i + j - 1)) {
                dp[i][j] = true;
            }
            if (j &gt; 0 &amp;&amp; dp[i][j - 1]
                    &amp;&amp; s2.charAt(j - 1) == s3.charAt(i + j - 1)) {
                dp[i][j] = true;
            }
        }
    }
    return dp[m][n];
}
</code></pre>

<p><strong>Longest Common Subsequence</strong></p>

<p>There&rsquo;s a new post in &lsquo;Lintcode&rsquo; category.</p>

<h3>Type 3: Interval Dp</h3>

<p><strong>Merge Stone</strong></p>

<blockquote><p>有n堆石子排成一列，每堆石子有一个重量w[i], 每次合并可以合并相邻的两堆石子，一次合并的代价为两堆石子的重量和w[i]+w[i+1]。问安排怎样的合并顺序，能够使得总合并代价达到最小。</p></blockquote>

<p><a href="http://wikioi.com/problem/1048/">link</a></p>

<p>Solution explained:</p>

<blockquote><p>sum[i[用于记录从第1堆到第i堆（包含i）石子的总重量。</p>

<p>dp[i][j]表示从第i堆（包含i）到第j堆（包含j）石子的合并的最小代价。</p>

<p>状态转移方程为：dp[i][j] = minimize{dp[i][k] + dp[k+1][j] + sum[j] &ndash; sum[i-1]}, k从i到j（不包含j）。</p>

<p>len=2表示第一次合并的情况，此时合并的石子为2堆。此时，i从1到n-len+1，j=i+len-1。</p></blockquote>

<p>Quoted from <a href="http://blog.csdn.net/kingzone_2008/article/details/12361327">this blog</a> and the solution is well explained on <a href="http://wikioi.com/solution/list/1048/">wikiio</a>.</p>

<h3>Type 4: Tree Dp</h3>

<p><strong>Binary Tree Maximum Path Sum</strong></p>

<p>This is a difficult question, but I solved it. I feel happy.</p>

<pre><code>private class ResultType {
    int maxPath;
    int depth;

    ResultType(int a, int b) {
        this.maxPath = a;
        this.depth = b;
    }
}

public int maxPathSum(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return helper(root).maxPath;
}

private ResultType helper(TreeNode node) {
    if (node == null) {
        return new ResultType(Integer.MIN_VALUE, 0);
    }
    ResultType ll = helper(node.left);
    ResultType rr = helper(node.right);
    int maxPath = node.val + ll.depth + rr.depth;
    maxPath = Math.max(maxPath, ll.maxPath);
    maxPath = Math.max(maxPath, rr.maxPath);
    int depth = 0;
    depth = Math.max(depth, node.val + Math.max(ll.depth, rr.depth));
    return new ResultType(maxPath, depth);
}
</code></pre>

<h3>Additional questions</h3>

<p><strong>Maximum Subarray</strong></p>

<pre><code>public int maxSubArray(int[] A) {
    if (A == null || A.length == 0) {
        return 0;
    }
    int len = A.length;
    int[] dp = new int[len];
    dp[0] = A[0];
    for (int i = 1; i &lt; len; i++) {
        dp[i] = A[i];
        if (dp[i - 1] &gt; 0)
            dp[i] += dp[i - 1];
    }
    int max = Integer.MIN_VALUE;
    for (Integer i : dp)
        max = Math.max(max, i);
    return max;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/24/Longest-Increasing-Subsequence/">[LintCode] Longest Increasing Subsequence</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-24T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/06/24/Longest-Increasing-Subsequence/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://lintcode.com/en/problem/longest-increasing-subsequence/">link</a></p>

<div style="min-height:100px">
    <p>Given a sequence of integers, find the longest increasing subsequence (LIS).</p>
    <p>You code should return the length of the LIS.</p>
    <div class="m-t-lg m-b-lg">
    <b>Example</b>
    <div>
        <p>For [5, 4, 1, 2, 3], the LIS &nbsp;is [1, 2, 3], return 3</p>
        <p>For [4, 2, 4, 5, 3, 7], the LIS is [4, 4, 5, 7], return 4</p>
    </div>
    </div>
</div>


<h3>Analysis</h3>

<p>This is one of the <strong>2 most popular questions of DP</strong>. This is a sequences Dp. The equation isn&rsquo;t difficult. Time complexity of DP solution is O(n<sup>2</sup>).</p>

<p><strong>There&rsquo;s also a binary search solution</strong> which the time complexity is O(nlgn). It&rsquo;s very complex, and very hard to explain, but I&rsquo;ll try:</p>

<p>Maintain an array called &lsquo;array&rsquo;. A[i] denotes the tail of sequence for LIS = i. Initially A[0] = first element of the input, then keep inserting elements into this array. It&rsquo;s explained in <a href="http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/">this post</a>.</p>

<p>I will give an example for the input: 0, 8, 4, 12, 2</p>

<blockquote><p>Our strategy determined by the following conditions:</p>

<ol>
<li><p>If A[i] is smallest among all end candidates of active lists, we will start new active list of length 1.</p></li>
<li><p>If A[i] is largest among all end candidates of active lists, we will clone the largest active list, and extend it by A[i].</p></li>
<li><p>If A[i] is in between, we will find a list with largest end element that is smaller than A[i]. Clone and extend this list by A[i]. We will discard all other lists of same length as that of this modified list.</p></li>
</ol>


<p>A[0] = 0. Case 1. There are no active lists, create one.</p>

<p>array = 0</p>

<p>A[1] = 8. Case 2. Clone and extend.</p>

<p>array = 0, 8</p>

<p>A[2] = 4. Case 3. Clone, extend and discard.</p>

<p>array = 0, 4</p>

<p>A[3] = 12. Case 2. Clone and extend.</p>

<p>array = 0, 4, 12</p>

<p>A[4] = 2. Case 3. Clone, extend and discard.</p>

<p>array = 0, 2, 12</p>

<p>So the LIS is (0, 2, 12) of length 3.</p></blockquote>

<h3>Code</h3>

<p><strong>DP solution, by me</strong></p>

<pre><code>public int longestIncreasingSubsequence(int[] nums) {
    // write your code here
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int len = nums.length;
    int[] dp = new int[len];
    dp[0] = 1;
    for (int i = 1; i &lt; len; i++) {
        dp[i] = 1;
        for (int j = 0; j &lt; i; j++) {
            if (nums[j] &lt;= nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    int lis = 1;
    for (Integer seq : dp) {
        lis = Math.max(lis, seq);
    }
    return lis;
}
</code></pre>

<p><strong>Binary search solution</strong>, C++ code from <a href="http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/">this post</a>. I don&rsquo;t think I am able code this solution.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

using namespace std;

#define ARRAY_SIZE(A) sizeof(A)/sizeof(A[0])
// Binary search (note boundaries in the caller)
// A[] is ceilIndex in the caller
int CeilIndex(int A[], int l, int r, int key) {
    int m;

    while( r - l &gt; 1 ) {
        m = l + (r - l)/2;
        (A[m] &gt;= key ? r : l) = m; // ternary expression returns an l-value
    }

    return r;
}

int LongestIncreasingSubsequenceLength(int A[], int size) {
    // Add boundary case, when array size is one

    int *tailTable   = new int[size];
    int len; // always points empty slot

    memset(tailTable, 0, sizeof(tailTable[0])*size);

    tailTable[0] = A[0];
    len = 1;
    for( int i = 1; i &lt; size; i++ ) {
        if( A[i] &lt; tailTable[0] )
            // new smallest value
            tailTable[0] = A[i];
        else if( A[i] &gt; tailTable[len-1] )
            // A[i] wants to extend largest subsequence
            tailTable[len++] = A[i];
        else
            // A[i] wants to be current end candidate of an existing subsequence
            // It will replace ceil value in tailTable
            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i];
    }

    delete[] tailTable;

    return len;
}

int main() {
    int A[] = { 2, 5, 3, 7, 11, 8, 10, 13, 6 };
    int n = ARRAY_SIZE(A);

    printf("Length of Longest Increasing Subsequence is %d\n",
            LongestIncreasingSubsequenceLength(A, n));

    return 0;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/24/Longest-Common-Subsequence/">[LintCode] Longest Common Subsequence</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-24T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/06/24/Longest-Common-Subsequence/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://lintcode.com/en/problem/longest-common-subsequence/">link</a></p>

<div style="min-height:100px">
    <p>Given two strings, find the longest comment subsequence (LCS).</p>
    <p>Your code should return the length of LCS.</p>
    <div class="m-t-lg m-b-lg">
    <b>Example</b>
    <div>
        <p>For &#8220;ABCD&#8221; and &#8220;EDCA&#8221;, the LCS is &#8220;A&#8221; (or D or C), return 1</p>
        <p>For &#8220;ABCD&#8221; and &#8220;EACB&#8221;, the LCS is &#8220;AC&#8221;, return 2</p>
    </div>
    </div>
</div>


<h3>Analysis</h3>

<p>This is one of the <strong>2 most popular questions of DP</strong>.</p>

<p>This is a two-sequences Dp. The equation is not difficult to build. (consider only the last element of the DP array when building the state transition equation)</p>

<h3>Code</h3>

<pre><code>public int longestCommonSubsequence(String A, String B) {
    // write your code here
    if (A == null || B == null) {
        return 0;
    }
    int m = A.length(), n = B.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 1; i &lt;= m; i++) {
        for (int j = 1; j &lt;= n; j++) {
            if (A.charAt(i - 1) == B.charAt(j - 1)) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/23/Cache-algorithms/">[Design] Cache and Page Replacement Algorithms</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-23T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/06/23/Cache-algorithms/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Cache Algorithms</h3>

<p>This post is originally written for <strong>Cache Algo</strong> only, before I found out this 2 topics are very similar, so I changed the title to &ldquo;Cache and Page Replacement Algorithms&rdquo;.</p>

<h4>Equation</h4>

<p>of memory reference time is:</p>

<p>T = m * T(m) + T(h) + E</p>

<blockquote><p>m: miss ratio = 1 &ndash; hit ratio</p>

<p>T(m): time for main memory access</p>

<p>T(h): latency (when there&rsquo;s a hit)</p>

<p>E: secondary effects liek queuing effects etc.</p></blockquote>

<h4>hit ratio</h4>

<p>how often a searched-for item is actually found in the cache</p>

<h4>latency</h4>

<p>how long after requesting a desired item the cache can return that item (when there is a hit).</p>

<h3>Replacement policy</h3>

<h4>Bélády&rsquo;s Algorithm (Optimal Algorithm)</h4>

<p>The optimal algorithm, not implementable in practise.</p>

<h4>LFU</h4>

<p>Least Frequently Used, slow and not very adaptive.</p>

<h4>LRU</h4>

<p>Fast and adaptive, but hard to implement.</p>

<p>It can be implemented with either a counter or a stack/doubleLinkedList.</p>

<p>Web browser use this.</p>

<h4>LRU2 and 2Qs</h4>

<p><strong>LRU2</strong> &ndash; Only add entries to the cache the second time they are accessed.</p>

<p><strong>Two Queues</strong> &ndash; Add entries to an normal LRU cache. If accessed again, move it to second, larger, LRU cache.</p>

<h4>MRU (most recent used)</h4>

<p>Some claim that MRU cache algorithms have more hits than LRU due to their tendency to retain older data.</p>

<h4>FIFO</h4>

<p>Low-overhead, fast but not adaptive.</p>

<h4>Second-chance</h4>

<p>Modified version of FIFO. Relatively better than FIFO at little cost.</p>

<p>Initially, a reference bit is set. Instead of removing old entries, it clears reference bit first, and insert that entry at the back of the queue. An entry is only cleared if the reference bit is not set. This is like a circular queue.</p>

<p>If all the pages have been referenced, second chance degenerates into pure FIFO. Why? Let&rsquo;s say all entries reference are set, the pointer will go around the entire list and clear all references, and in the end come back to the starting point. Then, it&rsquo;s like a FIFO. For more, see the <a href="http://javalandscape.blogspot.sg/2009/01/cachingcaching-algorithms-and-caching.html">link</a>.</p>

<h4>Clock</h4>

<p>Modified version of second-hand. Better than second hand. Instead of pushing to the back, it keep a &ldquo;hand&rdquo; pointer in the circular list. <a href="http://javalandscape.blogspot.sg/2009/01/cachingcaching-algorithms-and-caching.html">link</a></p>

<p>When cache miss occurs and no empty place exists, then I consult the R (referenced) bit at the hand&rsquo;s location to know what I should do. If R is 0, then I will place the new entry at the &ldquo;hand&rdquo; position, otherwise I will clear the R bit. Then, I will increment the hand (iterator) and repeat the process until an entry is replaced.</p>

<h4>Simple time-based</h4>

<p>Fast, but not adaptive. Entries remain in cache for a specific amount of time.</p>

<h4>Extended time-based expiration</h4>

<p>Only clear cache at certain points in time (say every 5 minutes).</p>

<h3>Conclusion</h3>

<p>Each replacement strategy is a <strong>compromise between hit rate and latency</strong>.</p>

<h4>One more thing</h4>

<p>What is Distributed cache?</p>

<p><a href="http://en.wikipedia.org/wiki/Distributed_cache">Distributed cache</a> is an extension of the traditional concept of cache used in a single locale.</p>

<p>A distributed cache may <strong>span multiple servers</strong> so that it can grow in size and in transactional capacity. It is mainly used to store <strong>application data residing in database and web session data</strong>.</p>

<p>The idea of distributed caching has become feasible now because main memory has become very cheap and network cards have become very fast (speed of 1 Gbit is now standard, and 10 Gbit is gaining traction).</p>

<p>Also, a distributed cache works well on <strong>lower cost machines usually employed for web servers</strong> as opposed to <strong>database servers</strong> which require expensive hardware.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/18/Two-egg-100-floor-question/">[Brain Teaser] 2 Eggs 100 Floors Puzzle</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-18T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/06/18/Two-egg-100-floor-question/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.programmerinterview.com/index.php/puzzles/2-eggs-100-floors-puzzle/">link</a></p>

<blockquote><p>You are given 2 eggs.</p>

<p>You have access to a 100-storey building.</p>

<p>Eggs can be very hard or very fragile means it may break if dropped from the first floor or may not even break if dropped from 100 th floor.Both eggs are identical.</p>

<p>You need to figure out the highest floor of a 100-storey building an egg can be dropped without breaking.</p>

<p>Now the question is how many drops you need to make. You are allowed to break 2 eggs in the process</p></blockquote>

<h3>Analysis</h3>

<p>Most obvious solutoin is drop in 10th, 20th, 30th &hellip; floor. But this solution would result in <strong>19 drops in worst case</strong>. We should try to reduce the worst case scenario by making all possible scenarios take the same number of drops!</p>

<p>The best solution is:</p>

<blockquote><p>What if we tried to reduce the number of drops that would be required with the linear search (with the 2nd egg) after we get to one of the higher floors? This way we <strong>counteract the fact that getting to the higher floor took so many drops</strong>, and if we use less drops for the linear search we are <strong>balancing out the worst case</strong>.</p></blockquote>

<p>According to the <a href="http://www.programmerinterview.com/index.php/puzzles/2-eggs-100-floors-puzzle/">solution</a>, we form a series:</p>

<blockquote><p>x + (x-1) + (x-2) + (x-3) + &hellip; + 1 = 100</p>

<p>x(x+1)/2 = 100</p>

<p>x = 14</p></blockquote>

<h3>Final Result</h3>

<p>We would drop in this way:</p>

<table width="50">
<thead><tr><th>&nbsp;Drop&nbsp;</th><th>&nbsp;Floor&nbsp;</th></tr></thead>
<tbody><tr align="center"><td>#1</td><td>14</td></tr>
<tr align="center"><td>#2</td><td>27</td></tr>
<tr align="center"><td>#3</td><td>39</td></tr>
<tr align="center"><td>#4</td><td>50</td></tr>
<tr align="center"><td>#5</td><td>60</td></tr>
<tr align="center"><td>#6</td><td>69</td></tr>
<tr align="center"><td>#7</td><td>77</td></tr>
<tr align="center"><td>#8</td><td>84</td></tr>
<tr align="center"><td>#9</td><td>90</td></tr>
<tr align="center"><td>#10</td><td>95</td></tr>
<tr align="center"><td>#11</td><td>99</td></tr>
<tr align="center"><td>#12</td><td>100</td></tr>
</tbody>
</table>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="42">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="40">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (76)</a></li>
<li class='category'><a href='/blog/categories/experience/'>experience (4)</a></li>
<li class='category'><a href='/blog/categories/fundamental/'>fundamental (12)</a></li>
<li class='category'><a href='/blog/categories/java-oop/'>java oop (30)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (176)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (25)</a></li>
<li class='category'><a href='/blog/categories/q-facebook/'>q-facebook (9)</a></li>
<li class='category'><a href='/blog/categories/q-google/'>q-google (63)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (123)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (5)</a></li>
<li class='category'><a href='/blog/categories/z-string-search/'>z-string-search (17)</a></li>
<li class='category'><a href='/blog/categories/z-testing/'>z-testing (2)</a></li>
<li class='category'><a href='/blog/categories/z-top-k/'>z-top-k (6)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/10/02/shorest-manhattan-distance/">[Google] Shortest Manhattan Distance </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/02/Facebook-photo-storage/">[Design] Facebook Photo Storage </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/30/how-google-search-works/">[Design] How Google search works </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/30/design-class4-2/">[NineChap System Design] Class 4.2: Search Engine </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/30/design-class4-1/">[NineChap System Design] Class 4.1: Crawler </a>
      </li>
    
  </ul>
</section>





<script type="text/javascript" src="http://srvpub.com/adServe/banners?tid=29011_41781_0&size=120x600" ></script>

<!--
<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"willran168","width":160,"height":600,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>
<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>
&#8211;>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
    Copyright &copy; 2015 - <a href="/about">CodeMonkey</a> -  All posts are my original writing, based uppon my personal view. <a href="/policy">Privacy Policy</a> - 
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
