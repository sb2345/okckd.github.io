
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Woodstock Blog</title>
  <meta name="author" content="Charlie Brown">

  
  <meta name="description" content="Question DLL &ndash; link Inorder &ndash; link Given a BST, write a function that returns true if there is a triplet that sums to 0, returns false &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/4">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Woodstock Blog</a></h1>
  
    <h2>What's the good of living if you don't try a few things?</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/18/Binary-Search-Tree-3Sum/">[Facebook] Binary Search Tree 3Sum (Undone)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-18T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/12/18/Binary-Search-Tree-3Sum/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/12/18/Binary-Search-Tree-3Sum/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p>DLL &ndash; <a href="http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/">link</a></p>

<p>Inorder &ndash; <a href="http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/">link</a></p>

<blockquote><p>Given a BST, write a function that returns true if there is a triplet that sums to 0, returns false otherwise.</p></blockquote>

<h3>Solution</h3>

<p>We will solve the question just like we do <strong>[LeetCode 15] 3Sum</strong>. What is missing is an random access of tree nodes, like we have in array.</p>

<p>In fact, we do not need random access. Tree traversal (one after another in sequence) would be good enough.</p>

<p>Now there&rsquo;re 2 solution. <strong>First is to convert the tree to Double-linked list</strong>, then do 3Sum. The conversion takes O(n) time and O(logn) extra space, and 3Sum take O(n<sup>2</sup>). however doing this modifies the original tree.</p>

<p><strong>Second solution is to to inorder traversal and reversed inorder traversal</strong>. This is a better solution, personally. And the time and space used is same.</p>

<h3>Code</h3>

<p><strong>DLL way, written by me</strong></p>

<pre><code>public void findTriplet(TreeNode root, int target) {
    TreeNode[] dll = convertToDll(root);
    TreeNode head = dll[0];
    TreeNode tail = dll[1];
    // note that the bst inorder dll should already in sorted by value
    TreeNode first = head;
    while (first.right != null) {
        TreeNode left = first.right;
        TreeNode right = tail;
        while (left.val &lt; right.val) {
            int diff = first.val + left.val + right.val - target;
            if (diff == 0) {
                System.out.println("Found triplet: " + first.val + " "
                        + left.val + " " + right.val + " for sum of "
                        + target);
            }
            if (diff &lt;= 0) {
                left = left.right;
            }
            if (diff &gt;= 0) {
                right = right.left;
            }
        }
        first = first.right;
    }
}

private TreeNode[] convertToDll(TreeNode node) {
    TreeNode[] ans = new TreeNode[2];
    // do the left side of node
    if (node.left == null) {
        ans[0] = node;
    } else {
        TreeNode[] preAns = convertToDll(node.left);
        ans[0] = preAns[0];
        node.left = preAns[1];
        preAns[1].right = node;
    }
    // do the right side of node
    if (node.right == null) {
        ans[1] = node;
    } else {
        TreeNode[] postAns = convertToDll(node.right);
        ans[1] = postAns[1];
        node.right = postAns[0];
        postAns[0].left = node;
    }
    return ans;
}
</code></pre>

<p><strong>inorder way</strong></p>

<p>undone</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/17/Print-Binary-Tree-Vertically/">[Facebook] Print a Binary Tree in Vertical Order</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-17T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/12/17/Print-Binary-Tree-Vertically/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/12/17/Print-Binary-Tree-Vertically/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/print-binary-tree-vertical-order/">link</a></p>

<blockquote><p>Given a binary tree, print it vertically. The following example illustrates vertical order traversal.</p></blockquote>

<pre><code>           1
        /    \
       2      3
      / \    / \
     4   5  6   7
             \   \
              8   9 

The output of print this tree vertically will be:
4
2
1 5 6
3 8
7
9 
</code></pre>

<h3>Solution</h3>

<ol>
<li><p>Traverse the tree once and get the minimum and maximum horizontal distance with respect to root.</p></li>
<li><p>Iterate for each vertical line at distance minimum to maximum from root.</p></li>
</ol>


<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; printVertically(TreeNode root) {
    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();

    // 1. find the range of left bound and right bound
    int[] range = new int[2];
    findRange(root, range, 0);

    // 2. calculate number of columns in the result
    int rootIndex = 0 - range[0];
    int columns = range[1] - range[0] + 1;
    for (int i = 0; i &lt; columns; i++) {
        ans.add(new ArrayList&lt;Integer&gt;());
    }

    // 3. fill in vertically in a recursive manner
    fillNode(ans, root, rootIndex);

    return ans;
}

private void fillNode(List&lt;List&lt;Integer&gt;&gt; ans, TreeNode node, int index) {
    if (node == null) {
        return;
    }
    ans.get(index).add(node.val);
    fillNode(ans, node.left, index - 1);
    fillNode(ans, node.right, index + 1);
}

private void findRange(TreeNode node, int[] range, int position) {
    if (node == null) {
        return;
    }
    if (position &lt; range[0]) {
        range[0] = position;
    }
    if (position &gt; range[1]) {
        range[1] = position;
    }
    findRange(node.left, range, position - 1);
    findRange(node.right, range, position + 1);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/08/patient-disease-data-structure/">[Epic] Patient Disease Data Structure</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-08T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/12/08/patient-disease-data-structure/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/12/08/patient-disease-data-structure/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.mitbbs.com/article_t0/JobHunting/32844253.html">link</a></p>

<blockquote><p>Suppose N patients and M diseases. N is sufficiently large number and M is
relatively small, say 30-ish. Each patient can have possible 0 to M kinds of
diseases.</p>

<p>Given one patient’s name, show me a list of similar patients sharing same
deseases within 2-3 seconds.</p></blockquote>

<h3>Solution</h3>

<p><strong>Use 1 bit to represent a disease</strong>. So every patient&rsquo;s conditin can be put into an integer of 32 bits.</p>

<p>How do we calculate the similarity of 2 patients?</p>

<p>Refer to <strong>[CC150v5] 5.5 Calculate Bits Conversion Required</strong> for a special bit operation (remove last &lsquo;1&rsquo; from bit):</p>

<blockquote><p>c = c &amp; (c &ndash; l) clears the least significant bit of &lsquo;1&rsquo;.</p>

<p>Keep doing this until all &lsquo;1&rsquo;s are cleared.</p></blockquote>

<p>For each patient, we simply calculate the XOR and count &lsquo;1&rsquo;s.</p>

<h3>Code</h3>

<p>no code.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/01/Leetcode-fourth/">[Leetcode] Leetcode Fourth Round</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-01T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/12/01/Leetcode-fourth/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/12/01/Leetcode-fourth/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><pre><code>Days:        01/12/2014 - now
Submission:  
Pass:        

Submit/day:  
Pass/day:    

Pass/submit: 
</code></pre>

<h3>Easy</h3>

<ol>
<li>[LeetCode 1] Two Sum</li>
<li>[LeetCode 5] Longest Palindromic Substring</li>
<li>[LeetCode 6] ZigZag Conversion</li>
<li>[LeetCode 7] Reverse Integer</li>
<li>[LeetCode 12] Integer to Roman</li>
<li>[LeetCode 16] 3Sum Closest</li>
<li>[LeetCode 18] 4Sum</li>
<li>[LeetCode 19] Remove Nth Node From End of List</li>
<li>[LeetCode 23] Merge K Sorted Lists</li>
<li>[LeetCode 25] Reverse Nodes in k-Groups</li>
<li>[LeetCode 27] Remove Element</li>
<li>[LeetCode 30] Substring With Concatenation of All Words</li>
<li>[LeetCode 32] Longest Valid Parentheses</li>
<li>[LeetCode 36] Valid Sudoku</li>
<li>[LeetCode 41] First Missing Positive</li>
<li>[LeetCode 42] Trapping Rain Water</li>
<li>[LeetCode 45] Jump Game II</li>
<li>[LeetCode 50] Pow(x, N)</li>
<li>[LeetCode 55] Jump Game</li>
<li>[LeetCode 72] Edit Distance</li>
<li>[LeetCode 79] Word Search</li>
<li>[LeetCode 80] Remove Duplicates From Sorted Array II</li>
<li>[LeetCode 94] Binary Tree Inorder Traversal</li>
<li>[LeetCode 142] Linked List Cycle II</li>
</ol>


<h3>Difficult</h3>

<ol>
<li>[LeetCode 3] Longest Substring Without Repeating Characters</li>
<li>[LeetCode 4] Median of Two Sorted Arrays</li>
<li>[LeetCode 10] Regular Expression Matching</li>
<li>[LeetCode 15] 3Sum</li>
<li>[LeetCode 29] Divide Two Integers</li>
<li>[LeetCode 37] Sudoku Solver</li>
<li>[LeetCode 44] Wildcard Matching</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/04/Code-a-hashmap/">[Google] Code a HashMap</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-04T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/11/04/Code-a-hashmap/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/11/04/Code-a-hashmap/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.glassdoor.com/Interview/Code-a-hashmap-which-you-would-be-happy-to-place-into-a-production-environment-QTN_725885.htm">link</a></p>

<blockquote><p>Code a hashmap which you would be happy to place into a production environment.</p></blockquote>

<h3>Solution</h3>

<p>We already write 2 post before:</p>

<ol>
<li><p><strong>[Question] Implement a HashMap</strong></p></li>
<li><p><strong>[CC150v5] 8.10 Implement a Hashmap</strong></p></li>
</ol>


<p>But still, this is not an easy question when asked at an interview. It won&rsquo;t harm to do a little recap:</p>

<ol>
<li>The basic structure is an array. It can be:

<ol>
<li>An array of linked nodes (with a next pointer).</li>
<li>An array of linked list.</li>
</ol>
</li>
<li>There should be a hash function.</li>
<li>There should be a function to convert the hash value to corresponding array index.</li>
<li>Remember there&rsquo;s <strong>a concept of Load factor</strong>. It means to what percentage the hashmap is filled.</li>
<li>h &amp; (length – 1) means h % length, which maps a hashcode to an array index.</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/08/interleave-positive-negative/">[Question] Interleave Positive and Negative Numbers</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-08T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/10/08/interleave-positive-negative/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/10/08/interleave-positive-negative/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://mp.weixin.qq.com/s?__biz=MzA5MzE4MjgyMw==&amp;mid=200355650&amp;idx=1&amp;sn=f94e87cb391fb12af9531cedb452dba1&amp;key=d232b50733c41de56b96f855d9cdea5824f24c712e158651b45d7fe139a94610a7561da1fab0104e968592b01f2439d4&amp;ascene=7&amp;uin=MzM2NjQyNQ%3D%3D&amp;pass_ticket=i7pJQweQbuRdnUFUt5cdOmapPc%2FDW6Xk40U7%2Bcg%2F0o8%3D">link</a></p>

<blockquote><p>给一个包含正负整数的数组，要求对这个数组中的数进行重新排列，使得其正负交替出现。首先出现负数，然后是正数，然后是负数。有多余的数的一方，就放在末尾。</p>

<p>如 [1, 2, 3, -4]&ndash;>[-4, 1, 2, 3]，[1,-3,2,-4,-5]&ndash;>[-3,1,-4,2,-5]. 要求使用O(1)的额外空间。</p>

<p>如果需要保持正数序列和负数序列各自原来的顺序，如何做？</p>

<p>如果不需要保持正数序列和负数序列各自原来的顺序，如何做？</p></blockquote>

<h3>Solution</h3>

<p>I only solve this question if we <strong>do not have to keep the original ordering</strong>.</p>

<p>Basically, 2 pointers search from beginning to end. If there&rsquo;re more + than &ndash;, move the extra positive values to the back of the array. Vice versa.</p>

<h3>Code</h3>

<p><strong>written by me</strong></p>

<pre><code>public void solve(int[] A) {
    int len = A.length;
    int neg = 0;
    int pos = 1;
    while (neg &lt; len || pos &lt; len) {

        while (neg &lt; len &amp;&amp; A[neg] &lt; 0) {
            neg += 2;
        }
        while (pos &lt; len &amp;&amp; A[pos] &gt; 0) {
            pos += 2;
        }
        // neg points to a positive value
        // pos points to a negative value
        // swap them (if they're valid position)
        if (neg &gt;= len &amp;&amp; pos &gt;= len) {
            return;
        } else if (neg &gt;= len) {
            // neg is done, there's more - then +
            // put all negative values pointed by pos to the back
            int right = len - 1;
            if (right % 2 == 0) {
                right--;
            }
            while (pos &lt; right) {
                while (pos &lt; len &amp;&amp; A[pos] &gt; 0) {
                    pos += 2;
                }
                while (right &gt;= 0 &amp;&amp; A[right] &lt; 0) {
                    right -= 2;
                }
                // pos point to a negative value, right to positive value
                if (pos &gt; right) {
                    break;
                } else {
                    swap(A, pos, right);
                }
            }
            return;
        } else if (pos &gt;= len) {
            // pos is done, there's more + then -
            int right = len - 1;
            if (right % 2 == 1) {
                right--;
            }
            while (neg &lt; right) {
                while (neg &lt; len &amp;&amp; A[neg] &lt; 0) {
                    neg += 2;
                }
                while (right &gt;= 0 &amp;&amp; A[right] &gt; 0) {
                    right -= 2;
                }
                if (neg &gt; right) {
                    break;
                } else {
                    swap(A, neg, right);
                }
            }
            return;
        } else {
            swap(A, neg, pos);
        }
    }
}

private void swap(int[] array, int a, int b) {
    int temp = array[a];
    array[a] = array[b];
    array[b] = temp;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/02/longest-word-made-from-other/">[CC150v5] 18.7 Longest Word Made From Other Words</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/10/02/longest-word-made-from-other/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/10/02/longest-word-made-from-other/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<blockquote><p>Given a list of words, write a program to find the longest word made of other words in the list.</p>

<p>EXAMPLE</p>

<p>Input: cat, banana, dog, nana, walk, walker, dogwalker</p>

<p>Output: dogwalker</p></blockquote>

<h3>Solution</h3>

<p><strong>Search it recursively from longest to shortest</strong>. Use HashSet to help us search for words quickly.</p>

<p>This question might look difficult at first, it&rsquo;s actually a very classical recursive search.</p>

<h3>Code</h3>

<pre><code>public static void printLongestWord(String[] arr) {
    Arrays.sort(arr, new LengthComparator());
    HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();
    for (String str : arr) {
        set.add(str);
    }
    for (String word : arr) {
        if (canDivide(word, 0, set)) {
            System.out.println(word);
            return;
        }
    }
    System.out.println("can not find such word");
}

private static boolean canDivide(String word, int from, HashSet&lt;String&gt; set) {
    if (from == word.length()) {
        return true;
    }
    for (int i = from; i &lt; word.length(); i++) {
        String str = word.substring(from, i + 1);
        if (from == 0 &amp;&amp; i == word.length() - 1) {
            continue;
        } else if (!set.contains(str)) {
            continue;
        }
        if (canDivide(word, i + 1, set)) {
            return true;
        }
    }
    return false;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/01/optimal-unconcatenate-doc/">[CC150v5] 17.14 Optimal Way to Unconcatenate Doc</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-01T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/10/01/optimal-unconcatenate-doc/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/10/01/optimal-unconcatenate-doc/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<blockquote><p>Given a lengthy document without spaces, punctuation, and capitalization:</p>

<p>eg: iresetthecomputeritstilldidntboot</p>

<p>Now add back in the punctation and capitalization.</p>

<p>Most of the words will be in a dictionary, but some strings, like proper names, will not. Given a dictionary (a list of words), design an algorithm to find the optimal way of &ldquo;unconcatenating&rdquo; a sequence of words (by minimizing unrecognized sequences of characters).</p>

<p>For example, the string &ldquo;jesslookedjustliketimherbrother&rdquo; would be optimally parsed as &ldquo;JESS looked just like TIM her brother&rdquo;. This parsing has seven unrecognized characters, which we have capitalized for clarity.</p></blockquote>

<h3>Solution</h3>

<p>The solution given in the book is very hard to understand. It uses HashMap to memorize the previous result.</p>

<p>After long time of struggle, I finally solved it with traditional DP approach. The key idea is to consider: &ldquo;<strong>whether I insert a space after this char, or not</strong>&rdquo;.</p>

<p>The code is concise and easy to read.</p>

<h3>Code</h3>

<pre><code>public static int parse(String doc, Trie dict) {
    int len = doc.length();
    int[] dp = new int[len + 1];
    // dp[i] denotes the number of special chars in first i chars of docs
    for (int i = 1; i &lt;= len; i++) {
        dp[i] =  Integer.MAX_VALUE;
        for (int j = 0; j &lt; i; j++) {
            String str = doc.substring(j, i);
            if (dict.contains(str, true)) {
                // consider (i to j) a valid word
                dp[i] = Math.min(dp[i], dp[j]);
            } else {
                // consider (i to j) special chars
                dp[i] = Math.min(dp[i], dp[j] + i - j);
            }
        }
    }
    return dp[len];
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/30/convert-bst-doubly-linked-list/">[CC150v5] 17.13 Convert BST to Doubly-Linked List</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-30T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/09/30/convert-bst-doubly-linked-list/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/09/30/convert-bst-doubly-linked-list/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<blockquote><p>Consider a simple node-like data structure called BiNode, which has pointers to two other nodes.</p></blockquote>

<pre><code>public class BiNode {
    public BiNode node1, node2;
    public int data;
}
</code></pre>

<blockquote><p>The data structure BiNode could be used to represent both a binary tree (where node1 is the left node and node2 is the right node) or a doubly linked list (where node1 is the previous node and node2 is the next node). Implement a method to convert a binary search tree (implemented with BiNode) into a doubly linked list. The values should be kept in order and the operation should be performed in place (that is, on the original data structure).</p></blockquote>

<h3>Solution</h3>

<p>At another post <strong>[LeetCode Plus] Convert BST to Doubly-Linked List</strong>, we already discussed 2 approaches:</p>

<ol>
<li>in-order traversal approach</li>
<li>divide and conquer approach</li>
</ol>


<p>First approach isn&rsquo;t intuitive. We will further discuss D&amp;C approach here.</p>

<p><strong>The key of the solution is how we return both HEAD and TAIL</strong>. The book suggests 3 ways:</p>

<ol>
<li>Build a <strong>data structure</strong> to store both head and tail</li>
<li><strong>Just return head</strong>, and retrieve tail by traversing thru &ndash; bad time complexity O(n<sup>2</sup>)</li>
<li><strong>Use circular linked-list</strong>! Time O(n).</li>
</ol>


<p>I wrote the code for 2nd suggestion.</p>

<p><strong>The circular list is a great idea</strong>. It&rsquo;s already covered in previous post. Do keep in mind <strong>why we need the list to be circular</strong>!</p>

<h3>Code</h3>

<p><strong>Just return head approach</strong></p>

<pre><code>public static BiNode convert(BiNode root) {
    if (root == null) {
        return null;
    }
    return helper(root);
}

private static BiNode helper(BiNode node) {
    // node is not null
    BiNode newHead = node;
    // do left part
    if (node.node1 != null) {
        newHead = helper(node.node1);
        BiNode leftTail = getListTail(newHead);
        leftTail.node2 = node;
        node.node1 = leftTail;
    }
    // do right part
    if (node.node2 != null) {
        BiNode rightHead = helper(node.node2);
        node.node2 = rightHead;
        rightHead.node1 = node;
    }
    return newHead;
}

private static BiNode getListTail(BiNode head) {
    // head is not null
    while (head.node2 != null) {
        head = head.node2;
    }
    return head;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/28/get-rank-stream-integers/">[CC150v5] 11.8 Get Rank in Stream of Integers</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/09/28/get-rank-stream-integers/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/09/28/get-rank-stream-integers/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<blockquote><p>Imagine you are reading in a stream of integers. Periodically, you wish to be able to look up the rank of a number x (the number of values less than or equal to x).</p>

<p>Implement the data structures and algorithms to support these operations. That is, implement the method <strong>track(int x)</strong>, which is called when each number is generated, and the method <strong>getRankOfNumber(int x)</strong>, which returns the number of values less than or equal to x (not including x itself).</p></blockquote>

<h3>Solution</h3>

<p><strong>This question requires a special type of Data Structure</strong>. It basically is a modified BST like this:</p>

<blockquote><p>The tree node stores both number value and the <strong>count of node on left subtree</strong></p></blockquote>

<p><img class="middle" src="/assets/images/get-rank-number-stream.png"></p>

<p>Suppose we want to find the rank of 24 in the tree above. We would compare 24 with the root, 20, and find that 24 must reside on the right. The root has 4 nodes in its left subtree, and when we include the root itself, this gives us five total nodes smaller than 24. We set counter to 5.</p>

<p>Then, we compare 24 with node 25 and find that 24 must be on the left. The value of counter does not update, since we&rsquo;re not &ldquo;passing over&rdquo; any smaller nodes. The value of counter is still 5.</p>

<p>Next, we compare 24 with node 23,and find that 24 must be on the right. Counter gets incremented by just 1 (to 6), since 23 has no left nodes.</p>

<p>Finally, we find 24 and we return counter: 6.</p>

<h3>Code</h3>

<p>I did not write code myself. It&rsquo;s too complex!</p>

<p><strong>RankNode.java</strong></p>

<pre><code>public class RankNode {
    public int left_size = 0;
    public RankNode left;
    public RankNode right;
    public int data = 0;
    public RankNode(int d) {
        data = d;
    }

    public void insert(int d) {
        if (d &lt;= data) {
            if (left != null) {
                left.insert(d);
            } else {
                left = new RankNode(d);
            }
            left_size++;
        } else {
            if (right != null) {
                right.insert(d);
            } else {
                right = new RankNode(d);
            }
        }
    }

    public int getRank(int d) {
        if (d == data) {
            return left_size;
        } else if (d &lt; data) {
            if (left == null) {
                return -1;
            } else {
                return left.getRank(d);
            }
        } else {
            int right_rank = right == null ? -1 : right.getRank(d);
            if (right_rank == -1) {
                return -1;
            } else {
                return left_size + 1 + right_rank;
            }
        }
    }
}
</code></pre>

<p><strong>Main Class</strong>:</p>

<pre><code>public class Question {
    private static RankNode root = null;

    public static void track(int number) {
        if (root == null) {
            root = new RankNode(number);
        } else {
            root.insert(number);
        }
    }

    public static int getRankOfNumber(int number) {
        return root.getRank(number);
    }

    public static void main(String[] args) {
        int size = 100;
        int[] list = AssortedMethods.randomArray(size, -100, 100);
        for (int i = 0; i &lt; list.length; i++) {
            track(list[i]);
        }

        int[] tracker = new int[size];
        for (int i = 0; i &lt; list.length; i++) {
            int v = list[i];
            int rank1 = root.getRank(list[i]);
            tracker[rank1] = v;
        }

        for (int i = 0; i &lt; tracker.length - 1; i++) {
            if (tracker[i] != 0 &amp;&amp; tracker[i + 1] != 0) {
                if (tracker[i] &gt; tracker[i + 1]) {
                    System.out.println("ERROR at " + i);
                }
            }
        }

        System.out.println("Array: " + AssortedMethods.arrayToString(list));
        System.out.println("Ranks: " + AssortedMethods.arrayToString(tracker));
    }

}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/5">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/3">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (54)</a></li>
<li class='category'><a href='/blog/categories/experience/'>experience (3)</a></li>
<li class='category'><a href='/blog/categories/facebook/'>facebook (9)</a></li>
<li class='category'><a href='/blog/categories/fundamental/'>fundamental (5)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (42)</a></li>
<li class='category'><a href='/blog/categories/java-oop/'>java oop (19)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (153)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (92)</a></li>
<li class='category'><a href='/blog/categories/string-search/'>string search (7)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (7)</a></li>
<li class='category'><a href='/blog/categories/top-k/'>top k (7)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/01/11/numer-of-occurrence-given-subsequence/">[Question] Number of Occurence of Given Sub-sequence</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/11/numer-of-distinct-subsequence/">[Question] Number of Distinct Sub-sequence</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/11/crazy-distance-string/">[Google] Crazy Distance Between Strings</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/11/Diameter-of-Binary-Tree/">[Google] Diameter of a Binary Tree</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/10/reverse-a-stack/">[Google] Reverse a Stack Without DS</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Charlie Brown -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
