
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="Question link Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/28">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Remove-Element/">[LeetCode 27] Remove Element</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/remove-element/">link</a></p>

<div class="question-content">
            <p></p><p>Given an array and a value, remove all instances of that value in place and return the new length.
</p>

<p>
The order of elements can be changed. It doesn&#8217;t matter what you leave beyond the new length.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>This question is easy.</p>

<h3>Solution</h3>

<p><strong>I thought 6 lines is the most concise solution, until I read</strong> <a href="http://needjobasap.blogspot.sg/2014/01/removeelement-leetcode.html">this blog</a>.</p>

<h3>My code</h3>

<pre><code>public int removeElement(int[] A, int elem) {
        int left = 0, right = 0;
        while (right &lt; A.length) {
            if (A[right] == elem) right++;
            else A[left ++] = A[right ++];
        }
        return left;
}
</code></pre>

<p>Change while loop to for loop, the solution is only 4 lines of code.</p>

<pre><code>public int removeElement(int[] A, int elem) {
        int p = 0;
        for (int i = 0; i &lt; A.length; i ++)
            if (A[i] != elem) A[p ++] = A[i];
        return p;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Remove-Duplicates-from-Sorted-Array/">[LeetCode 26] Remove Duplicates From Sorted Array</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a sorted array, remove the duplicates in place such that each element appear only <i>once</i> and return the new length.</p>

<p>
Do not allocate extra space for another array, you must do this in place with constant memory.
</p>

<p>
For example,<br>
Given input array A = <code>[1,1,2]</code>,
</p>
<p>
Your function should return length = <code>2</code>, and A is now <code>[1,2]</code>.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>This question is easy.</p>

<h3>Solution</h3>

<p>Two pointer operations.</p>

<h3>My code</h3>

<pre><code>public int removeDuplicates(int[] A) {
        if (A.length == 0) return 0;
        int left = 1, right = 1;
        int pre = A[0];
        while(right &lt; A.length){
            if (A[right] != pre) {
                A[left] = A[right];
                pre = A[left];
                left ++;
            }
            right ++;
        }
        return left;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Merge-Two-Sorted-Lists/">[LeetCode 21] Merge Two Sorted Lists</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/merge-two-sorted-lists/">link</a></p>

<div class="question-content">
            <p></p><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question is easy</strong>. There are difficult ways to solve.</p>

<h3>Solution</h3>

<p>I wrote 2 versions of code, one using recursion and one using direct approach (fake header + link operations). <strong>Surprisingly my second code is EXACTLY same</strong> as the code written in <a href="http://www.programcreek.com/2012/12/leetcode-merge-two-sorted-lists-java/">this blog</a>.</p>

<h3>My code</h3>

<p>Recursion:</p>

<pre><code>public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        if (l1.val &gt; l2.val) {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
        else{
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }

}
</code></pre>

<p>Fake header + link operations</p>

<pre><code>public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode pre = new ListNode(Integer.MIN_VALUE);
        ListNode cur = pre;
        while (l1 != null &amp;&amp; l2 != null) {
            if (l1.val &lt; l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        if (l1 == null) cur.next = l2;
        else cur.next = l1;
        return pre.next;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Generate-Parentheses/">[LeetCode 22] Generate Parentheses</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/valid-parentheses/">link</a></p>

<div class="question-content">
            <p></p><p>
Given <i>n</i> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
</p>

<p>
For example, given <i>n</i> = 3, a solution set is:
</p>
<p>
<code>"((()))", "(()())", "(())()", "()(())", "()()()"</code>
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>Most popular solutions online are using recursive calls</strong>. For example, <a href="http://www.geeksforgeeks.org/print-all-combinations-of-balanced-parentheses/">this blog</a>. I also used this method.</p>

<h3>Solution</h3>

<p>I kept 2 integers: <strong>open</strong> (number of unclosed left parenthesis) and <strong>remain</strong> (number of parenthesis that can be addded to the current string). I optimized my previous code and made it cleaner.</p>

<h3>My code</h3>

<pre><code>public ArrayList&lt;String&gt; generateParenthesis(int n) {
        return helper(new ArrayList&lt;String&gt;(), 0, n, "");
}

private ArrayList&lt;String&gt; helper(ArrayList&lt;String&gt; ans, 
                int open, int remain, String cur) {
        if (open == 0 &amp;&amp; remain == 0) ans.add(cur);
        if (remain &gt; 0) helper(ans, open + 1, remain - 1, cur + "(");
        if (open &gt; 0) helper(ans, open - 1, remain, cur + ")");
        return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/03/4Sum/">[LeetCode 18] 4Sum</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-03T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/4sum/">link</a></p>

<div class="question-content">
            <p></p><p>Given an array <i>S</i> of <i>n</i> integers, are there elements <i>a</i>, <i>b</i>, <i>c</i>, and <i>d</i> in <i>S</i> such that <i>a</i> + <i>b</i> + <i>c</i> + <i>d</i> = target? Find all unique quadruplets in the array which gives the sum of target.</p>

<p><b>Note:</b><br>
</p><ul>
<li>Elements in a quadruplet (<i>a</i>,<i>b</i>,<i>c</i>,<i>d</i>) must be in non-descending order. (ie, <i>a</i> ≤ <i>b</i> ≤ <i>c</i> ≤ <i>d</i>)</li>
<li>The solution set must not contain duplicate quadruplets.</li>
</ul>
<p></p>

<pre>    For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

    A solution set is:
    (-1,  0, 0, 1)
    (-2, -1, 1, 2)
    (-2,  0, 0, 2)
</pre><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">Rather long time</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This solution is using exactly same algorithm as 3Sum</strong>. Basic idea is for every value pair (a, b), find all (c, d) that makes the sum equals to the target.</p>

<p>Note that the final found answer set (a, b, c, d) is already in sorted order, no need  to re-sort.</p>

<h3>Solution</h3>

<p><strong>The code might be a little tricky dealing with duplications</strong>. I simple omit all repeated numbers, and luckily my code passed. There is <a href="http://www.programcreek.com/2013/02/leetcode-4sum-java/">another code</a> removing duplications by using <strong>HashSet.contains()</strong>. I will post his code below, but personally I think my solution is better.</p>

<p>The solution I gave is O(n<sup>3</sup>), which is <strong>a very popular solution from LeetCode blogs</strong>. This is good enough, but in case you&rsquo;re interested, there&rsquo;s a O(n<sup>2</sup>) solution using a HashMap to store all 2-number sums. The coding is difficult, thus would not be discussed here. Check code from <a href="http://www.cnblogs.com/TenosDoIt/p/3649607.html">this blog</a>.</p>

<p><strong>For this question, a O(n<sup>3</sup>) solution is good enough</strong>.</p>

<h3>My code</h3>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; fourSum(int[] numbers, int target) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (numbers == null || numbers.length == 0) {
        return ans;
    }
    Arrays.sort(numbers);
    int len = numbers.length;
    for (int i = 0; i &lt; len - 3; i++) {
        if (i &gt; 0 &amp;&amp; numbers[i - 1] == numbers[i]) {
            continue;
        }
        for (int j = i + 1; j &lt; len - 2; j++) {
            if (j &gt; i + 1 &amp;&amp; numbers[j - 1] == numbers[j]) {
                continue;
            }
            int left = j + 1;
            int right = len - 1;
            while (left &lt; right) {
                int diff = numbers[left] + numbers[right] + numbers[i] + numbers[j] - target;
                if (diff == 0) {
                    ArrayList&lt;Integer&gt; triplet = new ArrayList&lt;Integer&gt;();
                    triplet.add(numbers[i]);
                    triplet.add(numbers[j]);
                    triplet.add(numbers[left]);
                    triplet.add(numbers[right]);
                    ans.add(triplet);
                }
                if (diff &lt;= 0) {
                    left++;
                    while (left &lt; len &amp;&amp; numbers[left - 1] == numbers[left]) {
                        left++;
                    }
                }
                if (diff &gt;= 0) {
                    right--;
                    while (right &gt;= 0 &amp;&amp; numbers[right + 1] == numbers[right]) {
                        right--;
                    }
                }
            }
        }
    }
    return ans;
}
</code></pre>

<p>We can also use HashMap to remove duplication (interesting idea). Check this <a href="http://www.programcreek.com/2013/02/leetcode-4sum-java/">solution</a>.</p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; fourSum(int[] num, int target) {
    Arrays.sort(num);
    HashSet&lt;ArrayList&lt;Integer&gt;&gt; hashSet = new HashSet&lt;ArrayList&lt;Integer&gt;&gt;();
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    for (int i = 0; i &lt; num.length; i++) {
        for (int j = i + 1; j &lt; num.length; j++) {
            int k = j + 1;
            int l = num.length - 1;
            while (k &lt; l) {
                int sum = num[i] + num[j] + num[k] + num[l];
                if (sum &gt; target) l--;
                else if (sum &lt; target) k++;
                else if (sum == target) {
                    ArrayList&lt;Integer&gt; temp = 
                        new ArrayList&lt;Integer&gt;();
                    temp.add(num[i]);
                    temp.add(num[j]);
                    temp.add(num[k++]);
                    temp.add(num[l--]);
                    if (!hashSet.contains(temp)) {
                        hashSet.add(temp);
                        result.add(temp);
                    }
                }
            }
        }
    }
    return result;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/02/Remove-Nth-Node-From-End-of-List/">[LeetCode 19] Remove Nth Node From End of List</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/">link</a></p>

<div class="question-content">
            <p></p><p>Given a linked list, remove the <i>n</i><sup>th</sup> node from the end of list and return its head.</p>

<p>
For example,</p>

<pre>   Given linked list: <b>1-&gt;2-&gt;3-&gt;4-&gt;5</b>, and <b><i>n</i> = 2</b>.

   After removing the second node from the end, the linked list becomes <b>1-&gt;2-&gt;3-&gt;5</b>.
</pre>

<p>
<b>Note:</b><br>
Given <i>n</i> will always be valid.<br>
Try to do this in one pass.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question is easy</strong>. Just keep 2 pointers of a certain distance, and move together.</p>

<h3>Solution</h3>

<p>The code explains itself.</p>

<h3>My code</h3>

<pre><code>public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode p1 = head;
        ListNode p2 = head;
        for (int i=0 ; i&lt;n ; i++){
            p2 = p2.next;
        }
        if (p2 == null){
            return head.next;
        }
        // now p1 and p2 move together
        while(p2.next != null){
            p1 = p1.next;
            p2 = p2.next;
        }
        p1.next = p1.next.next;
        return head;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/02/Letter-Combinations-of-a-Phone-Number/">[LeetCode 17] Letter Combinations of a Phone Number</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/letter-combinations-of-a-phone-number/">link</a></p>

<div class="question-content">
            <p></p><p>Given a digit string, return all possible letter combinations that the number could represent.
</p>

<p>
A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png"></p>

<pre><b>Input:</b>Digit string "23"
<b>Output:</b> ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
</pre>

<p>
<b>Note:</b><br>
Although the above answer is in lexicographical order, your answer could be in any order you want.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">20 minutes</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>Altough this question is not difficult, IT IS VERY IMPORTANT</strong>. The way that recuisive/non-recursive calls are handled are very frequently examed in interviewed.</p>

<p>This question can be split into 2 sub-questions.</p>

<ol>
<li><p><strong>How to convert an number into a String (i.e. 2->&lsquo;abc&rsquo; etc.)</strong> There are 2 way: <strong>math way</strong>, or the <strong>simple way</strong>. I list 2 codes below, the first of which is written by me. The second piece using HashMap is most popular in other people&rsquo;s solutions, for example <a href="http://rafal.io/posts/leetcode-18-letter-combinations-of-a-phone-number.html">this one</a>. Some people also use array of string to achieve the same result.</p></li>
<li><p><strong>How to implement the code</strong>. There might be n digits, so using n nested-loops can solve the problem, but unable to code. There are 2 ways as well: <strong>recursive method</strong>, and <strong>non-recursive method</strong>. Please refer the solutions section.</p></li>
</ol>


<p>Number convert String, Math way:</p>

<pre><code>private String getLetters(int key) {
    if (key &lt;= 1 || key &gt;= 10) return "";
    // key must be in the range of [2,9]
    char first = (char) ('a' + (key - 2) * 3);
    if (key &gt;= 8) first++;
    String letters = "";
    for (int i = 0; i &lt; 4; i++) {
        if (i == 3 &amp;&amp; !(key == 7 || key == 9)) break;
        letters += first++;
    }
    return letters;
}
String letters = getLetters('3' - '0');
</code></pre>

<p>HashMap way(execute time is slightly higher):</p>

<pre><code>static final HashMap&lt;Character, String&gt; map = new HashMap&lt;Character, String&gt;() {
    {
        put('2', "abc");
        put('3', "def");
        put('4', "ghi");
        put('5', "jkl");
        put('6', "mno");
        put('7', "pqrs");
        put('8', "tuv");
        put('9', "wxyz");
    }
};
String letters = map.get('3');
</code></pre>

<h3>Solution</h3>

<p>As mentioned, there are 2 ways to code.</p>

<p><strong>Recursive method</strong> seems easy at first. I split the digits into head (the first digit) and tail (the rest). For example &ldquo;142&rdquo;, the head = 1, tail = 42. Then I use nested loop to concatenate all letters for head, and all answers for tail and get the correct answer. However, <strong>the code uses a lot of List and does not look cool</strong>. The performance however, is the same as the other recursive method.</p>

<p><strong>Now I will explain another (maybe better) recursive method</strong>. Keep an array of char, and a counter. In the beginning, counter = 0, array is empty. Then fill in the first position of the array, and increate counter by 1. Do this recursively until counter reach the last digit (at this point, insert the char array into answer set). <strong>Be very cautious about how the array is passed</strong>. Array is pass by reference, so the array keep getting changed. There shouldn&rsquo;t cause any trouble if your code is correct, but keep in mind that <strong>during recursive call, variables passed by reference is shared by all calls. This might be dangerous unless you handle it well</strong> (like use of counter). Otherwise, simply always create new objects like I did in the first code (2 arraylist are created in the first code, and 0 in the second code).</p>

<p>I printed execution stack for second code, which gives better illustration.</p>

<p>Call letterCombinations(&ldquo;29&rdquo;);</p>

<p>Success time: 0.07 memory: 380224 signal:0</p>

<p>len = 0, one is a
len = 1, one is a w
len = 1, one is a x
len = 1, one is a y
len = 1, one is a z
len = 0, one is b z
len = 1, one is b w
len = 1, one is b x
len = 1, one is b y
len = 1, one is b z
len = 0, one is c z
len = 1, one is c w
len = 1, one is c x
len = 1, one is c y
len = 1, one is c z</p>

<p><strong>Last, and the most important, is the non-recursive method</strong>. This idea is very intereting. 2 list are kept, first is called ans, and second called newAns. Now get all letters for next digit, and concatenate will all current ans using nested loop. Say currently all strings in ans is length 3, then after concatenate, the length because 4, and added to newAns. When all combinations are added to newAns, newAns become a list of string of length 4. Now one digit is finished. <strong>Before proceed to next digit, set ans = newAns, and clear newAns</strong>. Code below.</p>

<h3>My code</h3>

<p>The first recursive method (my code)</p>

<pre><code>public ArrayList&lt;String&gt; letterCombinations(String digits) {
    ArrayList&lt;String&gt; ans = new ArrayList&lt;String&gt;();
    if (digits.length() == 0) {
        ans.add("");
        return ans;
    }
    ArrayList&lt;String&gt; tailAns = this
            .letterCombinations(digits.substring(1));
    String headStr = this.getLetters(digits.charAt(0) - '0');
    for (char head : headStr.toCharArray()) {
        for (String tail : tailAns) 
            ans.add(head + tail);
    }
    return ans;
}

private String getLetters(int key) {
    if (key &lt;= 1 || key &gt;= 10) return "";
    char first = (char) ('a' + (key - 2) * 3);
    if (key &gt;= 8) first++;
    String letters = "";
    for (int i = 0; i &lt; 4; i++) {
        if (i == 3 &amp;&amp; !(key == 7 || key == 9)) break;
        letters += first++;
    }
    return letters;
}
</code></pre>

<p>Second recursive method (learnt and rewritten by me)</p>

<pre><code>public ArrayList&lt;String&gt; letterCombinations(String digits) {
    ArrayList&lt;String&gt; ans = new ArrayList&lt;String&gt;();
    char[] one = new char[digits.length()];
    fill(ans, one, 0, digits);
    return ans;
}

private void fill(ArrayList&lt;String&gt; ans, char[] one, int len, String digits) {
    if (len == one.length) {
        ans.add(String.valueOf(one));
        return;
    }
    String possibleChars = getLetters(digits.charAt(0) - '0');
    for (char c: possibleChars.toCharArray()) {
        one[len] = c;
        fill(ans, one, len+1, digits.substring(1));
    }
}

private String getLetters(int key) {
    if (key &lt;= 1 || key &gt;= 10) return "";
    char first = (char) ('a' + (key - 2) * 3);
    if (key &gt;= 8) first++;
    String letters = "";
    for (int i = 0; i &lt; 4; i++) {
        if (i == 3 &amp;&amp; !(key == 7 || key == 9)) break;
        letters += first++;
    }
    return letters;
}
</code></pre>

<p><strong>The non-recursive method (learnt and rewritten by me)</strong></p>

<p>To demostrate how <strong>HashMap</strong> is used, I changed the convertion method as well.</p>

<pre><code>public ArrayList&lt;String&gt; letterCombinations(String digits) {
        ArrayList&lt;String&gt; ans = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; newAns = new ArrayList&lt;String&gt;();
        ans.add("");
        for (int i = 0; i &lt; digits.length(); i ++) {
            String letters = map.get(digits.charAt(i));
            for (int j = 0; j &lt; letters.length(); j ++) {
                for (String cur: ans) {
                    newAns.add(cur + letters.charAt(j));
                }
            }
            ans = newAns;
            newAns = new ArrayList&lt;String&gt;();
        }
        return ans;
}

static final HashMap&lt;Character, String&gt; map = new HashMap&lt;Character, String&gt;() {
    {
        put('2', "abc");
        put('3', "def");
        put('4', "ghi");
        put('5', "jkl");
        put('6', "mno");
        put('7', "pqrs");
        put('8', "tuv");
        put('9', "wxyz");
    }
};
</code></pre>

<p><strong>Updated June 14th, rewrote the code using template</strong></p>

<p>It could have been better <a href="http://answer.ninechapter.com/solutions/letter-combinations-of-a-phone-number/">writing with StringBuilder</a>, but I think it&rsquo;s minor.</p>

<pre><code>public List&lt;String&gt; letterCombinations(String digits) {
    List&lt;String&gt; ans = new LinkedList&lt;String&gt;();
    if (digits == null) {
        return ans;
    }
    String[] pad = new String[]{
        " ","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    helper(ans, "", pad, digits, 0);
    return ans;
}

private void helper(List&lt;String&gt; ans, String path, String[] pad, String digits, int pos) {
    if (path.length() == digits.length()) {
        ans.add(path);
        return;
    }
    String letters = pad[digits.charAt(pos) - '0'];
    for (int i = 0; i &lt; letters.length(); i++) {
        path += letters.charAt(i) + "";
        helper(ans, path, pad, digits, pos + 1);
        path = path.substring(0, path.length() - 1);
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/02/3Sum-Closest/">[LeetCode 16] 3Sum Closest</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/3sum-closest/">link</a></p>

<div class="question-content">
            <p></p><p>Given an array <i>S</i> of <i>n</i> integers, find three integers in <i>S</i> such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>

<pre>    For example, given array S = {-1 2 1 -4}, and target = 1.

    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</pre><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">20 minutes coding only</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>This is a simplified version of 3Sum. <strong>The method is exactly the same as 3Sum, except the return is integer instead of a list of solutions</strong>. This makes life easier because <strong>we do not need to consider duplications</strong>.</p>

<p>Why? Because in 3Sum, when there is duplicate solution, we need to find them all. But in this question, if a solution is found, the closest value = 0, and is immediately returned.</p>

<h3>Solution</h3>

<p>The code explains itself.</p>

<h3>My code</h3>

<pre><code>public int threeSumClosest(int[] num, int target) {
    if (num.length &lt; 3) return 0;
    Arrays.sort(num);
    int diff = Integer.MAX_VALUE, realSum = -1;
    for (int i = 0; i &lt; num.length - 2; i++) {
        int left = i + 1, right = num.length - 1;
        while (left &lt; right) {
            int sum = num[i] + num[left] + num[right];
            if (sum == target) return target;
            else if (sum &lt; target) left++;
            else right--;
            if (diff &gt; Math.abs(sum - target)) {
                diff = Math.abs(sum - target);
                realSum = sum;
            }
        }
    }
    return realSum;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/02/3Sum/">[LeetCode 15] 3Sum</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-02T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/3sum/">link</a></p>

<div class="question-content">
            <p></p><p>Given an array <i>S</i> of <i>n</i> integers, are there elements <i>a</i>, <i>b</i>, <i>c</i> in <i>S</i> such that <i>a</i> + <i>b</i> + <i>c</i> = 0? Find all unique triplets in the array which gives the sum of zero.</p>

<p><b>Note:</b><br>
</p><ul>
<li>Elements in a triplet (<i>a</i>,<i>b</i>,<i>c</i>) must be in non-descending order. (ie, <i>a</i> ≤ <i>b</i> ≤ <i>c</i>)</li>
<li>The solution set must not contain duplicate triplets.</li>
</ul>
<p></p>

<pre>    For example, given array S = {-1 0 1 2 -1 -4},

    A solution set is:
    (-1, 0, 1)
    (-1, -1, 2)
</pre><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">
            <div>
                Difficult
            </div>
        </td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>The array must be sorted first. <strong>Then this question is easily solved with O(n<sup>2</sup>) time.</strong> The idea is, for every integer, a from the array, try to find all combinations of b and c, where b+c = -a. The implementation use <strong>2-pointer scan</strong>.</p>

<p>There might be a problem of duplications. Eg. array = {-5, 2, 2, 3, 3}. When a = -5, we can choose 2, 3 and move pointers both by 1 position. Then we can choose 2, 3 again. We shall increase the pointer to where the value is different, and the problem is solved.</p>

<h3>My code</h3>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(int[] num) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (num.length &lt; 3)
        return ans;
    Arrays.sort(num);
    for (int i = 0; i &lt; num.length - 2; i++) {
        if (i != 0 &amp;&amp; num[i - 1] == num[i])
            continue;
        int target = 0 - num[i];
        int left = i + 1, right = num.length - 1;
        while (left &lt; right) {
            if (num[left] + num[right] &gt; target)
                right--;
            else if (num[left] + num[right] &lt; target)
                left++;
            else {
                ArrayList&lt;Integer&gt; found = new ArrayList&lt;Integer&gt;();
                found.add(num[i]);
                found.add(num[left]);
                found.add(num[right]);
                Collections.sort(found);
                ans.add(found);
                while (left &lt; num.length - 1 &amp;&amp; num[++left] == num[left - 1]) ;
                while (right &gt; i + 1 &amp;&amp; num[--right] == num[right + 1]) ;
            }
        }
    }
    return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/01/Longest-Common-Prefix/">[LeetCode 14] Longest Common Prefix</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-01T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/longest-common-prefix/">link</a></p>

<div class="question-content">
            <p></p><p>Write a function to find the longest common prefix string amongst an array of strings.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="white">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">10 minutes</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question have straight-forward solution.</strong> Every online solution is the same as my method, however, there&rsquo;s another more generalized <a href="http://en.wikipedia.org/wiki/LCP_array"><strong>LCP array</strong></a> which is solved by use of <a href="http://en.wikipedia.org/wiki/Trie">Trie</a>. I&rsquo;m not interested in this topic right now.</p>

<h3>Solution</h3>

<p>The code explains itself.</p>

<h3>My code</h3>

<p>My original solution.</p>

<pre><code>public String longestCommonPrefix(String[] strs) {
    if (strs.length == 0)
        return "";
    int shortest = strs[0].length();
    for (String a : strs)
        shortest = Math.min(shortest, a.length());
    for (int i = 0; i &lt; shortest; i++) {
        for (int j = 1; j &lt; strs.length; j++) {
            // check strs[j].charAt(i)
            if (strs[j].charAt(i) != strs[j - 1].charAt(i)) {
                return strs[0].substring(0, i);
            }
        }
    }
    return strs[0].substring(0, shortest);
}
</code></pre>

<p><strong>Refactored code</strong>. I do not really need &lsquo;shortest&rsquo;. Increase execution time from 468ms to 456 ms.</p>

<p>This is the shortest code for this question, for my best knowledge :)</p>

<pre><code>public String longestCommonPrefix(String[] strs) {
    if (strs.length == 0) return "";
    for (int i = 0; i &lt; strs[0].length(); i++)
        for (int j = 1; j &lt; strs.length; j++)
            if (strs[j].length() == i
                    || strs[j].charAt(i) != strs[0].charAt(i))
                return strs[0].substring(0, i);
    return strs[0];
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/29">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/27">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/08/05/Write-a-RNG/">[Google] Write a Random Number Generator</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/05/Web-server-application-server/">[Design] Application Server vs. Web Server</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/05/Upcasting-and-Object-Slicing/">[Design] Upcasting, Downcasting and Object Slicing</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/05/Replace-Question-Mark-WIth-Number/">[Google] Replace Question Mark With Number</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/05/Map-Reduce/">[Design] MapReduce</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
