
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Woodstock Blog</title>
  <meta name="author" content="Charlie Brown">

  
  <meta name="description" content="Question link You are given 2 eggs. You have access to a 100-storey building. Eggs can be very hard or very fragile means it may break if dropped &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/28">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Woodstock Blog</a></h1>
  
    <h2>What's the good of living if you don't try a few things?</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/18/Two-egg-100-floor-question/">[Brain Teaser] 2 Eggs 100 Floors Puzzle</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-18T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/06/18/Two-egg-100-floor-question/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/06/18/Two-egg-100-floor-question/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.programmerinterview.com/index.php/puzzles/2-eggs-100-floors-puzzle/">link</a></p>

<blockquote><p>You are given 2 eggs.</p>

<p>You have access to a 100-storey building.</p>

<p>Eggs can be very hard or very fragile means it may break if dropped from the first floor or may not even break if dropped from 100 th floor.Both eggs are identical.</p>

<p>You need to figure out the highest floor of a 100-storey building an egg can be dropped without breaking.</p>

<p>Now the question is how many drops you need to make. You are allowed to break 2 eggs in the process</p></blockquote>

<h3>Analysis</h3>

<p>Most obvious solutoin is drop in 10th, 20th, 30th &hellip; floor. But this solution would result in <strong>19 drops in worst case</strong>. We should try to reduce the worst case scenario by making all possible scenarios take the same number of drops!</p>

<p>The best solution is:</p>

<blockquote><p>What if we tried to reduce the number of drops that would be required with the linear search (with the 2nd egg) after we get to one of the higher floors? This way we <strong>counteract the fact that getting to the higher floor took so many drops</strong>, and if we use less drops for the linear search we are <strong>balancing out the worst case</strong>.</p></blockquote>

<p>According to the <a href="http://www.programmerinterview.com/index.php/puzzles/2-eggs-100-floors-puzzle/">solution</a>, we form a series:</p>

<blockquote><p>x + (x-1) + (x-2) + (x-3) + &hellip; + 1 = 100</p>

<p>x(x+1)/2 = 100</p>

<p>x = 14</p></blockquote>

<h3>Final Result</h3>

<p>We would drop in this way:</p>

<table width="50">
<thead><tr><th>&nbsp;Drop&nbsp;</th><th>&nbsp;Floor&nbsp;</th></tr></thead>
<tbody><tr align="center"><td>#1</td><td>14</td></tr>
<tr align="center"><td>#2</td><td>27</td></tr>
<tr align="center"><td>#3</td><td>39</td></tr>
<tr align="center"><td>#4</td><td>50</td></tr>
<tr align="center"><td>#5</td><td>60</td></tr>
<tr align="center"><td>#6</td><td>69</td></tr>
<tr align="center"><td>#7</td><td>77</td></tr>
<tr align="center"><td>#8</td><td>84</td></tr>
<tr align="center"><td>#9</td><td>90</td></tr>
<tr align="center"><td>#10</td><td>95</td></tr>
<tr align="center"><td>#11</td><td>99</td></tr>
<tr align="center"><td>#12</td><td>100</td></tr>
</tbody>
</table>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/18/Number-sum-sequence/">[Question] Number Sum Sequence</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-18T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/06/18/Number-sum-sequence/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/06/18/Number-sum-sequence/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://bbs.csdn.net/topics/390332954">link</a></p>

<blockquote><p>定义一个数字有以下的特征, 它可以被分成几个部分,而前面的部分相加起来的和是后面的部分.举例来说</p>

<p>1235813,       1+2=3; 2+3=5;3+5=8; 5+8=13;</p>

<p>112112224,     112+112=224;</p>

<p>1981100,       19+81=100;</p>

<p>122436,        12+24=36;</p>

<p>1299111210,    12+99=111,99+111=210;</p>

<p>要求写出一个函数,输入一个数字,判断这个数字是不是要求的这个数。</p></blockquote>

<h3>Analysis</h3>

<p><strong>This is a difficult DFS search question</strong>. Basic idea from <a href="http://bbs.csdn.net/topics/390332954">this blog</a>:</p>

<blockquote><p>取前i位为a1,第i+1到j位为a2,检测n是否由a1和a2生成的序列组成。</p>

<p>时间复杂度为O(n<sup>3</sup>)（或O(n<sup>2</sup>)).</p></blockquote>

<h3>Code</h3>

<p>The code is surprisingly very short.</p>

<p>I have yet to prove whether this code works.</p>

<pre><code>def isLegal(n, i, j):
    """取前i位为a1,第i+1到j位为a2,检测n是否由a1和a2生成的序列组成。"""
    nextDigit = j
    a1 = int(n[:i])
    a2 = int(n[i:j])
    while nextDigit&lt;len(n): # n还有数字可用
        a2, a1 = a1+a2, a2
        s2 = str(a2)
        if n.startswith(s2, nextDigit): #从n的第nextDigit位开始，与s2比较
            nextDigit += len(s2)
        else:
            return False
    return True

def test(n):
    for i in range(1, len(n)-1):
        for j in range(i+1, len(n)-1):
            if isLegal(n, i, j):
                return True
    return False
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/18/NineChap-Linked-List-additional/">[NineChap 4.2] Linked List Additional</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-18T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/06/18/NineChap-Linked-List-additional/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/06/18/NineChap-Linked-List-additional/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Question list</h2>

<ol>
<li><p><strong><a href="/blog/2014/06/17/Union-and-intersection-of-linked-list/">Union and Intersection of two Linked Lists</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/30/Insertion-Sort-List/">Insertion Sort List</a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="/blog/2014/05/28/Flatten-Binary-Tree-to-Linked-List/">Flatten Binary Tree to Linked List</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/26/Convert-Sorted-List-to-Binary-Search-Tree/">Convert Sorted List to Binary Search Tree</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/19/Rotate-List/">Rotate List</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/02/Remove-Nth-Node-From-End-of-List/">Remove Nth Node From End of List</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/03/LRU-Cache/">LRU Cache </a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/11/Reverse-Nodes-in-k-Group/">Reverse Nodes in k-Groups</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/09/Swap-Nodes-in-Pairs/">Swap Nodes in Pairs</a></strong></p></li>
</ol>


<h2>Code</h2>

<p><strong>Union and Intersection of two Linked Lists</strong></p>

<p>Think about the idea only.</p>

<p><strong>Insertion Sort List</strong></p>

<pre><code>public ListNode insertionSortList(ListNode head) {
    if (head == null) {
        return null;
    }
    ListNode dummy = new ListNode(0);
    ListNode cur = head;
    while (cur != null) {
        // insert cur into correct pos
        ListNode pos = dummy;
        while (pos.next != null &amp;&amp; pos.next.val &lt; cur.val) {
            pos = pos.next;
        }
        ListNode temp = cur.next;
        cur.next = pos.next;
        pos.next = cur;
        cur = temp;
    }
    return dummy.next;
}
</code></pre>

<p><strong>Flatten Binary Tree to Linked List</strong></p>

<p>I forgot to set &ldquo;root.left = null&rdquo; again, which result in long-time debugging. This is a very common and very silly mistake that I really should avoid.</p>

<pre><code>public void flatten(TreeNode root) {
    root = helper(root);
}

private TreeNode helper(TreeNode node) {
    if (node == null) {
        return null;
    } else if (node.left == null &amp;&amp; node.right == null) {
        return node;
    } else if (node.left == null) {
        return helper(node.right);
    } else if (node.right == null) {
        node.right = node.left;
        node.left = null;
        return helper(node.right);
    } else {
        TreeNode tempRight = node.right;
        node.right = node.left;
        node.left = null;
        TreeNode leftTail = helper(node.right);
        leftTail.right = tempRight;
        return helper(tempRight);
    }
}
</code></pre>

<p><strong>Convert Sorted List to Binary Search Tree</strong></p>

<p>This is the Mock Interview question. My solution is:</p>

<pre><code>public TreeNode sortedListToBST(ListNode listHead) {
    if (listHead == null) {
        return null;
    }
    if (listHead.next == null) {
        return new TreeNode(listHead.val);
    }
    ListNode listFirstHalf = listHead;
    ListNode listPreMid = findMiddle(listHead);
    ListNode listSecondHalf = null;
    if (listPreMid.next != null) {
        listSecondHalf = listPreMid.next.next;
    }
    TreeNode head = new TreeNode(listPreMid.next.val);
    listPreMid.next = null;
    head.left = sortedListToBST(listFirstHalf);
    head.right = sortedListToBST(listSecondHalf);
    return head;
}

private ListNode findMiddle(ListNode listHead) {
    if (listHead == null) {
        return null;
    }
    ListNode slow = listHead;
    ListNode fast = listHead.next;
    while (fast != null &amp;&amp; fast.next != null&amp;&amp; fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}
</code></pre>

<p>This is not a good answer, cuz I have to findMid in each recursion.</p>

<p>The best solution is, use a global variable and 2 numbers to simplify this process. Code:</p>

<pre><code>ListNode cur = null;

public TreeNode sortedListToBST(ListNode head) {
    if (head == null) {
        return null;
    }
    cur = head;
    int k = 0;
    ListNode p = head;
    while (p != null) {
        k++;
        p = p.next;
    }
    return build(0, k - 1);
}

private TreeNode build(int start, int end) {
    if (start &gt; end) {
        return null;
    }
    int mid = start + (end - start) / 2;
    TreeNode leftBranch = build(start, mid - 1);
    TreeNode head = new TreeNode(cur.val);
    cur = cur.next;
    head.left = leftBranch;
    head.right = build(mid + 1, end);
    return head;
}
</code></pre>

<p><strong>Rotate List</strong></p>

<p>Naive solution:</p>

<pre><code>public ListNode rotateRight(ListNode head, int n) {
    if (head == null) {
        return null;
    }
    ListNode p = head;
    for (int i = 0; i &lt; n; i++) {
        if (p.next == null) {
            p = head;
        } else {
            p = p.next;
        }
    }
    ListNode q = head;
    while (p.next != null) {
        p = p.next;
        q = q.next;
    }
    p.next = head;
    ListNode newHead = q.next;
    q.next = null;
    return newHead;
}
</code></pre>

<p>Make a circular list:</p>

<pre><code>public ListNode rotateRight(ListNode head, int n) {
    if (head == null) {
        return null;
    }
    ListNode p = head;
    int k = 1;
    while (p.next != null) {
        k++;
        p = p.next;
    }
    p.next = head;
    int steps = k - (n % k);
    for (int i = 0; i &lt; steps; i++) {
        p = p.next;
    }
    head = p.next;
    p.next = null;
    return head;
}
</code></pre>

<p><strong>Remove Nth Node From End of List</strong></p>

<pre><code>public ListNode removeNthFromEnd(ListNode head, int n) {
    if (head == null || n == 0) {
        return null;
    }
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode right = dummy;
    for (int i = 0; i &lt; n; i++) {
        right = right.next;
    }
    ListNode left = dummy;
    while (right.next != null) {
        left = left.next;
        right = right.next;
    }
    left.next = left.next.next;
    return dummy.next;
}
</code></pre>

<p><strong>LRU Cache</strong></p>

<p>I solved it in the original post.</p>

<p><strong>Reverse Nodes in k-Groups</strong></p>

<pre><code>public ListNode reverseKGroup(ListNode head, int k) {
    ListNode p = head;
    int count = 0;
    while (p != null) {
        p = p.next;
        count++;
    }
    return helper(head, k, count);
}

public ListNode helper(ListNode head, int k, int count) {
    if (head == null || k &lt; 1 || count &lt; k) {
        return head;
    }
    ListNode result = null;
    ListNode cur = head;
    for (int i = 0; i &lt; k; i++) {
        if (cur == null) break;
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
    }
    head.next = helper(cur, k, count - k);
    return result;
}
</code></pre>

<p><strong>Swap Nodes in Pairs</strong></p>

<pre><code>public ListNode swapPairs(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode result = head.next;
    ListNode temp = head.next.next;
    result.next = head;
    head.next = swapPairs(temp);
    return result;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/17/Union-and-intersection-of-linked-list/">[Question] Union and Intersection of Two Linked Lists</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-17T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/06/17/Union-and-intersection-of-linked-list/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/06/17/Union-and-intersection-of-linked-list/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/union-and-intersection-of-two-linked-lists/">link</a></p>

<blockquote><p>Given two Linked Lists, create union and intersection lists that contain union and intersection of the elements present in the given lists. Order of elments in output lists doesn’t matter.</p>

<p>Example:</p>

<p>Input: &ldquo;10->15->4->20&rdquo; and &ldquo;8->4->2->10&rdquo;</p>

<p>Intersection: 4->10</p>

<p>Union: 2->8->20->4->15->10</p></blockquote>

<h3>Analysis</h3>

<p>There are 2 solutions.</p>

<p>First solution is to do mergesort, then do a linear search. Time complexity is O(mlgm + nlgn).</p>

<p>Second solution is using hashing. On time <a href="http://www.geeksforgeeks.org/union-and-intersection-of-two-linked-lists/">complexity</a>:</p>

<blockquote><p>Time complexity of this method depends on the hashing technique used and the distribution of elements in input lists. In practical, this approach may turn out to be better than above method.</p></blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/17/Time-complexity-calculation/">[Design] Time Complexity Calculation (Master Theorem)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-17T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/06/17/Time-complexity-calculation/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/06/17/Time-complexity-calculation/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Master theorem</h3>

<p>In the analysis of algorithms, the <a href="http://en.wikipedia.org/wiki/Master_theorem">master theorem</a> provides a cookbook solution in asymptotic terms (using Big O notation) for recurrence relations that occur in many divide and conquer algorithms. It was introduced and popularized by <strong>Introduction to Algorithms</strong>.</p>

<h3>Examples with common algorithms</h3>



<table class="tg">
  <tr>
    <th class="tg-031e">Algorithm</th>
    <th class="tg-031e">Recurrence</th>
    <th class="tg-031e">Big-Oh Solution</th>
  </tr>
  <tr>
    <td class="tg-031e">Binary Search</td>
    <td class="tg-031e">T(n) = T(n/2) + O(1)</td>
    <td class="tg-031e">O(log n)</td>
  </tr>
  <tr>
    <td class="tg-031e">tree traversal</td>
    <td class="tg-031e">T(n) = 2 T(n/2) + O(1)</td>
    <td class="tg-031e">O(n)</td>
  </tr>
  <tr>
    <td class="tg-031e">Mergesort</td>
    <td class="tg-031e">T(n) = 2 T(n/2) + O(n)</td>
    <td class="tg-031e">O(n log n)</td>
  </tr>
</table>


<p><a href="http://www.cs.duke.edu/~ola/ap/recurrence.html">source</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/17/Reverse-linkedlist-recursively/">[LeetCode Plus] Reverse Linked List Iteratively and Recursively</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-17T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/06/17/Reverse-linkedlist-recursively/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/06/17/Reverse-linkedlist-recursively/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://leetcode.com/2010/04/reversing-linked-list-iteratively-and.html">link</a></p>

<blockquote><p>Implement the reversal of a singly linked list iteratively and recursively.</p></blockquote>

<h3>Iteratively</h3>

<p>First, the iterative solution is very common, and is listed as <strong>one of the &ldquo;5 fundamental operations of linked list&rdquo;</strong> in the NineChap4 post. I will quote below.</p>

<blockquote><p>First variant: Reverse from a particular node to the end</p></blockquote>

<pre><code>public ListNode reverse(ListNode start) {
    ListNode result = null;
    ListNode cur = start;
    while (cur != null) {
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
    }
    return result;
}
</code></pre>

<blockquote><p>Second variant: Reverse from a node until another node</p></blockquote>

<pre><code>public ListNode reverseRange(ListNode start, int len) {
    ListNode result = null;
    ListNode cur = start;
    while (len &gt; 0) {
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
        len--;
    }
    start.next = cur;
    return result;
}
</code></pre>

<h3>Recursively</h3>

<p>A good code from <a href="http://stackoverflow.com/a/354937">here</a>.</p>

<pre><code>public ListNode Reverse(ListNode list) {
    if (list == null) return null; 
    if (list.next == null) return list; 
    ListNode secondElem = list.next;
    list.next = null;
    ListNode reverseRest = Reverse(secondElem);
    secondElem.next = list;
    return reverseRest;
}
</code></pre>

<p>Alternatively, the code can be written in a &lsquo;show-off&rsquo; practice.</p>

<pre><code>public ListNode Reverse(ListNode list) {
    if (list == null) return null;
    if (list.next == null) return list;
    ListNode reverseRest = Reverse(list.next);
    list.next.next = list;
    list.next = null;
    return reverseRest;
}
</code></pre>

<p>Test cases urgently needed.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/16/NineChap-Linked-List/">[NineChap 4.1] Linked List</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-16T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/06/16/NineChap-Linked-List/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/06/16/NineChap-Linked-List/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>First Word</h2>

<p>LinkedList aims to test one of the most important concepts in C++, pointers.</p>

<p><strong>Unlike array, linked list does not have &lsquo;in-place&rsquo; operations</strong>. This is very important to understand.</p>

<h3>Type 1: Dummy Node</h3>

<p>When the head is not determined, use DummyHead.</p>

<p>Note that when using DummyHead to solve problems, the pointer <strong>starts from DummyHead</strong>. By doing this, we assuming that DummyHead must be valid, and we <strong>only check pointer.next (instead of checking pointer itself)</strong>. See &lsquo;Remove Duplicates from Sorted List II&rsquo; for details.</p>

<h3>Type 2: Five Basic Operations in Linked List</h3>

<ol>
<li>Insert in Sorted List</li>
<li>Remove in Sorted List</li>
<li>Reverse a list</li>
<li>Merge 2 Sorted List</li>
<li>Find middle</li>
</ol>


<h4>1.Insert in Sorted List</h4>

<pre><code>public ListNode insert(ListNode head, ListNode node) {
    // first, initialize
    ListNode dummy = new ListNode(Integer.MIN_VALUE);
    dummy.next = head;

    // second, assume p is less than node, and check p.next
    ListNode p = dummy;
    while (p.next != null &amp;&amp; p.next.val &lt; node.val) {
        p = p.next;
    }

    // insert node after 'p'
    node.next = p.next;
    p.next = node;
    return dummy.next;
}
</code></pre>

<h4>2.Remove in Sorted List</h4>

<p>(written by me)</p>

<pre><code>public ListNode remove(ListNode head, int value) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode p = dummy;
    while (p.next != null &amp;&amp; p.next.val != value) {
        p = p.next;
    }
    if (p.next != null &amp;&amp; p.next.val == value) {
        while (p.next != null &amp;&amp; p.next.val == value)
            p.next = p.next.next;
    }
    return dummy.next;
}
</code></pre>

<h4>3.Reverse a list</h4>

<p>First variant: Reverse from a particular node to the end.</p>

<p>四句话 statement.</p>

<pre><code>public ListNode reverse(ListNode start) {
    ListNode result = null;
    ListNode cur = start;
    while (cur != null) {
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
    }
    return result;
}
</code></pre>

<p>Second variant: Reverse from a node until another node</p>

<pre><code>// Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, start = 2 and len = 3,
// return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. 
public ListNode reverseRange(ListNode start, int len) {
    ListNode result = null;
    ListNode cur = start;
    while (len &gt; 0) {
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
        len--;
    }
    start.next = cur;
    return result;
}
</code></pre>

<p>The comparison:</p>

<p><img class="middle" src="/assets/images/reverse-linked-list-code-compare.png"></p>

<p>More: there is a way to reverse list recursively. This can be another good interview question. <strong><a href="/blog/2014/06/17/Reverse-linkedlist-recursively/">Reverse linkedlist recursively</a></strong></p>

<h4>4.Merge 2 Sorted List</h4>

<pre><code>public ListNode merge(ListNode head1, ListNode head2) {
    ListNode dummy = new ListNode(0);
    ListNode p = dummy;
    while (head1 != null &amp;&amp; head2 != null) {
        if (head1.val &lt; head2.val) {
            p.next = head1;
            head1 = head1.next;
            p = p.next;
        } else {
            p.next = head2;
            head2 = head2.next;
            p = p.next;
        }
    }
    if (head1 == null) {
        p.next = head2;
    } else {
        p.next = head1;
    }
    return dummy.next;
}
</code></pre>

<h4>5.Find middle</h4>

<p>There are 2 ways to do this: calculate the total length, or fast/slow pointer. But fast/slow pointer is better <strong>because in engineering world, a lot of problems only allows information to flow once (数据流概念)</strong>. Sometimes it&rsquo;s not a good idea to read list for a second (or 1.5) time.</p>

<pre><code>public ListNode findMiddle(ListNode head) {
    if (head == null) {
        return null;
    }
    ListNode slow = head, fast = head.next;
    while (fast != null &amp;&amp; fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
</code></pre>

<p><strong>Dummy head questions</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/22/Remove-Duplicates-from-Sorted-List/">Remove Duplicates from Sorted List</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/22/Remove-Duplicates-from-Sorted-List-II/">Remove Duplicates from Sorted List II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/23/Partition-List/">Partition List</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/09/Merge-Two-Sorted-Lists/">Merge Two Sorted Lists</a></strong></p></li>
</ol>


<p><strong>5 basic operations questions</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/23/Reverse-Linked-List-II/">Reverse Linked List II</a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="/blog/2014/06/02/Sort-List/">Sort List</a></strong></p>

<p> 2 operations used</p></li>
<li><p><strong><a href="/blog/2014/06/03/Reorder-List/">Reorder List</a></strong></p>

<p> 3 operations used</p></li>
<li><p><strong><a href="/blog/2014/06/02/Linked-List-Cycle/">Linked List Cycle</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/02/Linked-List-Cycle-II/">Linked List Cycle II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/11/Merge-k-Sorted-Lists/">Merge k Sorted Lists</a></strong></p>

<p> For this question, it&rsquo;s important to write a comparator by yourself, to show your understanding of a PriorityQueue.</p>

<p> n<em>k</em>lgk time, why? 1:14:30 recording
 about heap 1:15:00 recording</p></li>
<li><p><strong><a href="/blog/2014/06/02/Copy-List-with-Random-Pointer/">Copy List with Random Pointer</a></strong></p></li>
</ol>


<h2>Code</h2>

<p><strong>Remove Duplicates from Sorted List</strong></p>

<p>Easy, no dummy head needed.</p>

<p><strong>Remove Duplicates from Sorted List II</strong></p>

<pre><code>public ListNode deleteDuplicates(ListNode head) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode p = dummy;
    while (p.next != null &amp;&amp; p.next.next != null) {
        if (p.next.val == p.next.next.val) {
            int dupVal = p.next.val;
            while (p.next != null &amp;&amp; p.next.val == dupVal) {
                p.next = p.next.next;
            }
        } else {
            p = p.next;
        }
    }
    return dummy.next;
}
</code></pre>

<p><strong>Partition List</strong> &ndash; spend a lot of time on a list cycle in the result</p>

<pre><code>public ListNode partition(ListNode head, int x) {
    if (head == null) {
        return null;
    }
    ListNode head1 = new ListNode(0);
    ListNode head2 = new ListNode(0);

    ListNode p1 = head1;
    ListNode p2 = head2;
    ListNode cur = head;

    while (cur != null) {
        if (cur.val &lt; x) {
            p1.next = cur;
            p1 = cur;
        } else {
            p2.next = cur;
            p2 = cur;
        }
        cur = cur.next;
    }

    p1.next = head2.next;
    // VERY IMPORTANT THIS LINE !!!
    p2.next = null;
    // VERY IMPORTANT THIS LINE !!!
    return head1.next;
}
</code></pre>

<p><strong>Merge Two Sorted Lists</strong></p>

<pre><code>public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode p = dummy;
    while (l1 != null &amp;&amp; l2 != null) {
        if (l1.val &lt; l2.val) {
            p.next = l1;
            l1 = l1.next;
            p = p.next;
        } else {
            p.next = l2;
            l2 = l2.next;
            p = p.next;
        } 
    }
    if (l1 == null) {
        p.next = l2;
    } else {
        p.next = l1;
    }
    return dummy.next;
}
</code></pre>

<h4>5 basic operations</h4>

<p><strong>Reverse Linked List II</strong></p>

<pre><code>public ListNode reverseBetween(ListNode head, int m, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode start = dummy;
    int count = 1;
    while (head != null &amp;&amp; count &lt; m) {
        start = start.next;
        count++;
    }
    start.next = reverseRange(start.next, n - m + 1);
    return dummy.next;
}

private ListNode reverseRange(ListNode start, int len) {
    ListNode result = null;
    ListNode cur = start;
    while (len &gt; 0) {
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
        len--;
    }
    start.next = cur;
    return result;
}
</code></pre>

<p><strong>Sort List</strong></p>

<p>Time complexity analysis: T(n) = 2 T(n/2) + O(n). <strong>By applying Master theorem, time = O(nlgn)</strong>.</p>

<pre><code>public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode mid = findMid(head);
        ListNode secondHalf = mid.next;
        mid.next = null;
        head = sortList(head);
        secondHalf = sortList(secondHalf);
        return merge(head, secondHalf);
}

private ListNode findMid(ListNode head) {
    ListNode slow = head;
    ListNode fast = head.next;
    while (fast != null &amp;&amp; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}

private ListNode merge(ListNode h1, ListNode h2) {
    ListNode dummy = new ListNode(0);
    ListNode p = dummy;
    while (h1 != null &amp;&amp; h2 != null) {
        if (h1.val &lt; h2.val) {
            p.next = h1;
            h1 = h1.next;
        } else {
            p.next = h2;
            h2 = h2.next;
        }
        p = p.next;
    }
    if (h1 == null) {
        p.next = h2;
    } else if (h2 == null) {
        p.next = h1;
    }
    return dummy.next;
}
</code></pre>

<p><strong>Reorder List</strong></p>

<pre><code>public void reorderList(ListNode head) {
    if (head == null || head.next == null) {
        return;
    }
    ListNode mid = findMid(head);
    ListNode secondHalf = mid.next;
    mid.next = null;
    secondHalf = reverse(secondHalf);
    head = mergeInterlace(head, secondHalf);
}

private ListNode findMid(ListNode head) {
    if (head == null) {
        return null;
    }
    ListNode slow = head;
    ListNode fast = head.next;
    while (fast != null &amp;&amp; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}

private ListNode reverse(ListNode head) {
    ListNode result = null;
    ListNode cur = head;
    while (cur != null) {
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
    }
    return result;
}

private ListNode mergeInterlace(ListNode h1, ListNode h2) {
    ListNode result = h1;
    h1 = h1.next;
    ListNode p = result;
    while (h1 != null &amp;&amp; h2 != null) {
        p.next = h2;
        h2 = h2.next;
        p.next.next = h1;
        h1 = h1.next;
        p = p.next.next;
    }
    if (h1 == null) {
        p.next = h2;
    } else {
        p.next = h1;
    }
    return result;
}
</code></pre>

<p><strong>Linked List Cycle</strong></p>

<pre><code>public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) 
        return false;
    ListNode slow = head;
    ListNode fast = head.next;
    while (fast != null &amp;&amp; fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) {
            return true;
        }
    }
    return false;
}
</code></pre>

<p><strong>Linked List Cycle II</strong></p>

<pre><code>public ListNode detectCycle(ListNode head) {
    if (head == null || head.next == null) 
        return null;
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null &amp;&amp; fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) {
            slow = head;
            while (slow != fast) {
                slow = slow.next;
                fast = fast.next;
            }
            return slow;
        }
    }
    return null;
}
</code></pre>

<p><strong>Merge k Sorted Lists</strong></p>

<p>I write the code in the original post.</p>

<p><strong>Copy List with Random Pointer</strong></p>

<pre><code>public RandomListNode copyRandomList(RandomListNode head)  {
    if (head == null)  {
        return null;
    }
    // 1, make a new copy of each node
    RandomListNode p = head;
    while (p != null) {
        RandomListNode copy = new RandomListNode(p.label);
        copy.next = p.next;
        p.next = copy;
        p = copy.next;
    }
    // 2. link the random pointer of copied nodes
    p = head;
    while (p != null) {
        if (p.random != null) {
            p.next.random = p.random.next;
        }
        p = p.next.next;
    }
    // 3. break the copied nodes from original nodes
    RandomListNode result = head.next;
    p = head;
    RandomListNode p2 = head.next;
    while (p != null) {
        p.next = p2.next;
        if (p2.next != null) {
            p2.next = p2.next.next;
        }
        p = p.next;
        p2 = p2.next;
    }
    return result;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/16/Binary-tree-serialize-deserialize/">[LeetCode Plus] Binary Tree Serialize and Deserialize</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-16T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/06/16/Binary-tree-serialize-deserialize/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/06/16/Binary-tree-serialize-deserialize/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://leetcode.com/2010/09/serializationdeserialization-of-binary.html">link1</a>, <a href="http://leetcode.com/2010/09/saving-binary-search-tree-to-file.html">link2</a>.</p>

<blockquote><p>Variant 1: Given a Binary Search Tree, serialize and deserialize it.</p>

<p>Variant 2: Given a Binary Tree, serialize and deserialize it.</p></blockquote>

<h3>Variant 1 &ndash; Binary search tree</h3>

<p><strong>We must only use pre-order</strong>.</p>

<p>Think about why, or read <a href="http://leetcode.com/2010/09/serializationdeserialization-of-binary.html">link1</a>. So, serialization is simple &ndash; preorder traversal.</p>

<p>The desecialization would make use of the first element, and range validation method. This is very similar to another question &lsquo;validate BST&rsquo;. Rmb the key is:</p>

<blockquote><p>Each time we add a number, we also pass the valid range within which the number can lie between.</p></blockquote>

<h4>Code</h4>

<p>The code is concise, but may not be easy to write:</p>

<pre><code>void readBSTHelper(int min, int max, int &amp;insertVal,
                   BinaryTree *&amp;p, ifstream &amp;fin) {
  if (insertVal &gt; min &amp;&amp; insertVal &lt; max) {
    int val = insertVal;
    p = new BinaryTree(val);
    if (fin &gt;&gt; insertVal) {
      readBSTHelper(min, val, insertVal, p-&gt;left, fin);
      readBSTHelper(val, max, insertVal, p-&gt;right, fin);
    }
  }
}

void readBST(BinaryTree *&amp;root, ifstream &amp;fin) {
  int val;
  fin &gt;&gt; val;
  readBSTHelper(INT_MIN, INT_MAX, val, root, fin);
}
</code></pre>

<h3>Variant 2 &ndash; Binary tree</h3>

<p>For binary tree, we could not use above solution any more. We must use some NULL pointers to fill in empty slots. For this variant, <strong>pre-order and level-order both would work</strong>.</p>

<p>Then which of these 2 is a better choice?</p>

<pre>
   1
  / \
 2   3
</pre>


<blockquote><p>Given the tree above:</p>

<p>The pre-order serialization is: {1, 2, #, #, 3, #, #}</p>

<p>The level-order serialization is: {1, 2, 3}</p>

<p>We can see that level-order is a better idea, because last level null pointers need not be handled.</p></blockquote>

<h4>Code (preorder)</h4>

<p>The serializaion is a simple traversal.</p>

<pre><code>void writeBinaryTree(BinaryTree *p, ostream &amp;out) {
  if (!p) {
    out &lt;&lt; "# ";
  } else {
    out &lt;&lt; p-&gt;data &lt;&lt; " ";
    writeBinaryTree(p-&gt;left, out);
    writeBinaryTree(p-&gt;right, out);
  }
}
</code></pre>

<p>The deserialization is a little bit like &ldquo;convert linked list to balanced tree&rdquo; (where we use first element of the list as root of the tree).</p>

<pre><code>void readBinaryTree(BinaryTree *&amp;p, ifstream &amp;fin) {
  int token;
  bool isNumber;
  if (!readNextToken(token, fin, isNumber)) 
    return;
  if (isNumber) {
    p = new BinaryTree(token);
    readBinaryTree(p-&gt;left, fin);
    readBinaryTree(p-&gt;right, fin);
  }
}
</code></pre>

<p>I did not find any code for level-order, but it&rsquo;s similar to &lsquo;level-order traversal&rsquo;.</p>

<h3>One more thing</h3>

<p>A Binary Search Tree (BST) is useful for storing phone book records in a memory limited device, such as a cell phone. The records are always maintained in sorted order, inserting and deleting a record takes O(lg n) time (slower than linked list, but much better than array).</p>

<h3>One more one-more-thing</h3>

<p><strong>This post we use # as a sentinel</strong>. There is also <strong><a href="http://stackoverflow.com/a/15044868">another idea</a> of doing both Inorder and Preorder traversal</strong> to searialize the tree data, and use the solution to &ldquo;Construct Binary Tree from Preorder and Inorder&rdquo; to deserialize it.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/15/NineChap-Binary-Tree-additional/">[NineChap 3.4] Binary Tree Additional</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-15T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/06/15/NineChap-Binary-Tree-additional/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/06/15/NineChap-Binary-Tree-additional/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>These are some additional questions that are not covered in previous NineChap posts. Some questions are non-standard and difficult to solve, and some are not found in OJ websites. But these are real questions that has been asked during interviews.</p>

<h2>Question list</h2>

<ol>
<li><p><strong><a href="/blog/2014/06/15/BST-find-upper-lower-bound/">Binary Search Tree find upper/lower bound</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/14/Iterator-of-Tree/">Implement iterator of Binary Search Tree</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/16/Binary-tree-serialize-deserialize/">Binary Tree Serialize and Deserialize</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/27/Populating-Next-Right-Pointers-in-Each-Node/">Populating Next Right Pointers in Each Node</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/27/Populating-Next-Right-Pointers-in-Each-Node-II/">Populating Next Right Pointers in Each Node II</a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="/blog/2014/05/26/Symmetric-Tree/">Symmetric Tree</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/25/Same-Tree/">Same Tree</a></strong></p></li>
</ol>


<h2>Code</h2>

<p><strong>Binary Search Tree find upper/lower bound</strong></p>

<p>Find the new post.</p>

<p><strong>Implement iterator of Binary Search Tree</strong></p>

<p>Find the new post.</p>

<p><strong>Binary Tree Serialize and Deserialize</strong></p>

<p>Find the new post.</p>

<p><strong>Populating Next Right Pointers in Each Node</strong></p>

<pre><code>public void connect(TreeLinkNode root) {
    TreeLinkNode dummy = new TreeLinkNode(0);
    dummy.left = root;
    helper(dummy, root);
}

private void helper(TreeLinkNode parent, TreeLinkNode child) {
    if (child == null) {
        return;
    }
    if (child == parent.left) {
        child.next = parent.right;
    } else if (child == parent.right) {
        if (parent.next != null) {
            child.next = parent.next.left;
        }
    }
    helper(child, child.left);
    helper(child, child.right);
}
</code></pre>

<p><strong>Populating Next Right Pointers in Each Node II</strong></p>

<p>This is a very tricky variant of DFS where the left sub-tree is making use of right sub-tree. I did not solve it even at second time.</p>

<pre><code>public void connect(TreeLinkNode root) {
    if (root == null) return;
    if (root.left == null &amp;&amp; root.right == null) return;
    TreeLinkNode levelNext = root.next;
    TreeLinkNode lowerNext = null;
    while (levelNext != null &amp;&amp; lowerNext == null) {
        if (levelNext.left != null) {
            lowerNext = levelNext.left;
            break;
        } else if (levelNext.right != null) {
            lowerNext = levelNext.right;
            break;
        } else {
            // if there is no child node of levelNext
            levelNext = levelNext.next;
        }
    }
    if (root.left == null) {
        root.right.next = lowerNext;
    } else if (root.right == null) {
        root.left.next = lowerNext;
    } else {
        root.left.next = root.right;
        root.right.next = lowerNext;
    }
    connect(root.right);
    connect(root.left);
}
</code></pre>

<p><strong>Symmetric Tree</strong></p>

<pre><code>public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    return mirror(root.left, root.right);
}

private boolean mirror(TreeNode left, TreeNode right) {
    if (left == null &amp;&amp; right == null) {
        return true;
    }
    if (left == null || right == null) {
        return false;
    }
    return (left.val == right.val) 
        &amp; mirror(left.left, right.right)
        &amp; mirror(left.right, right.left);
}
</code></pre>

<p><strong>Same Tree</strong></p>

<pre><code>public boolean isSameTree(TreeNode left, TreeNode right) {
    if (left == null &amp;&amp; right == null) {
        return true;
    }
    if (left == null || right == null) {
        return false;
    }
    return (left.val == right.val) 
        &amp; isSameTree(left.left, right.left)
        &amp; isSameTree(left.right, right.right);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/15/Java-Global-Variable/">[Java OOP] Java Global Variable</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-15T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2014/06/15/Java-Global-Variable/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2014/06/15/Java-Global-Variable/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Global variable?</h3>

<p>There is no such thing as a &lsquo;global variable&rsquo; in Java.</p>

<blockquote><p>In computer programming, a global variable is a variable that is accessible in every scope (the global environment). Some languages, like Java, don&rsquo;t have global variables. <a href="https://sg.answers.yahoo.com/question/index?qid=20110811104130AA5JrbR">reference</a></p></blockquote>

<p>But static variable can be seen as one, although every static variable must belong to some class (like Math.MIN_VALUE).</p>

<p>Global variables are generally only used for declaring constants. In this case, declare it as &lsquo;final static&rsquo;. <a href="http://stackoverflow.com/questions/4646577/global-variables-in-java">reference</a></p>

<h3>Four types of variable in Java</h3>

<h4>Local variables</h4>

<p>Created when the method, constructor or block is entered and will be destroyed once it exits the method, constructor or block.</p>

<h4>Instance variables</h4>

<p>Outside a method or constructor.</p>

<p>When a space is allocated for an object in the heap, a slot for each instance variable value is created. It is destroyed when the object is destroyed.</p>

<h4>Class/static variables</h4>

<p>Static variable is class variable.</p>

<p>Declared with &lsquo;static&rsquo; keyword in a class.</p>

<h4>Constants</h4>

<p>Most common usage of static variable &ndash; constant.</p>

<p>Declared with &lsquo;static final&rsquo; keyword in a class.</p>

<h3>One more thing</h3>

<p>About <a href="http://programmers.stackexchange.com/a/65289">stack and heap in Java</a>:</p>

<blockquote><p>In Java, primitives are created on the stack.</p>

<p>Objects are created on the heap, and only references (which in turn are primitives) are passed around on the stack.</p>

<p>If you create an object, it is put on the heap, with all the variables that belong to it, so that it can persist after the function call returns.</p></blockquote>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/29">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/27">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (54)</a></li>
<li class='category'><a href='/blog/categories/experience/'>experience (3)</a></li>
<li class='category'><a href='/blog/categories/facebook/'>facebook (9)</a></li>
<li class='category'><a href='/blog/categories/fundamental/'>fundamental (5)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (38)</a></li>
<li class='category'><a href='/blog/categories/java-oop/'>java oop (19)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (153)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (90)</a></li>
<li class='category'><a href='/blog/categories/string-search/'>string search (7)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (7)</a></li>
<li class='category'><a href='/blog/categories/top-k/'>top k (7)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/01/10/reverse-a-stack/">[Google] Reverse a Stack Without DS</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/10/minimum-range-inclueds-at-least-1/">[Amazon] Mininum Range That Includes at Least One</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/09/terminology-ngram/">[Design] Terminology: N-gram</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/09/most-frequent-word-from-book/">[Question] Most Frequent Word From a Book</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/09/match-triplet-with-reverse-order/">[Question] Match Triplet With Reverse Order</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Charlie Brown -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
