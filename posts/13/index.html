
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="strStr Question Implement strStr Before solving the problem, it&rsquo;s very important to ask this questions: Can we use system library (eg. str. &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/13">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/11/NineChap-strStr-coding-style/">[NineChap 1.1] strStr and Coding Style</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-11T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>strStr Question</h2>

<p><strong><a href="/blog/2014/05/10/Implement-strStr/">Implement strStr</a></strong></p>

<p>Before solving the problem, it&rsquo;s very important to ask this questions:</p>

<blockquote><p><strong>Can we use system library (eg. str.substring() or indexOf())</strong></p></blockquote>

<p>The answer is &lsquo;No&rsquo;, but asking this question shows that you think deep into questions. Keep in mind the characteristics for a candidate is judged by 4 things:</p>

<ol>
<li>Code readability &ndash; how long does it take to review your code?</li>
<li>Coding convention &ndash; do you have the habit to write efficient code?</li>
<li>Testing &ndash; it&rsquo;s good habit to write test case before asked to.</li>
<li>Communication skills</li>
</ol>


<p>Solution of this question is double for-loop. It&rsquo;s not linear time complexity, but it&rsquo;s OK. After getting the code correct, it&rsquo;s best to tell the O(n) time KMP solution. However, it&rsquo;s most probably not required to implement.</p>

<p><strong>my code</strong></p>

<pre><code>public String strStr(String haystack, String needle) {
    if (haystack == null || needle == null) {
        return null;
    }
    int len1 = haystack.length();
    int len2 = needle.length();
    for (int i = 0; i &lt;= len1 - len2; i ++) {
        // start from i, match chars
        boolean match = true;
        for (int j = 0; j &lt; len2; j ++) {
            if (haystack.charAt(i + j) != needle.charAt(j)) {
                match = false;
                break;
            }
        }
        if (match) {
            return haystack.substring(i);
        }
    }
    return null;
}
</code></pre>

<p>alternative code from <a href="http://answer.ninechapter.com/solutions/implement-strstr/">ninechap</a></p>

<pre><code>public String strStr(String haystack, String needle) {
    if(haystack == null || needle == null) {
        return null;
    }
    int i, j;
    for(i = 0; i &lt; haystack.length() - needle.length() + 1; i++) {
        for(j = 0; j &lt; needle.length(); j++) {
            if(haystack.charAt(i + j) != needle.charAt(j)) {
                break;
            }
        }
        if(j == needle.length()) {
            return haystack.substring(i);
        }
    }
    return null;
}
</code></pre>

<h2>Google Coding Style</h2>

<h4>if &hellip; else &hellip;</h4>

<pre><code>if (condition) {
    statements;
} else if (condition) {
    statements;
} else {
    statements;
}
</code></pre>

<h4>自增/自减</h4>

<pre><code>while （d++ = s++） {
    n++;
}
</code></pre>

<p>To be continued.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/10/Searching-a-2D-Sorted-Matrix/">[LeetCode Plus] Searching a 2D Sorted Matrix</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://leetcode.com/2010/10/searching-2d-sorted-matrix.html">link</a></p>

<blockquote>
<p class="font-color">Write an efficient algorithm that searches for a value in an <i>n</i> x <i>m</i> table (two-dimensional array). This table is sorted along the rows and columns — that is,</p><p class="font-color">Table[i][j] ≤ Table[i][j + 1], <br>Table[i][j] ≤ Table[i + 1][j]</p>
</blockquote>


<h3>Related questions</h3>

<p><strong><a href="/blog/2014/05/21/Search-a-2D-Matrix/">Search a 2D Matrix</a></strong>.</p>

<p><strong><a href="/blog/2014/06/10/Searching-a-2D-Sorted-Matrix/">Searching a 2D Sorted Matrix</a></strong>.</p>

<p><strong><a href="/blog/2014/06/14/Count-negative-in-2D-Sorted-Matrix/">Count negative in a 2D Sorted Matrix</a></strong>.</p>

<h3>Analysis</h3>

<p>This is a extremely high-freq question. Almost every company will ask.</p>

<p>This question is not to be confused with <strong><a href="/blog/2014/05/21/Search-a-2D-Matrix/">Search a 2D Matrix</a></strong>.</p>

<p><strong>Solution One: Step-wise Linear Search</strong>. Standard solution.</p>

<p>Time = O(n). Worse case 2n steps.</p>

<p>Note that <strong>this is the best solution</strong>!</p>

<p><img class="middle" src="/assets/images/search_2D_matrix_1.png"></p>

<blockquote><p>begin with the upper right corner, we traverse one step to the left or bottom. For example, the picture below shows the traversed path (the red line) when we search for 13.</p>

<pre><code>Essentially, each step we are able to eliminate either a row or a column.
</code></pre></blockquote>

<p><strong>Solution Two: Quad Partition 四分法</strong>.</p>

<p>Time = O(n<sup>1</sup>.58). Analysis can be found in the original question post.</p>

<p><img class="middle" src="/assets/images/search_2D_matrix_2.png"></p>

<p>Basic idea is like binary search &ndash; get mid and divide. We can then discard &frac14; of the matrix. For example: search for 6, we can discard the bottom right sub-matrix.</p>

<p><strong>Solution Three: Diagonal-based binary partition</strong>. This is based on previous solution, but better.</p>

<p>Time = O(nlgn).</p>

<p><img class="middle" src="/assets/images/search_2D_matrix_3.png"></p>

<p>This is a good solution, but it would fail in a non-square matrix, so&hellip;</p>

<h3>Code</h3>

<p><strong>step-wise linear search</strong></p>

<pre><code>bool stepWise(int mat[][N_MAX], int N, int target, 
              int &amp;row, int &amp;col) {
  if (target &lt; mat[0][0] || target &gt; mat[N-1][N-1]) return false;
  row = 0;
  col = N-1;
  while (row &lt;= N-1 &amp;&amp; col &gt;= 0) {
    if (mat[row][col] &lt; target) 
      row++;
    else if (mat[row][col] &gt; target)
      col--;
    else
      return true;
  }
  return false;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/10/NineChap-Binary-Tree-DFS/">[NineChap 3.1] Binary Tree DFS and Divide Conquer</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>DFS</h2>

<h4>Recursion or While-Loop?</h4>

<p>We can use recursion, because unless it&rsquo;s pre-order traverse, binary tree questions can be difficult.</p>

<p>Solving the problem is more important.</p>

<h4>Divide &amp; Conquer Algorithm</h4>

<ol>
<li>Merge Sort</li>
<li>Quick Sort</li>
<li>Most of Binary tree questions</li>
</ol>


<h4>Solution modal</h4>

<p>Generally, D&amp;C questions would do 2 things at same time:</p>

<ol>
<li>Divide &ndash; For binary tree, it mean solve left child, and solve right child</li>
<li>Conquer &ndash; return result value</li>
</ol>


<p>A very common type would be validating the left/right children and return -1 if the validation failed. Otherwise, a result value is returned. In this way, by checking the positive/negative sign, we know whether this node is valid, and if valid, we know the returned value.</p>

<p>This idea is extensivelly used among all binary tree questions. See &ldquo;Lowest Common Ancestor (LCA)&rdquo; for more details.</p>

<h4>Template</h4>

<p><strong>Divide &amp; Conquer</strong>, <a href="http://answer.ninechapter.com/solutions/dfs-template/">link</a></p>

<pre><code>public class Solution {
    public ResultType traversal(TreeNode root) {
        // null or leaf
        if (root == null) {
            // do something and return;
        }

        // Divide
        ResultType left = traversal(root.left);
        ResultType right = traversal(root.right);

        // Conquer
        ResultType result = Merge from left and right.
        return result;
    }
}
</code></pre>

<h2>Question list</h2>

<p><strong>Traversal</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/06/02/Binary-Tree-Preorder-Traversal/">Binary Tree Preorder Traversal</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/24/Binary-Tree-Inorder-Traversal/">Binary Tree Inorder Traversal</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/03/Binary-Tree-Postorder-Traversal/">Binary Tree Postorder Traversal</a></strong></p></li>
</ol>


<p><strong>Divide &amp; Conquer</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/25/Maximum-Depth-of-Binary-Tree/">Maximum Depth of Binary Tree</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/25/Minimum-Depth-of-Binary-Tree/">Minimum Depth of Binary Tree</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/26/Balanced-Binary-Tree/">Balanced Binary Tree</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/28/Binary-Tree-Maximum-Path-Sum/">Binary Tree Maximum Path Sum</a></strong> &ndash; the most important question for this category</p></li>
</ol>


<h4>Additional</h4>

<ol>
<li><p><strong>Lowest Common Ancestor Problem</strong></p>

<p> <a href="/blog/2014/06/10/Lowest-Common-Ancestor-BST/">problem one</a></p>

<p> <a href="/blog/2014/06/10/Lowest-Common-Ancestor-Tree/">problem two</a></p>

<p> <a href="/blog/2014/06/10/Lowest-Common-Ancestor-Tree-II/">problem three</a></p></li>
</ol>


<h2>Code</h2>

<p><strong>Binary Tree Preorder Traversal</strong></p>

<pre><code>public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; ans = new LinkedList&lt;Integer&gt;();
    if (root == null) return ans;
    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode cur = stack.pop();
        ans.add(cur.val);
        if (cur.right != null) {
            stack.push(cur.right);
        } 
        if (cur.left != null) {
            stack.push(cur.left);
        }
    }
    return ans;
}
</code></pre>

<p>There is a not-recommended but good-to-know solution of Divide &amp; Conquer (not written by me)</p>

<pre><code>public class Solution {
    public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) {
        ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        // null or leaf
        if (root == null) {
            return result;
        }

        // Divide
        ArrayList&lt;Integer&gt; left = preorderTraversal(root.left);
        ArrayList&lt;Integer&gt; right = preorderTraversal(root.right);

        // Conquer
        result.add(root.val);
        result.addAll(left);
        result.addAll(right);
        return result;
    }
}
</code></pre>

<p><strong>Binary Tree Inorder Traversal</strong></p>

<p>Keep traversing left until a NULL is found. When it happens, pop one and traverse right once. <strong>Remember this solution</strong>!</p>

<pre><code>public ArrayList&lt;Integer&gt; inorderTraversal(TreeNode root) {
    ArrayList&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();
    if (root == null) {
        return ans;
    }
    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
    TreeNode p = root;
    while (p != null || !stack.isEmpty()) {
        if (p != null) {
            stack.push(p);
            p = p.left;
        }
        else {
            p = stack.pop();
            ans.add(p.val);
            p = p.right;
        }
    }
    return ans;
}
</code></pre>

<p><strong>Binary Tree Postorder Traversal</strong></p>

<p>I failed to write the code even after reading the solution. I need to memorize this solution by heart.</p>

<pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();
    if (root == null) {
        return ans;
    }
    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
    stack.push(root);
    TreeNode pre = null;
    TreeNode cur = null;
    while (!stack.isEmpty()) {
        cur = stack.peek();
        if (pre == null || pre.left == cur || pre.right == cur) {
            if (cur.left != null) {
                stack.push(cur.left);
            } else if (cur.right != null) {
                stack.push(cur.right);
            }
        } else if (cur.left == pre) {
            if (cur.right != null) {
                stack.push(cur.right);
            }
        } else if (cur.right == pre || cur == pre) {
            // note that 'pre' and 'cur' are never going to be apart
            // for more then 1 edge (they can overlap) 
            ans.add(stack.pop().val);
        }
        pre = cur;
    }
    return ans;
}
</code></pre>

<p><strong>Maximum Depth of Binary Tree</strong></p>

<pre><code>// 1 minute
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
</code></pre>

<p><strong>Minimum Depth of Binary Tree</strong></p>

<pre><code>public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return checkLeaf(root);
}

private int checkLeaf(TreeNode node) {
    if (node.left == null &amp;&amp; node.right == null) {
        return 1;
    }
    int ll = Integer.MAX_VALUE;
    int rr = Integer.MAX_VALUE;
    if (node.left != null) ll = checkLeaf(node.left);
    if (node.right != null) rr = checkLeaf(node.right);
    return 1 + Math.min(ll, rr);
}
</code></pre>

<p>After checking <a href="http://answer.ninechapter.com/solutions/minimum-depth-of-binary-tree/">the answer</a>, the code above can be optimized:</p>

<pre><code>public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return getMin(root);
}

public int getMin(TreeNode root){
    if (root == null) {
        return Integer.MAX_VALUE; // important
    }

    if (root.left == null &amp;&amp; root.right == null) {
        return 1;
    }

    return Math.min(getMin(root.left), getMin(root.right)) + 1;
}
</code></pre>

<p><strong>Balanced Binary Tree</strong></p>

<pre><code>// 4 minutes
public boolean isBalanced(TreeNode root) {
    return getDepth(root) != -1;
}

private int getDepth(TreeNode node) {
    if (node == null) {
        return 0;
    }
    int ll = getDepth(node.left);
    int rr = getDepth(node.right);
    if (ll == -1 || rr == -1 || Math.abs(ll - rr) &gt; 1) {
        return -1;
    }
    return 1 + Math.max(ll, rr);
}
</code></pre>

<p><strong>Binary Tree Maximum Path Sum</strong></p>

<p>Although the following code works:</p>

<pre><code>int max = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) {
    maxDepth(root);
    return max;
}

private int maxDepth(TreeNode node) {
    if (node == null) {
        return 0;
    }
    int ll = maxDepth(node.left);
    int rr = maxDepth(node.right);
    int currentMaxPath = ll + rr + node.val;
    max = Math.max(max, currentMaxPath);
    return Math.max(0, node.val + Math.max(ll, rr));
}
</code></pre>

<p>Mr. Huang said it&rsquo;s AN EXTREMELY BAD IDEA TO USE GLOBAL VARIABLE in Java. It&rsquo;s just terrible. Don&rsquo;t do it.</p>

<p>According to Mr. Huang&rsquo;s <a href="http://answer.ninechapter.com/solutions/binary-tree-maximum-path-sum/">suggestion</a>, I added another class called &ldquo;ResultType&rdquo;. This can help me return 2 values at 1 single traversal.</p>

<p>Code is below. One &lsquo;catch-ya&rsquo; is when NULL is found, the maxPath should return Integer.MIN_VALUE instead of 0.</p>

<p>This code is much easier for both me and anyone else to understand, so <strong>stick to this solution, and never use global variable in Java</strong>!</p>

<pre><code>private class ResultType {
    int singlePath, maxPath;
    ResultType(int singlePath, int maxPath) {
        this.singlePath = singlePath;
        this.maxPath = maxPath;
    }
}

public int maxPathSum(TreeNode root) {
    ResultType result = helper(root);
    return result.maxPath;
}

private ResultType helper(TreeNode node) {
    // null case
    if (node == null) {
        return new ResultType(0, Integer.MIN_VALUE);
    }
    // divide
    ResultType ll = helper(node.left);
    ResultType rr = helper(node.right);
    // conquer
    int curSinglePath = Math.max(0, node.val + 
            Math.max(ll.singlePath, rr.singlePath));
    int childMaxPath = Math.max(ll.maxPath, rr.maxPath);
    int curMaxPath = Math.max(childMaxPath, node.val + 
            ll.singlePath + rr.singlePath);
    // done
    return new ResultType(curSinglePath, curMaxPath);
}
</code></pre>

<p><strong>Lowest Common Ancestor</strong> &ndash; I wrote three new posts on this topic:</p>

<p>Problem 1: BST: top-down O(height) solution</p>

<p>Problem 2: Binary Tree: bottom-up O(n) solution</p>

<p>Problem 3: Binary Tree with a link to parent</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/10/NineChap-Binary-Tree-BFS/">[NineChap 3.2] Binary Tree BFS</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Template (BFS)</h2>

<p>BFS can be implemented using either 2 queues (replacing) or 1 queue. Of course 1 queue is better.</p>

<p><a href="http://answer.ninechapter.com/solutions/bfs-template/">link</a></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    ArrayList result = new ArrayList();

    if (root == null)
        return result;

    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
    queue.offer(root);

    while (!queue.isEmpty()) {
        ArrayList&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;(); // important
        int size = queue.size();
        for (int i = 0; i &lt; size; i++) {
            TreeNode head = queue.poll();
            level.add(head.val);
            if (head.left != null)
                queue.offer(head.left);
            if (head.right != null)
                queue.offer(head.right);
        }
        result.add(level); // important
    }

    return result;
}
</code></pre>

<h2>Question list</h2>

<p><strong>BFS</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/25/Binary-Tree-Level-Order-Traversal/">Binary Tree Level Order Traversal</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/25/Binary-Tree-Level-Order-Traversal-II/">Binary Tree Level Order Traversal II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/25/Binary-Tree-Zigzag-Level-Order-Traversal/">Binary Tree Zigzag Level Order Traversal</a></strong></p></li>
</ol>


<p><strong>Additional</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/27/Construct-Binary-Tree-from-Preorder-and-Inorder/">Construct Binary Tree from Preorder and Inorder</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/27/Construct-Binary-Tree-from-Inorder-and-Postorder/">Construct Binary Tree from Inorder and Postorder</a></strong></p></li>
</ol>


<h2>Code</h2>

<p>First 3 questions are basically same. Below code is for question 1. There is no &lsquo;catch-ya&rsquo;, it&rsquo;s very standard code.</p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (root == null) {
        return ans;
    }
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
    q.offer(root);
    while(!q.isEmpty()) {
        int size = q.size();
        List&lt;Integer&gt; level = new LinkedList&lt;Integer&gt;();
        for (int i = 0; i &lt; size; i ++) {
            TreeNode node = q.poll();
            level.add(node.val);
            if (node.left != null) {
                q.offer(node.left);
            }
            if (node.right != null) {
                q.offer(node.right);
            }
        }
        ans.add(level);
    }
    return ans;
}
</code></pre>

<p><strong>Construct Binary Tree from Preorder and Inorder</strong> &ndash; written by me</p>

<pre><code>public TreeNode buildTree(int[] preorder, int[] inorder) {
    if (preorder == null || inorder == null || preorder.length != inorder.length) {
        return null;
    }
    return helper(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1);
}

private TreeNode helper(int[] preorder, int a, int b, int[] inorder, int c, int d) {
    if (a &gt; b) {
        return null;
    }
    int headVal = preorder[a];
    TreeNode head = new TreeNode(headVal);
    int p = c;
    while (p &lt;= d) {
        if (inorder[p] == headVal) {
            break;
        }
        p ++;
    }
    head.left = helper(preorder, a+1, a+p-c, inorder, c, p-1);
    head.right = helper(preorder, b-d+p+1, b, inorder, p+1, d);
    return head;
}
</code></pre>

<p><strong>Construct Binary Tree from Inorder and Postorder</strong> &ndash; similar to previous code, copied from <a href="http://answer.ninechapter.com/solutions/construct-binary-tree-from-inorder-and-postorder-traversal/">ninechap</a></p>

<pre><code>private int findPosition(int[] arr, int start, int end, int key) {
    int i;
    for (i = start; i &lt;= end; i++) {
        if (arr[i] == key) {
            return i;
        }
    }
    return -1;
}

private TreeNode myBuildTree(int[] inorder, int instart, int inend,
        int[] postorder, int poststart, int postend) {
    if (instart &gt; inend) {
        return null;
    }

    TreeNode root = new TreeNode(postorder[postend]);
    int position = findPosition(inorder, instart, inend, postorder[postend]);

    root.left = myBuildTree(inorder, instart, position - 1,
            postorder, poststart, poststart + position - instart - 1);
    root.right = myBuildTree(inorder, position + 1, inend,
            postorder, poststart + position - instart, postend - 1);
    return root;
}

public TreeNode buildTree(int[] inorder, int[] postorder) {
    if (inorder.length != postorder.length) {
        return null;
    }
    return myBuildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/10/NineChap-Binary-Search-Tree/">[NineChap 3.3] Binary Search Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Question list</h2>

<p><strong>BST</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/26/Validate-Binary-Search-Tree/">Validate Binary Search Tree</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/11/Study-BST-insert-and-delete/">Insert a Node in Binary Search Tree</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/11/Study-BST-insert-and-delete/">Delete a Node in Binary Search Tree</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/13/Search-range-BST-trim-BST/">Search Range in a Binary Search Tree</a></strong></p></li>
</ol>


<p><strong>Additional</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/25/Recover-Binary-Search-Tree/">Recover Binary Search Tree</a></strong> &ndash; used global variable</p></li>
<li><p><strong><a href="/blog/2014/05/26/Convert-Sorted-Array-to-Binary-Search-Tree/">Convert Sorted Array to Binary Search Tree</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/26/Convert-Sorted-List-to-Binary-Search-Tree/">Convert Sorted List to Binary Search Tree</a></strong> &ndash; used global variable</p></li>
</ol>


<h2>Code</h2>

<p><strong>Validate Binary Search Tree</strong></p>

<pre><code>public boolean isValidBST(TreeNode root) {
    return validate(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
}

private boolean validate(TreeNode node, int min, int max) {
    if (node == null) {
        return true;
    }
    if (node.val &lt;= min || max &lt;= node.val) {
        return false;
    }
    return validate(node.left, min, node.val) &amp; validate(node.right, node.val, max);
}
</code></pre>

<p><strong>Insert a Node in Binary Search Tree</strong> and <strong>Delete a Node in Binary Search Tree</strong> are written in a new post.</p>

<p><strong>Search Range in a Binary Search Tree</strong></p>

<p>There is a new post for this.</p>

<p><strong>Recover Binary Search Tree</strong></p>

<pre><code>// 3 global variables used
TreeNode first = null;
TreeNode second = null; 
TreeNode current = null;

public void recoverTree(TreeNode root) {
    traverse(root);
    if (first != null) {
        int temp = first.val;
        first.val = second.val;
        second.val = temp;
    }
}

public void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    traverse(root.left);
    // inorder traversal
    if (current != null &amp;&amp; current.val &gt; root.val) {
        if (first == null) {
            first = current;
        }
        second = root;
    }
    current = root;
    traverse(root.right);
}
</code></pre>

<p><strong>Convert Sorted Array to Binary Search Tree</strong></p>

<pre><code>public TreeNode sortedArrayToBST(int[] num) {
    if (num == null || num.length == 0) {
        return null;
    }
    return build(num, 0, num.length - 1);
}

private TreeNode build(int[] num, int start, int end) {
    if (start &gt; end) {
        return null;
    }
    int mid = start + (end - start) / 2;
    TreeNode head = new TreeNode(num[mid]);
    head.left = build(num, start, mid - 1);
    head.right = build(num, mid + 1, end);
    return head;
}
</code></pre>

<p><strong>Convert Sorted List to Binary Search Tree</strong> &ndash; note that this solution uses 1 global variable</p>

<pre><code>ListNode cur = null;

public TreeNode sortedListToBST(ListNode head) {
    // count total length of the list 
    ListNode p = head;
    int count = 0;
    while (p != null) {
        p = p.next;
        count++;
    }
    // start to traverse the tree and fill in data
    cur = head;
    return build(0, count - 1);
}

private TreeNode build(int start, int end) {
    if (start &gt; end) {
        return null;
    }
    int mid = start + (end - start) / 2;
    TreeNode head = new TreeNode(0);
    head.left = build(start, mid - 1);
    head.val = cur.val;
    cur = cur.next;
    head.right = build(mid + 1, end);
    return head;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/10/Lowest-Common-Ancestor-Tree-II/">[LeetCode Plus] Lowest Common Ancestor of a Binary Tree Part II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-tree-part-ii.html">link</a></p>

<div class="entry bg-color bg-img font-color">
    <blockquote>
        <p class="font-color">Given a binary tree, find the lowest common ancestor of two given nodes in the tree. Each node contains a parent pointer which links to its parent.</p>
    </blockquote>
    <p class="font-color bg-color bg-img"><span id="more-797" class="font-color"></span>
        <br> <strong><span style="color: red;" class="font-color">Note:</span></strong>
        <br>This is Part II of Lowest Common Ancestor of a Binary Tree. If you need to find the lowest common ancestor without parent pointers, please read <a href="http://www.leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-tree-part-i.html" class="font-color">Lowest Common Ancestor of a Binary Tree Part I</a>.
        <br>
    </p><pre>        _______<span style="color: #990000;" class="font-color">3</span>______
       /              \
    ___<span style="color: #990000;" class="font-color">5</span>__          ___<span style="color: #990000;" class="font-color">1</span>__
   /      \        /      \
   <span style="color: #990000;" class="font-color">6</span>      _<span style="color: #990000;" class="font-color">2       0       8</span>
         /  \
         <span style="color: #990000;" class="font-color">7   4</span></pre>
    <p class="font-color">If you are not so sure about the definition of lowest common ancestor (LCA), please refer to my previous post: <a href="http://www.leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-search-tree.html" class="font-color">Lowest Common Ancestor of a Binary Search Tree (BST)</a> or the definition of LCA <a href="http://en.wikipedia.org/wiki/Lowest_common_ancestor" class="font-color">here</a>. Using the tree above as an example, the LCA of nodes <span style="color: #990000;" class="font-color">5</span> and <span style="color: #990000;" class="font-color">1</span> is <span style="color: #990000;" class="font-color">3</span>. Please note that LCA for nodes <span style="color: #990000;" class="font-color">5</span> and <span style="color: #990000;" class="font-color">4</span> is <span style="color: #990000;" class="font-color">5</span>.</p>
    <p class="font-color">In my last post: <a href="http://www.leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-tree-part-i.html" class="font-color">Lowest Common Ancestor of a Binary Tree Part I</a>, we have devised a recursive solution which finds the LCA in O(<em>n</em>) time. If each node has a pointer that link to its parent, could we devise a better solution?</p>
    <p class="font-color"><strong>Hint:</strong>
        <br>No recursion is needed. There is an easy solution which uses extra space. Could you eliminate the need of extra space?</p>
</div>


<h3>Analysis</h3>

<p><strong>This is not an difficult question, right</strong>? Finding the common parent would only require 2 bottom-up walk, and find the first position to meet.</p>

<p><strong>However, we do not wish to use extra space for this solution</strong>. The solution is actually very very creative.</p>

<ol>
<li>Find the height of both nodes (from the head)</li>
<li>By calculating the height difference, move the lower nodes up (follow the parent path) to the same level as the other node.</li>
<li>Two nodes move up together until they meet.</li>
<li>This solution requires no extra space.</li>
</ol>


<p>Here is <strong>a very similar question: <a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/">Intersection of 2 LinkedList</a></strong>.</p>

<h3>Code</h3>

<pre><code>// As root-&gt;parent is NULL, we don't need to pass root in.
Node *LCA(Node *p, Node *q) {
  int h1 = getHeight(p);
  int h2 = getHeight(q);
  // swap both nodes in case p is deeper than q.
  if (h1 &gt; h2) {
    swap(h1, h2);
    swap(p, q);
  }
  // invariant: h1 &lt;= h2.
  int dh = h2 - h1;
  for (int h = 0; h &lt; dh; h++)
    q = q-&gt;parent;
  while (p &amp;&amp; q) {
    if (p == q) return p;
    p = p-&gt;parent;
    q = q-&gt;parent;
  }
  return NULL;  // p and q are not in the same tree
}

int getHeight(Node *p) {
  int height = 0;
  while (p) {
    height++;
    p = p-&gt;parent;
  }
  return height;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/10/Lowest-Common-Ancestor-Tree/">[LeetCode Plus] Lowest Common Ancestor of a Binary Tree Part I</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-tree-part-i.html">link</a></p>

<div class="entry bg-color bg-img font-color">
    <blockquote>
        <p class="font-color bg-color bg-img">Given a binary tree, find the lowest common ancestor of two given nodes in the tree.</p>
    </blockquote>
    <p class="font-color bg-color bg-img"><span id="more-790" class="font-color"></span>
        <br>
    </p><pre class="bg-color bg-img font-color">        _______<span style="color: #990000;" class="font-color">3</span>______
       /              \
    ___<span style="color: #990000;" class="font-color">5</span>__          ___<span style="color: #990000;" class="font-color">1</span>__
   /      \        /      \
   <span style="color: #990000;" class="font-color">6</span>      _<span style="color: #990000;" class="font-color">2       0       8</span>
         /  \
         <span style="color: #990000;" class="font-color">7   4</span></pre>
    <p class="font-color">If you are not so sure about the definition of lowest common ancestor (LCA), please refer to my previous post: <a href="http://www.leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-search-tree.html" class="font-color bg-color bg-img">Lowest Common Ancestor of a Binary Search Tree (BST)</a> or the definition of LCA <a href="http://en.wikipedia.org/wiki/Lowest_common_ancestor" class="font-color">here</a>. Using the tree above as an example, the LCA of nodes <strong><span style="color: #990000;" class="font-color">5</span></strong> and <strong><span style="color: #990000;" class="font-color">1</span></strong> is <strong><span style="color: #990000;" class="font-color">3</span></strong>. Please note that LCA for nodes <strong><span style="color: #990000;" class="font-color">5</span> </strong>and <strong><span style="color: #990000;" class="font-color">4</span> </strong>is <strong><span style="color: #990000;" class="font-color">5</span></strong>.</p>
    <p class="font-color bg-color bg-img"><strong>Hint:</strong>
        <br>Top-down or bottom-up? Consider both approaches and see which one is more efficient.</p>
</div>


<h3>Analysis</h3>

<p>This tree is not BST, so it&rsquo;s more difficult then previous. Top-down approach would take O(n<sup>2</sup>) time due to duplicate traverse.</p>

<p><strong>However, there is a very good bottom-up approach with O(n) time</strong>. This solution, though tricky, is the most standard and common interview question that can be asked about Binary Tree.</p>

<blockquote><p>We traverse from the bottom, and once we reach a node which matches one of the two nodes, we pass it up to its parent. The parent would then test its left and right subtree if each contain one of the two nodes. If yes, then the parent must be the LCA and we pass its parent up to the root. If not, we pass the lower node which contains either one of the two nodes (if the left or right subtree contains either p or q), or NULL (if both the left and right subtree does not contain either p or q) up.</p></blockquote>

<p>The coding is much easier than coming up with this idea.</p>

<blockquote cite="http://leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-tree-part-i.html">
<p class="font-color"><strong>Notes:<br> </strong>The LCA problem had been studied extensively by many computer scientists. There exists efficient algorithms for finding LCA in constant time after initial processing of the tree in linear time. For the adventurous reader, please read this article for more details: <a href="http://www.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=lowestCommonAncestor" class="font-color">Range Minimum Query and Lowest Common Ancestor in Topcoder</a>.
</p>
</blockquote>


<h3>Code</h3>

<p>Assuming root node is given. C++ code from leetcode.com.</p>

<pre><code>Node *LCA(Node *root, Node *p, Node *q) {
  if (!root) return NULL;
  if (root == p || root == q) return root;
  Node *L = LCA(root-&gt;left, p, q);
  Node *R = LCA(root-&gt;right, p, q);
  if (L &amp;&amp; R) return root;  // if p and q are on both sides
  return L ? L : R;  // either one of p,q is on one side OR p,q is not in L&amp;R subtrees
}
</code></pre>

<p>Assuming parent node is not given. This Java code is from <a href="http://answer.ninechapter.com/solutions/lowest-common-ancestor/">ninechap</a> (The first method getRoot() is used to get root node).</p>

<pre><code>private TreeNode getRoot(node) {
    while (node.parent != null) {
        node = node.parent;
    }
    return node;
}

private TreeNode getAncestor(TreeNode root, TreeNode node1, TreeNode node2) {
    if (root == null || root == node1 || root == node2) {
        return root;
    }

    // Divide
    TreeNode left = getAncestor(root.left, node1, node2);
    TreeNode right = getAncestor(root.right, node1, node2);

    // Conquer
    if (left != null &amp;&amp; right != null) {
        return root;
    } 
    if (left != null) {
        return left;
    }
    if (right != null) {
        return right;
    }
    return null;
}

public TreeNode latestCommonAncestor(TreeNode node1, TreeNode node2) {
    if (node1 == null || node2 == null) {
        return null;
    }
    TreeNode root = getRoot(node1);
    return getAncestor(root, node1, node2);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/10/Lowest-Common-Ancestor-BST/">[LeetCode Plus] Lowest Common Ancestor of a Binary Search Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-search-tree.html">link</a></p>

<div class="entry bg-color bg-img font-color">
    <blockquote class="bg-color bg-img font-color">
        <p class="font-color bg-color bg-img">Given a binary search tree (BST), find the lowest common ancestor of two given nodes in the BST.</p>
    </blockquote>
    <p class="font-color bg-color bg-img"><span id="more-782" class="font-color"></span>
        <br>
    </p><pre class="bg-color bg-img font-color">        _______<span style="color: #990000;" class="font-color">6</span>______
       /              \
    ___<span style="color: #990000;" class="font-color">2</span>__          ___<span style="color: #990000;" class="font-color">8</span>__
   /      \        /      \
   <span style="color: #990000;" class="font-color">0</span>      _<span style="color: #990000;" class="font-color">4       7       9</span>
         /  \
         <span style="color: #990000;" class="font-color">3   5</span></pre>
    <p class="font-color bg-color bg-img">Using the above tree as an example, the lowest common ancestor (LCA) of nodes <span style="color: #990000;" class="font-color">2</span> and <span style="color: #990000;" class="font-color bg-color bg-img">8</span> is <span style="color: #990000;" class="font-color">6</span>. But how about LCA of nodes <span style="color: #990000;" class="font-color">2</span> and <span style="color: #990000;" class="font-color">4</span>? Should it be <span style="color: #990000;" class="font-color">6</span> or <span style="color: #990000;" class="font-color">2</span>?</p>
    <p class="font-color bg-color bg-img">According to the <a href="http://en.wikipedia.org/wiki/Least_common_ancestor" class="font-color">definition of LCA on  Wikipedia</a>: &#8220;The lowest common ancestor is defined between two nodes <em>v</em> and <em>w</em> as the lowest node in T that has both <em>v</em> and <em>w</em> as descendants (where we allow a node to be a descendant of itself).&#8221; Since a node can be a descendant of itself, the LCA of <span style="color: #990000;" class="font-color">2</span> and <span style="color: #990000;" class="font-color">4</span> should be <span style="color: #990000;" class="font-color">2</span>, according to this definition.</p>
    <p class="font-color bg-color bg-img"><strong>Hint:</strong>
        <br>A top-down walk from the root of the tree is enough.</p>
</div>


<h3>Analysis</h3>

<p><strong>This question is the easiest of this series of questions</strong>. I will quote the solution analysis.</p>

<blockquote><p>There’s only three cases you need to consider.</p></blockquote>

<pre><code>1. Both nodes are to the left of the tree.
2. Both nodes are to the right of the tree.
3. One node is on the left while the other is on the right. This node must be LCA. 
4. Current node equals to one of the two nodes, this node must be the LCA. 
</code></pre>

<blockquote><p>The run time complexity is O(h), where h is the height of the BST.</p></blockquote>

<h3>Code</h3>

<p>The code is not written by me.</p>

<p>I shall write some test cases for all questions in leetcode_plus.</p>

<pre><code>Node *LCA(Node *root, Node *p, Node *q) {
  if (!root || !p || !q) return NULL;
  if (max(p-&gt;data, q-&gt;data) &lt; root-&gt;data)
    return LCA(root-&gt;left, p, q);
  else if (min(p-&gt;data, q-&gt;data) &gt; root-&gt;data)
    return LCA(root-&gt;right, p, q);
  else
    return root;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/10/First-Character-Appearing-Once/">[Question] First Character Appearing Only Once</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://codercareer.blogspot.sg/2011/10/no-13-first-character-appearing-only.html">link</a></p>

<blockquote><p>Problem: Implement a function to find the first character in a string which only appears once.</p>

<pre><code>For example: It returns ‘b’ when the input is “abaccdeff”.
</code></pre></blockquote>

<h3>Analysis</h3>

<p>Great solution from <a href="http://stackoverflow.com/a/2285561">Ryan</a>:</p>

<blockquote><p>You can&rsquo;t know that the character is un-repeated until you&rsquo;ve processed the whole string, so my suggestion would be&hellip;</p></blockquote>

<p>Keep 2 lists.</p>

<p>One stores chars that appear once, the other list stores repeated chars.</p>

<p>Code is shown below.</p>

<pre><code>def first_non_repeated_character(string):
  chars = []
  repeated = []
  for character in string:
    if character in chars:
      chars.remove(character)
      repeated.append(character)
    else:
      if not character in repeated:
        chars.append(character)
  if len(chars):
    return chars[0]
  else:
    return False
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/10/Classic-questions-to-memorize/">[Collection] Classic Questions That Needs to Be Memorized</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Question list</h2>

<p><strong>Permutation</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/22/Subsets/">Subsets</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/22/Subsets-II/">Subsets II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/14/Permutations/">Permutations</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/14/Permutations-II/">Permutations II</a></strong> &ndash; difficult</p></li>
</ol>


<p><strong>Binary Tree</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/24/Binary-Tree-Inorder-Traversal/">Binary Tree Inorder Traversal</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/03/Binary-Tree-Postorder-Traversal/">Binary Tree Postorder Traversal</a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="/blog/2014/06/10/Lowest-Common-Ancestor-Tree/">Lowest Common Ancestor Problem Version 2</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/28/Binary-Tree-Maximum-Path-Sum/">Binary Tree Maximum Path Sum</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/26/Convert-Sorted-List-to-Binary-Search-Tree/">Convert Sorted List to Binary Search Tree</a></strong></p></li>
</ol>


<p><strong>Other</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/21/Minimum-Window-Substring/">Minimum Window Substring </a></strong> &ndash; very difficult</p></li>
<li><p><strong><a href="/blog/2014/04/29/Regular-Expression-Matching/">Regular Expression Matching</a></strong> &ndash; very difficult</p></li>
<li><p><strong><a href="/blog/2014/05/15/Wildcard-Matching/">Wildcard Matching</a></strong> &ndash; difficult</p></li>
</ol>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/14">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/12">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150/'>cc150 (1)</a></li>
<li class='category'><a href='/blog/categories/collection/'>collection (6)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (20)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (12)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (152)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (65)</a></li>
<li class='category'><a href='/blog/categories/thoughts/'>thoughts (4)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/08/05/Write-a-RNG/">[Google] Write a Random Number Generator</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/05/Web-server-application-server/">[Design] Application Server vs. Web Server</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/05/Upcasting-and-Object-Slicing/">[Design] Upcasting, Downcasting and Object Slicing</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/05/Replace-Question-Mark-WIth-Number/">[Google] Replace Question Mark With Number</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/05/MapReduce-Intro/">[Design] MapReduce Intro</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
