
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="Number &amp; Bit questions Single Number
Single Number II
Single Number III
Single Number IV
Majority Number
Majority Number II
Majority Number III &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/14">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/28/NineChap-High-frequency/">[NineChap 8] High Frequency Questions</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Number &amp; Bit questions</h2>

<ol>
<li><strong><a href="/blog/2014/06/01/Single-Number/">Single Number</a></strong></li>
<li><strong><a href="/blog/2014/06/01/Single-Number-II/">Single Number II</a></strong></li>
<li><strong><a href="/blog/2014/06/28/Single-Number-III/">Single Number III</a></strong></li>
<li><strong><a href="/blog/2014/06/28/Single-Number-IV/">Single Number IV</a></strong></li>
<li><strong><a href="/blog/2014/06/28/Majority-Number/">Majority Number</a></strong></li>
<li><strong><a href="/blog/2014/06/28/Majority-Number-II/">Majority Number II</a></strong></li>
<li><strong><a href="/blog/2014/06/28/Majority-Number-III/">Majority Number III</a></strong></li>
</ol>


<h2>Subarray questions</h2>

<p>Always using the idea of 前缀和.</p>

<ol>
<li><strong><a href="/blog/2014/05/28/Best-Time-to-Buy-and-Sell-Stock/">Best Time to Buy and Sell Stock</a></strong> &ndash; 贪心法</li>
<li><strong><a href="/blog/2014/05/28/Best-Time-to-Buy-and-Sell-Stock-II/">Best Time to Buy and Sell Stock II</a></strong></li>
<li><strong><a href="/blog/2014/05/28/Best-Time-to-Buy-and-Sell-Stock-III/">Best Time to Buy and Sell Stock III</a></strong></li>
<li><strong><a href="/blog/2014/05/20/Maximum-Subarray/">Maximum Subarray</a></strong></li>
<li><strong><a href="/blog/2014/06/28/Minimum-subarray/">Minimum Subarray </a></strong></li>
<li><strong><a href="/blog/2014/06/28/Maximum-subarray-II/">Maximum Subarray II</a></strong></li>
<li><strong><a href="/blog/2014/07/04/Subarray-with-0-Sum/">Subarray with 0 Sum</a></strong></li>
<li><strong><a href="/blog/2014/07/04/Subarray-with-Particular-Sum/">Subarray with Particular Sum</a></strong></li>
<li><strong><a href="/blog/2014/07/04/Subarray-with-Sum-Closest/">Subarray with Sum Closest</a></strong></li>
</ol>


<h2>N Sum questions</h2>

<ol>
<li><strong><a href="/blog/2014/04/26/two-sum/">Two Sum</a></strong> &ndash; difficult</li>
<li><strong><a href="/blog/2014/05/02/3Sum/">3 Sum</a></strong></li>
<li><strong><a href="/blog/2014/05/02/3Sum-Closest/">3 Sum Closest</a></strong></li>
<li><strong><a href="/blog/2014/05/03/4Sum/">4 Sum</a></strong> &ndash; doing a O(n<sup>3</sup>) solution is good enough.</li>
<li><strong>k sum questions</strong> are basically solved with O(n<sup>k-1</sup>) time. Faster solution is available but too complex.</li>
</ol>


<h2>L 家最爱</h2>

<ol>
<li><strong><a href="/blog/2014/05/15/PowXN/">Pow(x,n)</a></strong></li>
<li><strong><a href="/blog/2014/05/21/SqrtX/">Sqrt(x)</a></strong></li>
<li><strong><a href="/blog/2014/07/02/Trailing-Zero-of-Factorial/">Trailing Zeros of Factorial</a></strong></li>
<li><strong><a href="/blog/2014/07/04/Check-Power-of-2/">Check Power of 2</a></strong></li>
</ol>


<h2>Additional questions</h2>

<ol>
<li><strong><a href="/blog/2014/06/28/Partition-array/">Partition Array</a></strong></li>
<li><strong><a href="/blog/2014/05/21/Sort-Colors/">Sort Color</a></strong></li>
</ol>


<h2>Code</h2>

<h4>Number questions</h4>

<p><strong>Single Number</strong></p>

<pre><code>public int singleNumber(int[] A) {
    int x = 0;
    for (Integer a: A) {
        x = x ^ a;
    }
    return x;
}
</code></pre>

<p><strong>Single Number II</strong></p>

<p>Last time, I used an array of size 32 to store count, but it&rsquo;s actually not necessary.</p>

<pre><code>public int singleNumber(int[] A) {
    int ans = 0;
    for (int i = 0; i &lt; 32; i++) {
        int count = 0;
        for (Integer a: A) {
            count += ((a &gt;&gt; i) &amp; 1);
        }
        ans |= (count % 3) &lt;&lt; i;
    }
    return ans;
}
</code></pre>

<h4>Subarray questions</h4>

<p><strong>Best Time to Buy and Sell Stock</strong></p>

<pre><code>public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int min = prices[0];
    int profit = 0;
    for (Integer p: prices) {
        min = Math.min(min, p);
        profit = Math.max(profit, p - min);
    }
    return profit;
}
</code></pre>

<p><strong>Best Time to Buy and Sell Stock II</strong></p>

<pre><code>public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int pre = prices[0];
    int profit = 0;
    for (Integer p: prices) {
        if (p &gt; pre) {
            profit += p - pre;
        }
        pre = p;
    }
    return profit;
}
</code></pre>

<p><strong>Best Time to Buy and Sell Stock III</strong></p>

<p>It&rsquo;s important to note the 2nd last line of the code, where we consider the corner case of doing only 1 transaction.</p>

<p>It&rsquo;s always best to list a simple test case and walk it thru before submitting the code.</p>

<pre><code>public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int len = prices.length;
    int[] dpLeft = new int[len];
    int leftMin = prices[0];
    for (int i = 1; i &lt; len; i++) {
        dpLeft[i] = Math.max(dpLeft[i - 1], prices[i] - leftMin);
        leftMin = Math.min(leftMin, prices[i]);
    }
    int[] dpRight = new int[len];
    int rightMax = prices[len - 1];
    for (int i = len - 2; i &gt;= 0; i--) {
        dpRight[i] = Math.max(dpRight[i + 1], rightMax - prices[i]);
        rightMax = Math.max(rightMax, prices[i]);
    }
    // now iterate the 2 DP array and find out the largest possible profit
    int profit = 0;
    for (int i = 0; i &lt; len - 1; i++) {
        profit = Math.max(profit, dpLeft[i] + dpRight[i + 1]);
    }
    int oneTransaction = Math.max(dpLeft[len - 1], dpRight[0]);
    return Math.max(profit, oneTransaction);
}
</code></pre>

<p><strong>Maximum Subarray</strong></p>

<pre><code>public int maxSubArray(int[] A) {
    if (A == null || A.length == 0) {
        return 0;
    }
    int max = Integer.MIN_VALUE;
    int pre = 0;
    // the largest sum ending at previous position in the array
    for (Integer a: A) {
        max = Math.max(max, pre + a);
        pre = Math.max(0, pre + a);
    }
    return max;
}
</code></pre>

<h4>3Sum questions</h4>

<p><strong>Two Sum</strong></p>

<p>This solution is O(nlgn) time.</p>

<p>Alternatively, we can use HashMap to solve this problem with O(n) time.</p>

<pre><code>public int[] twoSum(int[] numbers, int target) {
    // write your code here
    int[] ans = new int[2];
    if (numbers == null || numbers.length == 0) {
        return ans;
    }
    int len = numbers.length;
    Pair[] pairs = new Pair[len];
    for (int i = 0; i &lt; len; i++) {
        pairs[i] = new Pair(numbers[i], i + 1);
    }
    Arrays.sort(pairs);
    int left = 0;
    int right = len - 1;
    while (left &lt; right) {
        if (pairs[left].num + pairs[right].num == target) {
            ans[0] = pairs[left].index;
            ans[1] = pairs[right].index;
            Arrays.sort(ans);
            break;
        } else if (pairs[left].num + pairs[right].num &gt; target) {
            right--;
        } else {
            left++;
        }
    }
    return ans;
}

class Pair implements Comparable&lt;Pair&gt; {
    int num;
    int index;

    public Pair(int a, int b) {
        num = a;
        index = b;
    }

    public int compareTo(Pair another) {
        return this.num - another.num;
    }
}
</code></pre>

<p><strong>3 Sum</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(int[] numbers) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (numbers == null || numbers.length == 0) {
        return ans;
    }
    Arrays.sort(numbers);
    int len = numbers.length;
    for (int i = 0; i &lt; len; i++) {
        if (i &gt; 0 &amp;&amp; numbers[i - 1] == numbers[i]) {
            continue;
        }
        int left = i + 1;
        int right = len - 1;
        // find 2 numbers that sums to - number[i]
        while (left &lt; right) {
            int diff = numbers[left] + numbers[right] + numbers[i];
            if (diff == 0) {
                ArrayList&lt;Integer&gt; triplet = new ArrayList&lt;Integer&gt;();
                triplet.add(numbers[i]);
                triplet.add(numbers[left]);
                triplet.add(numbers[right]);
                ans.add(triplet);
            }
            if (diff &lt;= 0) {
                left++;
                while (left &lt; len &amp;&amp; numbers[left - 1] == numbers[left]) {
                    left++;
                }
            }
            if (diff &gt;= 0) {
                right--;
                while (right &gt;= 0 &amp;&amp; numbers[right + 1] == numbers[right]) {
                    right--;
                }
            }
        }
    }
    return ans;
}
</code></pre>

<p><strong>3 Sum Closest</strong></p>

<pre><code>public int threeSumClosest(int[] numbers, int target) {
    if (numbers == null || numbers.length == 0) {
        return 0;
    }
    Arrays.sort(numbers);
    int sum = 0;
    int diff = Integer.MAX_VALUE;
    int len = numbers.length;
    for (int i = 0; i &lt; len; i++) {
        int left = i + 1;
        int right = len - 1;
        while (left &lt; right) {
            int triple = numbers[left] + numbers[right] + numbers[i];
            if (triple == target) {
                return target;
            } else if (triple &lt; target) {
                left++;
            } else {
                right--;
            }
            if (Math.abs(target - triple) &lt; diff) {
                diff = Math.abs(target - triple);
                sum = triple;
            }
        }
    }
    return sum;
}
</code></pre>

<p><strong>4 Sum</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; fourSum(int[] numbers, int target) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (numbers == null || numbers.length == 0) {
        return ans;
    }
    Arrays.sort(numbers);
    int len = numbers.length;
    for (int i = 0; i &lt; len - 3; i++) {
        if (i &gt; 0 &amp;&amp; numbers[i - 1] == numbers[i]) {
            continue;
        }
        for (int j = i + 1; j &lt; len - 2; j++) {
            if (j &gt; i + 1 &amp;&amp; numbers[j - 1] == numbers[j]) {
                continue;
            }
            int left = j + 1;
            int right = len - 1;
            while (left &lt; right) {
                int diff = numbers[left] + numbers[right] + numbers[i] + numbers[j] - target;
                if (diff == 0) {
                    ArrayList&lt;Integer&gt; triplet = new ArrayList&lt;Integer&gt;();
                    triplet.add(numbers[i]);
                    triplet.add(numbers[j]);
                    triplet.add(numbers[left]);
                    triplet.add(numbers[right]);
                    ans.add(triplet);
                }
                if (diff &lt;= 0) {
                    left++;
                    while (left &lt; len &amp;&amp; numbers[left - 1] == numbers[left]) {
                        left++;
                    }
                }
                if (diff &gt;= 0) {
                    right--;
                    while (right &gt;= 0 &amp;&amp; numbers[right + 1] == numbers[right]) {
                        right--;
                    }
                }
            }
        }
    }
    return ans;
}
</code></pre>

<h4>L 家最爱</h4>

<p><strong>Pow(x,n)</strong></p>

<p>It&rsquo;s important to note that in Line 16, wrting &lsquo;while (pow * 2 &lt;= y)&rsquo; would not work (because of overflow). It took me a long time to find this bug.</p>

<pre><code>public double pow(double x, int n) {
    if (n &lt; 0) {
        return 1.0 / helper (x, 0 - n);
    } else {
        return helper(x, n);
    }
}

private double helper(double x, int y) {
    if (y == 0) {
        return 1.0;
    }
    int pow = 1;
    double num = x;
    while (pow &lt;= y / 2) {
        num *= num;
        pow &lt;&lt;= 1;
    }
    return num * helper(x, y - pow);
}
</code></pre>

<p><strong>Sqrt(x)</strong></p>

<p>Note that in Line 8, we must declare left and right as &lsquo;long&rsquo;, not &lsquo;int&rsquo;, otherwise there will be overflow problems. It took me a long time to find this bug.</p>

<pre><code>public int sqrt(int x) {
    if (x &lt; 0) {
        return -1;
    } else if (x &lt; 2) {
        return x;
    }
    long left = 1;
    long right = x;
    while (left + 1 &lt; right) {
        long mid = left + (right - left) / 2;
        if (mid * mid &lt; x) {
            left = mid;
        } else if (mid * mid &gt; x) {
            right = mid;
        } else {
            return (int) mid;
        }
    }
    return (int) left;
}
</code></pre>

<h4>Additional</h4>

<p><strong>Sort Color</strong></p>

<pre><code>public void sortColors(int[] A) {
    if (A == null || A.length == 0) {
        return;
    }
    int len = A.length;
    partition(A, 0, len - 1, 0);
    int p = 0;
    while (p &lt; len &amp;&amp; A[p] == 0) {
        p++;
    }
    partition(A, p, len - 1, 1);
}

private void partition(int[] A, int start, int end, int target) {
    // find the target and put it on the left side of the array
    while (start &lt; end) {
        while (start &lt; A.length &amp;&amp; A[start] == target) {
            start++;
        }
        while (end &gt;= 0 &amp;&amp; A[end] != target) {
            end--;
        }
        if (start &gt; end) {
            break;
        } else {
            int temp = A[start];
            A[start] = A[end];
            A[end] = temp;
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/28/NineChap-Data-structure/">[NineChap 7] Data Structure</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Data Structure</h2>

<p>Data structure is a way to manage data. It provides some methods to handle data stream. For example, DB is a DS.</p>

<h3>Stack and Queue</h3>

<ol>
<li><p><strong><a href="/blog/2014/07/01/Min-Stack/">Min-stack</a></strong></p></li>
<li><p><strong><a href="/blog/2014/07/01/Implement-queue-with-stack/">Implement a queue by two stacks</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/23/Largest-Rectangle-in-Histogram/">Largest Rectangle in histogram</a></strong></p></li>
</ol>


<h3>Hash</h3>

<h4>Hash function</h4>

<ol>
<li>MD5</li>
<li>Magic number 33 (<strong>PHP hash function <a href="http://events.ccc.de/congress/2011/Fahrplan/attachments/2007_28C3_Effective_DoS_on_web_application_platforms.pdf">DJBX33A</a></strong>)</li>
</ol>


<p>Magic Number:</p>

<pre><code>int hashfunc(String key) {
    int sum = 0;
    for (int i = 0; i &lt; key.length(); i++) {
        sum = sum * 33 + (int)(key.charAt(i));
        sum = sum % HASH_TABLE_SIZE;
    }
    return sum
}
</code></pre>

<h4>Collision</h4>

<ol>
<li><p><strong>Close hashing (also called Open addressing)</strong></p>

<p> Resolves conflict by probing, or searching through alternate locations in the array</p>

<p> Suck scheme may cause the lookup cost to skyrocket. Not good to use.</p></li>
<li><p><strong>Open hashing</strong></p>

<p> Keys stored in linked lists attached to cells of the hash table.</p>

<p> Practically, hash size set around 10 times the size of data</p>

<p> Used by Java and most other languages.</p></li>
</ol>


<h4>Rehashing</h4>

<ol>
<li><p>Memcached is a general-purpose distributed memory caching system. One of its bottleneck is rehashing, which locks down the entire hash.</p></li>
<li><p>Dynamic resizing (normally size * 2) and copy all elements into the new hash.</p></li>
<li><p>Extremely slow process, we should try to avoid it by setting a large enough initial size.</p></li>
</ol>


<h4>Hash questions:</h4>

<ol>
<li><p><strong><a href="/blog/2014/07/01/Implement-Hashmap/">Implement a hashmap</a></strong></p></li>
<li><p><strong><a href="/blog/2014/07/01/Hashmap-Hashtable-Hashset/">HashMap vs Hashtable vs HashSet</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/03/LRU-Cache/">LRU Cache</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/29/Longest-Consecutive-Sequence/">Longest consecutive sequence</a></strong></p></li>
</ol>


<h3>Heap</h3>

<ol>
<li>Child is always larger than parent</li>
<li>Heap is not a sorted structure, but it&rsquo;s partially ordered</li>
<li>Heap is always balanced</li>
</ol>


<p>Heap is better than array because average of 3 operations is O(logn), but array is O(n).</p>

<blockquote><p>Add O(log N)</p>

<p>Remove O(log N)</p>

<p>Min/Max O(1)</p></blockquote>

<h4>Heap implementation:</h4>

<ol>
<li><p>Low Level: dynamic array, not list</p></li>
<li><p>Internal Method: Shiftup, Shiftdown operations</p></li>
<li><p>A heap is a complete binary tree (最优二叉树) <strong>represented by an array</strong></p></li>
<li><p>When removing element from heap, we actually uses HashMap to find that element.</p></li>
</ol>


<blockquote><p>Heaps are usually implemented in an array, and do not require pointers between elements.</p>

<p>Full and almost full binary heaps may be represented in a very space-efficient way using an array alone. The first element will contain the root. The next two elements of the array contain its children. The next four contain the four children of the two child nodes, etc.</p>

<p>Thus the children of the node at position n would be at positions 2n+1 and 2n+2.</p></blockquote>

<p>So to summarize:</p>

<ol>
<li>elems[1] &ndash; root, also the minimum elem in elems.</li>
<li>elems[i]: left child is elems[i<em>2], right child is elems[i</em>2+1]</li>
</ol>


<p>Implementation code:</p>

<pre><code>Add:
    Push back to elems; size ++; Siftup;
Remove:
    Replace the elem to be removed with the last elem; 
    size --; 
    Siftup and Siftdown.
</code></pre>

<h4>Heap questions:</h4>

<ol>
<li><p><strong><a href="/blog/2014/07/01/Median-in-stream-of-integers/">Median in a stream of integers</a></strong></p></li>
<li><p><strong><a href="/blog/2014/07/01/The-Skyline-Problem/">The Skyline Problem</a></strong></p></li>
</ol>


<h3>Interval Tree</h3>

<p>Easily find the max/min value in an interval. 2 example questions are:</p>

<ol>
<li>Find min/max/sum in an interval</li>
<li>最长的连续1</li>
</ol>


<h2>Code</h2>

<p><strong>Largest Rectangle in histogram</strong></p>

<pre><code>public int largestRectangleArea(int[] height) {
    if (height == null || height.length == 0) {
        return 0;
    }
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    stack.add(0);
    int len = height.length;
    int area = 0;
    for (int i = 1; i &lt;= len; i++) {
        int h = i == len ? 0 : height[i];
        // pop a element and calculate its max area
        // pop until the top element is smaller than h, then push h
        while (!stack.isEmpty() &amp;&amp; h &lt; height[stack.peek()]) {
            int pos = stack.pop();
            int width = stack.isEmpty() ? i : i - stack.peek() - 1;
            area = Math.max(area, height[pos] * width);
        }
        stack.push(i);
    }
    return area;
}
</code></pre>

<p><strong>LRU Cache</strong></p>

<p>I posted code in the new post.</p>

<p><strong>Longest consecutive sequence</strong></p>

<pre><code>public int longestConsecutive(int[] num) {
    if (num == null || num.length == 0) {
        return 0;
    }
    HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
    for (Integer i: num) {
        set.add(i);
    }
    int longest = 0;
    for (Integer i: num) {
        if (!set.contains(i)) {
            continue;
        }
        int left = i - 1;
        while (set.contains(left)) {
            set.remove(left--);
        }
        int right = i + 1;
        while (set.contains(right)) {
            set.remove(right++);
        }
        longest = Math.max(longest, right - left - 1);
        set.remove(i);
    }
    return longest;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/28/Minimum-subarray/">[LintCode] Minimum Subarray</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.lintcode.com/en/problem/minimum-subarray/">link</a></p>

<blockquote><p>Given an array of integers, find the subarray with smallest sum. Return the sum of the subarray.</p>

<p>Note The subarray should contain at least one integer.</p>

<p>Example For [1, -1, -2, 1], return -3</p></blockquote>

<h3>Analysis</h3>

<p>Same as &ldquo;Max subarray&rdquo;.</p>

<h3>Code</h3>

<pre><code>public int minSubArray(ArrayList&lt;Integer&gt; nums) {
    // write your code
    if (nums == null || nums.size() == 0) {
        return 0;
    }
    int min = nums.get(0);
    int pre = Math.min(0, nums.get(0));
    for (int i = 1; i &lt; nums.size(); i++) {
        pre += nums.get(i);
        min = Math.min(min, pre);
        pre = Math.min(0, pre);
    }
    return min;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/28/Maximum-subarray-II/">[LintCode] Maximum Subarray II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.lintcode.com/en/problem/maximum-subarray-ii/">link</a></p>

<blockquote><p>Given an array of integers, find two non-overlapping subarrays which have the largest sum. The number in each subarray should be contiguous. Return the largest sum.</p>

<p>Note The subarray should contain at least one number</p>

<p>Example For given [1, 3, -1, 2, -1, 2], the two subarrays are [1, 3] and [2, -1, -2] or [1, 3, -1, 2] and [2], they both have the largest sum 7.</p></blockquote>

<h3>Analysis</h3>

<p><strong>This is not an easy question</strong>. I thought I have to use DP 2 times:</p>

<ol>
<li>first time, calculate max sum ending at each point.</li>
<li>second time, calculate max sum to the left/right of a point (inclusive but not necessarily ending at current point).</li>
</ol>


<p>After a second thought, <strong>the first DP path can be denoted with a single variable</strong>. So there comes the solution below.</p>

<h3>Code</h3>

<pre><code>public int maxTwoSubArrays(ArrayList&lt;Integer&gt; nums) {
    // write your code
    int len = nums.size();
    int[] dp1 = new int[len];
    int[] dp2 = new int[len];
    // dp1[k] denotes the max sum to the left of k (inclusive)
    // dp2[k] denotes the max sum to the right of k (inclusive)
    dp1[0] = nums.get(0);
    int sumSoFar = Math.max(0, nums.get(0));
    for (int i = 1; i &lt; len; i++) {
        sumSoFar += nums.get(i);
        dp1[i] = Math.max(dp1[i - 1], sumSoFar);
        sumSoFar = Math.max(0, sumSoFar);
    }
    dp2[len - 1] = nums.get(len - 1);
    sumSoFar = Math.max(0, nums.get(len - 1));
    for (int i = len - 2; i &gt;= 0; i--) {
        sumSoFar += nums.get(i);
        dp2[i] = Math.max(dp2[i + 1], sumSoFar);
        sumSoFar = Math.max(0, sumSoFar);
    }
    // now for every node, calculate leftMaxSum + rightMaxSum
    int maxSum = Integer.MIN_VALUE;
    for (int i = 0; i &lt; len - 1; i++) {
        maxSum = Math.max(maxSum, dp1[i] + dp2[i + 1]);
    }
    return maxSum;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/28/Majority-Number-III/">[LintCode] Majority Number III</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.lintcode.com/en/problem/majority-number-iii/">link</a></p>

<blockquote><p>Given an array of integers and a number k, the majority number is the number that occurs more than 1/k of the size of the array. Find it.</p>

<p>Note: There is only one majority number in the array</p>

<p>Example: For [3,1,2,3,2,3,3,4,4,4] and k = 3, return 3</p></blockquote>

<h3>Analysis</h3>

<p>Similar to &lsquo;Majority Number II&rsquo;, but a little more difficult.</p>

<p>_Instead of keeping 2 value for checking, now keep k values__. Since values are constantly checked for existance, using a HashMap looks like a great idea.</p>

<p>The idea is this.</p>

<h3>Code</h3>

<p>I did not write code for this question, because it looks too complex.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/28/Majority-Number-II/">[LintCode] Majority Number II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.lintcode.com/en/problem/majority-number-ii/">link</a></p>

<blockquote><p>Given an array of integers, the majority number is the number that occurs more than 1/3 of the size of the array. Find it.</p>

<p>Note: There is only one majority number in the array</p>

<p>Example: For [1, 2, 1, 2, 1, 3, 3] return 1</p></blockquote>

<h3>Analysis</h3>

<p>Similar to &lsquo;Majority Number&rsquo;, but a little more difficult.</p>

<p><strong>Instead of keeping 1 value for checking, now keep 2 values</strong>. If the new number is same as any of the 2 values, decrease the count. If the new number is a totally new one, decrease both. The coding is a bit difficult and lengthy.</p>

<p>Note that 2 values are found in the end, do another iteration thru the array, and find the correct result from these 2 values.</p>

<h3>Code</h3>

<pre><code>public int majorityNumber(ArrayList&lt;Integer&gt; nums) {
    // write your code
    if (nums == null || nums.size() &lt; 3) {
        return -1;
    }
    int num1 = nums.get(0);
    int p = 1;
    int len = nums.size();
    while (p &lt; len &amp;&amp; nums.get(p) == num1) {
        p++;
    }
    int num2 = nums.get(p);
    int count1 = p;
    int count2 = 1;
    for (int i = p + 1; i &lt; len; i++) {
        if (nums.get(i) == num1) {
            count1++;
        } else if (nums.get(i) == num2) {
            count2++;
        } else {
            // a totally different value
            if (count1 == 0) {
                num1 = nums.get(i);
                count1++;
            } else if (count2 == 0) {
                num2 = nums.get(i);
                count2++;
            } else {
                count1--;
                count2--;
            }
        }
    }
    if (count1 == 0 &amp;&amp; count2 == 0) {
        return -1;
    } else if (count1 == 0) {
        return num2;
    } else if (count2 == 0) {
        return num1;
    } else {
        // it's gotta be either num1 or num2
        int count = 0;
        for (Integer n: nums) {
            if (n == num1) {
                count ++;
            }
        }
        if (count &gt;= len / 3 + 1) {
            return num1;
        } else {
            return num2;
        }
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/28/Majority-Number/">[LintCode] Majority Number</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.lintcode.com/en/problem/majority-number/">link</a></p>

<blockquote><p>How to find the majority elelment in an array in O(n)?</p>

<p>Note: The majority element is the element that occurs more than half of the size of the array</p>

<p>Example: For [1, 1, 1, 1, 2, 2, 2], return 1</p></blockquote>

<h3>Analysis</h3>

<p>This question is called <strong><a href="http://www.cs.utexas.edu/~moore/best-ideas/mjrty/example.html">Moore’s Voting Algorithm</a></strong> (or Majority Vote Algorithm).</p>

<p>Psudo-code from <a href="http://www.geeksforgeeks.org/majority-element/">GFG</a>:</p>

<pre><code>findCandidate(a[], size)
1.  Initialize index and count of majority element
     maj_index = 0, count = 1
2.  Loop for i = 1 to size – 1
    (a)If a[maj_index] == a[i]
        count++
    (b)Else
        count--;
    (c)If count == 0
        maj_index = i;
        count = 1
3.  Return a[maj_index]
</code></pre>

<p>Sometimess majority element does not exist, so you might want to do another iteration to double check.</p>

<p>If the check shows invalid, then there&rsquo;s no majoirty element.</p>

<h3>Code</h3>

<pre><code>public int majorityNumber(ArrayList&lt;Integer&gt; nums) {
    // write your code
    if (nums == null || nums.size() == 0) {
        return 0;
    }
    int num = nums.get(0);
    int count = 1;
    for (int i = 1; i &lt; nums.size(); i++) {
        if (count == 0) {
            num = nums.get(i);
            count = 1;
        } else if (nums.get(i) == num) {
            count++;
        } else {
            count--;
        }
    }
    return num;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/27/Topology-sorting/">[Question] Topology Sort</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-27T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://en.wikipedia.org/wiki/Topological_sorting">link</a></p>

<blockquote><p>Topological ordering of a directed graph is a linear ordering of its vertices such that <strong>for every directed edge uv from vertex u to vertex v, u comes before v in the ordering</strong>.</p>

<p>A topological ordering is possible if and only if the graph has no directed cycles, that is, if it is a <strong>directed acyclic graph (DAG)</strong>.</p></blockquote>

<h3>Analysis</h3>

<p>Canonical application of toposort is to schedule tasks with dependency (project management etc.) It&rsquo;s also used for computing formulas, logic synthesis, order of compilation (&lsquo;make&rsquo; command) and data serialization.</p>

<p><img class="middle" src="/assets/images/topology_sort_example.png"></p>

<h3>Solution</h3>

<p>The usual algorithms have <strong>linear run-time</strong>, i.e. O(V + E).</p>

<blockquote><p>First step is to find a list of &ldquo;start nodes&rdquo; which have no incoming edges. Then insert them into a set S and delete it. At least one such node must exist in an <strong>directed acyclic graph</strong>. From a university <a href="https://courses.cs.washington.edu/courses/cse326/03wi/lectures/RaoLect20.pdf">lecture</a>.</p></blockquote>

<p>From Wiki:</p>

<pre><code>L ← Empty list that will contain the sorted elements
S ← Set of all nodes with no incoming edges
while S is non-empty do
    remove a node n from S
    add n to tail of L
    for each node m with an edge e from n to m do
        remove edge e from the graph
        if m has no other incoming edges then
            insert m into S
if graph has edges then
    return error (graph has at least one cycle)
else 
    return L (a topologically sorted order)
</code></pre>

<p>If the graph is a DAG, <strong>a solution will be contained in the list L</strong> (the solution is not necessarily unique). Otherwise, the graph must have at least one cycle and therefore <strong>a topological sorting is impossible</strong>.</p>

<h3>Code</h3>

<p>The solution comes from <a href="http://codereview.stackexchange.com/questions/44689/topological-sort-in-java">here</a>.</p>

<p><img class="middle" src="/assets/images/topology_sort.png" width="250" height="250"></p>

<pre><code>public class Graph {
    private int vertices;
    private Set&lt;Node&gt; nodes = new HashSet&lt;Node&gt;();

    public Graph(int vertices) {
        this.vertices = vertices;
    }

    public void addVertex(Node node) {
        this.nodes.add(node);
    }

    public Set&lt;Node&gt; topologicalSort() {
        Queue&lt;Node&gt; q = new LinkedList&lt;Node&gt;();
        Set&lt;Node&gt; topoSort = new LinkedHashSet&lt;Node&gt;();
        int vertexProcessesCtr = 0;
        for (Node m : this.nodes) {
            vertexProcessesCtr = addToQueue(m, topoSort, vertexProcessesCtr, q);
        }
        while (!q.isEmpty()) {
            Node m = q.poll();
            for (Node child : m.getAdjacenctNode()) {
                int indeq = child.getInDegree() - 1;
                child.setInDegree(indeq);
                vertexProcessesCtr = addToQueue(child, topoSort,
                        vertexProcessesCtr, q);
            }
        }
        if (vertexProcessesCtr &gt; this.vertices) {
            System.out.println();
        }
        return topoSort;
    }

    private int addToQueue(Node node, Set&lt;Node&gt; topoSort, int vertexProcess,
            Queue&lt;Node&gt; q) {
        if (node.getInDegree() == 0) {
            q.add(node);
            topoSort.add(node);
            return vertexProcess + 1;
        }
        return vertexProcess;
    }

    public static void main(String[] args) {
        Graph g = new Graph(8);

        Node TEN = new Node("10");
        Node ELEVEN = new Node("11");
        Node TWO = new Node("2");
        Node THREE = new Node("3");
        Node FIVE = new Node("5");
        Node SEVEN = new Node("7");
        Node EIGHT = new Node("8");
        Node NINE = new Node("9");

        SEVEN.AdjacenctNode.add(ELEVEN);
        ELEVEN.inDegree++;
        SEVEN.AdjacenctNode.add(EIGHT);
        EIGHT.inDegree++;
        FIVE.AdjacenctNode.add(ELEVEN);
        ELEVEN.inDegree++;
        THREE.AdjacenctNode.add(EIGHT);
        EIGHT.inDegree++;
        THREE.AdjacenctNode.add(TEN);
        TEN.inDegree++;
        ELEVEN.AdjacenctNode.add(TEN);
        TEN.inDegree++;
        ELEVEN.AdjacenctNode.add(TWO);
        TWO.inDegree++;
        ELEVEN.AdjacenctNode.add(NINE);
        NINE.inDegree++;
        EIGHT.AdjacenctNode.add(NINE);
        NINE.inDegree++;

        g.nodes.add(TWO);
        g.nodes.add(THREE);
        g.nodes.add(FIVE);
        g.nodes.add(SEVEN);
        g.nodes.add(EIGHT);
        g.nodes.add(NINE);

        System.out.println("Now calling the topologial sorts");
        Set&lt;Node&gt; result = g.topologicalSort();
        for (Node node : result) {
            System.out.println(node.data + " ");
        }
    }
}

class Node {
    public String data;
    public int dist;
    public int inDegree;
    LinkedList&lt;Node&gt; AdjacenctNode = new LinkedList&lt;Node&gt;();

    public void addAdjNode(final Node Child) {
        AdjacenctNode.add(Child);
        Child.inDegree++;
    }

    public Node(String data) {
        super();
        this.data = data;
    }

    public int getInDegree() {
        return inDegree;
    }

    public void setInDegree(int inDegree) {
        this.inDegree = inDegree;
    }

    public LinkedList&lt;Node&gt; getAdjacenctNode() {
        return AdjacenctNode;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/27/Previous-Permutation/">[LintCode] Previous Permutation</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-27T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.lintcode.com/en/problem/previous-permuation/">link</a></p>

<div style="min-height:100px">
<p>Given a list of integers, which denote a permutation.</p>

<p>Find the previous permutation in ascending order.</p>
    
<div class="m-t-lg m-b-lg">
      <b>Note</b>
      <div><p>The list may contains duplicate integers.</p>
      </div>
</div>
    
<div class="m-t-lg m-b-lg">
      <b>Example</b>
      <div><p>For <strong><span style="color:#B22222;">[1,3,2,3]</span></strong>, the previous permutation is <span style="color:#B22222;"><strong>[1,2,3,3]</strong></span></p>

<p>For <span style="color:#B22222;"><strong>[1,2,3,4]</strong></span>, the previous permutation is <span style="color:#B22222;"><strong>[4,3,2,1]</strong></span></p>
    </div>
</div>
</div>


<h3>Analysis</h3>

<p>This is almost the same question as &ldquo;Next Permutation&rdquo;.</p>

<ol>
<li>Find</li>
<li>Swap</li>
<li>Replace</li>
</ol>


<h3>Code</h3>

<pre><code>public ArrayList&lt;Integer&gt; previousPermuation(ArrayList&lt;Integer&gt; nums) {
    // write your code
    if (nums == null || nums.size() == 0) {
        return null;
    }
    int len = nums.size();
    int p = len - 2;
    // 1. find 1st increasing position from the back
    while (p &gt;= 0 &amp;&amp; nums.get(p) &lt;= nums.get(p + 1)) {
        p--;
    }
    // 2. swap p with the first smaller value from the back
    if (p != -1) {
        int q = len - 1;
        while (nums.get(q) &gt;= nums.get(p)) {
            q--;
        }
        swap(nums, p, q);
    }
    // swap array in range of (p+1, end)
    int left = p + 1;
    int right = len - 1;
    while (left &lt; right) {
        swap(nums, left++, right--);
    }
    return nums;
}

private void swap(ArrayList&lt;Integer&gt; num, int p, int q) {
    int temp = num.get(p);
    num.set(p, num.get(q));
    num.set(q, temp);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/26/NineChap-Graph/">[NineChap 6] Graph and Search</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-26T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Graph</h2>

<p>For graph, there are only 2 high-frequency questions, which is &lsquo;clone graph&rsquo; and &lsquo;topology sorting&rsquo;.</p>

<h3>Question list</h3>

<ol>
<li><p><strong><a href="/blog/2014/05/30/Clone-Graph/">Clone Graph</a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="/blog/2014/06/27/Topology-sorting/">Topology Sorting</a></strong></p></li>
</ol>


<h2>Search</h2>

<p>Search have either DFS or BFS.</p>

<p>First, we will cover permutations and combinations using DFS. In this section we solve the famous N-queens question.</p>

<p>Then, there&rsquo;s a few BFS questions. Graph traversal is BFS, and Word ladder is also a classic BFS question.</p>

<h3>Question list</h3>

<ol>
<li><p><strong><a href="/blog/2014/05/22/Subsets/">Subsets</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/22/Subsets-II/">Subsets II</a></strong></p>

<p> difficult</p></li>
<li><p><strong><a href="/blog/2014/05/14/Permutations/">Permutations</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/14/Permutations-II/">Permutations II</a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="/blog/2014/05/16/N-Queens/">N-Queens</a></strong></p>

<p> how to use hashmap (and some space) to make it faster? 3 hashmaps to store the row, the (x,y) diff and sum. This will make isValid() method O(1).</p></li>
<li><p><strong><a href="/blog/2014/05/16/N-Queens-II/">N-Queens II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/12/Next-Permutation/">Next Permutation</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/27/Previous-Permutation/">Previous Permutation</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/29/Palindrome-Partitioning/">Palindrome Partitioning</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/30/Palindrome-Partitioning-II/">Palindrome Partitioning II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/13/Combination-Sum/">Combination Sum</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/13/Combination-Sum/">Combination Sum II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/29/Word-Ladder/">Word Ladder</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/30/Word-Ladder-II/">Word Ladder II</a></strong></p></li>
</ol>


<h3>Additional questions</h3>

<ol>
<li><p><strong><a href="/blog/2014/05/24/Restore-IP-Addresses/">Restore IP Addresses</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/22/Combinations/">Combinations</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/02/Letter-Combinations-of-a-Phone-Number/">Letter Combinations of a Phone Number</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/19/Permutation-Sequence/">Permutation Sequence</a></strong></p></li>
</ol>


<h2>Code</h2>

<h3>Graph</h3>

<p><strong>Clone Graph</strong></p>

<pre><code>public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if (node == null) return null;
    HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = 
            new HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt;();
    Queue&lt;UndirectedGraphNode&gt; queue = new LinkedList&lt;UndirectedGraphNode&gt;();
    map.put(node, new UndirectedGraphNode(node.label));
    queue.add(node);
    while (!queue.isEmpty()) {
        UndirectedGraphNode cur = queue.remove();
        UndirectedGraphNode copy = map.get(cur);
        // here the 'copy' must exist. why? because all neighbors 
        // has been added to the map when they're pushed to queue.
        // so 'cur' must have a corresponding copy in the hashmap. 
        for (UndirectedGraphNode neib: cur.neighbors) {
            if (!map.containsKey(neib)) {
                queue.add(neib);
                map.put(neib, new UndirectedGraphNode(neib.label));
            }
            copy.neighbors.add(map.get(neib));
        }
    }
    return map.get(node);
}
</code></pre>

<p><strong>Topology Sorting</strong></p>

<p>A new post is written for it.</p>

<h3>Search</h3>

<p><strong>Subsets</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; subsets(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (num == null || num.length == 0) {
        return ans;
    }
    Arrays.sort(num);
    helper(ans, new LinkedList&lt;Integer&gt;(), num, 0);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num, int pos) {
    ans.add(new LinkedList&lt;Integer&gt;(path));
    for (int i = pos; i &lt; num.length; i++) {
        path.add(num[i]);
        helper(ans, path, num, i + 1);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Subsets II</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (num == null || num.length == 0) {
        return ans;
    }
    Arrays.sort(num);
    helper(ans, new LinkedList&lt;Integer&gt;(), num, 0);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num, int pos) {
    ans.add(new LinkedList&lt;Integer&gt;(path));
    for (int i = pos; i &lt; num.length; i++) {
        if (i &gt; pos &amp;&amp; num[i - 1] == num[i]) {
            continue;
        }
        path.add(num[i]);
        helper(ans, path, num, i + 1);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Permutations</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (num == null || num.length == 0) {
        return ans;
    }
    helper(ans, new LinkedList&lt;Integer&gt;(), num);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num){
    if (path.size() == num.length) {
        ans.add(new LinkedList&lt;Integer&gt;(path));
    }
    for (int i = 0; i &lt; num.length; i++) {
        if (path.contains(num[i])) {
            continue;
        }
        path.add(num[i]);
        helper(ans, path, num);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Permutations II</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (num == null || num.length == 0) {
        return ans;
    }
    Arrays.sort(num);
    helper(ans, new LinkedList&lt;Integer&gt;(), num, new int[num.length]);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num, int[] visited){
    if (path.size() == num.length) {
        ans.add(new LinkedList&lt;Integer&gt;(path));
        return;
    }
    for (int i = 0; i &lt; num.length; i++) {
        if (visited[i] == 1) {
            continue;
        }
        if (i &gt; 0 &amp;&amp; visited[i - 1] == 1 &amp;&amp; visited[i] == 0 &amp;&amp; num[i - 1] == num[i]) {
            // if current number is same as previous, then don't visit current
            continue;
        }
        path.add(num[i]);
        visited[i] = 1;

        helper(ans, path, num, visited);

        path.remove(path.size() - 1);
        visited[i] = 0;
    }
}
</code></pre>

<p><strong>N-Queens</strong></p>

<p>一次通关！高兴。</p>

<pre><code>public List&lt;String[]&gt; solveNQueens(int n) {
    List&lt;String[]&gt; ans = new LinkedList&lt;String[]&gt;();
    if (n &lt;= 0) {
        return ans;
    }
    helper(ans, new int[n], n, 0);
    return ans;
}

private void helper(List&lt;String[]&gt; ans, int[] path, int n, int pos) {
    if (pos &gt;= n) {
        ans.add(convert(path, n));
        return;
    }
    for (int i = 0; i &lt; n; i++) {
        path[pos] = i;
        if (!isValid(path, pos)) {
            continue;
        }
        helper(ans, path, n, pos + 1);
    }
}

private String[] convert(int[] path, int n) {
    String[] ans = new String[n];
    for (int j = 0; j &lt; n; j++) {
        ans[j] = "";
        for (int i = 0; i &lt; n; i++) {
            ans[j] += (j == path[i]) ? 'Q' : '.';
        }
    }
    return ans;
}

private boolean isValid(int[] path, int pos) {
    for (int i = 0; i &lt; pos; i++) {
        // check path[i] and path[pos]
        if (path[i] == path[pos]) {
            return false;
        }
        if (path[i] - path[pos] == pos - i) {
            return false;
        }
        if (path[pos] - path[i] == pos - i) {
            return false;
        }
    }
    return true;
}
</code></pre>

<p><strong>N-Queens II</strong></p>

<pre><code>int total;

public int totalNQueens(int n) {
    if (n &lt;= 0) {
        return 0;
    }
    helper(new int[n], n, 0);
    return total;
}

private void helper(int[] path, int n, int pos) {
    if (pos &gt;= n) {
        total++;
        return;
    }
    for (int i = 0; i &lt; n; i++) {
        path[pos] = i;
        if (!isValid(path, pos)) {
            continue;
        }
        helper(path, n, pos + 1);
    }
}

private boolean isValid(int[] path, int pos) {
    for (int i = 0; i &lt; pos; i++) {
        // check path[i] and path[pos]
        if (path[i] == path[pos]) {
            return false;
        }
        if (path[i] - path[pos] == pos - i) {
            return false;
        }
        if (path[pos] - path[i] == pos - i) {
            return false;
        }
    }
    return true;
}
</code></pre>

<p><strong>Next Permutation</strong></p>

<pre><code>public void nextPermutation(int[] num) {
    if (num == null || num.length &lt;= 1) {
        return;
    }
    int len = num.length;
    int p = len - 2;
    while (p &gt;= 0 &amp;&amp; num[p] &gt;= num[p + 1]) {
        p--;
    }
    if (p &lt; 0) {
        Arrays.sort(num);
    } else {
        int k = len - 1;
        while (k &gt;= 0 &amp;&amp; num[k] &lt;= num[p]) {
            k--;
        }
        swap(num, p, k);
        reverse(num, p + 1, len - 1);
    }
}

private void swap(int[] num, int p, int k) {
    num[p] = num[p] + num[k];
    num[k] = num[p] - num[k];
    num[p] = num[p] - num[k];
}

private void reverse(int[] num, int s, int d) {
    while (s &lt; d) {
        swap(num, s++, d--);
    }
}
</code></pre>

<p><strong>Previous Permutation</strong></p>

<p>Plz look at the new post.</p>

<p><strong>Palindrome Partitioning</strong></p>

<p>一次通关 again！very 高兴。</p>

<pre><code>public ArrayList&lt;ArrayList&lt;String&gt;&gt; partition(String s) {
    ArrayList&lt;ArrayList&lt;String&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;String&gt;&gt;();
    if (s == null || s.length() == 0) {
        return ans;
    }
    boolean[][] map = palinMap(s);
    helper(ans, new ArrayList&lt;String&gt;(), s, map, 0);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;String&gt;&gt; ans, ArrayList&lt;String&gt; path, String s, boolean[][] map, int pos) {
    int len = s.length();
    if (pos == len) {
        ans.add(new ArrayList&lt;String&gt;(path));
        return;
    }
    for (int i = pos; i &lt; len; i++) {
        if (!map[pos][i]) {
            continue;
        }
        path.add(s.substring(pos, i + 1));
        helper(ans, path, s, map, i + 1);
        path.remove(path.size() - 1);
    }
}

private boolean[][] palinMap(String s) {
    int len = s.length();
    boolean[][] map = new boolean[len][len];
    for (int i = len - 1; i &gt;= 0; i--) {
        for (int j = 0; j &lt; len; j++) {
            if (i &gt; j) {
                continue;
            } else if (i == j) {
                map[i][j] = true;
            } else if (j - i == 1) {
                map[i][j] = s.charAt(i) == s.charAt(j);
            } else {
                map[i][j] = map[i + 1][j - 1] &amp; 
                        s.charAt(i) == s.charAt(j);
            }
        }
    }
    return map;
}
</code></pre>

<p><strong>Palindrome Partitioning II</strong></p>

<p>This is DP, not Graph &amp; Search.</p>

<p><strong>Combination Sum</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (candidates == null || candidates.length == 0) {
        return ans;
    }
    Arrays.sort(candidates);
    helper(ans, new ArrayList&lt;Integer&gt;(), candidates, target, 0);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans, ArrayList&lt;Integer&gt; path, 
        int[] candidates, int target, int pos) {
    if (target == 0) {
        ans.add(new ArrayList&lt;Integer&gt;(path));
        return;
    } else if (target &lt; 0) {
        return;
    }
    for (int i = pos; i &lt; candidates.length; i++) {
        if (target &lt; candidates[i]) {
            continue;
        }
        path.add(candidates[i]);
        helper(ans, path, candidates, target - candidates[i], i);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Combination Sum II</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (candidates == null || candidates.length == 0) {
        return ans;
    }
    Arrays.sort(candidates);
    helper(ans, new ArrayList&lt;Integer&gt;(), candidates, target, 0);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans, ArrayList&lt;Integer&gt; path, 
        int[] candidates, int target, int pos) {
    if (target == 0) {
        ans.add(new ArrayList&lt;Integer&gt;(path));
        return;
    } else if (target &lt; 0) {
        return;
    }
    for (int i = pos; i &lt; candidates.length; i++) {
        if (target &lt; candidates[i]) {
            continue;
        }
        if (i &gt; pos &amp;&amp; candidates[i - 1] == candidates[i]) {
            continue;
        }
        path.add(candidates[i]);
        helper(ans, path, candidates, target - candidates[i], i + 1);
        path.remove(path.size() - 1);
    }
}
</code></pre>

<p><strong>Word Ladder</strong></p>

<p>Note that this is a <strong>BFS question, not DFS</strong>. I made it wrong and it took me a long time.</p>

<pre><code>public int ladderLength(String start, String end, Set&lt;String&gt; dict) {
    Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();
    queue.add(start);
    int length = 1;

    while (!queue.isEmpty()) {
        int currentSize = queue.size();
        for (int k = 0; k &lt; currentSize; k++) {
            String word = queue.remove();
            // insert all adjacent strings of word
            if (word.equals(end)) {
                return length;
            }
            for (int i = 0; i &lt; word.length(); i++) {
                char[] letters = word.toCharArray();
                char originalLetter = letters[i];
                for (char c = 'a'; c &lt;= 'z'; c++) {
                    if (c == originalLetter) continue;
                    letters[i] = c;
                    String newLetters = String.valueOf(letters);
                    if (dict.contains(newLetters)) {
                        queue.add(newLetters);
                        dict.remove(newLetters);
                    }
                }
                letters[i] = originalLetter;
            }
        }
        length++;
    }
    return 0;
}
</code></pre>

<p><strong>Word Ladder II</strong></p>

<p>unsolvable</p>

<h3>Additional questions</h3>

<p><strong>Restore IP Addresses</strong></p>

<pre><code>public List&lt;String&gt; restoreIpAddresses(String s) {
    List&lt;String&gt; ans = new ArrayList&lt;String&gt;();
    if (s == null || s.length() == 0) {
        return ans;
    }
    helper(ans, new ArrayList&lt;String&gt;(), s, 0);
    return ans;
}

private void helper(List&lt;String&gt; ans, List&lt;String&gt; path, String s, int pos) {
    if (path.size() == 4) {
        if (pos == s.length()) {
            ans.add(convert(path));
        }
        return;
    }
    for (int i = pos + 1; i &lt;= s.length() &amp;&amp; i &lt;= pos + 3; i++) {
        String nextNum = s.substring(pos, i);
        if (!isValid(nextNum)) {
            continue;
        }
        path.add(nextNum);
        helper(ans, path, s, i);
        path.remove(path.size() - 1);
    }
}

private boolean isValid(String str) {
    if (str.length() == 1) {
        return true;
    } else if (str.charAt(0) == '0') {
        return false;
    } else {
        int num = Integer.parseInt(str);
        return 0 &lt;= num &amp;&amp; num &lt;= 255;
    }
}

private String convert(List&lt;String&gt; path) {
    String str = "";
    for (String s: path) {
        str += "." + s;
    }
    return str.substring(1);
}
</code></pre>

<p><strong>Combinations</strong></p>

<p>skip</p>

<p><strong>Letter Combinations of a Phone Number</strong></p>

<p>skip</p>

<p><strong>Permutation Sequence</strong></p>

<pre><code>public String getPermutation(int n, int k) {
    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
    int fact = 1;
    for (int i = 1; i &lt;= n; i++) {
        list.add(i);
        fact *= i;
    }
    String ans = "";
    for (int i = n; i &gt; 0; i--) {
        fact = fact / i;
        int rank = (k - 1) / fact;
        k = (k - 1) % fact + 1;

        int curNum = list.remove(rank);
        ans += String.valueOf(curNum);
    }
    return ans;
}
</code></pre>

<h2>Conclusion</h2>

<h4>DFS (O(2<sup>n</sup>), O(n!))</h4>

<ol>
<li>Find all possible solutions</li>
<li>Permutations / Subsets</li>
</ol>


<h4>BFS (O(m), O(n))</h4>

<ol>
<li>Graph traversal</li>
<li>Find shortest path in a simple graph</li>
</ol>


<p><strong>Two most canonical BFS questions</strong>:</p>

<ol>
<li>Graph traversal and toposort</li>
<li>Word Ladder</li>
</ol>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/15">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/13">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150/'>cc150 (3)</a></li>
<li class='category'><a href='/blog/categories/collection/'>collection (5)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (37)</a></li>
<li class='category'><a href='/blog/categories/facebook/'>facebook (2)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (20)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (155)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (76)</a></li>
<li class='category'><a href='/blog/categories/thoughts/'>thoughts (4)</a></li>
<li class='category'><a href='/blog/categories/twitter/'>twitter (1)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/08/18/Leetcode-second-third/">[Leetcode] Leetcode Second Round (3)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/17/Numbers-Concatenation-Max/">[Question] Numbers Concatenation to Get Max Value</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/17/Number-of-tree-given-preorder-postorder/">[Question] Number of Valid Trees Given Preorder and Postorder</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/17/Expression-evaluation/">[Twitter] Arithmetic Expression Evaluation</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/16/orthogonal-traverse-map/">[Google] Orthogonal Traverse the Map (`)</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
