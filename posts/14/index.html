
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Shuatiblog.com</title>
  <meta name="author" content="CodeMonkey">

  
  <meta name="description" content="Question link Given a string, find its rank among all its permutations sorted lexicographically. For example, rank of “abc” is 1, rank of “acb” is 2 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.shuatiblog.com/posts/14/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Shuatiblog.com" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.shuatiblog.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="blue_light">
            Shuatiblog.com
        </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/18/Lexicographic-rank-of-string/">[Amazon] Lexicographic Rank of a String</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-18T00:00:00-06:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/18/Lexicographic-rank-of-string/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/lexicographic-rank-of-a-string/">link</a></p>

<blockquote><p>Given a string, find its rank among all its permutations sorted lexicographically.</p>

<p>For example, rank of “abc” is 1, rank of “acb” is 2, and rank of “cba” is 6.</p></blockquote>

<h3>Solution</h3>

<p>Let the given string be “<strong>STRG</strong>”. In the input string, ‘S’ is the first character. There are total 4 characters and <strong>2 of them are smaller than ‘S’</strong>. So there can be <strong>2 * 3!</strong> smaller strings where first character is smaller than ‘S’, like following:</p>

<pre><code>G X X X
R X X X
</code></pre>

<p>Repeat the same process for T, and we get:</p>

<pre><code>Rank = 2*3! + 2*2! + 1*1! + 0*0! = 17
</code></pre>

<h3>Code</h3>

<pre><code>public int getRank(String input) {
    if (input == null || input.length() == 0) {
        return 0;
    }
    input = input.toUpperCase();
    return helper(input) + 1;
}

public int helper(String input) {
    if (input == null || input.length() == 0) {
        return 0;
    }
    char headChar = input.charAt(0);
    int countSmallerThanHead = 0;
    for (char ch : input.toCharArray()) {
        if (ch &lt; headChar) {
            countSmallerThanHead++;
        }
    }
    return countSmallerThanHead * Common.factorial(input.length() - 1)
            + helper(input.substring(1));
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/17/find-nodes-distance-k-binary-tree/">[Amazon] Find Nodes of Distance K From Binary Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-17T00:00:00-06:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/17/find-nodes-distance-k-binary-tree/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=15069740">link</a></p>

<blockquote><p>Find the nodes at d distance from a certain node in a Binary Tree</p></blockquote>

<h3>Solution</h3>

<p><a href="http://www.geeksforgeeks.org/print-nodes-distance-k-given-node-binary-tree/">There are two types</a> of nodes to be considered:</p>

<ol>
<li>Nodes in the subtree rooted of the target node.</li>
<li>Other nodes, may be an ancestor of target, or a node in some other subtree.</li>
</ol>


<p>The details of find these nodes:</p>

<ol>
<li><p>Find the nodes which can be reached in k hops from the given node.</p></li>
<li><p>Second part we look at those nodes <strong>on the upper part of the tree</strong>. The parent of the given node is 1 hop away. Hence in the <strong>other child subtree</strong> of the parent, we find nodes with k-1 hops.</p>

<p> Similarly the grand parent of B, we find nodes with k &ndash; 2 distance.</p></li>
</ol>


<p>Implementation:</p>

<ol>
<li><p>Start from root, <strong>store all nodes in a queue</strong> of maximum size k till you reach the given node.</p></li>
<li><p>Call FindNodesAtDistance() on the nodes from the queue to get all the nodes <strong>distance k -i</strong> from the node.</p></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/12/java-blocking-queue-2/">[Java OOP] Java BlockingQueue (2)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-12T00:00:00-06:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/12/java-blocking-queue-2/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Blocking Queue Implementation</h3>

<p><img class="middle" src="/assets/images/blocking-queue.png"></p>

<p><a href="http://tutorials.jenkov.com/java-concurrency/blocking-queues.html">source</a></p>

<ol>
<li><p>A blocking queue is a queue, so we init a queue with a pre-defined size.</p></li>
<li><p>BlockingQueue Class comes with Java 5, in java.util.concurrent.BlockingQueue. This example is only used to help you understand what&rsquo;s happening behind the scene.</p></li>
<li><p>Both <strong>enqueue(Object o){}</strong> and <strong>dequeue(){}</strong> are <strong>synchronized</strong> method.</p></li>
<li><p>Both methods do <strong>while { wait(); }</strong> and then <strong>notifyAll()</strong>.</p></li>
</ol>


<h3>Code</h3>

<pre><code>public class MyBlockingQueue {

    private List&lt;Object&gt; queue = new LinkedList&lt;Object&gt;();
    private int size = 10;

    public MyBlockingQueue(int size) {
        this.size = size;
    }

    public synchronized void enqueue(Object item) throws InterruptedException {
        while (this.queue.size() == this.size) {
            wait();
        }
        if (this.queue.size() == 0) {
            notifyAll();
        }
        this.queue.add(item);
    }

    public synchronized Object dequeue() throws InterruptedException {
        while (this.queue.size() == 0) {
            wait();
        }
        if (this.queue.size() == this.size) {
            notifyAll();
        }

        return this.queue.remove(0);
    }

    public boolean isEmpty() {
        return this.queue.isEmpty();
    }
}
</code></pre>

<h3>Another example</h3>

<p>This BlockingQueue example makes use MyBlockingQueue that we defined above.</p>

<pre><code>public class Main {

    public static void main(String[] args) throws Exception {

        MyBlockingQueue queue = new MyBlockingQueue(1024);

        Producer producer = new Producer(queue);
        Consumer consumer = new Consumer(queue);

        new Thread(producer).start();
        new Thread(consumer).start();

        Thread.sleep(4000);
    }
}
</code></pre>

<p>Producer</p>

<pre><code>public class Producer implements Runnable {

    protected MyBlockingQueue queue = null;

    public Producer(MyBlockingQueue queue) {
        this.queue = queue;
    }

    public void run() {
        System.out.println("Producer starting... ");
        try {
            for (int i = 1; i &lt;= 5; i++) {
                queue.enqueue("" + i);
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>Consumer</p>

<pre><code>public class Consumer implements Runnable {

    protected MyBlockingQueue queue = null;

    public Consumer(MyBlockingQueue queue) {
        this.queue = queue;
    }

    public void run() {
        try {
            for (int i = 1; i &lt;= 5; i++) {
                System.out.println(queue.dequeue());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Consumer finished. ");
    }
}
</code></pre>

<p>Output:</p>

<pre><code>Producer starting... 
1
2
3
4
5
Consumer finished. 
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/12/java-blocking-queue-1/">[Java OOP] Java BlockingQueue (1)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-12T00:00:00-06:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/12/java-blocking-queue-1/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Overview</h3>

<p><strong><a href="http://tutorials.jenkov.com/java-concurrency/blocking-queues.html">A blocking queue</a></strong> is a queue that blocks when you try to <strong>dequeue from a empty queue</strong>, or if you try to <strong>enqueue items into a full queue</strong>.</p>

<p><img class="middle" src="/assets/images/blocking-queue.png"></p>

<h4>Details</h4>

<ol>
<li><p>BlockingQueue <strong>doesn’t accept null values</strong>. Otherwise throw NullPointerException.</p></li>
<li><p>BlockingQueue implementations are <strong>thread-safe</strong>. All queuing methods are atomic in nature and use internal locks or other forms of concurrency control.</p></li>
<li><p>BlockingQueue interface is part of java collections framework and it’s primarily used for implementing <strong>producer consumer problem</strong>.</p></li>
</ol>


<p>Two important methods:</p>

<ol>
<li><p>put(E e): This method is used to insert elements to the queue, if the queue is full it waits for the space to be available.</p></li>
<li><p>E take(): This method retrieves and remove the element from the head of the queue, if queue is empty it waits for the element to be available.</p></li>
</ol>


<h4>Usage</h4>

<p><a href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html">BlockingQueue is typically used</a> to have one thread produce objects, with another thread consumes (producer consumer problem). Refer to <strong>[Design] Producer Consumer Problem</strong>.</p>

<h3>Example 1</h3>

<p>This example shows <strong>how changing the speed of consuming and producing</strong> results in different sequence of outputs, using a BlockingQueue. The size of the BlockingQueue is initialized at 5.</p>

<pre><code>public class Main {

    // original post from:
    // http://www.journaldev.com/1034/java-blockingqueue-example-implementing-producer-consumer-problem

    private static final Setting testFullQueue = new Setting(3, 10, 0);
    private static final Setting testEmptyQueue = new Setting(10, 3, 100);

    public static void main(String[] args) {

        // Creating BlockingQueue of size 5
        BlockingQueue&lt;Message&gt; queue = new ArrayBlockingQueue&lt;&gt;(5);

        Setting variableSetting = testFullQueue;
        Producer producer = new Producer(queue, variableSetting.produceSpeed);
        Consumer consumer = new Consumer(queue, variableSetting.consumeSpeed,
                variableSetting.consumerDelay);

        // starting producer to produce messages in queue
        new Thread(producer).start();

        // starting consumer to consume messages from queue
        new Thread(consumer).start();

        System.out.println("Producer and Consumer has been started");
    }

    static class Setting {
        int produceSpeed;
        int consumeSpeed;
        int consumerDelay;

        public Setting(int a, int b, int c) {
            this.produceSpeed = a;
            this.consumeSpeed = b;
            this.consumerDelay = c;
        }
    }
}
</code></pre>

<p>Producer</p>

<pre><code>public class Producer implements Runnable {

    private BlockingQueue&lt;Message&gt; queue;
    int produceSpeed;

    public Producer(BlockingQueue&lt;Message&gt; q, int a) {
        this.queue = q;
        this.produceSpeed = a;
    }

    @Override
    public void run() {
        // produce messages
        for (int i = 0; i &lt; 13; i++) {
            Message msg = new Message("" + i);
            try {
                Thread.sleep(produceSpeed);
                queue.put(msg);
                System.out.println("Produced " + msg.getMsg() + "           ("
                        + queue.size() + " items)");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // adding exit message
        Message msg = new Message("exit");
        try {
            queue.put(msg);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}
</code></pre>

<p>Consumer</p>

<pre><code>public class Consumer implements Runnable {

    private BlockingQueue&lt;Message&gt; queue;
    int consumeSpeed;
    int consumerDelay;

    public Consumer(BlockingQueue&lt;Message&gt; q, int a, int b) {
        this.queue = q;
        this.consumeSpeed = a;
        this.consumerDelay = b;
    }

    @Override
    public void run() {
        try {
            // initial delay: used to wait for producer to
            // fill up the queue
            Thread.sleep(consumerDelay);
            Message msg;
            // consuming messages until exit message is received
            while ((msg = queue.take()).getMsg() != "exit") {
            System.out.println("         " + msg.getMsg() + " Consumed"+ "  ("
                    + queue.size() + " items)");
                Thread.sleep(consumeSpeed);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Consumer finished working. Exit. ");
    }
}
</code></pre>

<p>Message Class</p>

<pre><code>public class Message {
    private String msg;

    public Message(String str){
        this.msg=str;
    }

    public String getMsg() {
        return msg;
    }
}
</code></pre>

<p>Output (testFullQueue):</p>

<pre><code>Producer and Consumer has been started
Produced 0           (0 items)
         0 Consumed  (0 items)
Produced 1           (1 items)
Produced 2           (2 items)
         1 Consumed  (1 items)
Produced 3           (2 items)
Produced 4           (3 items)
Produced 5           (4 items)
         2 Consumed  (3 items)
Produced 6           (4 items)
Produced 7           (5 items)
         3 Consumed  (5 items)
Produced 8           (5 items)
         4 Consumed  (4 items)
Produced 9           (5 items)
         5 Consumed  (4 items)
Produced 10           (5 items)
         6 Consumed  (4 items)
Produced 11           (5 items)
         7 Consumed  (4 items)
Produced 12           (5 items)
         8 Consumed  (4 items)
         9 Consumed  (4 items)
         10 Consumed  (3 items)
         11 Consumed  (2 items)
         12 Consumed  (1 items)
Consumer finished working. Exit. 
</code></pre>

<p>Output (testEmptyQueue):</p>

<pre><code>Producer and Consumer has been started
Produced 0           (1 items)
Produced 1           (2 items)
Produced 2           (3 items)
Produced 3           (4 items)
Produced 4           (5 items)
Produced 5           (5 items)
         0 Consumed  (5 items)
         1 Consumed  (4 items)
         2 Consumed  (3 items)
Produced 6           (4 items)
         3 Consumed  (3 items)
         4 Consumed  (2 items)
Produced 7           (3 items)
         5 Consumed  (2 items)
         6 Consumed  (1 items)
         7 Consumed  (0 items)
Produced 8           (1 items)
         8 Consumed  (0 items)
Produced 9           (1 items)
         9 Consumed  (0 items)
Produced 10           (1 items)
         10 Consumed  (0 items)
Produced 11           (0 items)
         11 Consumed  (0 items)
Produced 12           (1 items)
         12 Consumed  (0 items)
Consumer finished working. Exit. 
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/12/blocking-queue-and-thread-pool/">[Java OOP] BlockingQueue and Thread Pool</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-12T00:00:00-06:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/12/blocking-queue-and-thread-pool/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Blocking Queue VS. Thread Pool</h3>

<p>These are 2 very different things, however it might be a little bit confusing for a layman. I have very little knowledge about Java multi-threading. But after writing some example of thread pool and blockingqueue, I am able to identify some significant differences between the 2 DS:</p>

<ol>
<li><p>Thread pools are often used in multi threaded servers. For example, we create 10 thread only for processing 1,000 tasks. However in BlockingQueue, there&rsquo;re typically only 2 thread: Producer and Consumer. Of course there can be more, but the basic pattern defines only 2 (types of) threads.</p></li>
<li><p>Threads are added into thread pool, while in BlockingQueue, it stores tasks (runnables).</p></li>
</ol>


<p>It&rsquo;s not a common practise to compare the 2 DS. If you read this and have got some interesting thoughts, do not hesitate to let me know by commenting below!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/11/numer-of-occurrence-given-subsequence/">[Question] Number of Occurence of Given Sub-sequence</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-11T00:00:00-06:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/11/numer-of-occurrence-given-subsequence/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://stackoverflow.com/questions/6877249/find-the-number-of-occurrences-of-a-subsequence-in-a-string">link</a></p>

<blockquote><p>Given a digit &lsquo;3141592653&rsquo;, find number of occurence of subsequence &ldquo;123&rdquo;. Note that the sequence occurs twice:</p></blockquote>

<pre><code>3141592653
 1    2  3
   1  2  3
</code></pre>

<blockquote><p>Output 2.</p></blockquote>

<h3>Solution</h3>

<p>Refer to <strong>[LeetCode 115] Distinct Subsequences</strong>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/11/numer-of-distinct-subsequence/">[Question] Number of Distinct Sub-sequence</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-11T00:00:00-06:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/11/numer-of-distinct-subsequence/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://stackoverflow.com/questions/5151483/how-to-find-the-number-of-distinct-subsequences-of-a-string">link</a></p>

<blockquote><p>Find the number of distinct subsequences of a string (include &ldquo;&rdquo; as a subsequence).</p>

<p>For example, Input</p></blockquote>

<pre><code>AAA 
ABCDEFG 
CODECRAFT 
</code></pre>

<blockquote><p>Output</p></blockquote>

<pre><code>4 
128 
496 
</code></pre>

<h3>Solution</h3>

<p>In <strong>[LeetCode 115] Distinct Subsequences</strong>, we discuss finding occurence of a given subsequence.</p>

<p>Now if we do not specify a subsequence, <strong>we want the total number of distinct subsequence</strong>.</p>

<p>The solution is DP, with the following equation:</p>

<pre><code>Let, 

dp[i] = number of distinct subsequences ending with a[i]

last[i] = last position of character i in the given string.
</code></pre>

<p><strong>Equation</strong>:</p>

<pre><code>dp[i] = dp[last[i] - 1] + ... + dp[i - 1]
</code></pre>

<p>The final result is:</p>

<pre><code>Distinct Subsequences = dp[1] + ... dp[len - 1]
</code></pre>

<p>Example 1:</p>

<pre><code>Input   : - A B C
dp array: 1 1 2 4
Total = 8
</code></pre>

<p>Example 2:</p>

<pre><code>Input   : - A A C
dp array: 1 1 1 3
Total = 6
</code></pre>

<p>The code is posted below.</p>

<h3>Optimize Solution</h3>

<p>There is a good optimization of this DP solution, which is to <strong>keep another dp array &lsquo;sum&rsquo;</strong>, which sum[i] = dp[1] + dp[2] + &hellip; + dp[i]. The final answer would be sum[len &ndash; 1].</p>

<p>This nice idea is from <a href="http://stackoverflow.com/a/5152203">this post</a>. Credit goes to <strong>IVlad</strong>.</p>

<h3>Code</h3>

<p>un-optimized code. calculate dp[0] &hellip; dp[n], then sum to final result.</p>

<pre><code>public int countDistinctSubseq(String input) {
    int len = input.length();
    int[] dp = new int[len + 1];
    // dp[i] denotes the number of distinct subseq within first 'i' chars
    dp[0] = 1;
    // the first 0 chars is "" - we consider it as 1 subseq

    for (int i = 1; i &lt;= len; i++) {
        // set dp[i]
        // dp[i] = dp[i-1] + ... + dp[k] where input{k} == input{i}
        int p = i - 1;
        while (p &gt;= 0) {
            dp[i] += dp[p];
            if (p &gt; 0 &amp;&amp; input.charAt(p - 1) == input.charAt(i - 1)) {
                // when meeting a same char ahead of position i, stop
                // adding to dp[i]
                break;
            }
            p--;
        }
    }
    int sum = 0;
    for (int i : dp) {
        sum += i;
    }
    return sum;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/11/longest-repeating-substring/">[Amazon] Longest Repeating Substring</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-11T00:00:00-06:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/11/longest-repeating-substring/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=9182781">link</a></p>

<blockquote><p>Finding the longest repeated substring.</p>

<p>Example: &ldquo;banana&rdquo; ==> &ldquo;ana&rdquo;</p></blockquote>

<h3>Solution</h3>

<p>There are 2 solutions: Suffix array, and Suffix tree.</p>

<p><strong>1. Suffix array</strong>. Simple code, explained <a href="http://www.careercup.com/question?id=9182781">here</a>.</p>

<blockquote><p>Bentley&rsquo;s programming pearl book has the simplest implementation (less than 15 lines code) which sort all suffix, and then check common prefix length among adjacent suffix. The time complexity is O(n<sup>2logn</sup>) for sorting the suffix (which has avg length of O(n)).</p></blockquote>

<p>A detailed step-by-step <a href="http://nriverwang.blogspot.com/2013/04/longest-repeated-substring.html">explanation</a>:</p>

<pre><code>str = banana, its suffixes are:
banana
anana
nana
ana
na
a
</code></pre>

<p>after sort, the suffix array looks like:</p>

<pre><code>a
ana
anana
banana
na
nana
</code></pre>

<p>Then for each two adjacent suffixes, check the length of the common prefix.</p>

<p>The answer is &ldquo;ana&rdquo; (if overlapping is allowed, otherwise, should be &ldquo;an&rdquo;).</p>

<p><strong>2. Suffix tree</strong>. Suggest by <a href="http://qr.ae/6W9yJ">this post</a>, Or <a href="http://www.careercup.com/question?id=9182781">this</a>:</p>

<blockquote><p>a good solution is to create a suffix tree for the given word and then find the deepest internal node in that tree (node with at least 2 descendants under it)&hellip;</p></blockquote>

<p>For a nice PPT presentation about suffix tree, look <a href="https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/suffixtrees.pdf">here</a>.</p>

<h3>Code</h3>

<p>Suffix array approach.</p>

<pre><code>public String longestRepeat(String input) {
    int len = input.length();
    String[] suffixArray = new String[len];
    for (int i = 0; i &lt; len; i++) {
        suffixArray[i] = input.substring(i);
    }
    // now sort the suffix array
    Arrays.sort(suffixArray);
    String longest = "";
    // start to compare neighborhood suffixes, and check LCP
    for (int i = 0; i &lt; suffixArray.length - 1; i++) {
        String lcp = longestCommonPrefix(suffixArray[i], suffixArray[i + 1]);
        if (lcp.length() &gt; longest.length()) {
            longest = lcp;
        }
    }
    return longest;
}

private String longestCommonPrefix(String s1, String s2) {
    int p = 0;
    while (p &lt; s1.length() &amp;&amp; p &lt; s2.length()) {
        if (s1.charAt(p) != s2.charAt(p)) {
            break;
        }
        p++;
    }
    return s1.substring(0, p);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/11/crazy-distance-string/">[Google] Crazy Distance Between Strings</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-11T00:00:00-06:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/11/crazy-distance-string/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://stackoverflow.com/questions/15061908/google-interview-find-crazy-distance-between-strings">link</a></p>

<blockquote><p>X and Y are strings formed by 0 or 1. Distance is define as:</p></blockquote>

<pre><code>D(X,Y) = Remove chars common at the start from both X &amp; Y. 
Then add the remaining lengths from both the strings.
</code></pre>

<blockquote><p>For e.g.</p></blockquote>

<pre><code>D(1111, 1000) = Only First alphabet is common. So the remaining string is 111 &amp; 000. Therefore the result length("111") &amp; length("000") = 3 + 3 = 6
</code></pre>

<blockquote><p>For e.g.</p></blockquote>

<pre><code>D(0101, 01100) = Only First two alphabets are common. So the remaining string is 01 &amp; 100. Therefore the result length("01") &amp; length("100") = 2 + 3 = 5
</code></pre>

<blockquote><p>Now given n input, say like</p></blockquote>

<pre><code>1111
1000
101
1100
</code></pre>

<blockquote><p>Find out the maximum crazy distance between 2 strings.</p>

<p><strong>n is</strong> the number of input strings. <strong>m is</strong> the max length of any input string.</p></blockquote>

<h3>Solution</h3>

<p>This is the <a href="http://stackoverflow.com/a/15062640">source</a>.</p>

<blockquote><p>Put the strings into a tree, where 0 means go left and 1 means go right. <strong>O(m*n) time</strong>.</p></blockquote>

<p>Example:</p>

<pre><code>            Root
             1
          0      1
         0 1*   0  1
        0*     0*    1*
</code></pre>

<blockquote><p>where the * means that an element ends there. Constructing this tree clearly takes O(n m).</p>

<p>Now we have to find <strong>the diameter of the tree</strong> (the longest path between two nodes).</p></blockquote>

<p>How to find out longest path between 2 leaf nodes? Please refer to <strong>[Google] Diameter of a Binary Tree</strong> for explanation.</p>

<p>Total time complexity is <strong>O(m*n) time</strong>.</p>

<h3>Code</h3>

<pre><code>public int crazyDist(String[] input) {
    TreeNode root = this.buildTree(input);
    return this.findMaxPath(root).path - 1;
}

private Result findMaxPath(TreeNode node) {
    if (node == null) {
        return new Result(Integer.MIN_VALUE, 0);
    }
    Result lr = this.findMaxPath(node.left);
    Result rr = this.findMaxPath(node.right);
    int path = Math.max(lr.path, rr.path);
    if (lr.depth != 0 &amp;&amp; rr.depth != 0) {
        // this check is important, because if any of the child node is
        // NULL, this root will not be eligible for computing the path
        path = Math.max(path, lr.depth + rr.depth + 1);
        // Why? cuz diameter must go from one leaf, thru root, and reach
        // another leaf. This is different from "Maximum Path Sum" leetcode
    }
    return new Result(path, 1 + Math.max(lr.depth, rr.depth));
}

private TreeNode buildTree(String[] input) {
    TreeNode root = new TreeNode(123);
    // share a common root. this root is deducted from the final calculation
    for (String str : input) {
        // insert str under the root
        TreeNode p = root;
        for (char c : str.toCharArray()) {
            if (c == '0') {
                if (p.left == null) {
                    p.left = new TreeNode(124);
                    // if 0, go to left; otherwise go to right
                    // thus value of TreeNodes does not really matter
                }
                p = p.left;
            } else {
                if (p.right == null) {
                    p.right = new TreeNode(125);
                }
                p = p.right;
            }
        }
    }
    return root;
}

class Result {
    int path;
    int depth;

    public Result(int a, int b) {
        path = a;
        depth = b;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/11/check-if-repeating-subsequence-exist/">[Google] Check if Repeating Subsequence Exists</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-11T00:00:00-06:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/11/check-if-repeating-subsequence-exist/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=5931067269709824">link</a></p>

<blockquote><p>Given a string, find if there is any sub-sequence that repeats itself. Do not reuse any char.</p>

<p>Eg:</p></blockquote>

<pre><code>1. abab &lt;------yes, ab is repeated
2. abba &lt;---- No, a and b follow different order 
3. acbdaghfb &lt;-------- yes, a followed by b twice 
4. abcdacb &lt;----- yes, a followed by b twice 
</code></pre>

<blockquote><p>Note that no char should be reused. I.e. &ldquo;aab&rdquo; is a false.</p></blockquote>

<h3>Solution</h3>

<p>This looks like a question without any clue. However, this actually is a modified version of <strong>[LintCode] Longest Common Subsequence</strong>.</p>

<p>Look at that question: there&rsquo;s 2 input string, and they match char-by-char. For this question, we are simply <strong>matching input string with input string itself</strong>. And chars should be match <strong>ONLY</strong> at different positions, that&rsquo;s the key. As pointed out by the <a href="http://www.careercup.com/question?id=5931067269709824">top comment</a>:</p>

<blockquote><p>Now we can modify the longest_common_subsequence(a, a) to find the value of the longest repeated subsequence in a by excluding the cases when i == j</p></blockquote>

<h3>Code</h3>

<pre><code>public boolean checkRepeatSubseq(String input) {
    int len = input.length();
    int[][] dp = new int[len + 1][len + 1];
    // dp[i][j] denotes the length of subseq between 2 strings:
    // 1. first i chars of input
    // 2. first j chars of input
    for (int i = 1; i &lt;= len; i++) {
        for (int j = i; j &lt;= len; j++) {
            if (i != j &amp;&amp; input.charAt(i - 1) == input.charAt(j - 1)) {
                int temp = Math.max(dp[i - 1][j], dp[i][j - 1]);
                dp[i][j] = Math.max(temp, dp[i - 1][j - 1] + 1);
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[len][len] &gt;= 2;
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="15">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="13">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (76)</a></li>
<li class='category'><a href='/blog/categories/experience/'>experience (4)</a></li>
<li class='category'><a href='/blog/categories/fundamental/'>fundamental (14)</a></li>
<li class='category'><a href='/blog/categories/java-oop/'>java oop (30)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (176)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (16)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (25)</a></li>
<li class='category'><a href='/blog/categories/q-facebook/'>q-facebook (9)</a></li>
<li class='category'><a href='/blog/categories/q-google/'>q-google (63)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (126)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (5)</a></li>
<li class='category'><a href='/blog/categories/z-string-search/'>z-string-search (17)</a></li>
<li class='category'><a href='/blog/categories/z-testing/'>z-testing (2)</a></li>
<li class='category'><a href='/blog/categories/z-top-k/'>z-top-k (6)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/10/13/Segment-Tree-Query-II/">[LintCode] Segment Tree Query II </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/13/Segment-Tree-Query/">[LintCode] Segment Tree Query </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/13/Segment-Tree-Modify/">[LintCode] Segment Tree Modify </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/13/Segment-Tree-Build-II/">[LintCode] Segment Tree Build II </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/13/Segment-Tree-Build/">[LintCode] Segment Tree Build </a>
      </li>
    
  </ul>
</section>





<script type="text/javascript" src="http://srvpub.com/adServe/banners?tid=29011_41781_0&size=120x600" ></script>

<!--
<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"willran168","width":160,"height":600,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>
<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>
&#8211;>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
    Copyright &copy; 2015 - <a href="/about">CodeMonkey</a> -  All posts are my original writing, based uppon my personal view. <a href="/policy">Privacy Policy</a> - 
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
