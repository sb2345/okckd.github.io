
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Woodstock Blog</title>
  <meta name="author" content="Charlie Brown">

  
  <meta name="description" content="Question link Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Stats Frequency 4 Difficulty 3 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/34">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Woodstock Blog</a></h1>
  
    <h2>What's the good of living if you don't try a few things?</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/11/Merge-k-Sorted-Lists/">[LeetCode 23] Merge K Sorted Lists</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-11T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/merge-k-sorted-lists/">link</a></p>

<div class="question-content">
            <p></p><p>
Merge <i>k</i> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">Difficult</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>There are two ways to solve this problem.</p>

<ul>
<li>k &ndash; number of lists</li>
<li>n &ndash; String length of each list</li>
</ul>


<p><strong>First approach is merge sort</strong>. Using divide and conquer approach, divide the entire input into halves, and then merge 2 list each time. Instead of merging 1 by 1 which the time complexity is O(nk x (k-1)), the 2 lists to be merged is always similar length, thus time complexity is reduced to O(nk x logk).</p>

<p><strong>You may wonder how I calculate time complexity</strong>. See, each round of sort, nk nodes are read and sorted. This happened O(logk) times, where k is the number of lists. Thus totoal time take is O(nk x logk).</p>

<p><strong>Second approach is heap sort</strong>. The idea of this is to always keep a sorted list of the head of each list. But before the code, what actually is heap/priority queue?</p>

<blockquote><p><strong><a href="http://en.wikipedia.org/wiki/Heap_%28data_structure%29">Heap</a> is a specialized tree-based data structure</strong>. Heap is crucial in Dijkstra&rsquo;s algorithm and heapsort.</p>

<p>We take max heap for example. The keys of parent nodes are always greater than or equal to the children node.</p>

<p><strong>The heap is an implementation of priority queue</strong>. In fact, priority queues are often referred to as &ldquo;heaps&rdquo;, regardless of how they may be implemented.</p>

<p>Note that despite the similarity of the name &ldquo;heap&rdquo; to &ldquo;stack&rdquo; and &ldquo;queue&rdquo;, the latter two are <strong>abstract data types</strong>, while a heap is a <strong>specific data structure</strong>, and &ldquo;priority queue&rdquo; is the proper term for the abstract data type.</p></blockquote>



<table class="tg">
  <tr>
    <th class="tg-s6z2">Heap</th>
    <th class="tg-s6z2">Time</th>
  </tr>
  <tr>
    <td class="tg-031e">Find max</td>
    <td class="tg-s6z2">O(1)</td>
  </tr>
  <tr>
    <td class="tg-031e">Delete</td>
    <td class="tg-s6z2">O(lgn)</td>
  </tr>
  <tr>
    <td class="tg-031e">Insert</td>
    <td class="tg-s6z2">O(lgn)</td>
  </tr>
  <tr>
    <td class="tg-031e">Merge</td>
    <td class="tg-s6z2">O(n)</td>
  </tr>
</table>


<br />


<p>Both method are well explained in <a href="http://blog.csdn.net/linhuanmars/article/details/19899259">this csdn blog</a>. Time complexity analysis is given by <a href="http://n00tc0d3r.blogspot.sg/2013/04/merge-k-sorted-lists.html">nootcoder blog</a>.</p>

<h3>Solution</h3>

<p>First, divide and conquer code is lengthy but medium difficulty.</p>

<p>Second solution, however, is not as easy. <strong>Especially when we have to write Comparator on our own</strong>.  A priority queue (heap) is implemented and head of each list is inserted into the heap. Then poll elements out from the heap until heap is empty.</p>

<h3>My code</h3>

<p><strong>Merge sort code, written by me</strong></p>

<pre><code>public ListNode mergeKLists(List&lt;ListNode&gt; lists) {
    if (lists == null || lists.size() == 0) {
        return null;
    }
    return mergeHelper(lists, 0, lists.size() - 1);
}

private ListNode mergeHelper(List&lt;ListNode&gt; lists, int start, int end) {
    if (start == end) {
        return lists.get(start);
    } 
    int mid = start + (end - start) / 2;
    ListNode firstHalf = mergeHelper(lists, start, mid);
    ListNode secondHalf = mergeHelper(lists, mid + 1, end);
    return mergeTwo(firstHalf, secondHalf);
}

private ListNode mergeTwo(ListNode head1, ListNode head2) {
    ListNode dummy = new ListNode(0);
    ListNode p = dummy;
    while (head1 != null &amp;&amp; head2 != null) {
        if (head1.val &lt; head2.val) {
            p.next = head1;
            head1 = head1.next;
            p = p.next;
        } else {
            p.next = head2;
            head2 = head2.next;
            p = p.next;
        }
    }
    if (head1 == null) {
        p.next = head2;
    } else {
        p.next = head1;
    }
    return dummy.next;
}
</code></pre>

<p><strong>Heap sort code, written by me</strong>. <a href="http://answer.ninechapter.com/solutions/merge-k-sorted-lists/">source</a></p>

<pre><code>public ListNode mergeKLists(List&lt;ListNode&gt; lists) {
    if (lists == null || lists.size() == 0) {
        return null;
    }
    int size = lists.size();
    NodeComparator comparator = new NodeComparator();
    Queue&lt;ListNode&gt; queue = new PriorityQueue&lt;ListNode&gt;(size, comparator);
    for (ListNode node: lists) {
        if (node == null) {
            continue;
        }
        queue.offer(node);
    }
    ListNode dummy = new ListNode(0);
    ListNode p = dummy;
    while (!queue.isEmpty()) {
        p.next = queue.poll();
        p = p.next;
        if (p.next != null) {
            queue.offer(p.next);
        }
    }
    p.next = null;
    return dummy.next;
}

class NodeComparator implements Comparator&lt;ListNode&gt; {
    public int compare(ListNode o1, ListNode o2) {
        return o1.val - o2.val;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/10/Substring-with-Concatenation-All-Words/">[LeetCode 30] Substring With Concatenation of All Words</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/substring-with-concatenation-of-all-words/">link</a></p>

<div class="question-content">
            <p></p><p>
You are given a string, <b>S</b>, and a list of words, <b>L</b>, that are all of the same length. Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters.
</p>

<p>
For example, given:<br>
<b>S</b>: <code>"barfoothefoobarman"</code><br>
<b>L</b>: <code>["foo", "bar"]</code>
</p>

<p>
You should return the indices: <code>[0,9]</code>.<br>
(order does not matter).
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">more than hour</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>There are 2 ways to solve this question. <strong>The naive approach takes around 1200ms to pass</strong>, and <strong>the KPM-like approach takes around half of that time</strong>. Both methods are explained well in <a href="http://n00tc0d3r.blogspot.sg/2013/06/substring-with-concatenation-of-all.html">this blog</a>.</p>

<h4>The HashMap</h4>

<p>Before the solution, I will like to do a recap on <strong>HashMap</strong>.</p>

<blockquote cite="http://www.sparknotes.com/cs/searching/hashtables/section1.html">
<div>
<a href="http://www.sparknotes.com/cs/searching/hashtables/section1.html">link</a>
</div>
<p>
A hash table is made up of two parts: an array (the actual table where the data to be searched is stored) and a mapping function, known as a hash function. 
</p>
<p>
The hash function is a mapping from the input space to the integer space that defines the indices of the array. In other words, the hash function provides a way for assigning numbers to the input data such that the data can then be stored at the array index corresponding to the assigned number.
</p>
</blockquote>


<p>For example, if I want to store &lt;&ldquo;Durant&rdquo;>, I pass &ldquo;Durant&rdquo; into the hash function, and get (let&rsquo;s say) number 3. So in the Hash Table, it will store table(3 &ndash;> &ldquo;Durant&rdquo;).</p>

<p>In this way, the <strong>searching of HashMap can almost achieve  O(1) time in best case</strong> (like array access).</p>

<p>However,</p>

<blockquote cite="http://stackoverflow.com/a/9214421">
<div>
<a href="http://stackoverflow.com/a/9214421">link</a>
</div>
<p>
For average case, It really is (as the wikipedia page says) O(1+n/k) where K is the hash table size. If K is large enough, then the result is effectively O(1). But suppose K is 10 and N is 100. In that case each bucket will have on average 10 entries, so the search time is definitely not O(1); it is a linear search through up to 10 entries.
</p>
</blockquote>


<p>In practise, we will just assume search in HashMap always O(1).</p>

<p>Below is a great conclusion.</p>

<blockquote cite="http://stackoverflow.com/a/9214594">
<div>
<a href="http://stackoverflow.com/a/9214594">link</a>
</div>
<p><a href="http://en.wikipedia.org/wiki/Hash_table">Hash tables</a> are <code>O(1)</code> <strong>average and <a href="http://en.wikipedia.org/wiki/Amortized_analysis">amortized</a></strong> case complexity, however is suffers from <code>O(n)</code> <strong>worst case</strong> time complexity. [And I think this is where your confusion is]</p>

<p>Hash tables suffer from <code>O(n)</code> worst time complexity due to two reasons:</p>

<ol>
<li>If too many elements were hashed into the same key: looking inside this key may take <code>O(n)</code> time.</li>
<li>Once a hash table has passed its <a href="http://en.wikipedia.org/wiki/Load_balancing_%28computing%29">load balance</a> - it has to rehash [create a new bigger table, and re-insert each element to the table]. </li>
</ol>

<p>However, it is said to be <code>O(1)</code> average and amortized case because:</p>

<ol>
<li>It is very rare that many items will be hashed to the same key [if you chose a good hash function and you don&#8217;t have too big load balance.</li>
<li>The rehash operation, which is <code>O(n)</code>, can at most happen after <code>n/2</code> ops, which are all assumed <code>O(1)</code>: Thus when you sum the average time per op, you get : <code>(n*O(1) + O(n)) / n) = O(1)</code></li>
</ol>
</blockquote>


<h3>Solution</h3>

<p><strong>The naive approach uses a HashMap</strong>. Reason 1 is because there can be duplications in L, and reason 2 is the searching is faster.</p>

<p><strong>Time complexity of this solution is O((n &ndash; k * m) x m)</strong>, and <strong>space is the size of list L, O(m)</strong>. If m is not very big, the time can be regarded as O(n).</p>

<p><strong>some variables used in this question</strong>.</p>

<ul>
<li>n &ndash; length of the input string</li>
<li>L &ndash; a list of words (dictionary)</li>
<li>m &ndash; the size of L</li>
<li>k &ndash; the length of each word in L (all words have same length)</li>
<li>(k * m) &ndash; this is the length of a possible concatenation</li>
<li>(n &ndash; k * m) &ndash; this is the number of possible concatenation exist</li>
</ul>


<h3>My code</h3>

<p><strong>Updated on July 7th</strong>, code.</p>

<pre><code>public List&lt;Integer&gt; findSubstring(String S, String[] L) {
    List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();
    if (S == null || L == null || S.length() == 0 || L.length == 0) {
        return ans;
    }
    HashMap&lt;String, Integer&gt; set = new HashMap&lt;String, Integer&gt;();
    for (String str: L) {
        if (set.containsKey(str)) {
            set.put(str, set.get(str) + 1);
        } else {
            set.put(str, 1);
        }
    }
    int num = L.length;
    int len = L[0].length();
    for (int i = 0; i &lt;= S.length() - num * len; i++) {
        // start from i, check (num) words of length (len)
        HashMap&lt;String, Integer&gt; setCopy = new HashMap&lt;String, Integer&gt;(set);
        for (int j = 0; j &lt; num; j++) {
            String cur = S.substring(i + j * len, i + (j + 1) * len);
            if (setCopy.containsKey(cur)) {
                if (setCopy.get(cur) == 1) {
                    setCopy.remove(cur);
                } else {
                    setCopy.put(cur, setCopy.get(cur) - 1);
                }
            } else {
                break;
            }
        }
        if (setCopy.isEmpty()) {
            ans.add(i);
        }
    }
    return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/10/Implement-strStr/">[LeetCode 28] Implement strStr</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/implement-strstr/">link</a></p>

<div class="question-content">
            <p></p><p>
Implement strStr().
</p>
<p>
Returns a pointer to the first occurrence of needle in haystack, or <b>null</b> if needle is not part of haystack.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">KMP is difficult</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>There are 2 ways to solve this problem. <strong>The most easy and common way</strong> is to use nested loop (many online solutions use this method).</p>

<p>However, <strong>this question can also be solved by <a href="http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">KPM algorithm</a></strong>.</p>

<h3>Solution</h3>

<p>I post my standard solution below. This is the most standard solution online, for example it is in <a href="http://goo.gl/2MNOS2">this post</a>.</p>

<p><strong>I have yet to written KPM solution</strong>. <a href="http://discuss.leetcode.com/questions/76/implement-strstr">This blog</a> and <a href="http://fisherlei.blogspot.sg/2012/12/leetcode-implement-strstr.html">this blog</a> have good KMP solution posted.</p>

<h3>My code</h3>

<p><strong>Simple solution</strong></p>

<pre><code>public String strStr(String haystack, String needle) {
        if (needle.length() == 0) return haystack;
        for (int i = 0; i &lt;= haystack.length() - needle.length(); i ++) {
                if (haystack.charAt(i) != needle.charAt(0)) continue;
                int j = 0;
                for (; j &lt; needle.length(); j ++) {
                        if (haystack.charAt(i + j) != needle.charAt(j)) break;
                }
                if (j == needle.length()) return haystack.substring(i);
        }
        return null;
}
</code></pre>

<p><strong>KPM solution</strong></p>

<p>Only need to understand to principles.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/10/Divide-Two-Integers/">[LeetCode 29] Divide Two Integers</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/divide-two-integers/">link</a></p>

<div class="question-content">
            <p></p><p>
Divide two integers without using multiplication, division and mod operator.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">really long time</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question is more difficult than you thought</strong>!</p>

<p>I had little experience with <strong>Java bit operation</strong>, so I was struggling in the beginning. I&rsquo;m still not good at it now. Below is a quick tutorial on this topic.</p>

<table border="2">
  <tr>
    <th>operator</th>
    <th>what is means</th>
  </tr>
  <tr>
    <td>~</td>
    <td>invert every bit</td>
  </tr>
  <tr>
    <td>&lt;&lt;</td>
    <td>shift left (same as *2)</td>
  </tr>
  <tr>
    <td>&gt;&gt;</td>
    <td>signed shift right</td>
  </tr>
  <tr>
    <td>&gt;&gt;&gt;</td>
    <td>unsigned shift right</td>
  </tr>
  <tr>
    <td>^</td>
    <td>XOR</td>
  </tr>
  <tr>
    <td>|</td>
    <td>OR</td>
  </tr>
</table>


<br />


<p>Note the unsigned right shift operator &ldquo;>>>&rdquo; shifts a <strong>zero into the leftmost position</strong>, while the leftmost position after &ldquo;>>&rdquo; <strong>depends on sign extension</strong>.</p>

<p>After the knowledge barriers of big operation is cleared, this problem basically is <strong>a while loop that keeps subtracting (divisor * (2 ^ n)) from dividend</strong>. There is various ways to do it.</p>

<p><strong>But remember that overflow always can happen</strong>, especially when you dealing with Integer.MAX_VALUE and Integer.MIN_VALUE.</p>

<h3>Solution</h3>

<p>I will post 2 solutions, <strong>first of which is written by me</strong> using the idea from <a href="http://leetcodenotes.wordpress.com/2013/10/19/divide-two-integers/">this blog</a>. This is also the most common solution from the net.</p>

<p><strong>Second solution is from</strong> <a href="http://discuss.leetcode.com/questions/209/divide-two-integers/385">this post</a> and I translated the c++ into Java with a bit refactoring work. This code is extremely concise and beautiful.</p>

<h3>My code</h3>

<p><strong>First code is written by me</strong>. Please take a look at this line:</p>

<blockquote><p>a = 0 &ndash; (long) dividend;</p></blockquote>

<p>Previously I was using the 2 pieces of code below, and both won&rsquo;t work:</p>

<blockquote><p>a = dividend * -1;</p>

<p>a = 0 &ndash; dividend;</p></blockquote>

<p>Some extra attentions should be taken on this.</p>

<pre><code>public int divide(int dividend, int divisor) {
    long sign = 1, a = dividend, b = divisor;
    if (dividend &lt; 0) {
        sign *= -1;
        // this is where caused my error for last submission
        a = 0 - (long) dividend;
    }
    if (divisor &lt; 0) {
        sign *= -1;
        b = 0 - (long) divisor;
    }
    return (int) (sign * helper(a, b));
}

public long helper(long a, long b) {
    if (a &lt; b) return 0;
    long remain = a, ans = 0;
    while (remain != 0) {
        long count = 1, num = b;
        if (num &gt; remain) {
            remain = 0;
            break;
        }
        while (num + num &gt; 0 &amp;&amp; num + num &lt;= remain) {
            num = num &lt;&lt; 1;
            count = count &lt;&lt; 1;
        }
        remain -= num;
        ans += count;
    }
    return ans;
}
</code></pre>

<p><strong>Second code, translated from c plus plus</strong>.</p>

<pre><code>public int divide(int dividend, int divisor) {
    long a = dividend &gt;&gt;&gt; 31 == 0 ? dividend : 0 - (long) dividend;
    long b = divisor &gt;&gt;&gt; 31 == 0 ? divisor : 0 - (long) divisor;
    long ret = 0;
    while (a &gt;= b) {
        long c = b;
        int i = 0;
        while (a &gt;= c) {
            a -= c;
            ret += 1 &lt;&lt; i++;
            c &lt;&lt;= 1;
        }
    }
    return (int) ((dividend ^ divisor) &gt;&gt;&gt; 31 == 0 ? ret : 0 - ret);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Valid-Parentheses/">[LeetCode 20] Valid Parentheses</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/valid-parentheses/">link</a></p>

<div class="question-content">
            <p></p><p>Given a string containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.</p>

<p>The brackets must close in the correct order, <code>"()"</code> and <code>"()[]{}"</code> are all valid but <code>"(]"</code> and <code>"([)]"</code> are not.</p>
<p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>Standard solution around the internet is to use stack</strong>.</p>

<p>I though using String is also fine, so I tried it. I also works.</p>

<h3>Solution</h3>

<p>The code is easy.</p>

<h3>My code</h3>

<pre><code>public boolean isValid(String s) {
        String p = "";
        for (int i = 0; i &lt; s.length(); i ++) {
            char cur = s.charAt(i);
            if (cur == '(' || cur == '{' || cur == '[') {
                p += cur;
            } else {
                if (p.length() == 0) return false;
                if (p.charAt(p.length()-1) - cur &lt;= 2)
                    p = p.substring(0, p.length()-1);
            }
        }
        if (p.length() == 0) return true;
        return false;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Swap-Nodes-in-Pairs/">[LeetCode 24] Swap Nodes in Pairs</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/swap-nodes-in-pairs/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a linked list, swap every two adjacent nodes and return its head.
</p>

<p>
For example,<br>
Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.
</p>

<p>
Your algorithm should use only constant space. You may <b>not</b> modify the values in the list, only nodes itself can be changed.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is an very very interesting question</strong>. We can use either recursions or link operations to solve the problem (the second being more difficult). I have write code for both.</p>

<p>However, looking around the internet, I realize <strong>the solution can be extremely concise</strong>.</p>

<h3>Solution</h3>

<p>I post 3 pieces of code below.</p>

<p>I will explain second code a little bit. <strong>The idea is keep 3 pointers always</strong>: pre, cur and (cur.next). Inside the while loop, I will swap cur and (cur.next), and let pre point to (cur.next). Then I can proceed to next loop, with the updated pre and cur pointer.</p>

<p><strong>However, looking at the last code, I realize previous approach is too complex</strong>. <a href="http://oj.leetcode.com/discuss/3608/seeking-for-a-better-solution">This idea</a> is keeping only 1 pointer at a time, and swap the next 2 nodes following this pointer. In this way, the code is extremely concise and the logic is much more easier to understand.</p>

<h3>My code</h3>

<p>Recursion code, by me.</p>

<pre><code>public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode newHead = head.next;
        head.next = swapPairs(newHead.next);
        newHead.next = head;
        return newHead;
}
</code></pre>

<p>Direct approach, written by me. Many blogs including <a href="http://gongxuns.blogspot.sg/2012/12/leetcodeswap-nodes-in-pairs.html">this one</a> gives the same solution.</p>

<pre><code>public ListNode swapPairs(ListNode head) {
        if (head == null) return head;
        ListNode preHead = new ListNode(1);
        preHead.next = head;
        ListNode cur = head, pre = preHead;
        while (cur != null &amp;&amp; cur.next != null) {
            pre.next = cur.next;
            ListNode newCur = cur.next.next;
            cur.next.next = cur;
            cur.next = newCur;
            pre = cur;
            cur = newCur;
        }
        return preHead.next;
}
</code></pre>

<p>This is a great solution by <a href="http://oj.leetcode.com/discuss/3608/seeking-for-a-better-solution">leetcode user Tao2014</a>.</p>

<pre><code>public ListNode swapPairs(ListNode head) {
        ListNode start = new ListNode(0); 
        start.next = head;
        for (ListNode cur = start; cur.next != null &amp;&amp; cur.next.next != null; 
                cur = cur.next.next) {
            cur.next = swap(cur.next, cur.next.next);
        }
        return start.next;
}

private ListNode swap(ListNode next1, ListNode next2) {
        next1.next = next2.next;
        next2.next = next1;
        return next2;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Remove-Element/">[LeetCode 27] Remove Element</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/remove-element/">link</a></p>

<div class="question-content">
            <p></p><p>Given an array and a value, remove all instances of that value in place and return the new length.
</p>

<p>
The order of elements can be changed. It doesn&#8217;t matter what you leave beyond the new length.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>This question is easy.</p>

<h3>Solution</h3>

<p><strong>I thought 6 lines is the most concise solution, until I read</strong> <a href="http://needjobasap.blogspot.sg/2014/01/removeelement-leetcode.html">this blog</a>.</p>

<h3>My code</h3>

<pre><code>public int removeElement(int[] A, int elem) {
        int left = 0, right = 0;
        while (right &lt; A.length) {
            if (A[right] == elem) right++;
            else A[left ++] = A[right ++];
        }
        return left;
}
</code></pre>

<p>Change while loop to for loop, the solution is only 4 lines of code.</p>

<pre><code>public int removeElement(int[] A, int elem) {
        int p = 0;
        for (int i = 0; i &lt; A.length; i ++)
            if (A[i] != elem) A[p ++] = A[i];
        return p;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Remove-Duplicates-from-Sorted-Array/">[LeetCode 26] Remove Duplicates From Sorted Array</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a sorted array, remove the duplicates in place such that each element appear only <i>once</i> and return the new length.</p>

<p>
Do not allocate extra space for another array, you must do this in place with constant memory.
</p>

<p>
For example,<br>
Given input array A = <code>[1,1,2]</code>,
</p>
<p>
Your function should return length = <code>2</code>, and A is now <code>[1,2]</code>.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>This question is easy.</p>

<h3>Solution</h3>

<p>Two pointer operations.</p>

<h3>My code</h3>

<pre><code>public int removeDuplicates(int[] A) {
        if (A.length == 0) return 0;
        int left = 1, right = 1;
        int pre = A[0];
        while(right &lt; A.length){
            if (A[right] != pre) {
                A[left] = A[right];
                pre = A[left];
                left ++;
            }
            right ++;
        }
        return left;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Merge-Two-Sorted-Lists/">[LeetCode 21] Merge Two Sorted Lists</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/merge-two-sorted-lists/">link</a></p>

<div class="question-content">
            <p></p><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question is easy</strong>. There are difficult ways to solve.</p>

<h3>Solution</h3>

<p>I wrote 2 versions of code, one using recursion and one using direct approach (fake header + link operations). <strong>Surprisingly my second code is EXACTLY same</strong> as the code written in <a href="http://www.programcreek.com/2012/12/leetcode-merge-two-sorted-lists-java/">this blog</a>.</p>

<h3>My code</h3>

<p>Recursion:</p>

<pre><code>public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        if (l1.val &gt; l2.val) {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
        else{
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }

}
</code></pre>

<p>Fake header + link operations</p>

<pre><code>public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode pre = new ListNode(Integer.MIN_VALUE);
        ListNode cur = pre;
        while (l1 != null &amp;&amp; l2 != null) {
            if (l1.val &lt; l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        if (l1 == null) cur.next = l2;
        else cur.next = l1;
        return pre.next;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/09/Generate-Parentheses/">[LeetCode 22] Generate Parentheses</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-09T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/valid-parentheses/">link</a></p>

<div class="question-content">
            <p></p><p>
Given <i>n</i> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
</p>

<p>
For example, given <i>n</i> = 3, a solution set is:
</p>
<p>
<code>"((()))", "(()())", "(())()", "()(())", "()()()"</code>
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Diffficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>Most popular solutions online are using recursive calls</strong>. For example, <a href="http://www.geeksforgeeks.org/print-all-combinations-of-balanced-parentheses/">this blog</a>. I also used this method.</p>

<h3>Solution</h3>

<p>I kept 2 integers: <strong>open</strong> (number of unclosed left parenthesis) and <strong>remain</strong> (number of parenthesis that can be addded to the current string). I optimized my previous code and made it cleaner.</p>

<h3>My code</h3>

<pre><code>public ArrayList&lt;String&gt; generateParenthesis(int n) {
        return helper(new ArrayList&lt;String&gt;(), 0, n, "");
}

private ArrayList&lt;String&gt; helper(ArrayList&lt;String&gt; ans, 
                int open, int remain, String cur) {
        if (open == 0 &amp;&amp; remain == 0) ans.add(cur);
        if (remain &gt; 0) helper(ans, open + 1, remain - 1, cur + "(");
        if (open &gt; 0) helper(ans, open - 1, remain, cur + ")");
        return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/35">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/33">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/classic/'>classic (3)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (52)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (35)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (152)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>octopress (1)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (85)</a></li>
<li class='category'><a href='/blog/categories/string-search/'>string search (3)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (5)</a></li>
<li class='category'><a href='/blog/categories/top-k/'>top k (4)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/09/16/google-guess-password/">[Google] Guess Password</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/12/DNS-communication-protocol/">[Design] DNS Communication Protocol</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/11/barrier-goods-van-and-distance/">[Google] Barrier, Goods Van and Distance</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/11/arithmetic-progression-triplet/">[Google] Arithmetic Progression Triplet</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/11/arithmetic-progression-longest/">[Google] Arithmetic Progression Longest</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Charlie Brown -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
