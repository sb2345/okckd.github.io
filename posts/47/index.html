
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Shuatiblog.com</title>
  <meta name="author" content="CodeMonkey">

  
  <meta name="description" content="Question link Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that: Only one &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.shuatiblog.com/posts/47/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Shuatiblog.com" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.shuatiblog.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="blue_light">
            Shuatiblog.com
        </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/30/Word-Ladder-II/">[LeetCode 126] Word Ladder II (Unsolvable)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-30T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/30/Word-Ladder-II/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/word-ladder-ii/">link</a></p>

<div class="question-content">
            <p></p><p>
Given two words (<i>start</i> and <i>end</i>), and a dictionary, find all shortest transformation sequence(s) from <i>start</i> to <i>end</i>, such that:
</p>
<ol>
<li>Only one letter can be changed at a time</li>
<li>Each intermediate word must exist in the dictionary</li>
</ol>

<p>
For example,
</p>
<p>
Given:<br>
<i>start</i> = <code>"hit"</code><br>
<i>end</i> = <code>"cog"</code><br>
<i>dict</i> = <code>["hot","dot","dog","lot","log"]</code><br>
</p>
<p>
Return<br>
</p><pre>  [
    ["hit","hot","dot","dog","cog"],
    ["hit","hot","lot","log","cog"]
  ]
</pre>
<p></p>

<p>
<b>Note:</b><br>
</p><ul>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
</ul>
<p></p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is an unsolvable question</strong>.</p>

<h3>Solution</h3>

<p>A solution is available <a href="http://blog.csdn.net/whuwangyi/article/details/21611433">here</a>, but I did not solved it and I gave up.</p>

<h3>Code</h3>

<pre><code>public class Node {  
    public int dist;  
    public String str;  
    public LinkedList&lt;Node&gt; prev;  

    public Node(int dist, String str) {  
        this.dist = dist;  
        this.str = str;  
        this.prev = new LinkedList&lt;Node&gt;();
    }

    public void addPrev(Node pNode) {  
        prev.add(pNode);  
    }  
}  

public ArrayList&lt;ArrayList&lt;String&gt;&gt; findLadders(String start,  
        String end, HashSet&lt;String&gt; dict) {  
    dict.add(end);  

    // Key: the dictionary string; Value: Node  
    Map&lt;String, Node&gt; map = new HashMap&lt;String, Node&gt;();  
    Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();  

    Node startNode = new Node(1, start);  
    queue.offer(start);  
    map.put(start, startNode);  

    ArrayList&lt;ArrayList&lt;String&gt;&gt; ret = new ArrayList&lt;ArrayList&lt;String&gt;&gt;();  

    while (!queue.isEmpty()) {  
        String str = queue.poll();  

        if (str.equals(end)) {  
            getPaths(map.get(end), map, new ArrayList&lt;String&gt;(), ret);  
            return ret;  
        }  

        for (int i = 0; i &lt; str.length(); i++) {  
            for (int j = 0; j &lt;= 25; j++) {  
                // transform it into another word  
                String newStr = replace(str, i, (char) ('a' + j));  

                // if a new word is explored  
                if (dict.contains(newStr)) {  
                    if (!map.containsKey(newStr)) {  
                        // construct a new node  
                        Node node = map.get(str);  
                        Node newNode = new Node(node.dist + 1, newStr);  
                        newNode.prev = new LinkedList&lt;Node&gt;();  
                        newNode.prev.add(node);  

                        map.put(newStr, newNode);  
                        queue.offer(newStr);  
                    } else {  
                        Node node = map.get(newStr);  
                        Node prevNode = map.get(str);  

                        // increase the path set  
                        if (node.dist == prevNode.dist + 1) {  
                            node.addPrev(prevNode);  
                            // queue.offer(newStr); // will cause TLE!!!  
                        }  
                    }  
                }  
            }  
        }  
    }  

    return ret; // return an empty set  
}  

// replace the index of the given string with the given char  
private String replace(String str, int index, char c) {  
    StringBuilder sb = new StringBuilder(str);  
    sb.setCharAt(index, c);  
    return sb.toString();  
}  

// get all the paths by using DFS  
private void getPaths(Node end, Map&lt;String, Node&gt; map,  
        ArrayList&lt;String&gt; curPath, ArrayList&lt;ArrayList&lt;String&gt;&gt; paths) {  
    if (end == null) {  
        paths.add(curPath);  
        return;  
    }  

    curPath.add(0, end.str);  
    if (!end.prev.isEmpty()) {  
        for (Node prevNode : end.prev) {  
            getPaths(prevNode, map, new ArrayList&lt;String&gt;(curPath), paths);  
        }  
    } else {  
        getPaths(null, map, curPath, paths);  
    }  
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/30/Palindrome-Partitioning-II/">[LeetCode 132] Palindrome Partitioning II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-30T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/30/Palindrome-Partitioning-II/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/palindrome-partitioning-ii/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a string <i>s</i>, partition <i>s</i> such that every substring of the partition is a palindrome.
</p>
<p>
Return the minimum cuts needed for a palindrome partitioning of <i>s</i>.
</p>
<p>
For example, given <i>s</i> = <code>"aab"</code>,<br>
Return <code>1</code> since the palindrome partitioning <code>["aa","b"]</code> could be produced using 1 cut.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is DP, but not traditional DP question</strong></p>

<h4>IT IS DOUBLE DP!</h4>

<p>It is very hard for me to even understand the solution, but <strong>I have found a great analysis from <a href="http://blog.sina.com.cn/s/blog_b9285de20101iwqt.html">peking2&rsquo;s blog</a></strong>.</p>

<blockquote><p>这题一般人一看就是DP，DP公式也很容易推出，算是一道简单的DP。</p>

<p>dp(i) = min( 1+dp(j+1), if substring(i,j) is palindrome)</p>

<p>从以上的分析时间复杂度为O(n<sup>3</sup>), 主要是因为检查回文也需要O(n)的时间。因此这题有意思的一点就是如何降低时间复杂度到O(n<sup>2</sup>)？</p>

<p><strong>其实这题是两个DP混杂在了一起</strong>，这也是这道题最有意思的地方。另外一个DP就是跟检查回文有关了，公式如下</p>

<p>dp(i)(j)=true if s(i)==s(j) &amp;&amp; dp(i+1)(j-1)</p>

<p>也就是说，你要检查一个回文只需要知道头尾的字符相等，并且中间的字串已经成为了回文即可。O(1)复杂度。</p></blockquote>

<p><strong>A more detailed analysis is available in <a href="http://fisherlei.blogspot.sg/2013/03/leetcode-palindrome-partitioning-ii.html">this blog</a></strong>.</p>

<blockquote cite="http://fisherlei.blogspot.sg/2013/03/leetcode-palindrome-partitioning-ii.html">

    <b>[Thoughts]</b>
    <br>凡是求最优解的，一般都是走DP的路线。这一题也不例外。首先求dp函数，
    <br>
    <br>定义函数
    <br>D[i,n] = 区间[i,n]之间最小的cut数，n为字符串长度
    <br>
    <br>&nbsp;a &nbsp; b &nbsp; a &nbsp; b &nbsp; b &nbsp; b &nbsp; a &nbsp; b &nbsp; b &nbsp; a &nbsp; b &nbsp; a
    <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;i &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n
    <br>如果现在求[i,n]之间的最优解？应该是多少？简单看一看，至少有下面一个解
    <br>
    <br>
    <br>&nbsp;a &nbsp; b &nbsp; a &nbsp; b &nbsp; b &nbsp; b &nbsp; a &nbsp; b &nbsp; b &nbsp; a &nbsp; b &nbsp; a
    <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;i &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
    <span style="color: red;">j</span>&nbsp;
    <span style="color: red;">j+1</span>&nbsp; &nbsp; n
    <br>
    <br>此时 &nbsp;D[i,n] = min(D[i, j] + D[j+1,n]) &nbsp;i&lt;=j &lt;n。这是个二维的函数，实际写代码时维护比较麻烦。所以要转换成一维DP。如果每次，从i往右扫描，每找到一个回文就算一次DP的话，就可以转换为
    <br>D[i] = 区间[i,n]之间最小的cut数，n为字符串长度， 则,
    <br>
    <br>D[i] = min(1+D[j+1] ) &nbsp; &nbsp;i&lt;=j &lt;n
    <br>
    <br>有个转移函数之后，一个问题出现了，就是如何判断[i,j]是否是回文？每次都从i到j比较一遍？太浪费了，这里也是一个DP问题。
    <br>定义函数
    <br>P[i][j] = true if [i,j]为回文
    <br>
    <br>那么
    <br>P[i][j] = str[i] == str[j] &amp;&amp; P[i+1][j-1];
    <br>
</blockquote>


<h3>Solution</h3>

<p>The coding is not easy, especially <strong>when 2 DP are written in 1 for-loop</strong>.</p>

<p>I wrote many times until I finally achieved the nice and concise solution that you see below.</p>

<h3>Code</h3>

<p><strong>Doing everything in 1 loop</strong>, not an intuitive code.</p>

<pre><code>public int minCut(String s) {
    int len = s.length();
    if (len &lt;= 1) return 0;
    boolean[][] pl = new boolean[len][len];
    int[] dp = new int[len];
    for (int i = len-1; i &gt;= 0; i --) {
        dp[i] = Integer.MAX_VALUE;
        for (int j = i; j &lt; len; j ++) {
            // first set pl[][], then update dp[i]
            if (j - i &lt;= 1) pl[i][j] = s.charAt(i) == s.charAt(j);
            else pl[i][j] = s.charAt(i) == s.charAt(j) &amp; pl[i+1][j-1];
            if (pl[i][j]) {
                if (j == len-1) dp[i] = 0;
                else 
                    dp[i] = Math.min(dp[i], dp[j+1] + 1);
            }
        }
    }
    return dp[0];
}
</code></pre>

<p><strong>Updated on July 18th, 2014</strong>, written by me.</p>

<pre><code>boolean[][] map = null;

public int minCut(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    map = getMap(s);
    int len = s.length();
    int[] dp = new int[len + 1];
    dp[0] = -1;
    for (int i = 0; i &lt; len; i++) {
        dp[i+1] = Integer.MAX_VALUE;
        for (int j = 0; j &lt;= i; j++) {
            if (map[j][i]) {
                dp[i+1] = Math.min(dp[i+1], dp[j] + 1);
            }
        }
    }
    return dp[len];
}

private boolean[][] getMap(String s) {
    int len = s.length();
    boolean[][] map = new boolean[len][len];
    for (int i = len - 1; i &gt;= 0; i--) {
        for (int j = 0; j &lt; len; j++) {
            if (i &gt; j) {
                continue;
            } else if (i == j) {
                map[i][j] = true;
            } else {
                if (i + 1 == j) {
                    map[i][j] = s.charAt(i) == s.charAt(j);
                } else {
                    map[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; map[i+1][j-1];
                }
            }
        }
    }
    return map;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/30/Insertion-Sort-List/">[LeetCode 147] Insertion Sort List</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-30T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/30/Insertion-Sort-List/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://oj.leetcode.com/problems/insertion-sort-list/">link</a></p>

<div class="question-content">
            <p></p><p>Sort a linked list using insertion sort.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question is a little tricky, but not difficult</strong>. First important thing is to konw what is <a href="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</a>. It is always keeping a sorted list, and then get next unsorted element and insert into correct position of the sorted list.</p>

<h3>Solution</h3>

<p><strong>Almost all solutions on internet is same, so I will just explain my code</strong>. My code can be optimized a little bit by studying <a href="http://blog.csdn.net/linhuanmars/article/details/21144553">this blog</a>, but I guess it&rsquo;s just refactoring 1 or 2 variables and execution time would not be affected.</p>

<p>My solution is dividing the list into 2 parts: sorted part and unsorted part. <strong>I keep getting next node from unsorted and insert into sorted</strong>.</p>

<h3>My code</h3>

<p>Recursion:</p>

<pre><code>public ListNode insertionSortList(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode sorted = new ListNode(Integer.MIN_VALUE);
    sorted.next = head;
    ListNode unsort = head.next;
    head.next = null;
    // the sorted and unsort both are not null at this point
    while (unsort != null) {
        ListNode pos = sorted;
        ListNode cur = unsort;
        unsort = unsort.next;
        while (pos.next != null &amp;&amp; pos.val &lt; cur.val 
            &amp;&amp; pos.next.val &lt; cur.val) pos = pos.next;
        // now insert (cur) to (pos.next)
        cur.next = pos.next;
        pos.next = cur;
    }
    return sorted.next;
}
</code></pre>

<p><strong>Updated on June 17th, rewrote the code with dummy head</strong>. This is different solution, with better readability.</p>

<pre><code>public ListNode insertionSortList(ListNode head) {
    if (head == null) {
        return null;
    }
    ListNode dummy = new ListNode(0);
    ListNode cur = head;
    while (cur != null) {
        // insert cur into correct pos
        ListNode pos = dummy;
        while (pos.next != null &amp;&amp; pos.next.val &lt; cur.val) {
            pos = pos.next;
        }
        ListNode temp = cur.next;
        cur.next = pos.next;
        pos.next = cur;
        cur = temp;
    }
    return dummy.next;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/30/Clone-Graph/">[LeetCode 133] Clone Graph</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-30T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/30/Clone-Graph/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/clone-graph/">link</a></p>

<div class="question-content bg-color bg-img font-color">

<p class="font-color"></p><p class="font-color">
Clone an undirected graph. Each node in the graph contains a <code>label</code> and a list of its <code>neighbors</code>.
</p>

<div class="bg-color bg-img font-color">
<br>
<b>OJ&#8217;s undirected graph serialization:</b>

<p class="font-color">
Nodes are labeled uniquely.
</p>

We use <code>#</code> as a separator for each node, and <code>,</code> as a separator for node label and each neighbor of the node.
<p class="font-color"></p>

<p class="font-color">
As an example, consider the serialized graph <code><font color="red">{<font color="black">0</font>,1,2#</font><font color="blue"><font color="black">1</font>,2#</font><font color="green"><font color="black">2</font>,2}</font></code>.
</p>

<p class="font-color">
The graph has a total of three nodes, and therefore contains three parts as separated by <code>#</code>.
</p><ol>
<li>First node is labeled as <code><font color="black">0</font></code>. Connect node <code><font color="black">0</font></code> to both nodes <code><font color="red">1</font></code> and <code><font color="red">2</font></code>.</li>
<li>Second node is labeled as <code><font color="black">1</font></code>. Connect node <code><font color="black">1</font></code> to node <code><font color="blue">2</font></code>.</li>
<li>Third node is labeled as <code><font color="black">2</font></code>. Connect node <code><font color="black">2</font></code> to node <code><font color="green">2</font></code> (itself), thus forming a self-cycle.</li>
</ol>
<p class="font-color"></p>

<p class="font-color">
Visually, the graph looks like the following:
</p><pre class="bg-color bg-img font-color">       1
      / \
     /   \
    0 --- 2
         / \
         \_/
</pre>
<p class="font-color"></p>

</div><p class="font-color"></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">thought for a while</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a difficult coding question, although the idea is simple</strong>.</p>

<h3>Solution</h3>

<p>Two solution: <strong>BFS (recommended) and DFS</strong>. <a href="http://leetcode.com/2012/05/clone-graph-part-i.html">This</a> is a good analysis article.</p>

<blockquote cite="http://leetcode.com/2012/05/clone-graph-part-i.html">
<p>Let’s analyze this further by using the below example:</p>
<div style="text-align: center; margin-bottom: 30px;"> <a href="http://www.leetcode.com/wp-content/uploads/2012/05/graph.png"><img src="http://www.leetcode.com/wp-content/uploads/2012/05/graph.png" alt="" title="graph" width="211" height="84" class="aligncenter size-full wp-image-1365"></a><span style="font-size: x-small;">A simple graph</span></div>
<p>Assume that the starting point of the graph is A. First, you make a copy of node A (A2), and found that A has only one neighbor B. You make a copy of B (B2) and connects A2-&gt;B2 by pushing B2 as A2′s neighbor. Next, you find that B has A as neighbor, which you have already made a copy of. Here, we have to be careful not to make a copy of A again, but to connect B2-&gt;A2 by pushing A2 as B2′s neighbor. But, how do we know if a node has already been copied?</p>
</blockquote>


<p><strong>Basic idea is to use HashMap to store the already-copied nodes</strong>.</p>

<p>My first attempt is DFS by making use of a &lsquo;visited&rsquo; Set to mark which node I have copied and which is not. This is a nice idea and it solved the problem neatly.</p>

<p>But after reading <a href="http://www.programcreek.com/2012/12/leetcode-clone-graph-java/">this article</a>, I realize that <strong>&lsquo;visited&rsquo; is not needed for BFS solution</strong>!</p>

<p><strong>The trick is, whenever I do a &lsquo;HashMap.put(curNode, newNode)&rsquo;, I push &lsquo;curNode&rsquo; to queue</strong>. This very well replaces the functionality of the &lsquo;visited&rsquo; set. It also guarantees that when I pop a new element from the queue, <strong>I CAN ALWAYS FIND ITS CORRESPONDING COPY</strong> from the HashMap &ndash; always there.</p>

<h3>Code</h3>

<p><strong>First, my DFS code</strong></p>

<pre><code>public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if (node == null) return null;
    UndirectedGraphNode newNode = new UndirectedGraphNode(node.label);
    HashMap&lt;Integer, UndirectedGraphNode&gt; map = 
        new HashMap&lt;Integer, UndirectedGraphNode&gt;();
    map.put(node.label, newNode);
    copy(node, newNode, map, new HashSet&lt;Integer&gt;());
    return newNode;
}

private void copy(UndirectedGraphNode orin, UndirectedGraphNode cp,
        HashMap&lt;Integer, UndirectedGraphNode&gt; map,
        HashSet&lt;Integer&gt; visited) {
    if (visited.contains(orin.label))
        return;
    else
        visited.add(orin.label);
    for (UndirectedGraphNode n : orin.neighbors) {
        if (map.containsKey(n.label)) {
            cp.neighbors.add(map.get(n.label));
        } else {
            UndirectedGraphNode newNode = new UndirectedGraphNode(n.label);
            map.put(n.label, newNode);
            cp.neighbors.add(map.get(n.label));
        }
    }
    // do DFS recursively
    for (int i = 0; i &lt; orin.neighbors.size(); i++) {
        copy(orin.neighbors.get(i), cp.neighbors.get(i), map, visited);
    }
}
</code></pre>

<p><strong>Second, my BFS code without using &lsquo;visited&rsquo; HashSet</strong></p>

<pre><code>public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if (node == null) return null;
    HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map 
            = new HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt;();
    map.put(node, new UndirectedGraphNode(node.label));
    LinkedList&lt;UndirectedGraphNode&gt; queue = new LinkedList&lt;UndirectedGraphNode&gt;();
    queue.add(node);
    // queue is guaranteed to always have non-traversed nodes
    while ( !queue.isEmpty() ) {
        UndirectedGraphNode orin = queue.remove();
        UndirectedGraphNode cp = map.get(orin);
        for (UndirectedGraphNode n : orin.neighbors) {
            if ( !map.containsKey(n) ) {
                map.put(n, new UndirectedGraphNode(n.label));
                queue.add(n);
            }
            UndirectedGraphNode newNode = map.get(n);
            cp.neighbors.add(newNode);
        }
    }
    return map.get(node);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/29/Word-Ladder/">[LeetCode 127] Word Ladder</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-29T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/29/Word-Ladder/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/word-ladder/">link</a></p>

<div class="question-content">
            <p></p><p>
Given two words (<i>start</i> and <i>end</i>), and a dictionary, find the length of shortest transformation sequence from <i>start</i> to <i>end</i>, such that:
</p>
<ol>
<li>Only one letter can be changed at a time</li>
<li>Each intermediate word must exist in the dictionary</li>
</ol>

<p>
For example,
</p>
<p>
Given:<br>
<i>start</i> = <code>"hit"</code><br>
<i>end</i> = <code>"cog"</code><br>
<i>dict</i> = <code>["hot","dot","dog","lot","log"]</code><br>
</p>
<p>
As one shortest transformation is <code>"hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog"</code>,<br>
return its length <code>5</code>.
</p>

<p>
<b>Note:</b><br>
</p><ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
</ul>
<p></p><p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is an extremely difficult question</strong>.</p>

<h3>Solution</h3>

<ol>
<li><p>This question is <strong>find shortest path</strong>, so we shall choose <strong>BFS</strong> over DFS.</p></li>
<li><p>Since finding an element in HashSet is O(1) time, <strong>we can generate all the possible strings of distance = 1</strong> and check if they are in the dictionary. In this way, we reduce time complexity from O(m x n) to O(m x 26).</p></li>
<li><p>If a word is found from the dictionary, remove it.</p></li>
</ol>


<p><strong>For the 3rd point, we remove the word from dict</strong>. It might be hard to understand. <a href="http://blog.csdn.net/zxzxy1988/article/details/8591890">This blog</a> explains it clear enough.</p>

<blockquote cite="http://blog.csdn.net/zxzxy1988/article/details/8591890">
另外一个需要注意的地方就是，如果我们曾经遍历过某个元素，我会将其从字典中删除，以防以后再次遍历到这个元素。这里有几种情况：<br><br>
1.以后再也遍历不到这个元素，那么我们删除它当然没有任何问题。<br><br>
2.我们以后会遍历到该元素，又分为两种情况：<br><br>
(1)在本层我们就能遍历到该元素。也就是说，我们到达这个元素有两条路径，而且它们都是最短路径。<br><br>
对于本题来说，是没有什么影响的，因为到dog距离都是3，到dig距离都是4。但是后面我们做word ladder 2的时候，如果没有考虑这个情况，将是非常致命的，因为题目要求输出最短路径的所有情况<br><br>
(2)在更下层我们才能够遍历到该元素。比如hot-&gt;dot-&gt;dog-&gt;dig和hot-&gt;hat-&gt;dat-&gt;dag-&gt;dog-&gt;dig，如果第一次我们找到了dog并且将其删除，那么第二次我们实际上是找不到这个元素的。这样对于本题来说，没有任何影响。对于word ladder 2来说，因为也是要输出最短路径，所以也不会有任何影响。<br><br>
</blockquote>


<h3>Code</h3>

<p><strong>BFS solution</strong></p>

<p>This is similar to the code posted in <a href="http://www.programcreek.com/2012/12/leetcode-word-ladder/">this article</a>.</p>

<pre><code>public int ladderLength(String start, String end, HashSet&lt;String&gt; dict) {
    if (start.equals(end)) return 1;
    LinkedList&lt;String&gt; words = new LinkedList&lt;String&gt;();
    LinkedList&lt;Integer&gt; nums = new LinkedList&lt;Integer&gt;();
    words.add(start);
    nums.add(1);
    while (!words.isEmpty()) {
        String word = words.remove();
        int num = nums.remove();
        // otherwise, change each char in word, and find it from dict
        char[] charArr = word.toCharArray();
        for (int i = 0; i &lt; charArr.length; i++) {
            char originChar = charArr[i];
            for (char j = 'a'; j &lt;= 'z'; j++) {
                charArr[i] = j;
                String newWord = new String(charArr);
                if (newWord.equals(end))
                    return num + 1;
                if (dict.contains(newWord)) {
                    dict.remove(newWord);
                    words.add(newWord);
                    nums.add(num + 1);
                }
            }
            charArr[i] = originChar;
        }
    }
    return 0;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/29/Surrounded-Regions/">[LeetCode 130] Surrounded Regions</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-29T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/29/Surrounded-Regions/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/surrounded-regions/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a 2D board containing <code>'X'</code> and <code>'O'</code>, capture all regions surrounded by <code>'X'</code>.</p>

<p>A region is captured by flipping all <code>'O'</code>s into <code>'X'</code>s in that surrounded region.
</p>

<p>
For example,<br>
</p><pre>X X X X
X O O X
X X O X
X O X X
</pre>
<p></p>

<p>
After running your function, the board should be:
</p><pre>X X X X
X X X X
X X X X
X O X X
</pre>
<p></p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question can be solved by DFS or BFS search</strong>.</p>

<p><strong>The idea is simple</strong>. For each edge nodes, if it is an &lsquo;O&rsquo;, search for all connected &lsquo;O&rsquo;s and mark it. My first attemps used another array to store result. It works, but it&rsquo;s actually bad, because space usage is huge. We can actually mark the connected nodes using some special character, for example in my case, &#8216;R&rsquo;. Then the solution can work in-place.</p>

<p>So this is the standard solution.</p>

<h3>Solution</h3>

<p>However, there is <strong>one big problem</strong> with my DFS solution.</p>

<p><strong>For super-large test cases, it gets &lsquo;java.lang.StackOverflowError&rsquo; exception</strong>. It&rsquo;s very werid to me, until I read <a href="https://oj.leetcode.com/discuss/1723/my-code-can-not-pass-this-longest-case">this blog</a>.</p>

<blockquote><p>If you use DFS Recursive, you will get Runtime Error. But if you implement DFS by stack, just like doing BFS by Queue, your code will get accepted.</p>

<p>Recursive dfs would take too much resource (too many calls which require space to store the calling state) than bfs for long long case. Considering one of test case with 200x200 matrix, in worst case the longest path (number of calls) might take 200x200 = 40,000 long. While with bfs, the maximal calls are about less than 400.</p></blockquote>

<p>One more thing, so <strong>DFS with stack, or BFS with queue, which one would consume less space</strong>? I think BFS. The difference is DFS space usage is max depth, while BFS is the max width. However in this question, each node have 4 adjacent nodes, so the DFS space usage would be increased to 3 x (max depth). More details on this topic, please refer to <strong>DFS, BFS and space efficiency</strong>.</p>

<p>If any reader have an idea on this, please comment!</p>

<h3>Code</h3>

<p><strong>bfs code realized with a queue</strong></p>

<pre><code>public void solve(char[][] board) {
    if (board.length == 0) return;
    int m = board.length, n = board[0].length;
    for (int i = 0; i &lt; m; i ++) {
        dfs(board, i, 0);
        dfs(board, i, n-1);
    }
    for (int j = 0; j &lt; n; j ++) {
        dfs(board, 0, j);
        dfs(board, m-1, j);
    }
    for (int i = 0; i &lt; m; i ++) 
        for (int j = 0; j &lt; n; j ++) 
            if (board[i][j] == 'R') 
                board[i][j] = 'O';
            else if (board[i][j] == 'O') 
                board[i][j] = 'X';
}

private void dfs(char[][] board, int x, int y) {
    int m = board.length, n = board[0].length;
    Queue&lt;Integer&gt; aa = new LinkedList&lt;Integer&gt;();
    Queue&lt;Integer&gt; bb = new LinkedList&lt;Integer&gt;();
    aa.add(x);
    bb.add(y);
    while (!aa.isEmpty()) {
        int a = aa.remove();
        int b = bb.remove();
        if (a &lt; 0 || a &gt;= m || b &lt; 0 || b &gt;= n) 
            continue;
        if (board[a][b] == 'X' || board[a][b] == 'R') 
            continue;
        board[a][b] = 'R';

        aa.add(a - 1);
        bb.add(b);
        aa.add(a + 1);
        bb.add(b);
        aa.add(a);
        bb.add(b - 1);
        aa.add(a);
        bb.add(b + 1);
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/29/Sum-Root-to-Leaf-Numbers/">[LeetCode 129] Sum Root to Leaf Numbers</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-29T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/29/Sum-Root-to-Leaf-Numbers/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/sum-root-to-leaf-numbers/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p>

<p>Find the total sum of all root-to-leaf numbers.</p>

<p>For example,
</p><pre>    1
   / \
  2   3
</pre>
<p></p>
<p>
The root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.<br>
The root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.
</p>
<p>
Return the sum = 12 + 13 = <code>25</code>.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">10 minutes</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is DFS standard question</strong>.</p>

<h3>Solution</h3>

<p>I posted 2 pieces of my code, and 1 best code (from <a href="http://blog.sina.com.cn/s/blog_b9285de20101iv6l.html">this blog</a>).</p>

<h3>Code</h3>

<p><strong>First, my solution using List</strong>.</p>

<pre><code>int sum = 0;

public int sumNumbers(TreeNode root) {
    dfs(root, new LinkedList&lt;Integer&gt;());
    return sum;
}

private void dfs(TreeNode node, LinkedList&lt;Integer&gt; list) {
    if (node == null) return;
    if (node.left == null &amp;&amp; node.right == null) {
        int num = 0;
        for (int i = 0; i &lt; list.size(); i ++) 
            num = num * 10 + list.get(i);
        sum += num * 10 + node.val;
        return;
    }
    // if node is not null, not a leaf
    list.add(node.val);
    dfs(node.left, list);
    dfs(node.right, list);
    list.remove(list.size() - 1);
}
</code></pre>

<p><strong>Second, previous code refactored, without using list</strong>, because it&rsquo;s not necessary to know the previous path.</p>

<pre><code>int sum = 0;
public int sumNumbers(TreeNode root) {
    dfs(root, 0);
    return sum;
}

private void dfs(TreeNode node, int preVal) {
    if (node == null) return;
    int curVal = preVal * 10 + node.val;
    if (node.left == null &amp;&amp; node.right == null) {
        int num = 0;
        sum += curVal;
        return;
    }
    // if node is not null, not a leaf
    dfs(node.left, curVal);
    dfs(node.right, curVal);
}
</code></pre>

<p><strong>Third, best solution</strong></p>

<pre><code>public int sumNumbers(TreeNode root) {
    return dfs(root,0);
}

int dfs(TreeNode root, int sum){
    if(root==null) return 0;
    sum=sum*10+root.val;
    if(root.left==null &amp;&amp; root.right==null) return sum;
    return dfs(root.left,sum) + dfs(root.right,sum);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/29/Palindrome-Partitioning/">[LeetCode 131] Palindrome Partitioning</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-29T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/29/Palindrome-Partitioning/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/palindrome-partitioning/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a string <i>s</i>, partition <i>s</i> such that every substring of the partition is a palindrome.
</p>
<p>
Return all possible palindrome partitioning of <i>s</i>.
</p>
<p>
For example, given <i>s</i> = <code>"aab"</code>,<br>

Return
</p><pre>  [
    ["aa","b"],
    ["a","a","b"]
  ]
</pre>
<p></p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is an extremely classic question</strong>.</p>

<p>It&rsquo;s not very hard to solve, although it looked impossible at first.</p>

<h3>Solution</h3>

<p><strong>The solution is DFS</strong>.</p>

<p>It&rsquo;s very standard DFS code, I will not go into coding details. This type of &ldquo;return all possible path&rdquo; question is always related to DFS, keep this in mind!</p>

<p>The code is borrowing ideas from <a href="http://blog.sina.com.cn/s/blog_b9285de20101jbtl.html">peking2&rsquo;s blog</a>. He also had an <strong>analysis on this series of questions</strong>:</p>

<blockquote><p>我觉得一般有三种变形，解法各有不同。</p>

<ol>
<li>最后结果是一个整数，比如Palindrome Partitioning II。这个用DP来解</li>
<li>最后求一个结果，比如最小切法。这个用DP＋backtrack来解</li>
<li>求所有的结果。这个一般用DFS来解。</li>
</ol>
</blockquote>

<p>This question is the 3rd case. <a href="http://fisherlei.blogspot.sg/2013/03/leetcode-palindrome-partitioning.html">Fish Lei</a> also said the same.</p>

<blockquote><p>这种需要输出所有结果的基本上都是DFS的解法</p></blockquote>

<h3>Code</h3>

<pre><code>public ArrayList&lt;ArrayList&lt;String&gt;&gt; partition(String s) {
    // int len = s.length();
    ArrayList&lt;ArrayList&lt;String&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;String&gt;&gt;();
    helper(ans, new ArrayList&lt;String&gt;(), s, 0);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;String&gt;&gt; ans, ArrayList&lt;String&gt; cur, 
        String s, int start) {
    int len = s.length();
    if (start == len) {
        ans.add(new ArrayList&lt;String&gt;(cur));
        return;
    }
    for (int i = start + 1; i &lt;= len; i ++) {
        String sub = s.substring(start, i);
        if (isPal(sub)) {
            cur.add(sub);
            helper(ans, cur, s, i);
            cur.remove(cur.size() - 1);
        }
    }
}

private boolean isPal(String str) {
    int left = 0, right = str.length() - 1;
    while (left &lt; right) {
        if (str.charAt(left) != str.charAt(right)) 
            return false;
        left++;
        right--;
    }
    return true;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/29/Longest-Consecutive-Sequence/">[LeetCode 128] Longest Consecutive Sequence</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-29T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/29/Longest-Consecutive-Sequence/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/longest-consecutive-sequence/">link</a></p>

<div class="question-content">
            <p></p><p>
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
</p>
<p>
For example,<br>
Given <code>[100, 4, 200, 1, 3, 2]</code>,<br>
The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Return its length: <code>4</code>.
</p>
<p>
Your algorithm should run in O(<i>n</i>) complexity.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">just coding is easy</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>I did not solve this question</strong>. We are going to make use of <strong>HashSet</strong>.</p>

<p>Information on HashSet from <a href="http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html">official document</a>:</p>

<blockquote><p><strong>java.util.HashSet</strong></p>

<p>This class <strong>implements the Set interface</strong>, backed by a <strong>hash table</strong> (actually a HashMap instance). It makes no guarantees as to the <strong>iteration order</strong> of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the <strong>null element</strong>.</p>

<p>This class offers <strong>constant time performance</strong> for the basic operations (add, remove, contains and size), assuming the hash function disperses the elements properly among the buckets. Iterating over this set requires time proportional to the sum of the HashSet instance&rsquo;s size (the number of elements) plus the &ldquo;capacity&rdquo; of the backing HashMap instance (the number of buckets). Thus, it&rsquo;s very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.</p>

<p>Note that this implementation is <strong>not synchronized</strong>. If multiple threads access a hash set concurrently, and at least one of the threads modifies the set, it must be synchronized externally.</p></blockquote>

<p><strong>To summarize it, HashSet</strong>:</p>

<ol>
<li><p>implements Set interface</p></li>
<li><p>implemented by using a hash table</p></li>
<li><p>un-ordered</p></li>
<li><p>add, remove and contains methods have constant time O(1)</p></li>
<li><p>can have null element</p></li>
<li><p>not sync</p></li>
</ol>


<h3>Solution</h3>

<p><strong>Well explained in <a href="http://stackoverflow.com/a/7453295">this site</a></strong>.</p>

<blockquote><p>Dump everything to a hash set.</p>

<p>Now go through the hashset. For each element, look up the set for all values neighboring the current value. Keep track of the largest sequence you can find, while removing the elements found from the set. Save the count for comparison.</p>

<p>Repeat this until the hashset is empty.</p>

<p>Assuming lookup, insertion and deletion are O(1) time, this algorithm would be O(N) time.</p></blockquote>

<p><strong>Updated on July 4th, 2014</strong>: Look at the 2nd for-loop. Here if I do &lsquo;for (Integer in: set)&rsquo; to iterate all numbers, I will get &ldquo;java.util.ConcurrentModificationException &rdquo;. This is because we are iterating while modifying. <strong>The most tricky part of this solution is iteration thru the array</strong>, instead of the set. Take note of that!</p>

<h3>Code</h3>

<pre><code>public int longestConsecutive(int[] num) {
    int longest = 1;
    HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
    for (Integer in: num) set.add(in);
    for (Integer in: num) {
        int left = in - 1, right = in + 1;
        while (set.contains(left)) {
            set.remove(left);
            left --;
        }
        while (set.contains(right)) {
            set.remove(right);
            right ++;
        }
        longest = Math.max(longest, right - left - 1);
    }
    return longest;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/29/DFS-BFS-space-efficiency/">[Design] DFS, BFS and Space Efficiency</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-29T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/29/DFS-BFS-space-efficiency/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>First Word</h3>

<p>This post talks about BFS, DFS and space efficiency.</p>

<h3>Analysis</h3>

<p><strong>For BFS</strong> it&rsquo;s easy to understand. It is implemented with a queue. <strong>Space usage is O(width)</strong></p>

<p><strong>For DFS</strong>, there are 2 types: true DFS and pseudo-DFS. True DFS space usage is <strong>O(depth)</strong>, while psudo-DFS is <strong>O(depth x <a href="http://en.wikipedia.org/wiki/Branching_factor">branching factor</a>)</strong>.</p>

<blockquote><p><strong>branching factor</strong> is the number of children at each node, the outdegree.</p></blockquote>

<p>Pseudo-DFS is implemented by <strong>simply take the BFS implementation and replace the Queue with Stack</strong>. But true-DFS is a very different algorithm where the <strong>stack is use for backtracking only</strong>. <a href="http://stackoverflow.com/a/20429574">This</a> is a great article talking about this topic.</p>

<blockquote><p>the true classic DFS cannot be obtained from BFS by such queue-to-stack replacement. The classic DFS is a completely different algorithm with significantly different inner structure. True DFS is a genuinely recursive algorithm that uses stack for backtracking purposes, not for storing the vertex discovery &ldquo;front&rdquo; (as is the case in BFS)</p></blockquote>

<p><strong>The following quoted texts are also worth-reading</strong>.</p>

<blockquote><p>Something worth noting &ndash; Pseudo-DFS should give you O(depth * branching factor) space, as opposed to O(depth) for proper DFS, which is still better than O(width).</p>

<p>The defining characteristic that separates true DFS and what you call pseudo DFS is how they use the stack. True DFS use it to store backtracking information in contrast to pseudo DFS which used the stack to store the vertex discovery front.</p></blockquote>

<h3>Examples</h3>

<p><strong>Given a perfect binary search tree of 4 levels</strong>. BFS would require 8 space, while DFS requires only 4 space. The branching factor is 2, so true and pseudo DFS use same amount of space.</p>

<p><strong>Given a star graph</strong>: a single central vertex surrounded by 1000 peripheral vertices, with each connected to the central vertex. If we run BFS on this graph, the queue size will immediately jump to 1000. The same thing happens for pseudo-DFS. But classic DFS algorithm will need stack depth of only 1 (!) to traverse this entire graph.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="48">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="46">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (76)</a></li>
<li class='category'><a href='/blog/categories/experience/'>experience (4)</a></li>
<li class='category'><a href='/blog/categories/fundamental/'>fundamental (11)</a></li>
<li class='category'><a href='/blog/categories/java-oop/'>java oop (30)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (176)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (25)</a></li>
<li class='category'><a href='/blog/categories/q-facebook/'>q-facebook (9)</a></li>
<li class='category'><a href='/blog/categories/q-google/'>q-google (62)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (124)</a></li>
<li class='category'><a href='/blog/categories/string-search/'>string search (17)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (7)</a></li>
<li class='category'><a href='/blog/categories/top-k/'>top k (5)</a></li>
<li class='category'><a href='/blog/categories/-top-k-/'>~top k~ (1)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/09/02/Facebook-photo-storage/">[Design] Facebook Photo Storage </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/30/how-google-search-works/">[Design] How Google search works </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/30/design-class4-2/">[NineChap System Design] Class 4.2: Search Engine </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/30/design-class4-1/">[NineChap System Design] Class 4.1: Crawler </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/28/design-class3-2/">[NineChap System Design] Class 3.2: Web Service </a>
      </li>
    
  </ul>
</section>





<script type="text/javascript" src="http://srvpub.com/adServe/banners?tid=29011_41781_0&size=120x600" ></script>

<!--
<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"willran168","width":160,"height":600,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>
<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>
&#8211;>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
    Copyright &copy; 2015 - <a href="/about">CodeMonkey</a> -  All posts are my original writing, based uppon my personal view. <a href="/policy">Privacy Policy</a> - 
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
