
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Shuatiblog.com</title>
  <meta name="author" content="CodeMonkey">

  
  <meta name="description" content="Question link Four rectangles are given. Find the smallest enclosing (new) rectangle into which these four may be fitted without overlapping. By &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.shuatiblog.com/posts/10/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Shuatiblog.com" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.shuatiblog.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="blue_light">
            Shuatiblog.com
        </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/29/Packing-Rectangles/">[Question] Packing Rectangles</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-29T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/29/Packing-Rectangles/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://olympiads.win.tue.nl/ioi95/task/pack.html">link</a></p>

<blockquote><p>Four rectangles are given. Find the smallest enclosing (new) rectangle into which these four may be fitted without overlapping. By smallest rectangle we mean the one with the smallest area.</p></blockquote>

<p><img class="middle" src="/assets/images/packing-rect.gif"></p>

<h3>Greedy</h3>

<p><a href="http://stackoverflow.com/a/1213571">Greedy</a> placement from <strong>large (area) to small</strong>.</p>

<ol>
<li>Put the largest rectangle remaining into your packed area.</li>
<li>If it can&rsquo;t fit anywhere, place it in a place that extends the pack region as little as possible.</li>
<li>Repeat until you finish with the smallest rectangle.</li>
</ol>


<h3>Optimal Solution</h3>

<p><a href="http://stackoverflow.com/a/4264497">There is a trade-off</a> between implementation complexity/time and optimality, but there is a wide range of algorithms to choose from.</p>

<p>Below is quoted:</p>

<blockquote>
    <div class="post-text" itemprop="text">
<ol>
<li><p>First-Fit Decreasing Height (FFDH) algorithm<br>
FFDH packs the next item R (in non-increasing height) on the first level where R fits. If no level can accommodate R, a new level is created.<br>
Time complexity of FFDH: O(n·log n).<br>
Approximation ratio: FFDH(I)&lt;=(17/10)·OPT(I)+1; the asymptotic bound of 17/10 is tight.</p></li>
<li><p>Next-Fit Decreasing Height (NFDH) algorithm<br>
NFDH packs the next item R (in non-increasing height) on the current level if R fits. Otherwise, the current level is &#8220;closed&#8221; and a new level is created.<br>
Time complexity: O(n·log n).<br>
Approximation ratio: NFDH(I) &lt;= 2·OPT(I)+1; the asymptotic bound of 2 is tight.</p></li>
<li><p>Best-Fit Decreasing Height (BFDH) algorithm<br>
BFDH packs the next item R (in non-increasing height) on the level, among those that can accommodate R, for which the residual horizontal space is the minimum. If no level can accommodate R, a new level is created. </p></li>
<li><p>Bottom-Left (BL) Algorithm<br>
BL first order items by non-increasing width. BL packs the next item as near to the bottom as it will fit and then as close to the left as it can go without overlapping with any packed item. Note that BL is not a level-oriented packing algorithm.<br>
Time complexity: O(n^2).<br>
Approximation ratio: BL(I) &lt;= 3·OPT(I).  </p></li>
<li><p>Baker&#8217;s Up-Down (UD) algorithm<br>
UD uses a combination of BL and a generalization of NFDH. The width of the strip and the items are normalized so that the strip is of unit width. UD orders the items in non-increasing width and then divides the items into five groups, each with width in the range (1/2, 1], (1/3,1/2], (1/4,1/3], (1/5,1/4], (0,1/5]. The strip is also divided into five regions R1, ··· , R5. Basically, some items of width in the range (1/i+1, 1/i], for 1 &lt;= i &lt;= 4, are packed to region Ri by BL. Since BL leaves a space of increasing width from top to bottom at the right side of the strip, UD takes this advantage by first packing the item to Rj for j = 1, ··· , 4 (in order) from top to bottom. If there is no such space, the item is packed to Ri by BL. Finally, items of size at most 1/5 are packed to the spaces in R1, ··· , R4 by the (generalized) NFDH algorithm. Again if there is no space in these regions, the item is packed to R5 using NFDH.<br>
Approximation ratio: UD(I) &lt;= (5/4) · OPT(I)+(53/8)H, where H is the maximum height of the items; the asymptotic bound of 5/4 is tight.</p></li>
<li><p>Reverse-fit (RF) algorithm<br>
RF also normalizes the width of the strip and the items so that the strip is of unit width. RF first stacks all items of width greater than 1/2. Remaining items are sorted in non-increasing height and will be packed above the height H0 reached by those greater than 1/2. Then RF repeats the following process. Roughly speaking, RF packs items from left to right with their bottom along the line of height H0 until there is no more room. Then packs items from right to left and from top to bottom (called reverse-level) until the total width is at least 1/2. Then the reverse-level is dropped down until (at least) one of them touches some item below. The drop down is somehow repeated.<br>
Approximation ratio: RF(I) &lt;= 2·OPT(I).</p></li>
<li><p>Steinberg&#8217;s algorithm<br>
Steinberg&#8217;s algorithm, denoted as M in the paper, estimates an upper bound of the height H required to pack all the items such that it is proved that the input items can be packed into a rectangle of width W and height H. They then define seven procedures (with seven conditions), each to divide a problem into two smaller ones and solve them recursively. It has been showed that any tractable problem satisfies one of the seven conditions.<br>
Approximation ratio: M(I) &lt;= 2·OPT(I).</p></li>
<li><p>Split-Fit algorithm (SF)
SF divides items into two groups, L1 with width greater than 1/2 and L2 at most 1/2. All items of L1 are first packed by FFDH. Then they are arranged so that all items with width more than 2/3 are below those with width at most 2/3. This creates a rectangle R of space with width 1/3. Remaining items in L2 are then packed to R and the space above those packed with L1 using FFDH. The levels created in R are considered to be below those created above the packing of L1.<br>
Approximation ratio: SF(I) &lt;= (3/2) ·OPT(I) + 2; the asymptotic bound of 3/2 is tight.</p></li>
<li><p>Sleator&#8217;s algorithm<br>
Sleater&#8217;s algorithm consists of four steps:</p>

<ol>
<li><p>All items of width greater than 1/2 are packed on top of one another in the bottom of the strip. Suppose h0 is the height of the resulting packing All subsequent packing will occur above h0.</p></li>
<li><p>Remaining items are ordered by non-increasing height. A level of items are packed (in non-increasing height order) from left to right along the line of height h0. </p></li>
<li><p>A vertical line is then drawn in the middle to cut the strip into two equal halves (note this line may cut an item that is packed partially in the right half). Draw two horizontal line segments of length one half, one across the left half (called the left baseline) and one across the right half (called the right baseline) as low as possible such that the two lines do not cross any item.</p></li>
<li><p>Choose the left or right baseline which is of a lower height and pack a level of items into the corresponding half of the strip until the next item is too wide.</p></li>
</ol>

<p>A new baseline is formed and Step (4) is repeated on the lower baseline until all items are packed.<br>
Time complexity: O(n ·log n).<br>
The approximation ratio of Sleator&#8217;s algorithm is 2.5 which is tight.</p></li>
</ol>
    </div>
</blockquote>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/28/two-dimensional-knapsack-problem/">[Question] Two Dimensional Knapsack Problem</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/28/two-dimensional-knapsack-problem/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://blog.sina.com.cn/s/blog_8a24b3a3010190ak.html">link</a></p>

<blockquote><p>给定n种物品和一背包。物品i的重量是wi，体积是bi，其价值为vi，背包的容量为C，容积为D。问应如何选择装入背包中的物品，使得装入背包中物品的总价值最大？</p>

<p>在选择装入背包的物品时，对每种物品i只有两种选择，即装入背包或者不装入背包。不能将物品i装入背包多次，也不能只装入部分的物品i。试设计一个解此问题的动态规划算法，并分析算法的计算复杂性。</p></blockquote>

<h3>Analysis</h3>

<p>This is a extended question from <strong>[Question] 0-1 Knapsack Problem</strong>.</p>

<p>Same solution, just use 3D-array for DP.</p>

<h3>Solution</h3>

<p>First of all, define a 2D array, Knapsack(n,W) denotes getting &lsquo;n&#8217;th item, with weight &#8216;W&rsquo;. When n == 0 or W = 0, dp value is 0.</p>

<blockquote><p>int[][][] dp = new int[n + 1][W + 1][B + 1];</p></blockquote>

<p>Now if item &lsquo;n&rsquo; is able to fit in:</p>

<blockquote><p>dp[i][j][k] = max(dp[i-1][j][k] , dp[i-1][j-w[i]][k-b[i]] + v[i]);</p></blockquote>

<p>If not able to fit in:</p>

<blockquote><p>dp[i][j][k] = dp[i-1][j][k];</p></blockquote>

<h3>Code</h3>

<p>Code from <a href="http://blog.sina.com.cn/s/blog_8a24b3a3010190ak.html">绝对快乐一生</a>:</p>

<pre><code>int main()
{
   int i,j,k;
   int n,c,d;
   int w[MAX] = {0};   //重量
   int b[MAX] = {0};   //体积
   int v[MAX] = {0};   //价值
   cout&lt;&lt;"请输入物品个数:";
   cin&gt;&gt;n;
   cout&lt;&lt;"请输入背包的容量及容积:";
   cin&gt;&gt;c&gt;&gt;d;
   cout&lt;&lt;"请依次输入各个物品的重量,体积,价值:(共"&lt;&lt;n&lt;&lt;"个)"&lt;&lt;endl;
   for(i =1;i&lt;n+1;i++)
   {
       cin&gt;&gt;w[i]&gt;&gt;b[i]&gt;&gt;v[i];
   }

   int dp[50][50][50]={0}; 
   //dp[i][j][k] i代表着第1到第i个物品，j代表的是重量，k代表的是容积，dp为最优价值

   for(i=1;i&lt;n+1;i++)
       for(j =1;j &lt;=c;j++)
           for(k = 1 ;k &lt;= d ; k++)
           {
               if(w[i]&lt;=j&amp;&amp;b[i]&lt;=k)  
               //当前物品重量小于当前容量，且体积小于容积时 ，才可以考虑装入物品的问题
                   dp[i][j][k] = max(dp[i-1][j][k] , dp[i-1][j-w[i]][k-b[i]] + v[i]);
               else dp[i][j][k] = dp[i-1][j][k];
           }
   cout&lt;&lt;"背包能放物品的最大价值为:"&lt;&lt;dp[n][c][d]&lt;&lt;endl;
  int x[MAX] ={0};   //记录是否被选中
  for(i =n;i&gt;1;i--)
       if(dp[i][c][d]==dp[i-1][c][d])x[i] =0;
      else {x[i]=1;c -= w[i];d -= b[i];}
   x[1]=(dp[1][c][d])?1:0;
   cout&lt;&lt;"被选入背包的物品的编号,质量和体积,价值分别是:"&lt;&lt;endl;
   for(i=1;i&lt;&lt;/span&gt;n+1;i++)
       if(x[i]==1)
           cout&lt;&lt;"第"&lt;&lt;i&lt;&lt;"个物品: "&lt;&lt;w[i]&lt;&lt;"  "&lt;&lt;b[i]&lt;&lt;"  "&lt;&lt;v[i]&lt;&lt;endl;

}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/28/implement-trie-suffix-tree/">[Fundamental] Implement Trie and Suffix Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-28T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/28/implement-trie-suffix-tree/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Trie Node</h3>

<pre><code>public class TrieNode {
    boolean isLeaf;
    TrieNode[] child;

    public TrieNode(boolean isLeaf) {
        this.isLeaf = isLeaf;
        this.child = new TrieNode[26];
    }

    public void insert(String str) {
        if (str == null || str.length() == 0) {
            this.isLeaf = true;
            return;
        }
        char cur = str.charAt(0);
        if (child[cur - 'a'] == null) {
            child[cur - 'a'] = new TrieNode(str.length() == 1);
        }
        child[cur - 'a'].insert(str.substring(1));
    }

    public boolean trieSearch(String str) {
        // have to consider leaf node
        if (str == null || str.length() == 0) {
            return isLeaf;
        }
        char cur = str.charAt(0);
        if (child[cur - 'a'] == null) {
            return false;
        }
        return child[cur - 'a'].trieSearch(str.substring(1));
    }

    public boolean suffixTreeSearch(String str) {
        // suffixTreeSearch don't consider leaf node
        // cuz we search for prefix of suffixes
        if (str == null || str.length() == 0) {
            return true;
        }
        char cur = str.charAt(0);
        if (child[cur - 'a'] == null) {
            return false;
        }
        return child[cur - 'a'].suffixTreeSearch(str.substring(1));
    }
}
</code></pre>

<h3>Trie</h3>

<pre><code>public class Trie {
    TrieNode root;

    public Trie(String[] input) {
        root = new TrieNode(false);

        for (String str : input) {
            root.insert(str);
        }
    }

    public boolean search(String query) {
        return root.trieSearch(query);
    }
}
</code></pre>

<h4>Suffix Tree</h4>

<p>Suffix tree might also consider the <strong>List of indexes</strong> thing, which I do not take into consideration in my code.</p>

<pre><code>public class SuffixTree {
    TrieNode root;

    public SuffixTree(String input) {
        root = new TrieNode(false);

        for (int i = 0; i &lt; input.length(); i++) {
            root.insert(input.substring(i));
        }
    }

    public boolean search(String query) {
        return root.suffixTreeSearch(query);
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/27/suffix-tree/">[Fundamental] Suffix Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-27T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/27/suffix-tree/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.geeksforgeeks.org/pattern-searching-set-8-suffix-tree-introduction/">ref</a></p>

<h3>Suffix tree</h3>

<p>Both KMP Algorithm and Rabin Karp Algorithm <strong>pre-process the pattern</strong> to make the pattern searching faster. The best time complexity that we could get by preprocessing pattern is <strong>O(n), where n is length of the text</strong>.</p>

<p>Now we will discuss an approach that <strong>pre-processes the text</strong>. A suffix tree is built of the text. After preprocessing text (building suffix tree of text), we can <strong>search any pattern in O(m) time</strong> where m is length of the pattern.</p>

<p>Though search is very fast &ndash; just proportional to length of the pattern, it may become costly if <strong>the text changes frequently</strong>. It is good for fixed text or less frequently changing text though.</p>

<h4>Suffix Tree VS. Trie</h4>

<p><strong>A Suffix Tree is a compressed trie of all suffixes of the given text</strong>.</p>

<h4>Compressed Trie</h4>

<p><strong>A Compressed Trie</strong> is obtained from standard trie by joining chains of single nodes.</p>

<p>Example, a standard trie:</p>

<p><img class="middle" src="/assets/images/standardtrieNew.png"></p>

<p>A Compressed Trie:</p>

<p><img class="middle" src="/assets/images/CompressedTrieNew.png"></p>

<h4>build a Suffix Tree</h4>

<ol>
<li>Generate all suffixes of given text.</li>
<li>Consider all suffixes as individual words and build a compressed trie.</li>
</ol>


<p>Eg.</p>

<pre><code>banana\0
anana\0
nana\0
ana\0
na\0
a\0
\0
</code></pre>

<p>Example question: <strong>[CC150v4] 20.8 Full Text Search (Suffix Tree)</strong></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/27/suffix-array/">[Fundamental] Suffix Array</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-27T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/27/suffix-array/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.geeksforgeeks.org/suffix-array-set-1-introduction/">ref</a></p>

<h3>Suffix Array</h3>

<p>A suffix array is a sorted array of all suffixes of a given string.</p>

<p><strong>Any suffix tree based algorithm</strong> can be replaced with an algorithm <strong>that uses a suffix array</strong> enhanced with additional information and solves the same problem in the same time complexity.</p>

<p><strong>Naive algorithm</strong> for construction of suffix array is to consider all suffixes, sort them using a O(nLogn) sorting algorithm and while sorting, maintain original indexes. Time complexity is _O(n<sup>2</sup> * Logn)__.</p>

<p>There is an advanced <strong>nLogn Algorithm</strong> algorithm available to read <a href="http://www.geeksforgeeks.org/suffix-array-set-2-a-nlognlogn-algorithm/">here</a>. Basic idea is to &ldquo;Sort according to first two characters&rdquo; and then &ldquo;according to first four character&rdquo;.</p>

<p>Example question: <strong>[Facebook] Query Search (HashMap, suffix array)</strong>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/27/prefix-tree/">[Fundamental] Prefix Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-27T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/27/prefix-tree/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.geeksforgeeks.org/trie-insert-and-search/">ref</a></p>

<h3>Prefix tree</h3>

<ol>
<li>Building a well balanced BST needs time proportional to M * log N, where M is maximum string length and N is number of keys in tree.</li>
<li>Using trie, search in O(M) time.</li>
<li>The penalty is on trie storage requirements.</li>
</ol>


<h3>Implementation</h3>

<ol>
<li>Every node of trie consists of multiple branches.</li>
<li>Each branch represents a possible character of keys.</li>
<li><p>Mark the last node of every key as leaf node.</p>

<p> struct trie_node
 {
     int value; /<em> Used to mark leaf nodes </em>/
     trie_node_t *children[ALPHABET_SIZE];
 };</p></li>
</ol>


<p>Note that a <strong>non-terminating node can also be marked as leaf</strong>. Eg.</p>

<pre><code>                   root
                /   \    \
                t  'a'    b
                |   |     |
                h   n    'y'
                |   |  \    \
               'e'  s  'y'  'e'
             /  |   |
            i   r   w
           /    |   |
         'r'   'e'  e
                    |
                   'r'
</code></pre>

<p>The leaf nodes are quoted in &lsquo;&rsquo;.</p>

<p>Insert and search costs <strong>O(key_length)</strong>, however the memory requirements of trie is <strong>O(ALPHABET_SIZE * key_length * N)</strong> where N is number of keys in trie.</p>

<p><strong>Compressed trie</strong>, ternary search tree, etc. can be used to minimize memory requirements of trie.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/27/pattern-searching-algorithms/">[Fundamental] Pattern Searching Algorithms</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-27T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/27/pattern-searching-algorithms/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.geeksforgeeks.org/tag/pattern-searching/page/2/">ref</a></p>

<h3>Overview</h3>

<p>strStr() is a classic question in CS. There are various ways to solve (which we have discussed before), this is a summarization:</p>

<ol>
<li><p>naive &ndash; O(m * n)</p></li>
<li><p><a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/">KMP</a> &ndash; O(n) in worst case</p></li>
<li><p><a href="http://www.geeksforgeeks.org/searching-for-patterns-set-3-rabin-karp-algorithm/">Rabin-Karp</a>, rolling hash &ndash; between O(m * n) and O(m + n)</p>

<p> Matches the hash value of the pattern with the hash value of pattern. If the hash values match, then only it starts matching individual characters.</p></li>
<li><p><a href="http://www.geeksforgeeks.org/pattern-searching-set-4-a-naive-string-matching-algo-question/">Modified naive algo</a>, only work if pattern contains no duplicate characters.</p>

<p> Only match the first char. This case is quite boring, can skip.</p></li>
<li><p>Suffix tree</p>

<p> Will discuss in details.</p></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/27/generate-request-id/">[Google] Generate Request ID</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-27T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/27/generate-request-id/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=5169800024162304">link</a></p>

<blockquote><p>Design a system to <strong>return an unique ID for each request</strong>.</p>

<p>(For most of requests, the ID value should increase as time goes, the system should handle 1000 requests per second at least. )</p>

<p>Note: <strong>Timestamps</strong> alone is not valid since there might be multiple requests with same timestamps.</p></blockquote>

<h3>Idea 1</h3>

<h4>Generating UUID</h4>

<p><strong>A universally unique identifier (UUID)</strong> is an identifier standard used in software construction. A UUID is simply a 128-bit value.</p>

<p>Generating unique IDs is easy. All modern OS&#8217;es have that functionality built in.</p>

<p><strong>Detail</strong>: UUIDs may be generated from a combination of <strong>system time stamp, CPU/system ID</strong>, NIC MAC addresses, HBA WWNs, server id etc.</p>

<h4>Clarifications</h4>

<p>Let&rsquo;s assume the following:</p>

<ol>
<li><p>What&rsquo;s the length of the ID?</p>

<p> &lt;= 128 bits. In that case I&rsquo;ll choose the standard 128 bit UUID format.</p></li>
<li><p>The requirement states the system should handle 1000 request/s at least.</p></li>
<li><p>What&rsquo;s the average request rate?</p>

<p> 1000 &lt; avg req. rate &lt; 10,000</p></li>
<li><p>What&rsquo;s the max. burst rate the system must handle?</p>

<p> &lt; 1,000,000</p></li>
<li><p>What&rsquo;s the max. latency (wait time) for a request?</p>

<p> 1 ms</p></li>
</ol>


<h4>Solution</h4>

<p>It&rsquo;s a classical consumer-producer problem.</p>

<p>In this case we have many consumers of UUIDs and one producer. Let&rsquo;s assume the OS provides an API to generate UUIDs and the max. running time of the API is 1ms.</p>

<ol>
<li><p>Pre-allocate 2 Mio UUIDs into an array / stack/ heap (depending on implementation) structure.</p></li>
<li><p>If no overhead 2 Mio UUIDs would take ~ 32MB of RAM. Not a problem on today&rsquo;s server system with many GB of RAM, but may be a problem on an embedded system.</p></li>
<li><p>2 Mio UUIDs ensures system can handle burst rate.</p></li>
<li><p>The solution needs to ensure that its pool of UUIDs doesn&rsquo;t run out as consumers request them and they are replenished.</p></li>
</ol>


<h3>Idea 2</h3>

<p>This question is quite open-ended.</p>

<p>For starter, how about <strong>appending random(N) to the timestamp</strong>? N can be large enough to make collisions unlikely. If each server has an ID we can also include it to further reduce collisions.</p>

<p>If IDs must be unique, then I suppose you can <strong>design a counter</strong> that will return an ID and increment it at the same time. You will then <strong>need mutex to access this counter</strong>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/26/make-java-method-thread-safe/">[Google] Make a Java Method Thread-safe</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-26T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/26/make-java-method-thread-safe/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.programcreek.com/2014/02/how-to-make-a-method-thread-safe-in-java/">link</a></p>

<blockquote><p>Consider the following class:</p></blockquote>

<pre><code>class MyCounter {
    private static int counter = 0;

    public static int getCount() {
        return counter++;
    }
}
</code></pre>

<blockquote><p>Is the method thread-safe? How to make it thread-safe?</p></blockquote>

<h3>Solution</h3>

<p><strong>No</strong>, it&rsquo;s not.</p>

<blockquote><p>The method is not thread-safe, because the <strong>counter++ operation is not atomic</strong>, which means it consists more than one atomic operations. In this case, one is accessing value and the other is increasing the value by one.</p>

<p>When Thread 1 accesses the method at t1, Thread 2 may not be done with the method. So the value returned to Thread 1 is the value that has not been increased.</p></blockquote>

<h3>Approach 1</h3>

<p>Adding <strong>synchronized</strong> to this method. This will synchronize the instance of the static class.</p>

<pre><code>class MyCounter {
    private static int counter = 0;

    public static synchronized int getCount() {
        return counter++;
    }
}
</code></pre>

<h3>Approach 2</h3>

<p>We actually can make <strong>count++</strong> atomic by using AtomicInteger from the package &ldquo;java.util.concurrent.atomic&rdquo;.</p>

<p>import java.util.concurrent.atomic.AtomicInteger;</p>

<pre><code>public class MyCounter {
    private static AtomicInteger counter = new AtomicInteger(0);

    public static int getCount() {
        return counter.getAndIncrement();
    }
}
</code></pre>

<h3>Follow-up on thread stack</h3>

<ol>
<li>Each thread has its own stack (never share stack).</li>
<li>All local variables defined in a method will be allocated memory in stack.</li>
<li>When execution completed by a thread, stack frame will be removed.</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/26/Push-and-Pop-Sequences-Stacks/">[Question] Push and Pop Sequences of Stacks</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-26T00:00:00+08:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2015/01/26/Push-and-Pop-Sequences-Stacks/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://codercareer.blogspot.sg/2011/11/no-21-push-and-pop-sequences-of-stacks.html">link</a></p>

<blockquote><p>Given two integer sequences, one of which is the push sequence of a stack, please check whether the other sequence is a corresponding pop sequence or not.</p>

<p>For example, if 1, 2, 3, 4, 5 is a push sequence, 4, 5, 3, 2, 1 is a corresponding pop sequence, but the sequence 4, 3, 5, 1, 2 is not.</p></blockquote>

<h3>Solution</h3>

<p>Refer to <a href="http://stackoverflow.com/a/17828345">this answer</a>:</p>

<blockquote><p>Construct the stack:</p>

<p>For each number X in the pop order:</p></blockquote>

<pre><code>If this number is not the same as the top of the stack (or the stack is empty), 
push numbers from the push order until you pushed X. 

If you pushed all numbers and didn't find X, there's no way to get the pop order.

Pop X
</code></pre>

<h3>Code</h3>

<pre><code>public boolean validSequence(int[] input, int[] sequenc) {
    // keep a pointer p in the input[] array
    int len = input.length;
    int p = 0;
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();

    int i = 0;
    while (i &lt; len) {
        if (stack.isEmpty()) {
            // just push an element to stack
            stack.push(input[p++]);
        } else {
            // stack got elements, then check top one
            if (stack.peek() == sequenc[i]) {
                // seq found, proceed to next number in seq
                stack.pop();
                i++;
            } else {
                // did not find seq, keep pushing to stack until done
                if (p == len) {
                    return false;
                } else {
                    stack.push(input[p++]);
                }
            }
        }
    }
    return i == len; // or just return true;
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="11">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="9">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (75)</a></li>
<li class='category'><a href='/blog/categories/experience/'>experience (4)</a></li>
<li class='category'><a href='/blog/categories/fundamental/'>fundamental (11)</a></li>
<li class='category'><a href='/blog/categories/java-oop/'>java oop (30)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (176)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (20)</a></li>
<li class='category'><a href='/blog/categories/q-facebook/'>q-facebook (9)</a></li>
<li class='category'><a href='/blog/categories/q-google/'>q-google (62)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (124)</a></li>
<li class='category'><a href='/blog/categories/string-search/'>string search (17)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (7)</a></li>
<li class='category'><a href='/blog/categories/top-k/'>top k (7)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/08/30/design-class-4/">[NineChap Sys] System Design Class 4: Crawler & Search Engine </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/28/design-class-3/">[NineChap Sys] System Design Class 3: Web Service </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/26/design-class-2/">[NineChap Sys] System Design Class 2: Database </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/24/three-property-object/">[Java OOP] Three Properties of Class/Object </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/23/design-class-1/">[NineChap Sys] System Design Class 1: Overview </a>
      </li>
    
  </ul>
</section>




<!--
<script type="text/javascript" src="http://srvpub.com/adServe/banners?tid=29011_41781_0&size=120x600" ></script>
&#8211;>

<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"willran168","width":160,"height":600,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>
<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
    Copyright &copy; 2015 - <a href="/about">CodeMonkey</a> -  All posts are my original writing, based uppon my personal view. <a href="/policy">Privacy Policy</a> - 
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
