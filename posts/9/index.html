
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="Question link Given two Linked Lists, create union and intersection lists that contain union and intersection of the elements present in the given &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/9">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/17/Union-and-intersection-of-linked-list/">[Question] Union and Intersection of Two Linked Lists</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-17T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/union-and-intersection-of-two-linked-lists/">link</a></p>

<blockquote><p>Given two Linked Lists, create union and intersection lists that contain union and intersection of the elements present in the given lists. Order of elments in output lists doesn’t matter.</p>

<p>Example:</p>

<p>Input: &ldquo;10->15->4->20&rdquo; and &ldquo;8->4->2->10&rdquo;</p>

<p>Intersection: 4->10</p>

<p>Union: 2->8->20->4->15->10</p></blockquote>

<h3>Analysis</h3>

<p>There are 2 solutions.</p>

<p>First solution is to do mergesort, then do a linear search. Time complexity is O(mlgm + nlgn).</p>

<p>Second solution is using hashing. On time <a href="http://www.geeksforgeeks.org/union-and-intersection-of-two-linked-lists/">complexity</a>:</p>

<blockquote><p>Time complexity of this method depends on the hashing technique used and the distribution of elements in input lists. In practical, this approach may turn out to be better than above method.</p></blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/17/Time-complexity-calculation/">[General] Time Complexity Calculation (Master Theorem)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-17T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Master theorem</h3>

<p>In the analysis of algorithms, the <a href="http://en.wikipedia.org/wiki/Master_theorem">master theorem</a> provides a cookbook solution in asymptotic terms (using Big O notation) for recurrence relations that occur in many divide and conquer algorithms. It was introduced and popularized by <strong>Introduction to Algorithms</strong>.</p>

<h3>Examples with common algorithms</h3>



<table class="tg">
  <tr>
    <th class="tg-031e">Algorithm</th>
    <th class="tg-031e">Recurrence</th>
    <th class="tg-031e">Big-Oh Solution</th>
  </tr>
  <tr>
    <td class="tg-031e">Binary Search</td>
    <td class="tg-031e">T(n) = T(n/2) + O(1)</td>
    <td class="tg-031e">O(log n)</td>
  </tr>
  <tr>
    <td class="tg-031e">tree traversal</td>
    <td class="tg-031e">T(n) = 2 T(n/2) + O(1)</td>
    <td class="tg-031e">O(n)</td>
  </tr>
  <tr>
    <td class="tg-031e">Mergesort</td>
    <td class="tg-031e">T(n) = 2 T(n/2) + O(n)</td>
    <td class="tg-031e">O(n log n)</td>
  </tr>
</table>


<p><a href="http://www.cs.duke.edu/~ola/ap/recurrence.html">source</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/17/Reverse-linkedlist-recursively/">[LeetCode Plus] Reverse Linked List Iteratively and Recursively</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-17T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://leetcode.com/2010/04/reversing-linked-list-iteratively-and.html">link</a></p>

<blockquote><p>Implement the reversal of a singly linked list iteratively and recursively.</p></blockquote>

<h3>Iteratively</h3>

<p>First, the iterative solution is very common, and is listed as <strong>one of the &ldquo;5 fundamental operations of linked list&rdquo;</strong> in the NineChap4 post. I will quote below.</p>

<blockquote><p>First variant: Reverse from a particular node to the end</p></blockquote>

<pre><code>public ListNode reverse(ListNode start) {
    ListNode result = null;
    ListNode cur = start;
    while (cur != null) {
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
    }
    return result;
}
</code></pre>

<blockquote><p>Second variant: Reverse from a node until another node</p></blockquote>

<pre><code>public ListNode reverseRange(ListNode start, int len) {
    ListNode result = null;
    ListNode cur = start;
    while (len &gt; 0) {
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
        len--;
    }
    start.next = cur;
    return result;
}
</code></pre>

<h3>Recursively</h3>

<p>A good code from <a href="http://stackoverflow.com/a/354937">here</a>.</p>

<pre><code>public ListNode Reverse(ListNode list) {
    if (list == null) return null; 
    if (list.next == null) return list; 
    ListNode secondElem = list.next;
    list.next = null;
    ListNode reverseRest = Reverse(secondElem);
    secondElem.next = list;
    return reverseRest;
}
</code></pre>

<p>Alternatively, the code can be written in a &lsquo;show-off&rsquo; practice.</p>

<pre><code>public ListNode Reverse(ListNode list) {
    if (list == null) return null;
    if (list.next == null) return list;
    ListNode reverseRest = Reverse(list.next);
    list.next.next = list;
    list.next = null;
    return reverseRest;
}
</code></pre>

<p>Test cases urgently needed.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/16/NineChap-Linked-List/">[NineChap 4.1] Linked List</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-16T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>First Word</h2>

<p>LinkedList aims to test one of the most important concepts in C++, pointers.</p>

<p><strong>Unlike array, linked list does not have &lsquo;in-place&rsquo; operations</strong>. This is very important to understand.</p>

<h3>Type 1: Dummy Node</h3>

<p>When the head is not determined, use DummyHead.</p>

<p>Note that when using DummyHead to solve problems, the pointer <strong>starts from DummyHead</strong>. By doing this, we assuming that DummyHead must be valid, and we <strong>only check pointer.next (instead of checking pointer itself)</strong>. See &lsquo;Remove Duplicates from Sorted List II&rsquo; for details.</p>

<h3>Type 2: Five Basic Operations in Linked List</h3>

<ol>
<li>Insert in Sorted List</li>
<li>Remove in Sorted List</li>
<li>Reverse a list</li>
<li>Merge 2 Sorted List</li>
<li>Find middle</li>
</ol>


<h4>1.Insert in Sorted List</h4>

<pre><code>public ListNode insert(ListNode head, ListNode node) {
    // first, initialize
    ListNode dummy = new ListNode(Integer.MIN_VALUE);
    dummy.next = head;

    // second, assume p is less than node, and check p.next
    ListNode p = dummy;
    while (p.next != null &amp;&amp; p.next.val &lt; node.val) {
        p = p.next;
    }

    // insert node after 'p'
    node.next = p.next;
    p.next = node;
    return dummy.next;
}
</code></pre>

<h4>2.Remove in Sorted List</h4>

<p>(written by me)</p>

<pre><code>public ListNode remove(ListNode head, int value) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode p = dummy;
    while (p.next != null &amp;&amp; p.next.val != value) {
        p = p.next;
    }
    if (p.next != null &amp;&amp; p.next.val == value) {
        while (p.next != null &amp;&amp; p.next.val == value)
            p.next = p.next.next;
    }
    return dummy.next;
}
</code></pre>

<h4>3.Reverse a list</h4>

<p>First variant: Reverse from a particular node to the end.</p>

<p>四句话 statement.</p>

<pre><code>public ListNode reverse(ListNode start) {
    ListNode result = null;
    ListNode cur = start;
    while (cur != null) {
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
    }
    return result;
}
</code></pre>

<p>Second variant: Reverse from a node until another node</p>

<pre><code>// Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, start = 2 and len = 3,
// return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. 
public ListNode reverseRange(ListNode start, int len) {
    ListNode result = null;
    ListNode cur = start;
    while (len &gt; 0) {
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
        len--;
    }
    start.next = cur;
    return result;
}
</code></pre>

<p>The comparison:</p>

<p><img class="left" src="/assets/images/reverse-linked-list-code-compare.png"></p>

<p>More: there is a way to reverse list recursively. This can be another good interview question. <strong><a href="/blog/2014/06/17/Reverse-linkedlist-recursively/">Reverse linkedlist recursively</a></strong></p>

<h4>4.Merge 2 Sorted List</h4>

<pre><code>public ListNode merge(ListNode head1, ListNode head2) {
    ListNode dummy = new ListNode(0);
    ListNode p = dummy;
    while (head1 != null &amp;&amp; head2 != null) {
        if (head1.val &lt; head2.val) {
            p.next = head1;
            head1 = head1.next;
            p = p.next;
        } else {
            p.next = head2;
            head2 = head2.next;
            p = p.next;
        }
    }
    if (head1 == null) {
        p.next = head2;
    } else {
        p.next = head1;
    }
    return dummy.next;
}
</code></pre>

<h4>5.Find middle</h4>

<p>There are 2 ways to do this: calculate the total length, or fast/slow pointer. But fast/slow pointer is better <strong>because in engineering world, a lot of problems only allows information to flow once (数据流概念)</strong>. Sometimes it&rsquo;s not a good idea to read list for a second (or 1.5) time.</p>

<pre><code>public ListNode findMiddle(ListNode head) {
    if (head == null) {
        return null;
    }
    ListNode slow = head, fast = head.next;
    while (fast != null &amp;&amp; fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
</code></pre>

<p><strong>Dummy head questions</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/22/Remove-Duplicates-from-Sorted-List/">Remove Duplicates from Sorted List</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/22/Remove-Duplicates-from-Sorted-List-II/">Remove Duplicates from Sorted List II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/23/Partition-List/">Partition List</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/09/Merge-Two-Sorted-Lists/">Merge Two Sorted Lists</a></strong></p></li>
</ol>


<p><strong>5 basic operations questions</strong></p>

<ol>
<li><p><strong><a href="/blog/2014/05/23/Reverse-Linked-List-II/">Reverse Linked List II</a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="/blog/2014/06/02/Sort-List/">Sort List</a></strong></p>

<p> 2 operations used</p></li>
<li><p><strong><a href="/blog/2014/06/03/Reorder-List/">Reorder List</a></strong></p>

<p> 3 operations used</p></li>
<li><p><strong><a href="/blog/2014/06/02/Linked-List-Cycle/">Linked List Cycle</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/02/Linked-List-Cycle-II/">Linked List Cycle II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/11/Merge-k-Sorted-Lists/">Merge k Sorted Lists</a></strong></p>

<p> For this question, it&rsquo;s important to write a comparator by yourself, to show your understanding of a PriorityQueue.</p>

<p> n<em>k</em>lgk time, why? 1:14:30 recording
 about heap 1:15:00 recording</p></li>
<li><p><strong><a href="/blog/2014/06/02/Copy-List-with-Random-Pointer/">Copy List with Random Pointer</a></strong></p></li>
</ol>


<h2>Code</h2>

<p><strong>Remove Duplicates from Sorted List</strong></p>

<p>Easy, no dummy head needed.</p>

<p><strong>Remove Duplicates from Sorted List II</strong></p>

<pre><code>public ListNode deleteDuplicates(ListNode head) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode p = dummy;
    while (p.next != null &amp;&amp; p.next.next != null) {
        if (p.next.val == p.next.next.val) {
            int dupVal = p.next.val;
            while (p.next != null &amp;&amp; p.next.val == dupVal) {
                p.next = p.next.next;
            }
        } else {
            p = p.next;
        }
    }
    return dummy.next;
}
</code></pre>

<p><strong>Partition List</strong> &ndash; spend a lot of time on a list cycle in the result</p>

<pre><code>public ListNode partition(ListNode head, int x) {
    if (head == null) {
        return null;
    }
    ListNode head1 = new ListNode(0);
    ListNode head2 = new ListNode(0);

    ListNode p1 = head1;
    ListNode p2 = head2;
    ListNode cur = head;

    while (cur != null) {
        if (cur.val &lt; x) {
            p1.next = cur;
            p1 = cur;
        } else {
            p2.next = cur;
            p2 = cur;
        }
        cur = cur.next;
    }

    p1.next = head2.next;
    // VERY IMPORTANT THIS LINE !!!
    p2.next = null;
    // VERY IMPORTANT THIS LINE !!!
    return head1.next;
}
</code></pre>

<p><strong>Merge Two Sorted Lists</strong></p>

<pre><code>public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode p = dummy;
    while (l1 != null &amp;&amp; l2 != null) {
        if (l1.val &lt; l2.val) {
            p.next = l1;
            l1 = l1.next;
            p = p.next;
        } else {
            p.next = l2;
            l2 = l2.next;
            p = p.next;
        } 
    }
    if (l1 == null) {
        p.next = l2;
    } else {
        p.next = l1;
    }
    return dummy.next;
}
</code></pre>

<h4>5 basic operations</h4>

<p><strong>Reverse Linked List II</strong></p>

<pre><code>public ListNode reverseBetween(ListNode head, int m, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode start = dummy;
    int count = 1;
    while (head != null &amp;&amp; count &lt; m) {
        start = start.next;
        count++;
    }
    start.next = reverseRange(start.next, n - m + 1);
    return dummy.next;
}

private ListNode reverseRange(ListNode start, int len) {
    ListNode result = null;
    ListNode cur = start;
    while (len &gt; 0) {
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
        len--;
    }
    start.next = cur;
    return result;
}
</code></pre>

<p><strong>Sort List</strong></p>

<p>Time complexity analysis: T(n) = 2 T(n/2) + O(n). <strong>By applying Master theorem, time = O(nlgn)</strong>.</p>

<pre><code>public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode mid = findMid(head);
        ListNode secondHalf = mid.next;
        mid.next = null;
        head = sortList(head);
        secondHalf = sortList(secondHalf);
        return merge(head, secondHalf);
}

private ListNode findMid(ListNode head) {
    ListNode slow = head;
    ListNode fast = head.next;
    while (fast != null &amp;&amp; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}

private ListNode merge(ListNode h1, ListNode h2) {
    ListNode dummy = new ListNode(0);
    ListNode p = dummy;
    while (h1 != null &amp;&amp; h2 != null) {
        if (h1.val &lt; h2.val) {
            p.next = h1;
            h1 = h1.next;
        } else {
            p.next = h2;
            h2 = h2.next;
        }
        p = p.next;
    }
    if (h1 == null) {
        p.next = h2;
    } else if (h2 == null) {
        p.next = h1;
    }
    return dummy.next;
}
</code></pre>

<p><strong>Reorder List</strong></p>

<pre><code>public void reorderList(ListNode head) {
    if (head == null || head.next == null) {
        return;
    }
    ListNode mid = findMid(head);
    ListNode secondHalf = mid.next;
    mid.next = null;
    secondHalf = reverse(secondHalf);
    head = mergeInterlace(head, secondHalf);
}

private ListNode findMid(ListNode head) {
    if (head == null) {
        return null;
    }
    ListNode slow = head;
    ListNode fast = head.next;
    while (fast != null &amp;&amp; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}

private ListNode reverse(ListNode head) {
    ListNode result = null;
    ListNode cur = head;
    while (cur != null) {
        ListNode temp = cur.next;
        cur.next = result;
        result = cur;
        cur = temp;
    }
    return result;
}

private ListNode mergeInterlace(ListNode h1, ListNode h2) {
    ListNode result = h1;
    h1 = h1.next;
    ListNode p = result;
    while (h1 != null &amp;&amp; h2 != null) {
        p.next = h2;
        h2 = h2.next;
        p.next.next = h1;
        h1 = h1.next;
        p = p.next.next;
    }
    if (h1 == null) {
        p.next = h2;
    } else {
        p.next = h1;
    }
    return result;
}
</code></pre>

<p><strong>Linked List Cycle</strong></p>

<pre><code>public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) 
        return false;
    ListNode slow = head;
    ListNode fast = head.next;
    while (fast != null &amp;&amp; fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) {
            return true;
        }
    }
    return false;
}
</code></pre>

<p><strong>Linked List Cycle II</strong></p>

<pre><code>public ListNode detectCycle(ListNode head) {
    if (head == null || head.next == null) 
        return null;
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null &amp;&amp; fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) {
            slow = head;
            while (slow != fast) {
                slow = slow.next;
                fast = fast.next;
            }
            return slow;
        }
    }
    return null;
}
</code></pre>

<p><strong>Merge k Sorted Lists</strong></p>

<p>I write the code in the original post.</p>

<p><strong>Copy List with Random Pointer</strong></p>

<pre><code>public RandomListNode copyRandomList(RandomListNode head)  {
    if (head == null)  {
        return null;
    }
    // 1, make a new copy of each node
    RandomListNode p = head;
    while (p != null) {
        RandomListNode copy = new RandomListNode(p.label);
        copy.next = p.next;
        p.next = copy;
        p = copy.next;
    }
    // 2. link the random pointer of copied nodes
    p = head;
    while (p != null) {
        if (p.random != null) {
            p.next.random = p.random.next;
        }
        p = p.next.next;
    }
    // 3. break the copied nodes from original nodes
    RandomListNode result = head.next;
    p = head;
    RandomListNode p2 = head.next;
    while (p != null) {
        p.next = p2.next;
        if (p2.next != null) {
            p2.next = p2.next.next;
        }
        p = p.next;
        p2 = p2.next;
    }
    return result;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/16/Binary-tree-serialize-deserialize/">[LeetCode Plus] Binary Tree Serialize and Deserialize</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-16T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://leetcode.com/2010/09/serializationdeserialization-of-binary.html">link1</a>, <a href="http://leetcode.com/2010/09/saving-binary-search-tree-to-file.html">link2</a>.</p>

<blockquote><p>Variant 1: Given a Binary Search Tree, serialize and deserialize it.</p>

<p>Variant 2: Given a Binary Tree, serialize and deserialize it.</p></blockquote>

<h3>Variant 1 &ndash; Binary search tree</h3>

<p><strong>We must only use pre-order</strong>.</p>

<p>Think about why, or read <a href="http://leetcode.com/2010/09/serializationdeserialization-of-binary.html">link1</a>. So, serialization is simple &ndash; preorder traversal.</p>

<p>The desecialization would make use of the first element, and range validation method. This is very similar to another question &lsquo;validate BST&rsquo;. Rmb the key is:</p>

<blockquote><p>Each time we add a number, we also pass the valid range within which the number can lie between.</p></blockquote>

<h4>Code</h4>

<p>The code is concise, but may not be easy to write:</p>

<pre><code>void readBSTHelper(int min, int max, int &amp;insertVal,
                   BinaryTree *&amp;p, ifstream &amp;fin) {
  if (insertVal &gt; min &amp;&amp; insertVal &lt; max) {
    int val = insertVal;
    p = new BinaryTree(val);
    if (fin &gt;&gt; insertVal) {
      readBSTHelper(min, val, insertVal, p-&gt;left, fin);
      readBSTHelper(val, max, insertVal, p-&gt;right, fin);
    }
  }
}

void readBST(BinaryTree *&amp;root, ifstream &amp;fin) {
  int val;
  fin &gt;&gt; val;
  readBSTHelper(INT_MIN, INT_MAX, val, root, fin);
}
</code></pre>

<h3>Variant 2 &ndash; Binary tree</h3>

<p>For binary tree, we could not use above solution any more. We must use some NULL pointers to fill in empty slots. For this variant, <strong>pre-order and level-order both would work</strong>.</p>

<p>Then which of these 2 is a better choice?</p>

<pre>
   1
  / \
 2   3
</pre>


<blockquote><p>Given the tree above:</p>

<p>The pre-order serialization is: {1, 2, #, #, 3, #, #}</p>

<p>The level-order serialization is: {1, 2, 3}</p>

<p>We can see that level-order is a better idea, because last level null pointers need not be handled.</p></blockquote>

<h4>Code (preorder)</h4>

<p>The serializaion is a simple traversal.</p>

<pre><code>void writeBinaryTree(BinaryTree *p, ostream &amp;out) {
  if (!p) {
    out &lt;&lt; "# ";
  } else {
    out &lt;&lt; p-&gt;data &lt;&lt; " ";
    writeBinaryTree(p-&gt;left, out);
    writeBinaryTree(p-&gt;right, out);
  }
}
</code></pre>

<p>The deserialization is a little bit like &ldquo;convert linked list to balanced tree&rdquo; (where we use first element of the list as root of the tree).</p>

<pre><code>void readBinaryTree(BinaryTree *&amp;p, ifstream &amp;fin) {
  int token;
  bool isNumber;
  if (!readNextToken(token, fin, isNumber)) 
    return;
  if (isNumber) {
    p = new BinaryTree(token);
    readBinaryTree(p-&gt;left, fin);
    readBinaryTree(p-&gt;right, fin);
  }
}
</code></pre>

<p>I did not find any code for level-order, but it&rsquo;s similar to &lsquo;level-order traversal&rsquo;.</p>

<h3>One more thing</h3>

<p>A Binary Search Tree (BST) is useful for storing phone book records in a memory limited device, such as a cell phone. The records are always maintained in sorted order, inserting and deleting a record takes O(lg n) time (slower than linked list, but much better than array).</p>

<h3>One more one-more-thing</h3>

<p><strong>This post we use # as a sentinel</strong>. There is also <strong><a href="http://stackoverflow.com/a/15044868">another idea</a> of doing both Inorder and Preorder traversal</strong> to searialize the tree data, and use the solution to &ldquo;Construct Binary Tree from Preorder and Inorder&rdquo; to deserialize it.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/15/NineChap-Binary-Tree-additional/">[NineChap 3.4] Binary Tree Additional</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-15T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>These are some additional questions that are not covered in previous NineChap posts. Some questions are non-standard and difficult to solve, and some are not found in OJ websites. But these are real questions that has been asked during interviews.</p>

<h2>Question list</h2>

<ol>
<li><p><strong><a href="/blog/2014/06/15/BST-find-upper-lower-bound/">Binary Search Tree find upper/lower bound</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/14/Iterator-of-Tree/">Implement iterator of Binary Search Tree</a></strong></p></li>
<li><p><strong><a href="/blog/2014/06/16/Binary-tree-serialize-deserialize/">Binary Tree Serialize and Deserialize</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/27/Populating-Next-Right-Pointers-in-Each-Node/">Populating Next Right Pointers in Each Node</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/27/Populating-Next-Right-Pointers-in-Each-Node-II/">Populating Next Right Pointers in Each Node II</a></strong> &ndash; difficult</p></li>
<li><p><strong><a href="/blog/2014/05/26/Symmetric-Tree/">Symmetric Tree</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/25/Same-Tree/">Same Tree</a></strong></p></li>
</ol>


<h2>Code</h2>

<p><strong>Binary Search Tree find upper/lower bound</strong></p>

<p>Find the new post.</p>

<p><strong>Implement iterator of Binary Search Tree</strong></p>

<p>Find the new post.</p>

<p><strong>Binary Tree Serialize and Deserialize</strong></p>

<p>Find the new post.</p>

<p><strong>Populating Next Right Pointers in Each Node</strong></p>

<pre><code>public void connect(TreeLinkNode root) {
    TreeLinkNode dummy = new TreeLinkNode(0);
    dummy.left = root;
    helper(dummy, root);
}

private void helper(TreeLinkNode parent, TreeLinkNode child) {
    if (child == null) {
        return;
    }
    if (child == parent.left) {
        child.next = parent.right;
    } else if (child == parent.right) {
        if (parent.next != null) {
            child.next = parent.next.left;
        }
    }
    helper(child, child.left);
    helper(child, child.right);
}
</code></pre>

<p><strong>Populating Next Right Pointers in Each Node II</strong></p>

<p>This is a very tricky variant of DFS where the left sub-tree is making use of right sub-tree. I did not solve it even at second time.</p>

<pre><code>public void connect(TreeLinkNode root) {
    if (root == null) return;
    if (root.left == null &amp;&amp; root.right == null) return;
    TreeLinkNode levelNext = root.next;
    TreeLinkNode lowerNext = null;
    while (levelNext != null &amp;&amp; lowerNext == null) {
        if (levelNext.left != null) {
            lowerNext = levelNext.left;
            break;
        } else if (levelNext.right != null) {
            lowerNext = levelNext.right;
            break;
        } else {
            // if there is no child node of levelNext
            levelNext = levelNext.next;
        }
    }
    if (root.left == null) {
        root.right.next = lowerNext;
    } else if (root.right == null) {
        root.left.next = lowerNext;
    } else {
        root.left.next = root.right;
        root.right.next = lowerNext;
    }
    connect(root.right);
    connect(root.left);
}
</code></pre>

<p><strong>Symmetric Tree</strong></p>

<pre><code>public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    return mirror(root.left, root.right);
}

private boolean mirror(TreeNode left, TreeNode right) {
    if (left == null &amp;&amp; right == null) {
        return true;
    }
    if (left == null || right == null) {
        return false;
    }
    return (left.val == right.val) 
        &amp; mirror(left.left, right.right)
        &amp; mirror(left.right, right.left);
}
</code></pre>

<p><strong>Same Tree</strong></p>

<pre><code>public boolean isSameTree(TreeNode left, TreeNode right) {
    if (left == null &amp;&amp; right == null) {
        return true;
    }
    if (left == null || right == null) {
        return false;
    }
    return (left.val == right.val) 
        &amp; isSameTree(left.left, right.left)
        &amp; isSameTree(left.right, right.right);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/15/Java-Global-Variable/">[General] Java Global Variable</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-15T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Global variable?</h3>

<p>There is no such thing as a &lsquo;global variable&rsquo; in Java.</p>

<blockquote><p>In computer programming, a global variable is a variable that is accessible in every scope (the global environment). Some languages, like Java, don&rsquo;t have global variables. <a href="https://sg.answers.yahoo.com/question/index?qid=20110811104130AA5JrbR">reference</a></p></blockquote>

<p>But static variable can be seen as one, although every static variable must belong to some class (like Math.MIN_VALUE).</p>

<p>Global variables are generally only used for declaring constants. In this case, declare it as &lsquo;final static&rsquo;. <a href="http://stackoverflow.com/questions/4646577/global-variables-in-java">reference</a></p>

<h3>Four types of variable in Java</h3>

<h4>Local variables</h4>

<p>Created when the method, constructor or block is entered and will be destroyed once it exits the method, constructor or block.</p>

<h4>Instance variables</h4>

<p>Outside a method or constructor.</p>

<p>When a space is allocated for an object in the heap, a slot for each instance variable value is created. It is destroyed when the object is destroyed.</p>

<h4>Class/static variables</h4>

<p>Static variable is class variable.</p>

<p>Declared with &lsquo;static&rsquo; keyword in a class.</p>

<h4>Constants</h4>

<p>Most common usage of static variable &ndash; constant.</p>

<p>Declared with &lsquo;static final&rsquo; keyword in a class.</p>

<h3>One more thing</h3>

<p>About <a href="http://programmers.stackexchange.com/a/65289">stack and heap in Java</a>:</p>

<blockquote><p>In Java, primitives are created on the stack.</p>

<p>Objects are created on the heap, and only references (which in turn are primitives) are passed around on the stack.</p>

<p>If you create an object, it is put on the heap, with all the variables that belong to it, so that it can persist after the function call returns.</p></blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/15/BST-find-upper-lower-bound/">[Question] Binary Search Tree Find Upper/lower Bound</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-15T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<blockquote><p>Given a BST, find the node that is larger/smaller than particular number</p></blockquote>

<p>Or the question can be:</p>

<blockquote><p>Given a binary search tree and a value k, please find a node in the binary search tree whose value is closest to k. <a href="http://codercareer.blogspot.sg/2013/03/no-45-closest-node-in-binary-search-tree_2.html">link</a></p></blockquote>

<h3>Analysis</h3>

<p><strong>This post is based on the second question above</strong>.</p>

<ol>
<li>Traverse the tree top-down.</li>
<li>While traversing, record values that are closer to target than previously-found value.</li>
<li>If found, the target, break and return. <a href="http://stackoverflow.com/a/6209372">source</a></li>
</ol>


<h3>Code</h3>

<p>From <a href="http://codercareer.blogspot.sg/2013/03/no-45-closest-node-in-binary-search-tree_2.html">this post</a>.</p>

<pre><code>BinaryTreeNode* getClosestNode(BinaryTreeNode* pRoot, int value)
{
    BinaryTreeNode* pClosest = NULL;
    int minDistance = 0x7FFFFFFF;
    BinaryTreeNode* pNode = pRoot;
    while(pNode != NULL){
        int distance = abs(pNode-&gt;m_nValue - value);
        if(distance &lt; minDistance){
            minDistance = distance;
            pClosest = pNode;
        }

        if(distance == 0)
            break;

        if(pNode-&gt;m_nValue &gt; value)
            pNode = pNode-&gt;m_pLeft;
        else if(pNode-&gt;m_nValue &lt; value)
            pNode = pNode-&gt;m_pRight;
    }

    return pClosest;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/14/Java-modifier-and-access-level/">[General] Java Modifier and Access Level</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-14T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>4 Types of Access Level</h2>

<h4>Private</h4>

<p>Like you&rsquo;d think, only the class in which it is declared can see it.</p>

<h4>Package Private (default)</h4>

<p>Can only be seen and used by the package in which it was declared.</p>

<p>This is the default in Java (which some see as a mistake).</p>

<h4>Protected</h4>

<p>Package Private, plus can be seen by subclasses.</p>

<h4>Public</h4>

<p>Everyone can see it.</p>

<h2>Differences</h2>



<table class="tg">
  <tr>
    <th class="tg-031e">Modifier</th>
    <th class="tg-031e">Class</th>
    <th class="tg-031e">Package</th>
    <th class="tg-031e">SubClass</th>
    <th class="tg-031e">World</th>
  </tr>
  <tr>
    <td class="tg-031e">public</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">Y</td>
  </tr>
  <tr>
    <td class="tg-031e">protected</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">N</td>
  </tr>
  <tr>
    <td class="tg-031e">no modifier</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">N</td>
    <td class="tg-031e">N</td>
  </tr>
  <tr>
    <td class="tg-031e">private</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">N</td>
    <td class="tg-031e">N</td>
    <td class="tg-031e">N</td>
  </tr>
</table>


<br />


<p><strong>Note</strong>: &lsquo;No modifier&rsquo; = &lsquo;Java default access right&rsquo; = &lsquo;Package Private&rsquo;. It&rsquo;s just different sayings.</p>

<p><strong>Another note</strong>: by saying &lsquo;subclass&rsquo;, it means subclass declared in another package.</p>

<h4>Example</h4>

<p>Class structure:</p>

<p><img class="left" src="/assets/images/java-classes-access-level.gif"></p>

<p>For the methods of &lsquo;Alpha&rsquo; class, the visibility is listed below.</p>

<p>For example, Gamma can only access public methods in Alpha.</p>

<table class="tg">
  <tr>
    <th class="tg-031e">Modifier</th>
    <th class="tg-031e">Alpha</th>
    <th class="tg-031e">Beta</th>
    <th class="tg-031e">Alphasub</th>
    <th class="tg-031e">Gamma</th>
  </tr>
  <tr>
    <td class="tg-031e">public</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">Y</td>
  </tr>
  <tr>
    <td class="tg-031e">protected</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">N</td>
  </tr>
  <tr>
    <td class="tg-031e">no modifier</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">N</td>
    <td class="tg-031e">N</td>
  </tr>
  <tr>
    <td class="tg-031e">private</td>
    <td class="tg-031e">Y</td>
    <td class="tg-031e">N</td>
    <td class="tg-031e">N</td>
    <td class="tg-031e">N</td>
  </tr>
</table>


<br />


<h2>Additional question</h2>

<h4>Can we declare a top-level class as private?</h4>

<p>Answer: No, Java does not allow top-level private class. Think about it, a top-level class as private would be useless because nothing could access it.</p>

<p>If you really want, you can use inner or nested classes. If you have a private inner or nested class, then access is restricted to the scope of that outer class.</p>

<p><a href="http://stackoverflow.com/questions/1913863/java-why-can-we-define-a-top-level-class-as-private">link</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/14/Iterator-of-Tree/">[Question] Iterator of Binary Search Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-14T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<blockquote><p>Implement a iterator for a binary search tree</p></blockquote>

<p><strong>Related question</strong>: <a href="/blog/2014/05/24/Binary-Tree-Inorder-Traversal/">Binary Tree Inorder Traversal</a></p>

<h3>Analysis</h3>

<p>First of all, what is an iterator in Java?</p>

<blockquote><p>Java has a commonly used Iterator interface.</p>

<p>It is usually used like this:</p></blockquote>

<pre><code>Iterator e = container.iterator();  
while (e.hasNext()) {
    System.out.println(e.next());
}
</code></pre>

<p>The source code of Iterator interface:</p>

<pre><code>public interface Iterator&lt;E&gt; {
    boolean hasNext();
    E next();
    void remove();
}
</code></pre>

<p>In this post, we will only implement next(), because Tree node deletion is covered in another post, and it&rsquo;s not easy.</p>

<p>The most standard way is to do an inorder traversal (by storing a pointer to the next node). The only difference is iterator is 1 step at a time. If you cannot write inorder traversal without using recursion, <a href="/blog/2014/05/24/Binary-Tree-Inorder-Traversal/">learn it first</a>. The solution of iterator is available from <a href="http://manbroski.blogspot.sg/2011/11/iterator-for-binary-search-tree.html">this blog</a>, although he made some small syntax errors.</p>

<h3>Code</h3>

<pre><code>class TreeIterator implements Iterator&lt;TreeNode&gt; {
    TreeNode root, cursor;
    Stack&lt;TreeNode&gt; iteratorStack;

    public TreeIterator(TreeNode root) {
        this.root = root;
        this.cursor = root;
        this.iteratorStack = new Stack&lt;TreeNode&gt;();
    }

    public boolean hasNext() {
        return (!iteratorStack.empty() || cursor != null);
    }

    public TreeNode next() {
        TreeNode nextNodeValue;
        while (cursor != null) {
            iteratorStack.push(cursor);
            cursor = cursor.left;
        }
        cursor = iteratorStack.pop();
        nextNodeValue = cursor;
        cursor = cursor.right;
        return nextNodeValue;
    }

    @Override
    public void remove() {
    }
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/10">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/8">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/07/31/Run-Length-Encoding/">[Question] Run-Length Encoding</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/31/Points-On-Globe/">[Question] Points on Globe Puzzle</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/31/Number-Of-Bus-Stations/">[Question] Number of Bus-Stations</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/31/Inorder-Successor-BST/">[Question] Inorder Successor in Binary Search Tree</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/30/Peripheral-Of-Complete-Tree/">[Question] Peripheral of a Complete Tree</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
