
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Woodstock Blog</title>
  <meta name="author" content="Charlie Brown">

  
  <meta name="description" content="Question link Given a digit &lsquo;3141592653&rsquo;, find number of occurence of subsequence &ldquo;123&rdquo;. Note that the sequence occurs twice &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Woodstock Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Woodstock Blog</a></h1>
  
    <h2>What's the good of living if you don't try a few things?</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/11/numer-of-occurrence-given-subsequence/">[Question] Number of Occurence of Given Sub-sequence</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-11T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2015/01/11/numer-of-occurrence-given-subsequence/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2015/01/11/numer-of-occurrence-given-subsequence/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://stackoverflow.com/questions/6877249/find-the-number-of-occurrences-of-a-subsequence-in-a-string">link</a></p>

<blockquote><p>Given a digit &lsquo;3141592653&rsquo;, find number of occurence of subsequence &ldquo;123&rdquo;. Note that the sequence occurs twice:</p></blockquote>

<pre><code>3141592653
 1    2  3
   1  2  3
</code></pre>

<blockquote><p>Output 2.</p></blockquote>

<h3>Solution</h3>

<p>Refer to <strong>[LeetCode 115] Distinct Subsequences</strong>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/11/numer-of-distinct-subsequence/">[Question] Number of Distinct Sub-sequence</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-11T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2015/01/11/numer-of-distinct-subsequence/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2015/01/11/numer-of-distinct-subsequence/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://stackoverflow.com/questions/5151483/how-to-find-the-number-of-distinct-subsequences-of-a-string">link</a></p>

<blockquote><p>Find the number of distinct subsequences of a string (include &ldquo;&rdquo; as a subsequence).</p>

<p>For example, Input</p></blockquote>

<pre><code>AAA 
ABCDEFG 
CODECRAFT 
</code></pre>

<blockquote><p>Output</p></blockquote>

<pre><code>4 
128 
496 
</code></pre>

<h3>Solution</h3>

<p>In <strong>[LeetCode 115] Distinct Subsequences</strong>, we discuss finding occurence of a given subsequence.</p>

<p>Now if we do not specify a subsequence, <strong>we want the total number of distinct subsequence</strong>.</p>

<p>The solution is DP, with the following equation:</p>

<pre><code>Let, 

dp[i] = number of distinct subsequences ending with a[i]

last[i] = last position of character i in the given string.
</code></pre>

<p><strong>Equation</strong>:</p>

<pre><code>dp[i] = dp[last[i] - 1] + ... + dp[i - 1]
</code></pre>

<p>The final result is:</p>

<pre><code>Distinct Subsequences = dp[1] + ... dp[len - 1]
</code></pre>

<p>Example 1:</p>

<pre><code>Input   : - A B C
dp array: 1 1 2 4
Total = 8
</code></pre>

<p>Example 2:</p>

<pre><code>Input   : - A A C
dp array: 1 1 1 3
Total = 6
</code></pre>

<p>The code is posted below.</p>

<h3>Optimize Solution</h3>

<p>There is a good optimization of this DP solution, which is to <strong>keep another dp array &lsquo;sum&rsquo;</strong>, which sum[i] = dp[1] + dp[2] + &hellip; + dp[i]. The final answer would be sum[len &ndash; 1].</p>

<p>This nice idea is from <a href="http://stackoverflow.com/a/5152203">this post</a>. Credit goes to <strong>IVlad</strong>.</p>

<h3>Code</h3>

<p>un-optimized code. calculate dp[0] &hellip; dp[n], then sum to final result.</p>

<pre><code>public int countDistinctSubseq(String input) {
    int len = input.length();
    int[] dp = new int[len + 1];
    // dp[i] denotes the number of distinct subseq within first 'i' chars
    dp[0] = 1;
    // the first 0 chars is "" - we consider it as 1 subseq

    for (int i = 1; i &lt;= len; i++) {
        // set dp[i]
        // dp[i] = dp[i-1] + ... + dp[k] where input{k} == input{i}
        int p = i - 1;
        while (p &gt;= 0) {
            dp[i] += dp[p];
            if (p &gt; 0 &amp;&amp; input.charAt(p - 1) == input.charAt(i - 1)) {
                // when meeting a same char ahead of position i, stop
                // adding to dp[i]
                break;
            }
            p--;
        }
    }
    int sum = 0;
    for (int i : dp) {
        sum += i;
    }
    return sum;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/11/longest-repeating-substring/">[Amazon] Longest Repeating Substring</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-11T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2015/01/11/longest-repeating-substring/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2015/01/11/longest-repeating-substring/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=9182781">link</a></p>

<blockquote><p>Finding the longest repeated substring.</p>

<p>Example: &ldquo;banana&rdquo; ==> &ldquo;ana&rdquo;</p></blockquote>

<h3>Solution</h3>

<p>There are 2 solutions: Suffix array, and Suffix tree.</p>

<p><strong>1. Suffix array</strong>. Simple code, explained <a href="http://www.careercup.com/question?id=9182781">here</a>.</p>

<blockquote><p>Bentley&rsquo;s programming pearl book has the simplest implementation (less than 15 lines code) which sort all suffix, and then check common prefix length among adjacent suffix. The time complexity is O(n<sup>2logn</sup>) for sorting the suffix (which has avg length of O(n)).</p></blockquote>

<p>A detailed step-by-step <a href="http://nriverwang.blogspot.com/2013/04/longest-repeated-substring.html">explanation</a>:</p>

<pre><code>str = banana, its suffixes are:
banana
anana
nana
ana
na
a
</code></pre>

<p>after sort, the suffix array looks like:</p>

<pre><code>a
ana
anana
banana
na
nana
</code></pre>

<p>Then for each two adjacent suffixes, check the length of the common prefix.</p>

<p>The answer is &ldquo;ana&rdquo; (if overlapping is allowed, otherwise, should be &ldquo;an&rdquo;).</p>

<p><strong>2. Suffix tree</strong>. Suggest by <a href="http://qr.ae/6W9yJ">this post</a>, Or <a href="http://www.careercup.com/question?id=9182781">this</a>:</p>

<blockquote><p>a good solution is to create a suffix tree for the given word and then find the deepest internal node in that tree (node with at least 2 descendants under it)&hellip;</p></blockquote>

<p>For a nice PPT presentation about suffix tree, look <a href="https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/suffixtrees.pdf">here</a>.</p>

<h3>Code</h3>

<p>Suffix array approach.</p>

<pre><code>public String longestRepeat(String input) {
    int len = input.length();
    String[] suffixArray = new String[len];
    for (int i = 0; i &lt; len; i++) {
        suffixArray[i] = input.substring(i);
    }
    // now sort the suffix array
    Arrays.sort(suffixArray);
    String longest = "";
    // start to compare neighborhood suffixes, and check LCP
    for (int i = 0; i &lt; suffixArray.length - 1; i++) {
        String lcp = longestCommonPrefix(suffixArray[i], suffixArray[i + 1]);
        if (lcp.length() &gt; longest.length()) {
            longest = lcp;
        }
    }
    return longest;
}

private String longestCommonPrefix(String s1, String s2) {
    int p = 0;
    while (p &lt; s1.length() &amp;&amp; p &lt; s2.length()) {
        if (s1.charAt(p) != s2.charAt(p)) {
            break;
        }
        p++;
    }
    return s1.substring(0, p);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/11/crazy-distance-string/">[Google] Crazy Distance Between Strings</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-11T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2015/01/11/crazy-distance-string/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2015/01/11/crazy-distance-string/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://stackoverflow.com/questions/15061908/google-interview-find-crazy-distance-between-strings">link</a></p>

<blockquote><p>X and Y are strings formed by 0 or 1. Distance is define as:</p></blockquote>

<pre><code>D(X,Y) = Remove chars common at the start from both X &amp; Y. 
Then add the remaining lengths from both the strings.
</code></pre>

<blockquote><p>For e.g.</p></blockquote>

<pre><code>D(1111, 1000) = Only First alphabet is common. So the remaining string is 111 &amp; 000. Therefore the result length("111") &amp; length("000") = 3 + 3 = 6
</code></pre>

<blockquote><p>For e.g.</p></blockquote>

<pre><code>D(0101, 01100) = Only First two alphabets are common. So the remaining string is 01 &amp; 100. Therefore the result length("01") &amp; length("100") = 2 + 3 = 5
</code></pre>

<blockquote><p>Now given n input, say like</p></blockquote>

<pre><code>1111
1000
101
1100
</code></pre>

<blockquote><p>Find out the maximum crazy distance between 2 strings.</p>

<p><strong>n is</strong> the number of input strings. <strong>m is</strong> the max length of any input string.</p></blockquote>

<h3>Solution</h3>

<p>This is the <a href="http://stackoverflow.com/a/15062640">source</a>.</p>

<blockquote><p>Put the strings into a tree, where 0 means go left and 1 means go right. <strong>O(m*n) time</strong>.</p></blockquote>

<p>Example:</p>

<pre><code>            Root
             1
          0      1
         0 1*   0  1
        0*     0*    1*
</code></pre>

<blockquote><p>where the * means that an element ends there. Constructing this tree clearly takes O(n m).</p>

<p>Now we have to find <strong>the diameter of the tree</strong> (the longest path between two nodes).</p></blockquote>

<p>How to find out longest path between 2 leaf nodes? Please refer to <strong>[Google] Diameter of a Binary Tree</strong> for explanation.</p>

<p>Total time complexity is <strong>O(m*n) time</strong>.</p>

<h3>Code</h3>

<pre><code>public int crazyDist(String[] input) {
    TreeNode root = this.buildTree(input);
    return this.findMaxPath(root).path - 1;
}

private Result findMaxPath(TreeNode node) {
    if (node == null) {
        return new Result(Integer.MIN_VALUE, 0);
    }
    Result lr = this.findMaxPath(node.left);
    Result rr = this.findMaxPath(node.right);
    int path = Math.max(lr.path, rr.path);
    if (lr.depth != 0 &amp;&amp; rr.depth != 0) {
        // this check is important, because if any of the child node is
        // NULL, this root will not be eligible for computing the path
        path = Math.max(path, lr.depth + rr.depth + 1);
        // Why? cuz diameter must go from one leaf, thru root, and reach
        // another leaf. This is different from "Maximum Path Sum" leetcode
    }
    return new Result(path, 1 + Math.max(lr.depth, rr.depth));
}

private TreeNode buildTree(String[] input) {
    TreeNode root = new TreeNode(123);
    // share a common root. this root is deducted from the final calculation
    for (String str : input) {
        // insert str under the root
        TreeNode p = root;
        for (char c : str.toCharArray()) {
            if (c == '0') {
                if (p.left == null) {
                    p.left = new TreeNode(124);
                    // if 0, go to left; otherwise go to right
                    // thus value of TreeNodes does not really matter
                }
                p = p.left;
            } else {
                if (p.right == null) {
                    p.right = new TreeNode(125);
                }
                p = p.right;
            }
        }
    }
    return root;
}

class Result {
    int path;
    int depth;

    public Result(int a, int b) {
        path = a;
        depth = b;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/11/check-if-repeating-subsequence-exist/">[Google] Check if Repeating Subsequence Exists</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-11T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2015/01/11/check-if-repeating-subsequence-exist/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2015/01/11/check-if-repeating-subsequence-exist/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=5931067269709824">link</a></p>

<blockquote><p>Given a string, find if there is any sub-sequence that repeats itself. Do not reuse any char.</p>

<p>Eg:</p></blockquote>

<pre><code>1. abab &lt;------yes, ab is repeated
2. abba &lt;---- No, a and b follow different order 
3. acbdaghfb &lt;-------- yes, a followed by b twice 
4. abcdacb &lt;----- yes, a followed by b twice 
</code></pre>

<blockquote><p>Note that no char should be reused. I.e. &ldquo;aab&rdquo; is a false.</p></blockquote>

<h3>Solution</h3>

<p>This looks like a question without any clue. However, this actually is a modified version of <strong>[LintCode] Longest Common Subsequence</strong>.</p>

<p>Look at that question: there&rsquo;s 2 input string, and they match char-by-char. For this question, we are simply <strong>matching input string with input string itself</strong>. And chars should be match <strong>ONLY</strong> at different positions, that&rsquo;s the key. As pointed out by the <a href="http://www.careercup.com/question?id=5931067269709824">top comment</a>:</p>

<blockquote><p>Now we can modify the longest_common_subsequence(a, a) to find the value of the longest repeated subsequence in a by excluding the cases when i == j</p></blockquote>

<h3>Code</h3>

<pre><code>public boolean checkRepeatSubseq(String input) {
    int len = input.length();
    int[][] dp = new int[len + 1][len + 1];
    // dp[i][j] denotes the length of subseq between 2 strings:
    // 1. first i chars of input
    // 2. first j chars of input
    for (int i = 1; i &lt;= len; i++) {
        for (int j = i; j &lt;= len; j++) {
            if (i != j &amp;&amp; input.charAt(i - 1) == input.charAt(j - 1)) {
                int temp = Math.max(dp[i - 1][j], dp[i][j - 1]);
                dp[i][j] = Math.max(temp, dp[i - 1][j - 1] + 1);
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[len][len] &gt;= 2;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/11/all-repeating-substring-given-length/">[LinkedIn] Find All Repeating Substring With Given Length</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-11T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2015/01/11/all-repeating-substring-given-length/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2015/01/11/all-repeating-substring-given-length/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=6495932900179968">link</a></p>

<blockquote><p>Find all the repeating substring of specified length in a large string sequence.</p>

<p>For e.g.</p></blockquote>

<pre><code>Input String: "ABCACBABC" 
repeated sub-string length: 3 
Output: ABC 
</code></pre>

<blockquote><p>eg.</p></blockquote>

<pre><code>Input String: "ABCABCA" 
repeated sub-string length: 2 
Output: AB, BC, CA
</code></pre>

<h3>Solution</h3>

<p>Similar to <strong>[Amazon] Longest Repeating Substring</strong>, the best solution is to do <strong>Suffix Tree</strong>, or suffix array. We then need to print nodes on a certain level, who has more than 1 descendant.</p>

<p>However, since the length of substring is given, we can also do simply iteration: insert all substring with given length into a HashSet, and check repetition. <a href="https://github.com/techpanja/interviewproblems/blob/master/src/strings/repeatingstringsofspecifiedlength/RepeatingStringOfSpecificLength.java">ref</a></p>

<h3>Code</h3>

<p>Suffix tree solution: not written.</p>

<p>Hashset code:</p>

<pre><code>public List&lt;String&gt; solve(String input, int k) {
    List&lt;String&gt; ans = new ArrayList&lt;String&gt;();
    HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();
    for (int i = 0; i &lt;= input.length() - k; i++) {
        String sub = input.substring(i, i + k);
        if (set.contains(sub)) {
            ans.add(sub);
        }
        set.add(sub);
    }
    return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/11/all-distinct-subsequences-given-length%20-%20Copy/">[Question] All Distinct Subsequences With Given Length</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-11T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2015/01/11/all-distinct-subsequences-given-length%20-%20Copy/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2015/01/11/all-distinct-subsequences-given-length%20-%20Copy/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://11011110.livejournal.com/254164.html">link</a></p>

<blockquote><p>Find a polynomial-time algorithm that takes a string of length n, and a number k, output the number of distinct k-character subsequences.</p>

<p>For instance, input &ldquo;food&rdquo; and number k=2, output should be 4. There are four distinct 2-character subsequences of &ldquo;food&rdquo;: &ldquo;fo&rdquo;, &ldquo;fd&rdquo;, &ldquo;oo&rdquo;, and &ldquo;od&rdquo;.</p></blockquote>

<h3>Solution</h3>

<p>Similar to <strong>[Question] Number of distinct sub-sequence</strong>, we solve this problem with DP. The dp equation is a bit difficult to write.</p>

<p>The idea come from comment from <a href="http://11011110.livejournal.com/254164.html">gareth_rees</a>:</p>

<blockquote><p>Let θ(S, k) be the number of distinct k-character subsequences in the string S of length n.</p>

<p>Clearly θ(S, k) = 1 if n = k or k = 0</p>

<p>and θ(S, k) = 0 if n &lt; k.</p>

<p>Otherwise, <strong>choose 1 unique char from S</strong>, and deduct k by 1, then do the DP calculation with the remaining part of S.</p></blockquote>

<p>Look at this example:</p>

<pre><code>θ("food", 2) = θ("ood", 1) + θ("od", 1) + θ("", 1)
= (θ("od", 0) + θ("", 0)) + (θ("d", 0) + θ("", 0)) + 0
= (1 + 1) + (1 + 1)
= 4
</code></pre>

<p><strong>&ldquo;food&rdquo; is divided into 3 parts</strong>. First part we choose &ldquo;f&rdquo; to be the first char, thus the value is θ(&ldquo;ood&rdquo;, 1). Second part we choose &ldquo;o&rdquo;, and final part we choose &ldquo;d&rdquo;.</p>

<p><strong>Note that when we choose a char, it must never have been chosen before</strong>. In case of &ldquo;food&rdquo;, we only choose &lsquo;f&rsquo;, &lsquo;o&rsquo;, &rsquo;d&#8217; once for each.</p>

<p>This is a very difficult DP question, but the explanation really makes the answer easier. Read my implementation below.</p>

<h3>Code</h3>

<pre><code>public int countSubSeq(String input, int k) {
    // assuming all input chars are small letter
    return choose(input, 0, k);
}

private int choose(String input, int start, int numChar) {
    int charLeft = input.length() - start;
    if (charLeft == numChar || numChar == 0) {
        return 1;
    } else if (charLeft &lt; numChar || numChar &lt; 0) {
        return 0;
    }
    // now numChar is smaller than charLeft, and larger than 0
    // start to pick a char (which is at first appearance)
    int total = 0;
    HashSet&lt;Character&gt; chosen = new HashSet&lt;Character&gt;();
    while (start &lt; input.length()) {
        char currentChar = input.charAt(start);
        if (!chosen.contains(currentChar)) {
            // pick the char pointer by 'start'
            total += choose(input, start + 1, numChar - 1);
            chosen.add(currentChar);
        }
        start++;
    }
    return total;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/11/Diameter-of-Binary-Tree/">[Google] Diameter of a Binary Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-11T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2015/01/11/Diameter-of-Binary-Tree/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2015/01/11/Diameter-of-Binary-Tree/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/diameter-of-a-binary-tree/">link</a></p>

<blockquote><p>The diameter of a tree (sometimes called the width) is the number of nodes on the longest path between two leaves in the tree.</p></blockquote>

<p><img class="middle" src="/assets/images/tree-diameter-1.gif"></p>

<h3>Solution</h3>

<p>This is a similar question to <strong>[LeetCode 124] Binary Tree Maximum Path Sum</strong>. <strong>However there&rsquo;s a significant difference</strong> which might be overlooked while coding.</p>

<p>Look at this example:</p>

<pre><code>     0
       1
        1
       0  1
           1
</code></pre>

<p>If we only want to find the max path, that would return result of 5, which is root-to-rightmost-leaf. However, the diameter should be 4, which is the distance between 2 leaf nodes.</p>

<p>A solution is available for reading <a href="http://stackoverflow.com/a/3124575">here</a>.</p>

<p>For <strong>[Google] Crazy Distance Between Strings</strong>, there is another special case: {&ldquo;1&rdquo;, &ldquo;11&rdquo;, &ldquo;10&rdquo;}. The program will not output correct result (1), because this is not really the diameter of a tree, but instead, a max path from a non-leaf to a leaf. I leave this part for you to finish.</p>

<h3>Code</h3>

<p>Refer to <strong>[Google] Crazy Distance Between Strings</strong> for complete code.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/10/reverse-a-stack/">[Google] Reverse a Stack Without DS</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2015/01/10/reverse-a-stack/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2015/01/10/reverse-a-stack/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.geeksforgeeks.org/reverse-a-stack-using-recursion/">link</a></p>

<blockquote><p>Reverse a stack using recursion. You are not allowed to use loops or data structure, and you can only use the following functions:</p></blockquote>

<pre><code>isEmpty(S)
push(S)
pop(S)
</code></pre>

<h3>Solution</h3>

<p>Well since we are not allowed to use additional DS or loop, we have to use system stack to help us!</p>

<p>We add a new method: <strong>insert at stack bottom</strong>. Then we can solve this question recursively. Nice question, and tricky answer!</p>

<h3>Code</h3>

<pre><code>public void reverse(Stack&lt;Integer&gt; stack) {
    if (stack.isEmpty() || stack.size() == 1) {
        return;
    }
    int top = stack.pop();
    this.reverse(stack);
    this.insertAtBottom(stack, top);
}

private void insertAtBottom(Stack&lt;Integer&gt; stack, int val) {
    if (stack.isEmpty()) {
        stack.push(val);
        return;
    }
    int temp = stack.pop();
    this.insertAtBottom(stack, val);
    stack.push(temp);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/10/minimum-range-inclueds-at-least-1/">[Amazon] Mininum Range That Includes at Least One</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-10T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2015/01/10/minimum-range-inclueds-at-least-1/#disqus_thread"
             data-disqus-identifier="http://okckd.github.io/blog/2015/01/10/minimum-range-inclueds-at-least-1/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="http://www.careercup.com/question?id=5103437989543936">link</a></p>

<blockquote><p>There are many sorted arrays. Find a minimum range, so that in each array there&rsquo;s at least one integer within this range.</p></blockquote>

<h3>Solution</h3>

<p><strong>Min-heap</strong>. <a href="http://www.careercup.com/question?id=16759664">source</a></p>

<blockquote><p>There are k lists of sorted integers. Make a min heap of size k containing 1 element from each list. Keep track of min and max element and calculate the range.</p>

<p>In min heap, minimum element is at top. Delete the minimum element and another element instead of that from the same list to which minimum element belong. Repeat the process till any one of the k list gets empty.</p></blockquote>

<h3>Code</h3>

<pre><code>public void printMinRange(int[][] input) {
    Comparator&lt;Pointer&gt; compr = new HeapComparator(input);
    // Note that we pass in 'input' arrays to the comparator
    PriorityQueue&lt;Pointer&gt; heap = new PriorityQueue&lt;Pointer&gt;(SIZE, compr);

    int maxVal = Integer.MIN_VALUE;
    for (int i = 0; i &lt; SIZE; i++) {
        heap.add(new Pointer(i, 0));
        // insert the head of each array into the heap
        maxVal = Math.max(maxVal, input[i][0]);
        // keep additional value to keep track of the max value in heap
    }

    int left = 0;
    int right = Integer.MAX_VALUE;
    while (heap.size() == SIZE) {
        Pointer p = heap.remove();
        // first, update the range
        if (maxVal - input[p.index][p.position] &lt; right - left) {
            right = maxVal;
            left = input[p.index][p.position];
        }
        // then, push the next element after 'p' to the heap
        // meanwhile, update 'maxVal'
        if (p.position + 1 &lt; input[p.index].length) {
            Pointer nextP = new Pointer(p.index, p.position + 1);
            heap.add(nextP);
            maxVal = Math.max(maxVal, input[nextP.index][nextP.position]);
        }
        // when 'p' is the last element in the row, terminate loop
    }
    System.out.println("Left boundary: " + left);
    System.out.println("Right boundary: " + right);
}

class HeapComparator implements Comparator&lt;Pointer&gt; {

    int[][] arrays = null;

    public HeapComparator(int[][] input) {
        arrays = input;
    }

    public int compare(Pointer p1, Pointer p2) {
        return arrays[p1.index][p1.position]
                - arrays[p2.index][p2.position];
    }
}

class Pointer {
    int index, position;

    public Pointer(int x, int y) {
        index = x;
        position = y;
    }
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/3">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (57)</a></li>
<li class='category'><a href='/blog/categories/experience/'>experience (3)</a></li>
<li class='category'><a href='/blog/categories/facebook/'>facebook (9)</a></li>
<li class='category'><a href='/blog/categories/fundamental/'>fundamental (5)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (44)</a></li>
<li class='category'><a href='/blog/categories/java-oop/'>java oop (22)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (153)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (99)</a></li>
<li class='category'><a href='/blog/categories/string-search/'>string search (7)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (7)</a></li>
<li class='category'><a href='/blog/categories/top-k/'>top k (7)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/01/19/speed-up-web-page-2/">[Design] Speed Up Webpage for Slow Connection (2)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/19/difference-http-tcp/">[Design] Difference Between HTTP Protocol and TCP Protocol</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/18/speed-up-web-page-1/">[Design] Speed Up Webpage for Slow Connection (1)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/18/max-squre-with-all-1/">[Question] Maximum Square Sub-matrix With All 1s</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/18/lexicographic-order-from-dict/">[Google] Lexicographic Order From Dictionary</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Charlie Brown -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
