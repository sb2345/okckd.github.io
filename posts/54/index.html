
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Shuatiblog.com</title>
  <meta name="author" content="CodeMonkey">

  
  <meta name="description" content="Question link Given n non-negative integers representing the histogram&#8217;s bar height where the width of each bar is 1, find the area of largest &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.shuatiblog.com/posts/54/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Shuatiblog.com" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.shuatiblog.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="blue_light">
            Shuatiblog.com
        </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/23/Largest-Rectangle-in-Histogram/">[LeetCode 84] Largest Rectangle in Histogram</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-23T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/23/Largest-Rectangle-in-Histogram/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/largest-rectangle-in-histogram/">link</a></p>

<div class="question-content">
            <p></p><p>
Given <i>n</i> non-negative integers representing the histogram&#8217;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.
</p>

<p>
<img src="http://www.leetcode.com/wp-content/uploads/2012/04/histogram.png"><br>
</p><p style="font-size: 11px">Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p>
<p></p>

<p>
<img src="http://www.leetcode.com/wp-content/uploads/2012/04/histogram_area.png"><br>
</p><p style="font-size: 11px">The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p>
<p></p>

<p>
For example,<br>
Given height = <code>[2,1,5,6,2,3]</code>,<br>
return <code>10</code>.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is an extremely difficult question</strong>.</p>

<p>The idea of the solution (using stack) seems understandable, but can be very tricky when coding.</p>

<p><strong>The basic idea is, always keep increasing elements in the stack</strong>. When I see a decrease in number, pop stack. And I calculate max area only when poping elements. In the end, a &lsquo;0&rsquo; is inserted to the end, so that all stack item will be popped (and at the same time, max area been calculated).</p>

<p>Sorry if I did not explain well enough. <a href="http://www.geeksforgeeks.org/largest-rectangle-under-histogram/">Here</a> is a better one:</p>

<blockquote cite="http://www.geeksforgeeks.org/largest-rectangle-under-histogram/">
<p>
We traverse all bars from left to right, maintain a stack of bars.  Every bar is pushed to stack once.  A bar is popped from stack when a bar of smaller height is seen.  When a bar is popped, we calculate the area with the popped bar as smallest bar. How do we get left and right indexes of the popped bar – the current index tells us the ‘right index’ and index of previous item in stack is the ‘left index’.  Following is the complete algorithm.
</p>
<p><strong>1) </strong>Create an empty stack.</p>
<p><strong>2) </strong>Start from first bar, and do following for every bar ‘hist[i]‘ where ‘i’ varies from 0 to n-1.<br>
……<strong>a)</strong> If stack is empty or hist[i] is higher than the bar at top of stack, then push ‘i’ to stack.<br>
……<strong>b)</strong> If this bar is smaller than the top of stack, then keep removing the top of stack while top of the stack is greater. Let the removed bar be hist[tp]. Calculate area  of rectangle with hist[tp] as smallest bar. For hist[tp], the ‘left index’ is previous (previous to tp) item in stack and ‘right index’ is ‘i’ (current index).</p>
<p><strong>3)</strong> If the stack is not empty, then one by one remove all bars from stack and do step 2.b for every removed bar.</p>
</blockquote>


<p>Time complexity of the stack solution is <strong>O(n)</strong>. (Another algo analysis article <a href="http://tech-queries.blogspot.sg/2011/03/maximum-area-rectangle-in-histogram.html">here</a>)</p>

<h3>Solution</h3>

<p><strong>I wrote the code using idea from <a href="http://jane4532.blogspot.sg/2013/07/longest-rectangle-in-histogramleetcode.html">blog</a></strong>. It works, but there are 2 things that I got wrong.</p>

<p><strong>First, if elements are equal</strong>. I shall also push it. I can not simply skip it, I don&rsquo;t know why!</p>

<blockquote><p>if (stack.isEmpty() || cur >= height[stack.peek()])</p></blockquote>

<p><strong>Second, about how to calculate the width of the rectangle</strong>. I used this before:</p>

<blockquote><p>int width = stack.isEmpty() ? p : p &ndash; h;</p></blockquote>

<p>It&rsquo;s wrong, I must get the value of next element from stack, and then calculate width. Why? there might be element been popped before, which locate between these 2 elements in stack.</p>

<blockquote><p>int width = stack.isEmpty() ? p : p &ndash; stack.peek() &ndash; 1;</p></blockquote>

<p><strong>Updated on July 4th, 2014</strong>: the above 2 points are very valid, especially the second. Keep in mind:</p>

<ol>
<li><p>The values in stack means the last position that a height can be found. For example, height is (2, 10, 5) then the stack would have (2, removed, 5). When calculating the area for height 5, we should note the removed space is in consideration as well.</p></li>
<li><p>So, when equal height is found, pop it. Because you won&rsquo;t need it any more. The stack only stores last position this height is found.</p></li>
<li><p>When stack is empty, the width of rectange should be calculated from 0.</p></li>
</ol>


<h3>Code</h3>

<p><strong>My code written on July 4th, 2014</strong></p>

<pre><code>public int largestRectangleArea(int[] height) {
    if (height == null || height.length == 0) {
        return 0;
    }
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    stack.add(0);
    int len = height.length;
    int area = 0;
    for (int i = 1; i &lt;= len; i++) {
        int h = i == len ? 0 : height[i];
        // pop a element and calculate its max area
        // pop until the top element is smaller than h, then push h
        while (!stack.isEmpty() &amp;&amp; h &lt;= height[stack.peek()]) {
            int pos = stack.pop();
            int width = stack.isEmpty() ? i : i - stack.peek() - 1;
            area = Math.max(area, height[pos] * width);
        }
        stack.push(i);
    }
    return area;
}
</code></pre>

<p><strong>My code written on July 18th, 2014</strong></p>

<pre><code>public int largestRectangleArea(int[] height) {
    if (height == null || height.length == 0) {
        return 0;
    }
    int maxArea = Integer.MIN_VALUE;
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    int p = 0;
    while (p &lt; height.length) {
        if (stack.isEmpty() || height[stack.peek()] &lt;= height[p]) {
            stack.push(p);
            p++;
        } else {
            int h = stack.pop();
            int w = stack.isEmpty() ? p : p - stack.peek() - 1;
            int area = height[h] * w;
            maxArea = Math.max(maxArea, area);
        }
    }
    while (!stack.isEmpty()) {
        int h = stack.pop();
        int w = stack.isEmpty() ? p : p - stack.peek() -1;
        int area = height[h] * w;
        maxArea = Math.max(maxArea, area);
    }
    return maxArea;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/23/Gray-Code/">[LeetCode 89] Gray Code</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-23T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/23/Gray-Code/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/gray-code/">link</a></p>

<div class="question-content">
            <p></p><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>

<p>Given a non-negative integer <i>n</i> representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>

<p>For example, given <i>n</i> = 2, return <code>[0,1,3,2]</code>. Its gray code sequence is:</p>
<pre>00 - 0
01 - 1
11 - 3
10 - 2
</pre>

<p><b>Note:</b><br>
For a given <i>n</i>, a gray code sequence is not uniquely defined.
</p>
<p>For example, <code>[0,2,3,1]</code> is also a valid gray code sequence according to the above definition.</p>

<p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a qure mathematics question.</strong></p>

<p><a href="http://en.wikipedia.org/wiki/Gray_code">Gray Code</a> is a very classic binary system, and we shall keep in mind clearly of its mathematical solution.</p>

<h3>Solution</h3>

<p><strong>My solution is using recursion</strong>. First get the answer of input value = (n-1), then from that list, generate answer for input = n. <a href="http://fisherlei.blogspot.sg/2012/12/leetcode-gray-code.html">A post</a> talked about this.</p>

<p><strong>The math approach to solve this problem is much more simpler</strong>. The (i)th element of Gray Code is calculated by the following method (I learnt from <a href="http://blog.csdn.net/worldwindjp/article/details/21536103">this blog</a>):</p>

<blockquote><p>binaryToGray = (i >> 1) ^ i;</p></blockquote>

<p>For example,</p>

<blockquote><p>00 &ndash;> 00</p>

<p>01 &ndash;> 01</p>

<p>10 &ndash;> 11</p>

<p>11 &ndash;> 10</p></blockquote>

<h3>Code</h3>

<p><strong>First, my solution</strong></p>

<pre><code>public ArrayList&lt;Integer&gt; grayCode(int n) {
    ArrayList&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();
    if (n == 0) {
        ans.add(0);
        return ans;
    }
    ArrayList&lt;Integer&gt; half = grayCode(n-1);
    ans.addAll(half);
    for (int i = half.size() - 1; i &gt;= 0; i -- ) 
        ans.add(half.get(i) + (int)Math.pow(2, n-1));
    return ans;
}
</code></pre>

<p><strong>Second, math solution</strong></p>

<pre><code>public ArrayList&lt;Integer&gt; grayCode(int n) {
    ArrayList&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();
    for (int i = 0; i &lt; 1 &lt;&lt; n; i ++) 
        ans.add((i &gt;&gt; 1) ^ i);
    return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/23/Decode-Ways/">[LeetCode 91] Decode Ways</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-23T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/23/Decode-Ways/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/decode-ways/">link</a></p>

<div class="question-content">
            <p></p><p>
A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:
</p>

<pre>'A' -&gt; 1
'B' -&gt; 2
...
'Z' -&gt; 26
</pre>

<p>
Given an encoded message containing digits, determine the total number of ways to decode it.
</p>

<p>
For example,<br>
Given encoded message <code>"12"</code>,
it could be decoded as <code>"AB"</code> (1 2) or <code>"L"</code> (12).
</p>

<p>
The number of ways decoding <code>"12"</code> is 2.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question is easy to think, but hard to write.</strong></p>

<p>Why? Because there are a lot of cases that the decode ways = 0. For example, input = &ldquo;02&rdquo; or &ldquo;50&rdquo;. We must handle those cases well. Also, boundary cases can cause some trouble.</p>

<h3>Solution</h3>

<p><strong>DP solution, the transformation function is:</strong></p>

<blockquote><p>Count[i] = Count[i-1]  if only S[i-1] is valid</p>

<p>Count[i] = Count[i-1] + Count[i-2] if S[i-1] and S[i-2] both valid</p></blockquote>

<h3>Code</h3>

<p><strong>First, my code.</strong></p>

<pre><code>public int numDecodings(String s) {
    int len = s.length();
    if (len == 0) return 0;
    // now len &gt;= 1
    int[] dp = new int[len];
    if (s.charAt(0) == '0') dp[0] = 0;
    else dp[0] = 1;
    if (len == 1) return dp[0];
    // now len &gt;= 2
    for (int i = 1; i &lt; len; i ++) {
        if (s.charAt(i) != '0') dp[i] += dp[i-1];
        int doubleDigit = Integer.parseInt(s.substring(i-1, i+1));
        if (s.charAt(i-1) != '0' &amp;&amp; 1 &lt;= doubleDigit &amp;&amp; doubleDigit &lt;= 26)
            if (i != 1) dp[i] += dp[i-2];
            else dp[i] += 1;
    }
    return dp[len - 1];
}
</code></pre>

<p><strong>Second, code from <a href="http://blog.csdn.net/u011095253/article/details/9248109">this blog</a>.</strong></p>

<p>The only difference is an additional &lsquo;1&rsquo; at position 0 of the dp array. This helps simply the code a lot!</p>

<pre><code>public int numDecodings(String s) {  
    int n = s.length();  
    if (n==0) return 0;  
    int[] dp = new int[n+1];  
    dp[0] = 1;  
    if (isValid(s.substring(0,1))) dp[1] = 1;  
    else dp[1] = 0;  
    for(int i=2; i&lt;=n;i++){  
        if (isValid(s.substring(i-1,i)))  
            dp[i] = dp[i-1];  
        if (isValid(s.substring(i-2,i)))  
            dp[i] += dp[i-2];  
    }  
    return dp[n];  
}  

public boolean isValid(String s){  
    if (s.charAt(0)=='0') return false;  
    int code = Integer.parseInt(s);  
    return code&gt;=1 &amp;&amp; code&lt;=26;  
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/22/Subsets-II/">[LeetCode 90] Subsets II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-22T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/22/Subsets-II/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/subsets-ii/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a collection of integers that might contain duplicates, <i>S</i>, return all possible subsets.
</p>
<p><b>Note:</b><br>
</p><ul>
<li>Elements in a subset must be in non-descending order.</li>
<li>The solution set must not contain duplicate subsets.</li>
</ul>
<p></p>
<p>
For example,<br>
If <b><i>S</i></b> = <code>[1,2,2]</code>, a solution is:
</p>

<pre>[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
</pre><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a question based on &ldquo;Subsets&rdquo; question</strong>.</p>

<p>Solution is similar, only need to add features to avoid duplication.</p>

<h3>Solution</h3>

<p>Based on the solution of previous question, I only add 1 variable called <strong>nonDupSize</strong>, which is the size that I need to merge new element with. For example, <strong>input = {1, 2, 3, 3}</strong></p>

<blockquote><p>Initialize the subset:  {}</p>

<p>Added element &ldquo;1&rdquo;: {}, <strong>{&ldquo;1&rdquo;}</strong> (1 more elements)</p>

<p>Added element &ldquo;2&rdquo;: {}, {&ldquo;1&rdquo;}, <strong>{&ldquo;2&rdquo;}, {&ldquo;1&rdquo;, &ldquo;2&rdquo;}</strong> (2 more elements)</p>

<p>Added element &ldquo;3&rdquo;: {}, {&ldquo;1&rdquo;}, {&ldquo;2&rdquo;}, {&ldquo;1&rdquo;, &ldquo;2&rdquo;}, <strong>{&ldquo;3&rdquo;}, {&ldquo;1&rdquo;,&ldquo;3&rdquo;}, {&ldquo;2&rdquo;,&ldquo;3&rdquo;}, {&ldquo;1&rdquo;, &ldquo;2&rdquo;,&ldquo;3&rdquo;}</strong> (4 more elements)</p>

<p>Added element &ldquo;3&rdquo;: {}, {&ldquo;1&rdquo;}, {&ldquo;2&rdquo;}, {&ldquo;1&rdquo;, &ldquo;2&rdquo;}, {&ldquo;3&rdquo;}, {&ldquo;1&rdquo;,&ldquo;3&rdquo;}, {&ldquo;2&rdquo;,&ldquo;3&rdquo;}, {&ldquo;1&rdquo;,&ldquo;2&rdquo;,&ldquo;3&rdquo;}, <strong>{&ldquo;3&rdquo;,&ldquo;3&rdquo;}, {&ldquo;1&rdquo;,&ldquo;3&rdquo;,&ldquo;3&rdquo;}, {&ldquo;2&rdquo;,&ldquo;3&rdquo;,&ldquo;3&rdquo;}, {&ldquo;1&rdquo;,&ldquo;2&rdquo;,&ldquo;3&rdquo;,&ldquo;3&rdquo;}</strong> (4 more elements)</p></blockquote>

<p>So instead of getting every list and merge with new element, I only get the lists of pre-calculated size (from bottom), and merge. Someone is having <a href="http://blog.csdn.net/perfect8886/article/details/22922785">similar solution</a> using a start-pointer.</p>

<h3>Code</h3>

<p><strong>my code</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subsetsWithDup(int[] num) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    ans.add(new ArrayList&lt;Integer&gt;());
    Arrays.sort(num);
    // In this solution I introduce a new variable: nonDupSize
    int curSize = 1, nonDupSize = 1;
    for (int i = 0; i &lt; num.length; i ++) {
        curSize = ans.size();
        if (i &gt; 0 &amp;&amp; num[i] != num[i - 1]) nonDupSize = curSize;
        for (int j = curSize - nonDupSize; j &lt; curSize; j ++) {
            ArrayList&lt;Integer&gt; cur = new ArrayList&lt;Integer&gt;(ans.get(j));
            cur.add(num[i]);
            ans.add(cur);
        }
    }
    return ans;
}
</code></pre>

<p><strong>Updated on June 12th</strong> &ndash; solution using the &lsquo;Permutation Model&rsquo;.</p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    if(num == null || num.length == 0) {
        return result;
    }
    Arrays.sort(num);
    helper(result, new LinkedList&lt;Integer&gt;(), num, 0);
    return result;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num, int position) {
    ans.add(new LinkedList&lt;Integer&gt;(path));
    for (int i = position; i &lt; num.length; i ++) {
        if (i &gt; position &amp;&amp; num[i - 1] == num[i]) {
            // if duplicate, only append num[position]
            continue;
        }
        path.add(num[i]);
        helper(ans, path, num, i + 1);
        path.remove(path.size() - 1);
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/22/Subsets/">[LeetCode 78] Subsets</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-22T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/22/Subsets/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/subsets/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a set of distinct integers, <i>S</i>, return all possible subsets.
</p>
<p><b>Note:</b><br>
</p><ul>
<li>Elements in a subset must be in non-descending order.</li>
<li>The solution set must not contain duplicate subsets.</li>
</ul>
<p></p>
<p>
For example,<br>
If <b><i>S</i></b> = <code>[1,2,3]</code>, a solution is:
</p>

<pre>[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</pre><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Solution</h3>

<p><strong>This is a classic DFS problem</strong>. This problem is easily solved by recursive calls.  But recursion is always not the best solution.</p>

<p><strong>A popular solution is</strong> (since elements got no duplications) <strong>adding elements 1 by 1</strong>. That is to say, get previous answer, add each list by a new element, and then add each new list back to answer. Continue until all elements are added in sequence. For example:</p>

<blockquote><p>Initialize the subset:  {}</p>

<p>Added element &ldquo;1&rdquo;: {}, {&ldquo;1&rdquo;}</p>

<p>Added element &ldquo;2&rdquo;: {}, {&ldquo;1&rdquo;}, {&ldquo;2&rdquo;}, {&ldquo;1&rdquo;, &ldquo;2&rdquo;}</p>

<p>Added element &ldquo;3&rdquo;: {}, {&ldquo;1&rdquo;}, {&ldquo;2&rdquo;}, {&ldquo;1&rdquo;, &ldquo;2&rdquo;}, {&ldquo;3&rdquo;}, {&ldquo;1&rdquo;,&ldquo;3&rdquo;}, {&ldquo;2&rdquo;,&ldquo;3&rdquo;}, {&ldquo;1&rdquo;, &ldquo;2&rdquo;,&ldquo;3&rdquo;}</p></blockquote>

<p>I found a very interesting <a href="http://blog.csdn.net/perfect8886/article/details/20496225">bit operation solution</a>, and I will also post it below.</p>

<h3>Code</h3>

<p><strong>First, recursion</strong>. This solution is trivial and boring.</p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subsets(int[] S) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (S.length == 0) {
        ans.add(new ArrayList&lt;Integer&gt;());
        return ans;
    }
    Arrays.sort(S);
    int head = S[0];
    int[] theRest = new int[S.length - 1];
    for (int i = 0; i &lt; theRest.length; i++) {
        theRest[i] = S[i + 1];
    }
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subAns = subsets(theRest);
    for (ArrayList&lt;Integer&gt; oneSet: subAns) {
        ArrayList&lt;Integer&gt; longerOneSet = new ArrayList&lt;Integer&gt;();
        longerOneSet.add(head);
        for (Integer a: oneSet) {
            longerOneSet.add(a);
        }
        ans.add(longerOneSet);
        ans.add(oneSet);
    }
    return ans;
}
</code></pre>

<p><strong>Second, add elements 1 by 1</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subsets(int[] S) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    ans.add(new ArrayList&lt;Integer&gt;());
    Arrays.sort(S);
    for (int i = 0; i &lt; S.length; i ++) {
        int curSize = ans.size();
        for (int j = 0; j &lt; curSize; j ++) {
            ArrayList&lt;Integer&gt; cur = new ArrayList&lt;Integer&gt;(ans.get(j));
            cur.add(S[i]);
            ans.add(cur);
        }
    }
    return ans;
}
</code></pre>

<p><strong>Third, bit operations</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subsets(int[] S) {  
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();  
    Arrays.sort(S);  
    int N = S.length;  
    for (int i = 0; i &lt; Math.pow(2, N); ++i) {  
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();  
        for (int j = 0; j &lt; N; ++j) {  
            if ((i &amp; (1 &lt;&lt; j)) &gt; 0) {  
                list.add(S[j]);  
            }  
        }  
        ans.add(list);  
    }  
    return ans;  
}  
</code></pre>

<p><strong>Updated on June 12th</strong> &ndash; solution using the &lsquo;Permutation Model&rsquo;.</p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; subsets(int[] num) {
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    if(num == null || num.length == 0) {
        return result;
    }
    Arrays.sort(num);
    helper(result, new LinkedList&lt;Integer&gt;(), num, 0);
    return result;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int[] num, int position) {
    ans.add(new LinkedList&lt;Integer&gt;(path));
    for (int i = position; i &lt; num.length; i ++) {
        path.add(num[i]);
        helper(ans, path, num, i + 1);
        path.remove(path.size() - 1);
    }
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/22/Search-in-Rotated-Sorted-Array-II/">[LeetCode 81] Search in Rotated Sorted Array II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-22T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/22/Search-in-Rotated-Sorted-Array-II/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/search-in-rotated-sorted-array-ii/">link</a></p>

<div class="question-content">
            <p></p><p>Follow up for &#8220;Search in Rotated Sorted Array&#8221;:<br>
What if <i>duplicates</i> are allowed?</p>

<p>Would this affect the run-time complexity? How and why?</p>

<p>Write a function to determine if a given target is in the array.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This one is based on the solution of previous question</strong>.</p>

<p>The previous question is already very difficult, both the logic and coding part. However, if you solve previous question by yourself, you will do this one easily.</p>

<p>I will pick the 2nd piece of code in previous question, and modify it to solve this problem.</p>

<blockquote><p>Solution for previous question:</p></blockquote>

<pre><code>public int search(int[] A, int target) {
    int left = 0;
    int right = A.length - 1;
    while (left &lt;= right) {
        int mid = (left + right) / 2;
        if (target == A[mid]) return mid;
        if (A[left] &lt;= A[mid]) {
            if (A[left] &lt;= target &amp;&amp; target &lt;= A[mid]) right = mid;
            else left = mid + 1;
        } else {
            if (A[mid] &lt;= target &amp;&amp; target &lt;= A[right]) left = mid;
            else right = mid - 1;
        }
    }
    return -1;
}
</code></pre>

<h3>Solution</h3>

<p><strong>My solution is to skip all duplicated numbers</strong> before the while-loop.</p>

<p><strong>The most standard solution is left-pointer incremental</strong>. A good code is written from <a href="http://www.cnblogs.com/feiling/p/3231196.html">this blog</a>.</p>

<h3>Code</h3>

<p><strong>First, my solution</strong></p>

<pre><code>public boolean search(int[] A, int target) {
    int len = A.length, L = 0, R = len - 1;
    if (A[L] == A[R]) {
        int duplicate = A[R];
        if (duplicate == target) return true;
        while (L &lt; len &amp;&amp; A[L] == duplicate) L ++;
        while (R &gt;= 0 &amp;&amp; A[R] == duplicate) R --;
    }
    while (L &lt;= R) {
        // Avoid overflow, same as M=(L+R)/2
        int M = L + ((R - L) / 2);
        if (A[M] == target) return true;
        // the bottom half is sorted
        if (A[L] &lt;= A[M])
            if (A[L] &lt;= target &amp;&amp; target &lt; A[M]) R = M - 1;
            else L = M + 1;
        // the upper half is sorted
        else 
            if (A[M] &lt; target &amp;&amp; target &lt;= A[R]) L = M + 1;
            else R = M - 1;
    }
    return false;
}
</code></pre>

<p><strong>Second, standard solution</strong></p>

<pre><code>public boolean search(int[] A, int target) {
    int len = A.length, L = 0, R = len - 1;
    while (L &lt;= R) {
        int M = L + ((R - L) / 2);
        if (A[M] == target) return true;
        if (A[L] &lt; A[M])
            if (A[L] &lt;= target &amp;&amp; target &lt; A[M]) R = M - 1;
            else L = M + 1;
        else if (A[L] &gt; A[M])
            if (A[M] &lt; target &amp;&amp; target &lt;= A[R]) L = M + 1;
            else R = M - 1;
        else L ++;
    }
    return false;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/22/Remove-Duplicates-from-Sorted-List-II/">[LeetCode 82] Remove Duplicates From Sorted List II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-22T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/22/Remove-Duplicates-from-Sorted-List-II/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <i>distinct</i> numbers from the original list.
</p>
<p>
For example,<br>
Given <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code>, return <code>1-&gt;2-&gt;5</code>.<br>
Given <code>1-&gt;1-&gt;1-&gt;2-&gt;3</code>, return <code>2-&gt;3</code>.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very important question</strong>. Solution is a little tricky with boundary cases that need consider.</p>

<p>My code works, but there is an <strong>extremely good solution</strong> posted below.</p>

<h3>Code</h3>

<p><strong>First, my code</strong></p>

<pre><code>public ListNode deleteDuplicates(ListNode head) {
    ListNode preHead = new ListNode(0);
    preHead.next = head;
    ListNode left = preHead, right = head;
    while (right != null) {
        if (right.next == null || right.val != right.next.val) {
            // next is differnet from previous
            left = right;
            right = right.next;
        }
        else {
            // next is same as previous
            while (right.next != null &amp;&amp; right.val == right.next.val) 
                right = right.next;
            left.next = right.next;
            right = right.next;
        }
    }
    return preHead.next;
}
</code></pre>

<p><strong>Second, a great solution from <a href="http://codeganker.blogspot.sg/2014/04/remove-duplicates-from-sorted-list-ii.html">this blog</a>.</strong></p>

<pre><code>public ListNode deleteDuplicates(ListNode head) {
    if(head == null) return head;
    ListNode helper = new ListNode(0);
    helper.next = head;
    ListNode pre = helper, cur = head;
    while(cur!=null)
    {
        while(cur.next!=null &amp;&amp; pre.next.val==cur.next.val)
            cur = cur.next;
        if (pre.next == cur) 
            pre = pre.next;
        else 
            pre.next = cur.next;
        cur = cur.next;
    }
    return helper.next;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/22/Remove-Duplicates-from-Sorted-List/">[LeetCode 83] Remove Duplicates From Sorted List</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-22T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/22/Remove-Duplicates-from-Sorted-List/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a sorted linked list, delete all duplicates such that each element appear only <i>once</i>.
</p>
<p>
For example,<br>
Given <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.<br>
Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question is trivial.</strong> The next following up question is not easy.</p>

<h3>Code</h3>

<p><strong>my code</strong></p>

<pre><code>public ListNode deleteDuplicates(ListNode head) {
    if (head == null) return null;
    ListNode pre = head;
    ListNode post = head;
    while (post != null){
        post = post.next;
        if (post == null || pre.val != post.val){
            pre.next = post;
            pre = post;
        }
    }
    return head;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/22/Remove-Duplicates-from-Sorted-Array-II/">[LeetCode 80] Remove Duplicates From Sorted Array II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-22T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/22/Remove-Duplicates-from-Sorted-Array-II/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/remove-duplicates-from-sorted-array-ii/">link</a></p>

<div class="question-content">
            <p></p><p>
Follow up for &#8220;Remove Duplicates&#8221;:<br>
What if duplicates are allowed at most <i>twice</i>?</p>

<p>
For example,<br>
Given sorted array A = <code>[1,1,1,2,2,3]</code>,
</p>
<p>
Your function should return length = <code>5</code>, and A is now <code>[1,1,2,2,3]</code>.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is an easy question</strong></p>

<h3>Code</h3>

<p><strong>my first code</strong></p>

<pre><code>public int removeDuplicates(int[] A) {
    if (A.length == 0) return 0;
    int insert = 1, pre = 0, cur = 1, count = 1;
    while (cur &lt; A.length) {
        if (A[pre] == A[cur]) {
            if (count == 1) {
                count = 2;
                A[insert] = A[pre];
                insert++;
                pre++;
            }
        } else if (A[pre] != A[cur]) {
            count = 1;
            A[insert++] = A[cur];
            pre = cur;
        }
        cur ++;
    }
    return insert;
}
</code></pre>

<p><strong>my second code</strong></p>

<pre><code>public int removeDuplicates(int[] A) {
    int len = A.length;
    if (len &lt; 3) return len;
    int left = 0, right = 0;
    boolean dup = false;
    while (right &lt; len) {
        if (right == 0 || A[right] != A[right - 1]) {
            A[left ++] = A[right ++];
            dup = false;
        } else if (! dup) {
            A[left ++] = A[right ++];
            dup = true;
        } else right ++;
    }
    return left;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/22/Combinations/">[LeetCode 77] Combinations</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-22T00:00:00-05:00" pubdate data-updated="true"></time>
        
         | <a href="/blog/2014/05/22/Combinations/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/combinations/">link</a></p>

<div class="question-content">
            <p></p><p>
Given two integers <i>n</i> and <i>k</i>, return all possible combinations of <i>k</i> numbers out of 1 &#8230; <i>n</i>.
</p>
<p>
For example,<br>
If <i>n</i> = 4 and <i>k</i> = 2, a solution is:
</p>

<pre>[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</pre><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8212;-</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very classic problem</strong>.</p>

<p>The solution is standard, and we must be able to write it without even using our <strong>brain</strong> (only use hands).</p>

<h3>Solution</h3>

<p>Solution 1, recursive DFS calls.</p>

<p>Solution 2, nested loop. Code is shown below.</p>

<h3>Code</h3>

<p><strong>First, my DFS solution</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combine(int n, int k) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (k == 0) return ans;
    helper(ans, new ArrayList&lt;Integer&gt;(), n, k, 0, 0);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans,ArrayList&lt;Integer&gt; list,
                    int n, int k, int curPt, int preNum) {
    if (curPt == k) {
        ans.add(new ArrayList&lt;Integer&gt;(list));
        return;
    }
    for (int i = preNum + 1; i &lt;= n - k + 1 + curPt; i ++) {
        list.add(i);
        helper(ans, list, n, k, curPt + 1, i);
        list.remove(list.size() - 1);
    }
}
</code></pre>

<p><strong>Second, my nested for-loop solution</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combine(int n, int k) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    ans.add(new ArrayList&lt;Integer&gt;());
    if (n == 0 || k == 0 || k &gt; n) return ans;
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; temp = null;
    for (int i = 0; i &lt; k; i ++) {
        temp = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
        for (ArrayList&lt;Integer&gt; a: ans) {
            for (int j = 1; j &lt;= n; j ++) {
                if (a.size() &gt; 0 &amp;&amp; a.get(a.size() - 1) &gt;= j) 
                    continue;
                a.add(j);
                temp.add(new ArrayList&lt;Integer&gt;(a));
                a.remove(a.size() - 1);
            }
        }
        ans = temp;
    }
    return ans;
}
</code></pre>

<p><strong>Updated June 14th, rewrote the code using template</strong></p>

<pre><code>public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();
    if (n == 0 || k == 0 || n &lt; k) {
        return ans;
    }
    helper(ans, new LinkedList&lt;Integer&gt;(), n, k, 1);
    return ans;
}

private void helper(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path, int n, int k, int pos) {
    if (path.size() == k) {
        ans.add(new LinkedList&lt;Integer&gt;(path));
        return;
    }
    for (int i = pos; i &lt;= n; i++) {
        path.add(i);
        helper(ans, path, n, k, i + 1);
        path.remove(path.size() - 1);
    }
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="55">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="53">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150v4/'>cc150v4 (34)</a></li>
<li class='category'><a href='/blog/categories/cc150v5/'>cc150v5 (28)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (76)</a></li>
<li class='category'><a href='/blog/categories/experience/'>experience (4)</a></li>
<li class='category'><a href='/blog/categories/fundamental/'>fundamental (18)</a></li>
<li class='category'><a href='/blog/categories/java-oop/'>java oop (36)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (177)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (16)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (25)</a></li>
<li class='category'><a href='/blog/categories/q-facebook/'>q-facebook (9)</a></li>
<li class='category'><a href='/blog/categories/q-google/'>q-google (63)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (126)</a></li>
<li class='category'><a href='/blog/categories/testing/'>testing (5)</a></li>
<li class='category'><a href='/blog/categories/z-string-search/'>z-string-search (17)</a></li>
<li class='category'><a href='/blog/categories/z-testing/'>z-testing (2)</a></li>
<li class='category'><a href='/blog/categories/z-top-k/'>z-top-k (6)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/11/04/Best-Time-to-Buy-and-Sell-Stock-IV/">[LeetCode 188] Best Time to Buy and Sell Stock IV </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/28/arraylist-implementation/">[Java OOP] Java ArrayList implementation </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/23/static-class-inner-class/">[Java OOP] Static class and Inner class </a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/23/java-what-is-exception/">[Java OOP] What is Java Exception</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/23/java-vector-arraylist/">[Java OOP] Java Vector and ArrayList </a>
      </li>
    
  </ul>
</section>





<script type="text/javascript" src="http://srvpub.com/adServe/banners?tid=29011_41781_0&size=120x600" ></script>

<!--
<script type="text/javascript">
  ( function() {
    if (window.CHITIKA === undefined) { window.CHITIKA = { 'units' : [] }; };
    var unit = {"calltype":"async[2]","publisher":"willran168","width":160,"height":600,"sid":"Chitika Default"};
    var placement_id = window.CHITIKA.units.length;
    window.CHITIKA.units.push(unit);
    document.write('<div id="chitikaAdBlock-' + placement_id + '"></div>');
}());
</script>
<script type="text/javascript" src="//cdn.chitika.net/getads.js" async></script>
&#8211;>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
    Copyright &copy; 2015 - <a href="/about">CodeMonkey</a> -  All posts are my original writing, based uppon my personal view. <a href="/policy">Privacy Policy</a> - 
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'woodstockblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
