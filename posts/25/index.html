
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="Question link Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Note:
A solution &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://okckd.github.io/posts/25">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52495723-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:okckd.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Recover-Binary-Search-Tree/">[LeetCode 99] Recover Binary Search Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/recover-binary-search-tree/">link</a></p>

<div class="question-content">
            <p></p><p>
Two elements of a binary search tree (BST) are swapped by mistake.</p>

<p>Recover the tree without changing its structure.
</p>

<b>Note:</b><br>
A solution using O(<i>n</i>) space is pretty straight forward. Could you devise a constant space solution?
<p></p>

<p></p>
</div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is one of the most difficult questions that I have solved</strong>.</p>

<p>The question can be solved using 2 pointers to point to the 2 misplaced nodes, and swap them. I solved the problem with this approach, and I found a good explanation <a href="http://chaoren.is-programmer.com/posts/42931.html">here</a>.</p>

<blockquote><p>Only two variables (first, second) are enough to record nodes to be exchanged.</p>

<p>If there&rsquo;s only one descending order pair (e.g. 20, 10, 30, 40, 50), use first &amp; second to record it.</p>

<p>If there are two descending order pairs (e.g. 10, 40, 30, 20, 50 or 50, 20, 30, 40, 10), use the smaller number in second pair to update variable &lsquo;second&rsquo;.</p>

<p>In the end, swap first and second.</p></blockquote>

<p>This is a popular solution on the Internet, which <strong>uses O(1) space, plus average case O(lgn) stack space</strong> (because recursion always incur stack usage). So this solution is actually not fulfilling the requirements.</p>

<blockquote><p>中序遍历二叉树的空间复杂度是O(logN) on average case</p></blockquote>

<p><strong>So finally I found a solution with constent space, and it&rsquo;s using Treaded Binary Tree again</strong>! Look below for details.</p>

<h3>Solution</h3>

<p><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/">This</a> is a systematic analysis of <strong>Morris Traversal</strong> based on <strong>Threaded Binary Tree</strong>.</p>

<p><strong>A solution of using Morris Traversal is explained <a href="http://www.cnblogs.com/TenosDoIt/p/3445682.html">here</a></strong>. Don&rsquo;t worry about the tree structure being changed, because it&rsquo;s reverted back after the traversal.</p>

<blockquote><p>算法2：为了满足O(1)空间复杂度，我们就要使用非递归且不使用栈的中序遍历算法，在leetcode另一个题目Binary Tree Inorder Traversal中，我们提到了Morris Traversal中序遍历算法，它既没有递归，也没有使用栈，而是用了线索二叉树的思想，用闲置的右节点指向中序序列中该节点的后缀，遍历后再恢复树的原始指针。其主要算法步骤如下：</p>

<p>重复以下1、2直到当前节点为空。</p></blockquote>

<p><strong><a href="http://fisherlei.blogspot.sg/2012/12/leetcode-recover-binary-search-tree.html">Another person</a></strong> have a very good (maybe better) English version of analysis and code:</p>

<pre><code>1. Initialize current as root 
2. While current is not NULL
   If current does not have left child
      a) Print current’s data
      b) Go to the right, i.e., current = current-&amp;gt;right
   Else
      a) Make current as right child of the rightmost node in current's left subtree
      b) Go to this left child, i.e., current = current-&amp;gt;left
</code></pre>

<h3>Code</h3>

<p><strong>First, my code (2 pointer solution)</strong></p>

<pre><code>TreeNode first = null, second = null;
TreeNode pre = new TreeNode(Integer.MIN_VALUE);

public void recoverTree(TreeNode root) {
    helper(root);
    // now first and second are both found
    int temp = first.val;
    first.val = second.val;
    second.val = temp;
}

private void helper(TreeNode root) {
    if (root == null) return;
    helper(root.left);
    if (pre.val &gt; root.val) {
        if (first == null) {
            first = pre;
            second = root;
        }
        else second = root;
    }
    pre = root;
    helper(root.right);
}
</code></pre>

<p><strong>Second, real O(1) space solution</strong> using Threaded Binary Tree (i.e. Morris Traversal) in C++. I could not memorize this code.</p>

<pre><code>void recoverTree(TreeNode *root) {
       TreeNode *f1=NULL, *f2=NULL;
       TreeNode  *current,*pre, *parent=NULL;

       if(root == NULL)
             return;
       bool found = false;
       current = root;
       while(current != NULL)
       {                
             if(current-&gt;left == NULL)
             {
                    if(parent &amp;&amp; parent-&gt;val &gt; current-&gt;val)
                    {
                           if(!found)
                           {
                                 f1 = parent;
                                 found = true;
                           }
                           f2 = current;
                    }
                    parent = current;
                    current = current-&gt;right;     
             }   
             else
             {
                    /* Find the inorder predecessor of current */
                    pre = current-&gt;left;
                    while(pre-&gt;right != NULL &amp;&amp; pre-&gt;right != current)
                           pre = pre-&gt;right;

                    /* Make current as right child of its inorder predecessor */
                    if(pre-&gt;right == NULL)
                    {
                           pre-&gt;right = current;
                           current = current-&gt;left;
                    }

                    /* Revert the changes made in if part to restore the original
                    tree i.e., fix the right child of predecssor */  
                    else
                    {
                           pre-&gt;right = NULL;
                           if(parent-&gt;val &gt; current-&gt;val)
                           {
                                 if(!found)
                                 {
                                        f1 = parent;       
                                        found = true;
                                 }
                                 f2 = current;
                           }
                           parent = current;
                           current = current-&gt;right;     
                    } /* End of if condition pre-&gt;right == NULL */
             } /* End of if condition current-&gt;left == NULL*/
       } /* End of while */

       if(f1 &amp;&amp; f2)
             swap(f1-&gt;val, f2-&gt;val);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Minimum-Depth-of-Binary-Tree/">[LeetCode 111] Minimum Depth of Binary Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/minimum-depth-of-binary-tree/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, find its minimum depth.</p>

<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>There are various ways to solve this question.</strong></p>

<p>Eg. DFS, BFS, queue and so on.</p>

<h3>Solution</h3>

<p>I have nothing to say with the code.</p>

<h3>Code</h3>

<pre><code>public int minDepth(TreeNode root) {
    if (root == null) return 0;
    return helper(root, Integer.MAX_VALUE, 1);
}

private int helper(TreeNode node, int min, int level) {
    if (node == null || level &gt;= min) 
        return min;
    if (node.left == null &amp;&amp; node.right == null)
        return level;
    min = helper(node.left, min, level + 1);
    min = helper(node.right, min, level + 1);
    return min;
}
</code></pre>

<p><strong>Updated on June 10th, this question is better solved with the Divide &amp; Conquer template</strong>! <a href="http://answer.ninechapter.com/solutions/minimum-depth-of-binary-tree/">link</a></p>

<pre><code>public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return checkLeaf(root);
}

private int checkLeaf(TreeNode node) {
    if (node == null) {
        return Integer.MAX_VALUE;
    }
    if (node.left == null &amp;&amp; node.right == null) {
        return 1;
    }
    int ll = checkLeaf(node.left);
    int rr = checkLeaf(node.right);
    return 1 + Math.min(ll, rr);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Maximum-Depth-of-Binary-Tree/">[LeetCode 104] Maximum Depth of Binary Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/maximum-depth-of-binary-tree/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, find its maximum depth.</p>

<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>There are various ways to solve this question.</strong></p>

<p>Eg. DFS, BFS, queue and so on.</p>

<h3>Solution</h3>

<p>I have nothing to say with the code.</p>

<h3>Code</h3>

<pre><code>public int maxDepth(TreeNode root) {
    return helper(root, 0, 1);
}

private int helper(TreeNode node, int max, int level) {
    if (node == null) return max;
    if (node.left == null &amp;&amp; node.right == null)
        return Math.max(max, level);
    max = helper(node.left, max, level + 1);
    max = helper(node.right, max, level + 1);
    return max;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Collection-Tree-Traversal/">[Collection] a Collection of Tree Traversal Questions</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>First Word</h3>

<p>Tree Traversal is a classic category of question, however solving it in non-recursive way is not very easy.</p>

<h3>Question List</h3>

<p>Inorder, preorder and postorder</p>

<ol>
<li><p><strong><a href="/blog/2014/05/24/Binary-Tree-Inorder-Traversal/">Binary Tree Inorder Traversal</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/24/Binary-Tree-Inorder-Traversal/">Binary Tree Preorder Traversal</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/24/Binary-Tree-Inorder-Traversal/">Binary Tree Postorder Traversal</a></strong></p></li>
</ol>


<p>Level-order</p>

<ol>
<li><p><strong><a href="/blog/2014/05/25/Binary-Tree-Level-Order-Traversal/">Binary Tree Level Order Traversal</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/25/Binary-Tree-Level-Order-Traversal-II/">Binary Tree Level Order Traversal II</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/25/Binary-Tree-Zigzag-Level-Order-Traversal/">Binary Tree Zigzag Level Order Traversal</a></strong></p></li>
</ol>


<p>Traversal-related questions</p>

<ol>
<li><p><strong><a href="/blog/2014/05/27/Construct-Binary-Tree-from-Preorder-and-Inorder/">Construct Binary Tree from Preorder and Inorder</a></strong></p></li>
<li><p><strong><a href="/blog/2014/05/27/Construct-Binary-Tree-from-Inorder-and-Postorder/">Construct Binary Tree from Inorder and Postorder</a></strong></p></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Binary-Tree-Zigzag-Level-Order-Traversal/">[LeetCode 103] Binary Tree Zigzag Level Order Traversal</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, return the <i>zigzag level order</i> traversal of its nodes&#8217; values. (ie, from left to right, then right to left for the next level and alternate between).</p>

<p>
For example:<br>
Given binary tree <code>{3,9,20,#,#,15,7}</code>,<br>
</p><pre>    3
   / \
  9  20
    /  \
   15   7
</pre>
<p></p>
<p>
return its zigzag level order traversal as:<br>
</p><pre>[
  [3],
  [20,9],
  [15,7]
]
</pre>
<p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This question is based on &ldquo;Binary Tree Level Order Traversal&rdquo;</strong>.</p>

<p>Altough this is difficulty level 4, the real difficult part is solving &ldquo;Binary Tree Level Order Traversal&rdquo;. If that question is solved, only slight modification is needed for this question.</p>

<h3>Solution</h3>

<p><strong>Instead of using queue</strong> like in &ldquo;Binary Tree Level Order Traversal&rdquo;, <strong>this question is solved by using Stack</strong>. And it&rsquo;s not hard to see why. The only additional things to note:</p>

<ol>
<li><p>There is no &lsquo;single stack solution&rsquo;, we must use <strong>2 stacks</strong>. (because when push, it&rsquo;s pushed to top).</p></li>
<li><p>Keep a boolean variable to remember rightToLeft or leftToRight.</p></li>
</ol>


<h3>Code</h3>

<p><strong>First, standard BFS solution</strong> using 2 stacks.</p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (root == null) return ans;
    Stack&lt;TreeNode&gt; q = new Stack&lt;TreeNode&gt;();
    q.push(root);
    boolean reverse = true;
    while (! q.isEmpty()) {
        ans.add(new ArrayList&lt;Integer&gt;());
        Stack&lt;TreeNode&gt; qq = new Stack&lt;TreeNode&gt;();
        int curSize = q.size();
        for (int i = 0; i &lt; curSize; i ++) {
            TreeNode node = q.pop();
            ans.get(ans.size() - 1).add(node.val);
            if (reverse) {
                if (node.left != null) qq.push(node.left);
                if (node.right != null) qq.push(node.right);
            }
            else {
                if (node.right != null) qq.push(node.right);
                if (node.left != null) qq.push(node.left);
            }
        }
        q = qq;
        reverse = ! reverse;
    }
    return ans;
}
</code></pre>

<p><strong>Second, DFS solution written by me</strong>, and yes, I love DFS more.</p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    helper(ans, root, 1);
    return ans;
}

private void helper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans, TreeNode node, int level) {
    if (node == null) return;
    if (ans.size() &lt; level) {
        ArrayList&lt;Integer&gt; lv = new ArrayList&lt;Integer&gt;();
        lv.add(node.val);
        ans.add(lv);
    }
    else {
        if (level % 2 == 0) 
            ans.get(level - 1).add(0, node.val);
        else
            ans.get(level - 1).add(node.val);
    }
    helper(ans, node.left, level + 1);
    helper(ans, node.right, level + 1);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Binary-Tree-Level-Order-Traversal-II/">[LeetCode 107] Binary Tree Level Order Traversal II</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, return the <i>bottom-up level order</i> traversal of its nodes&#8217; values. (ie, from left to right, level by level from leaf to root).</p>

<p>
For example:<br>
Given binary tree <code>{3,9,20,#,#,15,7}</code>,<br>
</p><pre>    3
   / \
  9  20
    /  \
   15   7
</pre>
<p></p>
<p>
return its bottom-up level order traversal as:<br>
</p><pre>[
  [15,7]
  [9,20],
  [3],
]
</pre>
<p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="white">very easy</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is the same question as previous one</strong>.</p>

<h3>Solution</h3>

<p><strong>There are also 2 solution: BFS and DFS</strong>.</p>

<p>I post BFS code below. Only 2 lines are different: ans.get() and ans.add().</p>

<h3>Code</h3>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (root == null) return ans;
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
    q.add(root);
    while (! q.isEmpty()) {
        ans.add(0, new ArrayList&lt;Integer&gt;());
        int curSize = q.size();
        for (int i = 0; i &lt; curSize; i ++) {
            TreeNode node = q.remove();
            ans.get(0).add(node.val);
            if (node.left != null) q.add(node.left);
            if (node.right != null) q.add(node.right);
        }
    }
    return ans;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/25/Binary-Tree-Level-Order-Traversal/">[LeetCode 102] Binary Tree Level Order Traversal</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-25T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/binary-tree-level-order-traversal/">link</a></p>

<div class="question-content">
            <p></p><p>Given a binary tree, return the <i>level order</i> traversal of its nodes&#8217; values. (ie, from left to right, level by level).</p>

<p>
For example:<br>
Given binary tree <code>{3,9,20,#,#,15,7}</code>,<br>
</p><pre>    3
   / \
  9  20
    /  \
   15   7
</pre>
<p></p>
<p>
return its level order traversal as:<br>
</p><pre>[
  [3],
  [9,20],
  [15,7]
]
</pre>
<p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="red">4</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="lime">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a really classic question</strong>.</p>

<p>It is not difficult, however, it&rsquo;s important to understand 2 different ways to solve this problem: <strong>DFS and BFS</strong>.</p>

<p><strong>The different between Inorder, preorder, postorder and Level-order</strong> is explained very well in <a href="http://leetcode.com/2010/09/printing-binary-tree-in-level-order.html">this post</a>.</p>

<blockquote><p>pre-order, in-order, and post-order tree traversal are called Depth First Search (DFS), since they visit the tree by proceeding deeper and deeper until it reaches the leaf nodes.</p>

<p>DFS uses a data structure called Stack and is commonly implemented using recursion. If recursion is not allowed, we can simulate the recursion by using iterative method with the help of stack. For example in the question &ldquo;Binary Search Tree In-Order Traversal&rdquo;, we have a iterative DFS solution using a stack.</p>

<p>The most natural solution for level-order traversal is Breadth First Search (BFS), since it visits the nodes level by level. BFS requires the use of a data structure called Queue.</p></blockquote>

<p><strong>To summarize, Inorder, preorder and postorder is DFS implemented by Stack. Level-order is BFS implemented by Queue</strong>. It is very important to forever make it clear and take it into your grave 60 years later (maybe more, if not less).</p>

<p>One mor thing, <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Stack.html">Stack</a> is a Java class that inherit from <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html">Vector</a>.</p>

<blockquote><p>The Vector class implements a growable array of objects. Like an array, it contains components that can be accessed using an integer index. However, the size of a Vector can grow or shrink as needed to accommodate adding and removing items after the Vector has been created.</p>

<p>ArrayList is roughly equivalent to Vector, except that it is unsynchronized.</p></blockquote>

<p>However, <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Queue.html">Queue</a> is an interface, not a class. What is the most popular Queue implementation in Java? It is not <strong>PriorityQueue</strong>, it&rsquo;s <strong>LinkedList</strong>!</p>

<h3>Solution</h3>

<p><strong>As said, level-order is BFS</strong>. The first code posted below is implemented with a queue. A lot of people used 2 queues, which I don&rsquo;t like.</p>

<p><strong>Second code is DFS</strong>. This is my initial solution, maybe because I&rsquo;m more familiar with DFS.</p>

<h3>Code</h3>

<p><strong>First, BFS code using 1 queue</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (root == null) return ans;
    int level = 0;
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
    q.add(root);
    while (! q.isEmpty()) {
        ans.add(new ArrayList&lt;Integer&gt;());
        int curSize = q.size();
        for (int i = 0; i &lt; curSize; i ++) {
            TreeNode node = q.remove();
            ans.get(level).add(node.val);
            if (node.left != null) q.add(node.left);
            if (node.right != null) q.add(node.right);
        }
        level ++;
    }
    return ans;
}
</code></pre>

<p><strong>First code revised</strong>: I do not really need the variable &lsquo;level&rsquo;.</p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (root == null) return ans;
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
    q.add(root);
    while (! q.isEmpty()) {
        ans.add(new ArrayList&lt;Integer&gt;());
        int curSize = q.size();
        for (int i = 0; i &lt; curSize; i ++) {
            TreeNode node = q.remove();
            ans.get(ans.size() - 1).add(node.val);
            if (node.left != null) q.add(node.left);
            if (node.right != null) q.add(node.right);
        }
    }
    return ans;
}
</code></pre>

<p><strong>Second, DFS code</strong></p>

<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    if (root == null) return ans;
    traverse(ans, root, 0);
    return ans;
}

private void traverse (ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans, TreeNode node, int level) {
    if (node == null) return;
    if (ans.size() &gt;= level + 1) 
        ans.get(level).add(node.val);
    else {
        ArrayList&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;();
        temp.add(node.val);
        ans.add(temp);
    }
    traverse(ans, node.left, level + 1);
    traverse(ans, node.right, level + 1);
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/24/Restore-IP-Addresses/">[LeetCode 93] Restore IP Addresses</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-24T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/restore-ip-addresses/">link</a></p>

<div class="question-content">
            <p></p><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>

<p>
For example:<br>
Given <code>"25525511135"</code>,
</p>
<p>
return <code>["255.255.11.135", "255.255.111.35"]</code>. (Order does not matter)
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">40 minutes</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p>This is question can be solved by <strong>either DFS or Brute Force</strong>, both are fine.</p>

<h3>Solution</h3>

<p><strong>The DFS solution is obvious, I have the code for it</strong>.</p>

<p>However, there&rsquo;s <a href="http://blog.csdn.net/u011095253/article/details/9158449">another person</a> who wrote much less code while implementing the same solution as mine. I will post his code as a good example to learn.</p>

<p><strong>The brute force solution in this case</strong> does not sound like a bad idea. This is the <strong>most top-rated idea on <a href="https://oj.leetcode.com/discuss/77/restore-ip-addresses">official forum</a></strong> as well.</p>

<blockquote><p> You can get points&#8217; positions by i, j, k. Using these positions, you can divide s into candidate ip-form. Then, you can judge whether the candidate fits ip. To improve the efficiency, you can narrow the scope of i, j, k.</p></blockquote>

<p>So, this BF code is also posted below.</p>

<p>Just one more thing. I tested the <strong>exact same BF code written in C++</strong>. Compared to the <strong>420ms</strong> it took Java to pass OJ test, C++ takes <strong>8ms</strong> only! I was kind of shocked.</p>

<h3>Code</h3>

<p><strong>First, DFS, my code</strong></p>

<p>Note: I could have just insert as string, so that convert() method would not be needed.</p>

<pre><code>public ArrayList&lt;String&gt; restoreIpAddresses(String s) {
    ArrayList&lt;String&gt; ans = new ArrayList&lt;String&gt;();
    helper(ans, new ArrayList&lt;String&gt;(), s, 0);
    return ans;
}

private void helper(ArrayList&lt;String&gt; ans, ArrayList&lt;String&gt; cur, String s, int from) {
    int len = s.length();
    if (from &gt;= len) return;
    if (cur.size() == 3) {
        String lastStr = s.substring(from);
        if (isValidIpNumber(lastStr)) {
            ArrayList&lt;String&gt; oneAns = new ArrayList&lt;String&gt;(cur);
            oneAns.add(lastStr);
            ans.add(convert(oneAns));
        }
    }
    else {
        // cur.size less than 3, so get next num (length = 1, 2 or 3)
        for (int i = 1; i &lt;= 3 &amp;&amp; from + i &lt;= len; i ++) {
            String nextStr = s.substring(from, from + i);
            if (isValidIpNumber(nextStr)) {
                cur.add(nextStr);
                helper(ans, cur, s, from + i);
                cur.remove(cur.size() - 1);
            }
        }
    }
}

private boolean isValidIpNumber(String str) {
    if (str.length() == 0 || str.length() &gt; 3) return false;
    if (str.charAt(0) == '0' &amp;&amp; str.length() != 1) return false;
    int num = Integer.parseInt(str);
    return (0 &lt;= num &amp;&amp; num &lt;= 255);
}

private String convert(ArrayList&lt;String&gt; l) {
    String ans = "";
    for (String a: l)
        ans += "." + a;
    return ans.substring(1);
}
</code></pre>

<p><strong>Second, DFS, shorter version code</strong></p>

<pre><code>public ArrayList&lt;String&gt; restoreIpAddresses(String s) {
    ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;();  
    if (s.length()&lt;4||s.length()&gt;12) return res;  
    dfs(s,"",res,0);  
    return res;  
}  

public void dfs(String s, String tmp, ArrayList&lt;String&gt; res, int count){  
    if (count == 3 &amp;&amp; isValid(s)) {  
        res.add(tmp + s);  
        return;  
    }  
    for(int i=1; i&lt;4 &amp;&amp; i&lt;s.length(); i++){  
        String substr = s.substring(0,i);  
        if (isValid(substr)){  
            dfs(s.substring(i), tmp + substr + '.', res, count+1);  
        }  
    }  
}  

public boolean isValid(String s){  
    if (s.charAt(0)=='0') return s.equals("0");  
    int num = Integer.parseInt(s);  
    return num&lt;=255 &amp;&amp; num&gt;0;  
}  
</code></pre>

<p><strong>Third, BF code using triple nested loop (Java)</strong></p>

<pre><code>public ArrayList&lt;String&gt; restoreIpAddresses(String s) {
    ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;();  
    if (s.length() &gt; 12 || s.length() &lt; 4) return res;
    for (int i = 1; i &lt; 4; i ++) {
        String first = s.substring(0, i);
        if (! isValid(first)) continue;
        for (int j = 1; i + j &lt; s.length() &amp;&amp; j &lt; 4; j ++) {
            String second = s.substring(i, i + j);
            if (! isValid(second)) continue;
            for (int k = 1; i + j + k &lt; s.length() &amp;&amp; k &lt; 4; k ++) {
                String third = s.substring(i + j, i + j + k);
                String fourth = s.substring(i + j + k);
                if (isValid(third) &amp;&amp; isValid(fourth)) 
                    res.add(first + "." + second + "." + third + "." + fourth);
            }
        }
    }
    return res;
}  

public boolean isValid(String s) {
    if (s.length() &gt; 1 &amp;&amp; s.charAt(0) == '0') return false;
    return 0 &lt;= Integer.parseInt(s) &amp;&amp; Integer.parseInt(s) &lt;= 255;  
}
</code></pre>

<p><strong>Fourth, same BF code (C++)</strong></p>

<pre><code>vector&lt;string&gt; restoreIpAddresses(string s) {
    vector&lt;string&gt; res;
    if (s.size() &gt; 12 || s.size() &lt; 4) return res;
    for (int i=1; i&lt;4; i++) {
        string first = s.substr(0, i);
        if (!isValid(first)) continue;
        for (int j=1; i+j &lt; s.size() &amp;&amp; j&lt;4; j++) {
            string second = s.substr(i, j);
            if (!isValid(second)) continue;
            for (int k=1; i+j+k &lt; s.size() &amp;&amp; k&lt;4; k++) {
                string third = s.substr(i+j, k);
                string fourth = s.substr(i+j+k);
                if (isValid(third) &amp;&amp; isValid(fourth)) {
                    string temp = first+"."+second+"."+third+"."+fourth;
                    res.push_back(temp);
                }
            }
        }
    }
    return res;
}

bool isValid(string s) {
    if (s.size() &gt; 1 &amp;&amp; s[0] == '0') return false;
    if (stoi(s) &lt;= 255 &amp;&amp; stoi(s) &gt;= 0) return true;
    else return false;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/24/Maximal-Rectangle/">[LeetCode 85] Maximal Rectangle</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-24T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/maximal-rectangle/">link</a></p>

<div class="question-content">
            <p></p><p>
Given a 2D binary matrix filled with 0&#8217;s and 1&#8217;s, find the largest rectangle containing all ones and return its area.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="white">1</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="red">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a very difficult question</strong>. It is similar and also related to &ldquo;<strong>Largest Rectangle in Histogram</strong>&rdquo;.</p>

<p>Two solutions are available for this question.</p>

<p><strong>First solution is O(n<sup>2</sup>)</strong>. This makes use of solution of &ldquo;<strong>Largest Rectangle in Histogram</strong>&rdquo;, which is to say, we are finding the max rectangle for each row (as base) in the matrix.</p>

<p>This solution is very easy to write once you realize this connection &ndash; I guess not many people would. That&rsquo;s why I have the next solution.</p>

<p><strong>Second solution is a clever Brute Force, time complexity is O(n<sup>3</sup>)</strong>. The fundamental idea is to make a 2-D array storing the number of &lsquo;1&rsquo;s occured before current node (inclusive). After this is done, there&rsquo;re 2 different ways to implement. Read code 2 and code 3.</p>

<h3>Solution</h3>

<p>FIrst code is easy.</p>

<p>Second code is the idea from <a href="http://blog.csdn.net/fightforyourdream/article/details/17711893">this blog</a>. For every node in the 2-D array, checks all possible rectangles ending at this node (which mean check all the way up/left).</p>

<p>Third code from <a href="http://leetcodenotes.wordpress.com/2013/10/19/leetcode-maximal-rectangle-0101%E7%BB%84%E6%88%90%E7%9A%84%E7%9F%A9%E9%98%B5%EF%BC%8C%E6%B1%82%E9%87%8C%E9%9D%A2%E5%85%A8%E6%98%AF1%E7%9A%84%E7%9F%A9%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2/">this blog</a>. It is similar to second, but it&rsquo;s checking all rectangles that shared same width as current line. So it&rsquo;s checking up then down, both direction. Read the code and it&rsquo;s easy to understand.</p>

<h3>Code</h3>

<p><strong>First, solution making use of &ldquo;Largest rectangle&rdquo;</strong></p>

<pre><code>public int maximalRectangle(char[][] matrix) {
    if (matrix.length == 0 || matrix[0].length == 0) return 0;
    int[][] m = new int[matrix.length][matrix[0].length];
    for (int i = 0; i &lt; matrix.length; i ++) {
        for (int j = 0; j &lt; matrix[i].length; j ++) {
            if (i == 0 || matrix[i][j] == '0') 
                m[i][j] = matrix[i][j] - '0';
            else 
                m[i][j] = m[i-1][j] + 1;
        }
    }
    int max = 0;
    for (int i = 0; i &lt; m.length; i ++) {
        max = Math.max(max, largestRectangleArea(m[i]));
    }
    return max;
}

// the following code is the solution for "Largest Rectangle in Histogram"
public int largestRectangleArea(int[] height) {
    int len = height.length;
    if (len == 0) return 0;
    int max = Integer.MIN_VALUE;
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    for (int i = 0; i &lt; len; i ++) {
        if (stack.isEmpty() || height[stack.peek()] &lt;= height[i]) stack.push(i);
        else {
            int temp = stack.pop();
            // here I must do a check of stack.isEmpty(), 
            // And do nto use (i-height[temp]) instead use (i-stack.peek()-1])
            max = Math.max(max, height[temp] * 
                (stack.isEmpty() ? i : (i - stack.peek() - 1)));
            i --;
        }
    }
    while (! stack.isEmpty()) {
            int temp = stack.pop();
            max = Math.max(max, height[temp] * 
                (stack.isEmpty() ? len : (len - stack.peek() - 1)));
    }
    return max;
}
</code></pre>

<p><strong>Second </strong></p>

<pre><code>public int maximalRectangle(char[][] matrix) {
    int rows = matrix.length;  
    if (rows == 0) return 0;  
    int cols = matrix[0].length;  
    int [][] hOnes = new int[rows][cols];
    int max = 0;
    for (int i=0; i&lt;rows; i++)
        for(int j=0; j&lt;cols; j++) 
            if(matrix[i][j] == '1')
                if(j == 0) hOnes[i][j] = 1;
                else hOnes[i][j] = hOnes[i][j-1] + 1;
    for (int i=0; i&lt;rows; i++)
        for (int j=0; j&lt;cols; j++){  
            if (hOnes[i][j] != 0){  
                int minI = i;
                int minRowWidth = hOnes[i][j];
                while (minI &gt;= 0){
                    minRowWidth = Math.min(minRowWidth, hOnes[minI][j]);  
                    int area = minRowWidth * (i-minI+1);  
                    max = Math.max(max, area);  
                    minI--;  
                }
            }
        }
    return max;  
}
</code></pre>

<p><strong>Third</strong></p>

<pre><code>public int maximalRectangle(char[][] matrix) {
    if (matrix.length == 0) return 0;
    int res = 0;
    int m = matrix.length, n = matrix[0].length;
    int[][] d = new int[m][n];
    for (int i = 0; i &lt; m; i++) {
        d[i][0] = matrix[i][0] - '0';
        for (int j = 1; j &lt; n; j++) 
            d[i][j] = matrix[i][j] == '1' ? d[i][j - 1] + 1 : 0;
    }
    for (int i = 0; i &lt; m; i++) 
        for (int j = 0; j &lt; n; j++) 
            res = Math.max(res, expand(d, i, j));
    return res;
}

private int expand(int[][] d, int I, int J) {
    int height = 0, width = d[I][J];
    //go up
    for (int i = I - 1; i &gt;= 0; i--)
        if (d[i][J] &gt;= width) height++;
        else break;
    //go down
    for (int i = I; i &lt; d.length; i++) 
        if (d[i][J] &gt;= width) height++;
        else break;
    return width * height;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/24/Interleaving-String/">[LeetCode 97] Interleaving String</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-24T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Question</h3>

<p><a href="https://oj.leetcode.com/problems/interleaving-string/">link</a></p>

<div class="question-content">
            <p></p><p>
Given <i>s1</i>, <i>s2</i>, <i>s3</i>, find whether <i>s3</i> is formed by the interleaving of <i>s1</i> and <i>s2</i>.
</p>

<p>
For example,<br>
Given:<br>
<i>s1</i> = <code>"aabcc"</code>,<br>
<i>s2</i> = <code>"dbbca"</code>,
</p>
<p>
When <i>s3</i> = <code>"aadbbcbcac"</code>, return true.<br>
When <i>s3</i> = <code>"aadbbbaccc"</code>, return false.
</p><p></p>
          </div>


<h3>Stats</h3>

<table border="2">
    <tr>
        <td>Frequency</td>
        <td bgcolor="lime">2</td>
    </tr>
    <tr>
        <td>Difficulty</td>
        <td bgcolor="red">5</td>
    </tr>
    <tr>
        <td>Adjusted Difficulty</td>
        <td bgcolor="yellow">3</td>
    </tr>
    <tr>
        <td>Time to use</td>
        <td bgcolor="yellow">&#8212;&#8212;&#8211;</td>
    </tr>
</table>


<p>Ratings/Color = 1(white) 2(lime) 3(yellow) 4/5(red)</p>

<h3>Analysis</h3>

<p><strong>This is a DP question</strong>.</p>

<p>At first look it might look like very easily solved by DFS. It it, but TLE exception.</p>

<p>So, I learnt the idea from <a href="http://blog.csdn.net/u011095253/article/details/9248073">this blog</a>. It&rsquo;s easy to realize this is a <strong>very standard DP question</strong>.</p>

<h3>Solution</h3>

<p>Declare a 2-D array for DP, and dp(i)(j) denotes whether it&rsquo;s possible to construct s3 (of length i+j) by using s1 (of length i) and s2 (of length j).</p>

<p>Only thing needs to mention is the size of dp is (m+1)*(n+1), because i = [0, m] and j = [0, n].</p>

<h3>Code</h3>

<p><strong>DP solution</strong></p>

<pre><code>public boolean isInterleave(String s1, String s2, String s3) {
    int len1 = s1.length();
    int len2 = s2.length();
    int len3 = s3.length();
    if (len1 + len2 != len3) return false;
    boolean[][] dp = new boolean[len1 + 1][len2 + 1];
    dp[0][0] = true;
    for (int i = 1; i &lt;= len2; i ++)
        dp[0][i] = dp[0][i - 1] &amp; s2.charAt(i-1) == s3.charAt(i-1);
    for (int i = 1; i &lt;= len1; i ++)
        dp[i][0] = dp[i-1][0] &amp; s1.charAt(i-1) == s3.charAt(i-1);
    for (int i = 1; i &lt;= len1; i ++) {
        for (int j = 1; j &lt;= len2; j ++) {
            if (s1.charAt(i-1) == s3.charAt(i+j-1) &amp;&amp; dp[i-1][j])
                dp[i][j] = true;
            if (s2.charAt(j-1) == s3.charAt(i+j-1) &amp;&amp; dp[i][j-1])
                dp[i][j] = true;
        }
    }
    return dp[len1][len2];
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/26">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/24">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section class="well">
  <h1>Categories</h1>
  <ul id="categories" class="nav nav-list">
    <li class='category'><a href='/blog/categories/cc150/'>cc150 (3)</a></li>
<li class='category'><a href='/blog/categories/collection/'>collection (5)</a></li>
<li class='category'><a href='/blog/categories/design/'>design (39)</a></li>
<li class='category'><a href='/blog/categories/facebook/'>facebook (2)</a></li>
<li class='category'><a href='/blog/categories/google/'>google (20)</a></li>
<li class='category'><a href='/blog/categories/leetcode/'>leetcode (155)</a></li>
<li class='category'><a href='/blog/categories/leetcode-plus/'>leetcode_plus (9)</a></li>
<li class='category'><a href='/blog/categories/lintcode/'>lintcode (11)</a></li>
<li class='category'><a href='/blog/categories/ninechap/'>ninechap (15)</a></li>
<li class='category'><a href='/blog/categories/question/'>question (80)</a></li>
<li class='category'><a href='/blog/categories/thoughts/'>thoughts (5)</a></li>
<li class='category'><a href='/blog/categories/twitter/'>twitter (1)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/08/20/Square-count-in-matchstick-graph/">[Question] Square Count of Matchstick Graph</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/20/Dice-roll-DP-question/">[Question] Ways of Dice Throw</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/20/Count-set-bit-in-binary-number/">[Question] Count Set Bit in Binary Number</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/19/design-pattern-basic-singleton-factory/">[Design] Design Pattern - Singleton & Factory</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/19/Talk-about-singleton/">[Design] About Singleton</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
